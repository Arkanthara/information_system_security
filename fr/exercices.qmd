## S√©rie 1 : Arithm√©tique Modulaire

### üéØ Notions Cl√©s

**Ensembles :** $\mathbb{Z}_n = \{0,1,...,n-1\}$, $\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n | \text{pgcd}(a,n)=1\}$

**Congruence :** $a \equiv b \mod n \iff n|(a-b)$

**Inversibilit√© :** $a$ inversible mod $n \iff \text{pgcd}(a,n)=1$

**Th√©or√®mes fondamentaux :**

- **B√©zout :** $ax + by = \text{pgcd}(a,b)$
- **Euler :** $a^{\Phi(n)} \equiv 1 \mod n$ (si $\text{pgcd}(a,n)=1$)
- **Fermat :** $a^p \equiv a \mod p$ ($p$ premier)

**Ordre :** $\text{ord}_n(a)$ = plus petit $x > 0$ tel que $a^x \equiv 1 \mod n$

**G√©n√©rateur :** $g$ g√©n√®re $\mathbb{Z}_n^*$ si $\text{ord}_n(g) = \Phi(n)$

**Structures :** Groupe ‚Üí Anneau ‚Üí Corps (inversibilit√© croissante)

::: {.callout collapse="true"}
### üí° Calculs modulaires

**Q :** $((11 \mod 7) \cdot (17 \mod 7)) \mod 7$

**R :** $4 \cdot 3 = 12 \equiv 5 \mod 7$
:::

::: {.callout collapse="true"}
### üí° Trouver l'ordre

**Q :** Ordre de 2 mod 7 ?

**R :** $2^1=2$, $2^2=4$, $2^3=8\equiv 1$ ‚Üí $\text{ord}_7(2)=3$
:::

::: {.callout collapse="true"}
### üí° Identifier un g√©n√©rateur

**Q :** 3 est-il g√©n√©rateur de $\mathbb{Z}_7^*$ ?

**R :** $3^1=3, 3^2=2, 3^3=6, 3^4=4, 3^5=5, 3^6=1$ ‚Üí g√©n√®re tous les √©l√©ments ‚Üí **OUI**
:::

---

## S√©rie 2 : Entropie

### üéØ Notions Cl√©s

**Entropie :** Mesure l'incertitude/information d'une variable al√©atoire

$$H(X) = -\sum_{i=1}^n p_i \log_2(p_i) = \sum_{i=1}^n p_i \log_2\left(\frac{1}{p_i}\right)$$

**Propri√©t√©s :**

- $H(X)$ maximale quand toutes les probabilit√©s sont √©gales
- $H(X) = 0$ si une seule valeur possible (probabilit√© = 1)
- Pour $n$ valeurs √©quiprobables : $H(X) = \log_2(n)$

**Entropie jointe :** $H(X,Y) = -\sum_x \sum_y p(x,y)\log_2(p(x,y))$

**Entropie conditionnelle :** $H(X|Y) = -\sum_y \sum_x p(y)p(x|y)\log_2(p(x|y))$

**En cryptographie :** On veut $H(\text{Plaintext}|\text{Ciphertext}) \approx H(\text{Plaintext})$

::: {.callout collapse="true"}
### üí° Entropie minimale/maximale

**Q :** Variable 256 bits, entropies min/max ?

**R :**

- **Min :** $H=0$ (une seule valeur possible, $p=1$)
- **Max :** $H=256$ (toutes valeurs √©quiprobables, $p=2^{-256}$)
:::

::: {.callout collapse="true"}
### üí° Entropie d'une concat√©nation

**Q :** $H(X)=64$, on g√©n√®re une valeur et la concat√®ne √† elle-m√™me (512 bits). Entropie ?

**R :** $H=64$ (pas de nouvelle information, juste duplication)
:::

::: {.callout collapse="true"}
### üí° Entropie de mot de passe

**Q :** Mot de passe = date "MM/DD/YYYY" al√©atoire (365 jours, ann√©es 0000-2025)

**R :** $365 \times 2026 = 739490$ possibilit√©s ‚Üí $H = \log_2(739490) \approx 19.5$ bits
:::

::: {.callout collapse="true"}
### üí° G√©n√©rateur am√©lior√©

**Q :** G√©n√©rateur $G$ : $P(0)=0.5+\delta$, $P(1)=0.5-\delta$. On cr√©e $A$ : prend 2 bits de $G$, garde 01‚Üí0 ou 10‚Üí1, rejette 00 et 11. Avantage ?

**R :**

- $P_A(0) = P_A(1) = 0.5$ (parfaitement al√©atoire !)
- Co√ªt : besoin de $\frac{2x}{0.5-2\delta^2}$ bits de $G$ pour $x$ bits de $A$
:::

---

## S√©rie 3 : Chiffrements Historiques

### üéØ Notions Cl√©s

**Chiffre de C√©sar :**

Rotation de $k$ positions : $E_k(x) = (x + k) \mod 26$, $D_k(c) = (c - k) \mod 26$

**Substitution monoalphab√©tique :**

Cl√© = permutation de l'alphabet. Chaque lettre ‚Üí lettre fixe.

**Chiffre de Vigen√®re :**

Substitution polyalphab√©tique : $C_i = (M_i + K_{i \mod |K|}) \mod 26$

```{mermaid}
graph LR
    A[C√©sar] -->|g√©n√©ralisation| B[Substitution mono]
    B -->|cl√© r√©p√©t√©e| C[Vigen√®re]
    
    style A fill:#ffe1e1
    style B fill:#fff4e1
    style C fill:#e1f5ff
```

**Cassage :**

- **C√©sar :** Force brute (25 cl√©s max) ou analyse fr√©quentielle
- **Mono :** Analyse fr√©quentielle + structure du langage
- **Vigen√®re :** Indice de co√Øncidence + analyse fr√©quentielle

::: {.callout collapse="true"}
### üí° Chiffrement C√©sar

**Q :** Chiffrer "HELLO" avec $k=5$

**R :** H‚ÜíM, E‚ÜíJ, L‚ÜíQ, L‚ÜíQ, O‚ÜíT ‚Üí **"MJQQT"**
:::

::: {.callout collapse="true"}
### üí° Chiffrement Vigen√®re

**Q :** Chiffrer "BONJOUR" avec cl√© "BAC"

**R :**

- B+B=C, O+A=O, N+C=P, J+B=K, O+A=O, U+C=W, R+B=S
- **"COPKOWS"**
:::

::: {.callout collapse="true"}
### üí° Cassage Vigen√®re - Longueur de cl√©

**M√©thode :** Indice de co√Øncidence

Pour longueur $L$, d√©caler le texte de $L$ positions et compter les lettres identiques :

$$\text{IC}(L) = \frac{\sum_{i=1}^{N-L} [a_i == b_i]}{N-L}$$

Le maximum d'IC indique la longueur de cl√© (ou un multiple).
:::

::: {.callout collapse="true"}
### üí° Cassage Vigen√®re - Trouver la cl√©

**M√©thode :** Analyse fr√©quentielle par sous-texte

1. Diviser le texte en $k$ sous-textes (positions $1, k+1, 2k+1, ...$)
2. Pour chaque sous-texte, calculer distance avec fr√©quences de la langue :

$$\text{Dist}_x = \sqrt{\sum_{i=0}^{25} (F_i - M_{(i+x) \mod 26})^2}$$

3. Le $x$ minimisant la distance est la lettre de cl√© correspondante
:::

---

## S√©rie 4 : Chiffrements par Blocs

### üéØ Notions Cl√©s

**Modes de chiffrement :**

```{mermaid}
graph TD
    A[ECB<br/>Simple] --> B[CBC<br/>Cha√Ænage]
    B --> C[CFB<br/>Feedback]
    C --> D[OFB<br/>Output FB]
    
    style A fill:#ffe1e1
    style B fill:#fff4e1
    style C fill:#e1f5ff
    style D fill:#e1ffe1
```

**ECB (Electronic CodeBook) :**

$$C_i = E_K(P_i)$$

‚ö†Ô∏è Blocs identiques ‚Üí chiffr√©s identiques (faible s√©curit√©)

**CBC (Cipher Block Chaining) :**

$$C_i = E_K(P_i \oplus C_{i-1}), \quad C_0 = IV$$

**CFB (Cipher FeedBack) :**

$$C_i = E_K(C_{i-1}) \oplus P_i, \quad C_0 = IV$$

**OFB (Output FeedBack) :**

$$O_i = E_K(O_{i-1}), \quad C_i = O_i \oplus P_i, \quad O_0 = IV$$

**Fonction de chiffrement :** Doit √™tre **inversible** (bijective)

::: {.callout collapse="true"}
### üí° Chiffrement lin√©aire - Danger

**Q :** Chiffrement lin√©aire $E_L(k, m_1 \oplus m_2) = E_L(k,m_1) \oplus E_L(k,m_2)$. Avec 128 textes chiffr√©s choisis, montrer qu'on peut d√©chiffrer sans cl√©.

**R :**

1. Choisir $c_1,...,c_{128}$ o√π $c_i$ a seulement le bit $i$ √† 1
2. Tout chiffr√© $c$ s'√©crit comme XOR de certains $c_i$
3. $c = c_{i_1} \oplus ... \oplus c_{i_n} = E_L(k, m_{i_1} \oplus ... \oplus m_{i_n})$
4. Donc $m = m_{i_1} \oplus ... \oplus m_{i_n}$ (connu !)
5. **Conclusion :** Chiffrement lin√©aire = tr√®s dangereux
:::

::: {.callout collapse="true"}
### üí° Fonctions inversibles

**Q :** $E_i = (B_i \cdot K_i) \mod 16$ est-elle utilisable ?

**R :** **NON**. Si $K_i=2$, alors $B_i=1$ et $B_i=9$ donnent tous deux $E_i=2 \mod 16$. Non-bijective !
:::

::: {.callout collapse="true"}
### üí° Chiffrement ECB

**Q :** $K=(AB)_{16}$, $m=(A741BA)_{16}$, $E_K(B) = B \oplus K$, chiffrer

**R :**

- $C_1 = A7 \oplus AB = 0C$
- $C_2 = 41 \oplus AB = EA$
- $C_3 = BA \oplus AB = 11$
- **R√©sultat :** $(0CEA11)_{16}$
:::

::: {.callout collapse="true"}
### üí° Chiffrement CBC

**Q :** $K=(AB)_{16}$, $IV=(AD)_{16}$, $m=(A741BA)_{16}$, $E_K(B) = B \oplus K$

**R :**

- $C_1 = (A7 \oplus AD) \oplus AB = 0A \oplus AB = A1$
- $C_2 = (41 \oplus A1) \oplus AB = E0 \oplus AB = 4B$
- $C_3 = (BA \oplus 4B) \oplus AB = F1 \oplus AB = 5A$
- **R√©sultat :** $(A14B5A)_{16}$
:::

---

## S√©rie 5 : RSA, Rabin, ElGamal

### üéØ Notions Cl√©s

**RSA :**

- **Cl√©s :** $n=pq$, $e$ avec $\text{pgcd}(e, \Phi(n))=1$, $d = e^{-1} \mod \Phi(n)$
- **Chiffrement :** $c = m^e \mod n$
- **D√©chiffrement :** $m = c^d \mod n$

**Exponentiation rapide :** Calculer $a^{42}$ : √©crire $42=32+8+2$ puis $a^{42} = a^{32} \cdot a^8 \cdot a^2$

**Rabin :**

- **Cl√©s :** $n=pq$ avec $p \equiv q \equiv 3 \mod 4$
- **Chiffrement :** $c = m^2 \mod n$
- **D√©chiffrement :** 4 solutions possibles via syst√®me de congruences

**ElGamal :**

- **Cl√©s :** Premier $p$, g√©n√©rateur $\alpha$, cl√© priv√©e $a$, cl√© publique $\alpha^a \mod p$
- **Chiffrement :** $(\lambda, \sigma) = (\alpha^k, m \cdot (\alpha^a)^k) \mod p$
- **D√©chiffrement :** $m = \lambda^{-a} \cdot \sigma \mod p$

::: {.callout collapse="true"}
### üí° G√©n√©rer cl√©s RSA

**Q :** $p=11$, $q=17$, cr√©er paire de cl√©s RSA

**R :**

1. $n = 11 \times 17 = 187$
2. $\Phi(n) = 10 \times 16 = 160$
3. Choisir $e=7$ (premier avec 160)
4. Trouver $d$ : $7d \equiv 1 \mod 160$ ‚Üí $d=23$
5. **Cl√© publique :** $(187, 7)$, **Cl√© priv√©e :** $(187, 23)$
:::

::: {.callout collapse="true"}
### üí° Chiffrement RSA rapide

**Q :** Chiffrer $m=28$ avec $(n=247, e=41)$

**R :** Exponentiation rapide $28^{41} \mod 247$ :

- $28^1=28$, $28^2=43$, $28^4=120$, $28^8=74$, $28^{16}=42$, $28^{32}=35$
- $41 = 32+8+1$ donc $28^{41} = 35 \cdot 74 \cdot 28 = 149 \mod 247$
:::

::: {.callout collapse="true"}
### üí° Casser RSA (petits nombres)

**Q :** $(n=247, e=41)$, trouver cl√© priv√©e

**R :**

1. Factoriser : $247 = 13 \times 19$
2. $\Phi(n) = 12 \times 18 = 216$
3. Euclide √©tendu pour $d = e^{-1} \mod 216$ ‚Üí $d=137$
4. V√©rifier : $41 \times 137 = 5617 = 26 \times 216 + 1 \equiv 1 \mod 216$ ‚úì
:::

::: {.callout collapse="true"}
### üí° Rabin

**Q :** $n=253$, chiffrer $m=134$

**R :** $c = 134^2 = 17956 \equiv 246 \mod 253$

Pour d√©chiffrer (factoriser $n=11 \times 23$) :

- $m_p = 246^3 \mod 11 = 9$
- $m_q = 246^6 \mod 23 = 4$
- 4 solutions dont $m_4 = 134$ ‚úì
:::

---

## S√©rie 6 : Fonctions de Hachage et MAC

### üéØ Notions Cl√©s

**Propri√©t√©s cryptographiques :**

1. **R√©sistance √† la pr√©image :** Difficile de trouver $x$ tel que $h(x)=y$
2. **R√©sistance √† la seconde pr√©image :** Difficile de trouver $x' \neq x$ avec $h(x')=h(x)$
3. **R√©sistance aux collisions :** Difficile de trouver $x \neq x'$ avec $h(x)=h(x')$

‚ö†Ô∏è Collision implique seconde pr√©image (mais pas pr√©image)

**MAC (Message Authentication Code) :**

Garantit int√©grit√© ET authenticit√©. Construit souvent avec CBC : $MAC = E_K(...E_K(E_K(m_1) \oplus m_2)... \oplus m_n)$

::: {.callout collapse="true"}
### üí° Mauvaise fonction de hachage

**Q :** $h_1(x) = x \mod n$ est-elle s√ªre ?

**R :** **NON** pour les 3 propri√©t√©s :

- Pr√©image : $x=y$ donne $h_1(x)=y$
- Seconde pr√©image : $x'=x+n$ donne collision
- Collision : idem seconde pr√©image
:::

::: {.callout collapse="true"}
### üí° MAC avec CBC vuln√©rable

**Q :** $t_1=E_K(m_1)$, $t_{i+1}=E_K(m_{i+1} \oplus t_i)$. Avec $(m_1||m_2, t_1||t_2)$, falsifier ?

**R :** Message falsifi√© : $m'=(m_2 \oplus t_1) || (t_2 \oplus m_1)$

MAC falsifi√© : $t' = t_2 || t_1$ (calculable sans cl√© !)
:::

::: {.callout collapse="true"}
### üí° MAC = dernier bloc CBC

**Q :** Si $MAC=c_n$ (dernier bloc CBC), peut-on modifier le message ?

**R :** **OUI** ! On peut modifier tous les blocs $c_1,...,c_{n-1}$ sans changer $c_n=MAC$. Le d√©chiffrement donnera un message diff√©rent avec MAC valide !

**Solution :** Utiliser deux cl√©s diff√©rentes (une pour chiffrement, une pour MAC)
:::

---

## S√©rie 7 : Authentification et √âtablissement de Cl√©s

### üéØ Notions Cl√©s

**Diffie-Hellman :**

```{mermaid}
sequenceDiagram
    participant Alice
    participant Bob
    
    Note over Alice,Bob: Public: p, Œ±
    Alice->>Alice: Choisit x secret
    Bob->>Bob: Choisit y secret
    Alice->>Bob: Œ±À£ mod p
    Bob->>Alice: Œ± ∏ mod p
    Alice->>Alice: K = (Œ± ∏)À£ mod p
    Bob->>Bob: K = (Œ±À£) ∏ mod p
    Note over Alice,Bob: Cl√© partag√©e: K = Œ±À£ ∏ mod p
```

**Attaque Man-In-The-Middle sur DH :** Intercepter et remplacer les √©changes

**Propri√©t√©s de s√©curit√© :**

- **Authentification implicite :** Seuls A et B peuvent avoir la cl√©
- **Confirmation de cl√© :** A et B prouvent qu'ils ont la cl√©
- **Authentification explicite :** Implicite + Confirmation
- **Perfect Forward Secrecy :** Compromission de cl√©s long-terme ne r√©v√®le pas sessions pass√©es
- **Future Secrecy :** Compromission ne r√©v√®le pas futures sessions (attaquant passif)

::: {.callout collapse="true"}
### üí° Protocole d'authentification faible

**Q :** A envoie $r_1$ √† B, B r√©pond $(r_2, K_B^{priv}(r_1))$, A v√©rifie et envoie $K_A^{priv}(r_2)$. Comment C peut usurper A ?

**R :**

1. C envoie $r_1$ √† B
2. B r√©pond $(r_2, K_B^{priv}(r_1))$
3. C lance protocole avec A, envoie $r_2$ comme challenge
4. A r√©pond $(r_3, K_A^{priv}(r_2))$
5. C envoie $K_A^{priv}(r_2)$ √† B ‚Üí **B authentifie C comme A !**
:::

::: {.callout collapse="true"}
### üí° Diffie-Hellman complet

**Q :** $p=17$, $\alpha=3$, Alice $x=7$, Bob $y=11$. Calculer cl√© partag√©e.

**R :**

- Alice calcule et envoie : $3^7 \mod 17 = 11$
- Bob calcule et envoie : $3^{11} \mod 17 = 7$
- Alice calcule : $K = 7^7 \mod 17 = 12$
- Bob calcule : $K = 11^{11} \mod 17 = 12$
- **Cl√© partag√©e :** $K=12$
:::

::: {.callout collapse="true"}
### üí° Man-In-The-Middle sur DH

**Q :** Charlie (MitM) avec $x'=3$, $y'=5$. Comment intercepter ?

**R :**

**Avec Alice :**

- Intercepte $\alpha^x=11$, r√©pond $\alpha^{y'}=3^5=5$
- $K_{AC} = 5^7 = 10 \mod 17$

**Avec Bob :**

- Intercepte $\alpha^y=7$, r√©pond $\alpha^{x'}=3^3=10$
- $K_{BC} = 10^{11} = 3 \mod 17$

Charlie a 2 cl√©s et contr√¥le totalement la communication !
:::

::: {.callout collapse="true"}
### üí° Analyse de protocole

**Q :** A et B partagent $S$, √©changent $r_a$ et $r_b$, puis $K=E_S(r_a \oplus r_b)$. Analyser les propri√©t√©s.

**R :**

- ‚úì **Authentification implicite** (seuls A et B connaissent $S$)
- ‚úó **Confirmation de cl√©** (pas de preuve de possession)
- ‚úó **Authentification explicite** (pas de confirmation)
- ‚úó **Perfect Forward Secrecy** (attaquant avec $S$ d√©crypte tout)
- ‚úó **Future Secrecy** (attaquant passif avec $S$ calcule futures cl√©s)
:::

---

## üìã Aide-M√©moire Express

**Arithm√©tique :** $a^{\Phi(n)} \equiv 1 \mod n$ | G√©n√©rateur si $\text{ord}(g)=\Phi(n)$

**Entropie :** $H=\log_2(n)$ si √©quiprobable | Max quand uniforme

**C√©sar :** $E(x)=(x+k) \mod 26$ | Cassage : 26 essais

**Vigen√®re :** IC pour longueur, fr√©quences pour cl√©

**Blocs :** ECB simple, CBC cha√Æn√©, CFB/OFB feedback | Fonction doit √™tre bijective

**RSA :** $c=m^e$, $m=c^d$ | $ed \equiv 1 \mod \Phi(n)$

**Hash :** Pr√©image < Seconde pr√©image < Collision

**DH :** $K=\alpha^{xy} \mod p$ | Vuln√©rable au MitM