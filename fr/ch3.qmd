# Cryptographie sym√©trique

## Stream Ciphers (Cryptage en cha√Æne)

### Introduction aux Stream Ciphers

#### D√©finition et Principe

Les **stream ciphers** (chiffrements en flux) sont une famille de syst√®mes de cryptage caract√©ris√©s par :

- **Taille de bloc unitaire** : chaque bloc encrypt√© = 1 bit
- **Architecture en deux phases** :
  1. **G√©n√©ration du keystream** : production de la s√©quence de cl√©s
  2. **Substitution** : op√©ration sur les bits du plaintext en fonction du keystream

**Exemple classique** : le *one-time pad*

- G√©n√©ration : g√©n√©rateur (pseudo-)al√©atoire
- Substitution : op√©ration XOR ($\oplus$) avec le keystream

#### Caract√©ristiques G√©n√©rales

**Avantages :**

- **Rapidit√©** : cryptage au niveau des registres, id√©al pour le *streaming* en temps r√©el (vid√©o)
- **L√©g√®ret√©** : fonctionnent sur syst√®mes √† ressources CPU limit√©es
- **Faible m√©moire** : pas ou peu de buffering n√©cessaire
- **Erreurs non propag√©es** : retransmission des paquets d√©fectueux suffisante (adapt√© aux transmissions sans fil - WiFi)

**Inconv√©nients :**

- **D√©pendance √† la qualit√© du keystream** : le caract√®re al√©atoire (randomness) d√©termine la robustesse
- **R√©utilisation dangereuse** : la r√©utilisation du keystream permet une cryptanalyse facile

::: {.callout-note collapse=true}
## üìÑ Texte original

### Cryptage en cha√Æne (Stream Ciphers)

- Les **stream ciphers** constituent une **famille de syst√®mes de cryptage** o√π la **taille du bloc encrypt√© est √©gale √† 1 bit**.
- Les stream ciphers sont g√©n√©ralement compos√©s de **deux phases**:
    - Une **phase de g√©n√©ration** de la s√©quence d'√©l√©ments formant la cl√© (le **keystream**).
    - Une **phase de substitution** o√π les bits du *plaintext* subissent une op√©ration sp√©cifique d√©pendante du keystream.
- Un exemple √©vident d'un stream cipher est le **one-time pad** avec:
    - Une phase de g√©n√©ration du keystream effectu√©e par un **g√©n√©rateur (ps√©udo-) al√©atoire**.
    - Une phase de substitution qui consiste √† effectuer un **xor** ($\oplus$) avec le keystream.

### Stream Ciphers: Caract√©ristiques

- **Rapidit√©**: Le cryptage se fait directement au niveau des registres. Id√©al pour des applications n√©cessitant un cryptage *"on the fly"* comme le **video streaming**.
- **Facilit√©**: Les op√©rations peuvent √™tre effectu√©es par des syst√®mes ayant des **ressources CPU limit√©es**.
- **Pas (ou peu...) besoin de m√©moire/buffering**.
- **Propagation des erreurs limit√©e ou absente**: la retransmission des paquets fautifs suffit normalement (adapt√© aux applications o√π les pertes de paquets sont fr√©quentes comme les **transmissions sans fil (WiFi)**).
- **Inconv√©nients**:
    - La **qualit√© en termes de randomness** du keystream g√©n√©r√© d√©termine la **robustesse du syst√®me**.
    - La **r√©utilisation du keystream** permet une **cryptanalyse facile** (cf. le one-time pad).
:::

::: {.callout-tip collapse=true}
## üìå R√©vision rapide

**Stream Ciphers** = cryptage bit par bit en 2 phases (g√©n√©ration keystream + substitution). 

**Avantages** : rapides, l√©gers, pas de propagation d'erreurs.

**Inconv√©nients** : qualit√© du keystream critique, r√©utilisation = vuln√©rabilit√©.
:::

---

### Stream Ciphers Synchrones

#### Principe de Fonctionnement

Dans un **stream cipher synchrone**, le keystream d√©pend **uniquement de la cl√©**, ind√©pendamment du plaintext et du ciphertext.

**√âquations du processus :**

$$\sigma_{i+1} = f(\sigma_i, k)$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

O√π :

- $\sigma_i$ : √©tat √† l'instant $i$ (√©tat initial $\sigma_0$ peut d√©pendre de $k$)
- $k$ : cl√© secr√®te
- $f$ : fonction de transition d'√©tat
- $g$ : fonction de production du keystream $z_i$
- $h$ : fonction de sortie produisant le ciphertext $c_i$ √† partir du plaintext $m_i$

```{mermaid}
graph LR
    A[Cl√© k] --> B[√âtat œÉi]
    B --> C[Fonction f]
    C --> D[√âtat œÉi+1]
    B --> E[Fonction g]
    E --> F[Keystream zi]
    F --> G[Fonction h]
    H[Plaintext mi] --> G
    G --> I[Ciphertext ci]
    D -.->|boucle| B
```

#### Caract√©ristiques

**Exigence de synchronisation :**

- √âmetteur et r√©cepteur doivent partager la m√™me cl√© $k$ **ET** le m√™me √©tat $\sigma_i$
- Perte de synchronisation = n√©cessit√© de m√©canismes externes (marqueurs, analyse de redondance)

**Propri√©t√©s :**

- **Pas de propagation d'erreur** : modification du ciphertext n'affecte pas les s√©quences ult√©rieures
- **Attention** : suppression d'un ciphertext = d√©synchronisation du r√©cepteur

**Vuln√©rabilit√©s aux attaques actives :**

- ‚úì D√©tection : insertion, √©limination, replay de fragments
- ‚úó Modification de bits : adversaire peut modifier des bits et analyser l'impact sur le plaintext
- **Solution** : m√©canismes d'authentification suppl√©mentaires n√©cessaires

#### Cas particulier : Stream Cipher Additif

Le cas le plus fr√©quent o√π :

- Fonctions $f$ et $g$ remplac√©es par un g√©n√©rateur al√©atoire
- Fonction $h$ = addition modulo 2 (XOR : $\oplus$)

**Formule** : $c_i = z_i \oplus m_i$

::: {.callout-note collapse=true}
## üìÑ Texte original

### Stream Ciphers Synchrones

- Le **keystream g√©n√©r√© d√©pend seulement de la cl√©** et non pas du plaintext ni du ciphertext.
- Le processus d'encryption d'un **stream cipher synchrone** est d√©crit par les √©quations suivantes: 
  $$\sigma_{i+1} = f(\sigma_i, k)$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  avec $\sigma_i$ l'**√©tat initial** qui peut d√©pendre de la cl√© $k$, $f$ la **fonction qui d√©termine l'√©tat suivant**, $g$ la **fonction qui produit le keystream** $z_i$ et $h$ la **fonction de sortie** qui produit le ciphertext $c_i$ √† partir du plaintext $m_i$.

### Stream Ciphers Synchrones: Caract√©ristiques

- **N√©cessitent la synchronisation** de l'√©metteur et du r√©cepteur: En plus d'utiliser la m√™me cl√© $k$, les deux doivent se trouver dans le **m√™me √©tat** pour que le processus fonctionne. Si la synchronisation est perdue il faut des **m√©canismes externes** pour la r√©cup√©rer (marqueurs sp√©ciaux, analyses de redondance du plaintext, etc.)
- **Pas de propagation d'erreur**. La modification du ciphertext pendant la transmission n'entra√Æne pas des perturbations dans des s√©quences de ciphertext ult√©rieures (cependant, la **suppression** d'un ciphertext provoquerait la **d√©synchronisation** du r√©cepteur).
- **Attaques actives**: L'insertion, l'√©limination ou le replay de parties de ciphertext sont **d√©tect√©s** par le r√©cepteur. Cependant, un adversaire pourrait **modifier certains bits** du ciphertext et analyser l'impact sur le plaintext correspondant. Des **m√©canismes d'authentification d'origine** suppl√©mentaires sont n√©cessaires afin de d√©tecter ces attaques.
- **Cas les plus fr√©quent** des Stream Cipher Synchrones: le **stream cipher additif** (cf. le one-time pad) o√π les fonctions $f$ et $g$ g√©n√©rant le keystream sont remplac√©es par un **g√©n√©rateur al√©atoire** et la fonction $h$ est une **addition modulo 2 (xor)**.
:::

::: {.callout-tip collapse=true}
## üìå R√©vision rapide

**Synchrone** : keystream = $f$(cl√© uniquement). √âquations : $\sigma_{i+1} = f(\sigma_i, k)$, $z_i = g(\sigma_i, k)$, $c_i = h(z_i, m_i)$. 

**Exige synchronisation** √©metteur/r√©cepteur. Pas de propagation d'erreur mais vuln√©rable aux modifications de bits. 

**Cas fr√©quent** : cipher additif avec XOR.
:::

---

### Stream Ciphers Asynchrones

#### Principe de Fonctionnement

Aussi appel√©s **auto-synchronis√©s** (*self-synchronizing ciphers*).

Le keystream d√©pend de la cl√© **ET** d'un nombre fixe de ciphertexts pr√©c√©dents.

**√âquations du processus :**

$$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

O√π $\sigma_i$ repr√©sente un buffer des $t$ derniers ciphertexts.

```{mermaid}
graph LR
    A[Cl√© k] --> B[Fonction g]
    C[Buffer: ci-t...ci-1] --> B
    B --> D[Keystream zi]
    D --> E[Fonction h]
    F[Plaintext mi] --> E
    E --> G[Ciphertext ci]
    G -.->|feedback| C
```

#### Caract√©ristiques

**Auto-synchronisation :**

- En cas d'insertion/√©limination de ciphertexts, le r√©cepteur se **re-synchronise automatiquement**
- M√©canisme : m√©morisation (buffer) des derniers ciphertexts

**Propagation d'erreurs limit√©e :**

- Erreur se propage uniquement sur la **taille du buffer** ($t$ bits)
- Apr√®s √©puisement du buffer, d√©cryption correcte reprend

**S√©curit√© face aux attaques actives :**

- **Meilleure d√©tection** : modifications d√©tect√©es gr√¢ce √† la propagation d'erreurs
- **Attention** : l'auto-synchronisation permet au r√©cepteur de continuer m√™me apr√®s insertions/suppressions
- **Solution** : v√©rification de l'int√©grit√© et l'authenticit√© du flux entier n√©cessaire

**Diffusion des statistiques du plaintext :**

- Chaque bit du plaintext influence **tous les ciphertexts subs√©quents**
- **R√©sultat** : meilleure dispersion des statistiques vs. cas synchrone
- **Application** : utiliser pour plaintexts √† faible entropie ou fortement redondants

::: {.callout-note collapse=true}
## üìÑ Texte original

### Stream Ciphers Asynchrones

- Aussi appel√©s **auto-synchronis√©s** (*self synchronizing ciphers*).
- Le **keystream g√©n√©r√© d√©pend de la cl√© ainsi que d'un nombre fix√© de ciphertexts pr√©c√©dents**.
- Le processus d'encryption d'un **stream cipher asynchrone** est d√©crit par les √©quations suivantes: 
  $$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  avec $\sigma_i$, $g$ et $h$ comme pour le cas synchrone.

### Stream Ciphers Asynchrones: Caract√©ristiques

- **Auto-synchronisation**: En cas d'√©limination ou d'insertion de ciphertexts en cours de route, le r√©cepteur est capable de **se re-synchroniser avec l'√©metteur** gr√¢ce √† la **m√©morisation (buffer)** d'un nombre de ciphertext pr√©c√©dents.
- **Propagation d'erreurs limit√©e**: La propagation d'erreurs s'√©tend uniquement au **nombre de bits du ciphertext m√©moris√©s** (taille du buffer). Apr√®s, la decryption se d√©roule √† nouveau correctement.
- **Attaques actives**: La modification de fragments du ciphertext sera **plus facilement d√©tect√©** que dans le cas synchrone √† cause de la propagation d'erreurs. Cependant, comme le r√©cepteur est capable de s'auto-synchroniser avec l'√©metteur, m√™me si des ciphertexts sont √©limin√©s ou ins√©r√©s en cours de route, il convient de **v√©rifier l'int√©grit√© et l'authenticit√© du flot entier**.
- **Diffusion des statistiques du plaintext**: Le fait que **chaque bit du plaintext aura une influence sur la totalit√© des ciphertexts subs√©quents** se traduit par une **plus grande dispersion des statistiques** du plaintext compar√©e au cas synchrone...
- ... Il convient, donc, d'utiliser des **stream ciphers asynchrones lorsque l'entropie des plaintexts est limit√©e** et pourrait permettre des attaques cibl√©es aux plaintexts fortement redondants.
:::

::: {.callout-tip collapse=true}
## üìå R√©vision rapide

**Asynchrone** (auto-synchronis√©) : keystream = $f$(cl√© + derniers ciphertexts). √âtat $\sigma_i$ = buffer de $t$ ciphertexts pr√©c√©dents. 

**Auto-synchronisation** automatique. Propagation d'erreur limit√©e au buffer. 

**Meilleure diffusion** des statistiques ‚Üí id√©al pour plaintexts redondants/faible entropie.
:::

---

### G√©n√©rateurs de Keystreams : LSFR

#### Contexte et N√©cessit√©

**Probl√©matique** : g√©n√©rer un keystream de longueur $m$ √† partir d'une cl√© secr√®te de longueur $l$ avec $l \ll m$.

**Solution** : Linear Feedback Shift Register (**LSFR** ou **LFSR**)

#### Caract√©ristiques des LSFR

**Avantages :**

- **Impl√©mentation hardware optimale** : circuits tr√®s efficaces
- **P√©riodes longues** : s√©quences de grande longueur
- **Bonne qualit√© al√©atoire** : randomness notable
- **Base math√©matique** : propri√©t√©s alg√©briques des combinaisons lin√©aires

**Structure g√©n√©rique** : LSFR de longueur $L$

```{mermaid}
graph LR
    A[bit L-1] --> B[bit L-2]
    B --> C[...]
    C --> D[bit 1]
    D --> E[bit 0]
    E --> F[Output]
    A -.->|feedback| G[‚äï]
    D -.->|coeff| G
    C -.->|coeff| G
    G --> A
```

#### Remarques Importantes sur les LSFR

**Historique et Usage :**

- Construction tr√®s r√©pandue en cryptographie et th√©orie des codes
- Nombreux stream ciphers militaires bas√©s sur LSFR

**Limites de S√©curit√© :**

- **Niveau de s√©curit√© insuffisant** compar√© aux block ciphers modernes
- **Vuln√©rabilit√©** : l'algorithme de Berlekamp-Massey permet de :
  - D√©terminer la **complexit√© lin√©aire** d'un LSFR
  - Calculer un nombre arbitraire de s√©quences g√©n√©r√©es

**M√©trique** : Complexit√© lin√©aire (*linear complexity*)

**Solution d'Am√©lioration :**

Remplacer la combinaison lin√©aire par une **fonction non lin√©aire** $f$

‚Üí **Non Linear Feedback Shift Registers** (NLFSR)

::: {.callout-note collapse=true}
## üìÑ Texte original

### Stream Ciphers: G√©n√©rateurs de Keystreams

- Lorsqu'il convient de **g√©n√©rer un keystream d'une longueur $m$** √† partir d'une **cl√© secr√®te de longueur $l$** avec $l \ll m$, on fait appel √† des **g√©n√©rateurs de keystreams**.
- Le plus courant de ces g√©n√©rateurs est le **Linear Feedback Shift Register (LSFR)**.
- Un LSFR a les caract√©ristiques suivantes:
    - S'adapte **tr√®s bien aux implantations hardware**.
    - Produit des s√©quences de **p√©riodes longues** et avec une **qualit√© al√©atoire notable** (randomness assez forte)
    - Se base sur les **propri√©t√©s alg√©briques des combinaisons lin√©aires**.

### LSFRs: Quelques Remarques

- Les LSFRs sont des constructions **tr√®s r√©pandues** dans la cryptographie et dans la th√©orie de codes.
- Un **grand nombre de stream ciphers** bas√©s sur les LSFRs (surtout dans la **sph√®re militaire**) ont √©t√© d√©velopp√©s dans le pass√©.
- Malheureusement, le **niveau de s√©curit√© offert par ces syst√®mes est jug√© insuffisant** de nos jours (compar√© √† celui des blocks ciphers...)
- La **m√©trique** permettant d'analyser un LFSR est sa **complexit√© lin√©aire** (*linear complexity*). L'**algorithme de Berlekamp-Massey** permet de d√©terminer la complexit√© lin√©aire d'un LSFR et de calculer ainsi un nombre arbitrairement grand de s√©quences g√©n√©r√©es par un LSFR.
- Une solution pour **augmenter la complexit√©** est de substituer la combinaison lin√©aire des bits du ciphertext par une **fonction non lin√©aire** $f$. Ce sont les **Non Linear Feedback Shift Registers**.
:::

::: {.callout-tip collapse=true}
## üìå R√©vision rapide

**LSFR** : g√©n√©rateur de keystream long ($m$) depuis cl√© courte ($l$). Base = combinaisons lin√©aires. 

**Avantages** : hardware efficace, p√©riodes longues. 

**Probl√®me** : s√©curit√© insuffisante, vuln√©rable √† Berlekamp-Massey (calcul de complexit√© lin√©aire). 

**Solution** : NLFSR (fonction non lin√©aire).
:::

---

### RC4 : Stream Cipher Logiciel

#### Pr√©sentation G√©n√©rale

**RC4‚Ñ¢** (*Rivest Cipher 4*) d√©velopp√© en 1987 par Ron Rivest pour RSA Security.

**Caract√©ristiques principales :**

- **Cl√© variable** : longueur flexible
- **Extr√™mement rapide** : 10√ó plus rapide que DES
- **Mode synchrone** : keystream ind√©pendant du plaintext/ciphertext

**Historique :**

- 1987-1994 : brevet√©, d√©tails confidentiels (contrat NDA requis)
- 1994 : publication non officielle dans un newsgroup
- Depuis : analyse intensive par la communaut√© cryptographique

#### Architecture

**Composants cl√©s :**

- **S-box** : bo√Æte de substitution 8√ó8 (256 entr√©es)
  - Contenu : permutation des nombres 0 √† 255
  - D√©pend de la cl√© principale de longueur variable : $0 < len(k) \leq 255$
- **Combinaisons** : lin√©aires et non lin√©aires
- **Chiffrement final** : XOR entre keystream et plaintext

#### Applications et S√©curit√©

**Utilisations commerciales (nombreuses) :**

- Lotus Notes
- Oracle SQL
- Microsoft Windows
- SSL/TLS
- Et bien d'autres...

**Analyses et Vuln√©rabilit√©s :**

- Travaux exhaustifs sur le key scheduling et le PRGA
- **Faille majeure** : impl√©mentation dans WEP (WiFi Wired Equivalent Privacy)
  - Protocole WEP compl√®tement compromis
  - Probl√®me : mode d'utilisation d√©faillant, pas l'algorithme RC4 lui-m√™me

#### Fonctionnement

RC4 se d√©compose en **deux √©tapes** :

1. **Key Scheduling Algorithm (KSA)**
   - Responsable de la permutation initiale de la S-box
   - Fonction de la cl√© de longueur variable $len(k) = l$

2. **Pseudo Random Generator Algorithm (PRGA)**
   - G√©n√®re le keystream de taille arbitraire
   - S'appuie sur la S-box permut√©e par KSA

```{mermaid}
graph TB
    A[Cl√© k de longueur variable] --> B[KSA: Key Scheduling]
    B --> C[S-box permut√©e]
    C --> D[PRGA: G√©n√©ration]
    D --> E[Keystream zi]
    E --> F[XOR]
    G[Plaintext mi] --> F
    F --> H[Ciphertext ci]
```

::: {.callout-note collapse=true}
## üìÑ Texte original

### Software Cipher Streams: RC4

- Le grand **d√©savantage des stream ciphers bas√©s sur des registres** est qu'ils sont **tr√®s lents en version programm√©e** dans une machine g√©n√©rique. **RC4‚Ñ¢** est un **stream cipher √† cl√© variable** d√©velopp√© en **1987 par Ron Rivest** pour la soci√©t√© RSA security. Il est **tr√®s rapide** (**10 fois plus rapide que DES** !)
- Pendant 7 ans, cet algorithme √©tait **brevet√©** et les d√©tails son fonctionnement interne √©tait d√©voil√©s seulement apr√®s la **signature d'un contrat de confidentialit√©**. Depuis sa **publication (non officielle) dans un newsgroup en 1994**, il est globalement discut√© et analys√© dans toute la communaut√© cryptographique.
- L'algorithme travaille en **mode synchrone** (le keystream est ind√©pendant du ciphertext et du plaintext).
- Il est compos√© de **combinaisons lin√©aires et non lin√©aires**. L'√©l√©ment cl√© est une **bo√Æte de substitution (S-box) de taille 8√ó8** dont les entr√©es sont une **permutation des chiffres 0 √† 255**. La permutation est une **fonction de la cl√© principale** de taille variable avec $0 < len(k) \leq 255$. L'**encryption finale est obtenue par un xor** entre le keystream et le plaintext.
- RC4 est utilis√© dans un **grand nombre d'applications commerciales**: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. Il est l'objet d'un grand nombre de **travaux analytiques et exhaustifs** qui ont r√©ussi √† **compromettre la s√©curit√©** du key scheduling et du PRGA.
- En particulier l'application de RC4 sur les **Wired Equivalent Privacy (WiFi WEP) protocole a √©t√© "cass√©e"** suite √† une **faille dans le mode d'utilisation** du protocole.

### RC4: Fonctionnement

- L'algorithme est constitu√© de **deux √©tapes**:
    - Le **Key Scheduling Algorithm (KSA)**: Responsable de la **permutation initiale** qui remplira la S-box en fonction de la cl√© de longueur variable $len(k) = l$.
    - Le **Pseudo Random Generator Algorithm (PRGA)**: G√©n√®re le **keystream de taille arbitraire** en s'appuyant sur la S-box.
:::

::: {.callout-tip collapse=true}
## üìå R√©vision rapide

**RC4** : stream cipher logiciel, cl√© variable, 10√ó plus rapide que DES.

**Architecture** : S-box 8√ó8 (permutation 0-255) + XOR. 

**2 √©tapes** : KSA (permutation S-box) + PRGA (g√©n√©ration keystream). Mode synchrone. 

**Vuln√©rabilit√©** : WEP cass√© (faille d'utilisation). Utilis√© dans SSL, Windows, Oracle...
:::

## Block Ciphers (Cryptage par Blocs)

### 1. Introduction aux Block Ciphers

#### D√©finition et Principe

Un **block cipher** (chiffrement par blocs) est une fonction cryptographique qui :

- **Transforme des blocs de taille fixe** : fait correspondre un bloc de $n$ bits √† un autre bloc de la m√™me taille
- **Est param√©tris√©e par une cl√©** : la cl√© $K$ de $k$ bits d√©finit la transformation
- **Doit √™tre bijective** : pour permettre un d√©cryptage unique
- **Chaque cl√© = bijection diff√©rente** : garantit la variabilit√©

**Taille nominale** : taille d'entr√©e du bloc sur lequel s'applique l'encryption

#### Crit√®res de Qualit√©

**1. Taille/Entropie de la cl√©**

- Cl√©s id√©alement **√©quiprobables** avec entropie = $k$ bits
- Forte entropie prot√®ge contre les **attaques brute-force**
- **Minimum requis** : 128 bits pour les block ciphers modernes

**2. Performances**

- Vitesse d'ex√©cution
- Efficacit√© en software/hardware

**3. Taille du bloc**

- Bloc trop petit = vuln√©rabilit√© aux **dictionnaires plaintext/ciphertext**
- **Standard moderne** : blocs ‚â• 128 bits

**4. R√©sistance cryptographique**

- R√©sistance aux techniques connues :
  - Cryptanalyse lin√©aire
  - Cryptanalyse diff√©rentielle
  - Meet in the middle
- **Effort de cryptanalyse** √©quivalent au brute force

```{mermaid}
graph LR
    A[Plaintext n bits] --> B[Block Cipher]
    C[Cl√© K k bits] --> B
    B --> D[Ciphertext n bits]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
```

::: {.callout-note collapse=true}
### üìÑ Texte original

#### Cryptage par Blocs (Block Ciphers)

- Les **block ciphers sym√©triques** constituent la **pierre angulaire de la cryptographie**. Leur fonctionnalit√© principale est la **confidentialit√©** mais ils sont √©galement √† la base des services d'**authentification**, **fonctions de hachage**, **g√©n√©ration al√©atoire**, etc.

- **D√©finition**: Un block cipher est une **fonction** qui fait correspondre √† un **bloc de $n$ bits** un autre bloc de **la m√™me taille**. La fonction est **param√®tr√©e par une cl√© $K$ de $k$ bits**. Afin de permettre une **decryption unique**, la fonction doit √™tre **bijective**. **Chaque cl√© d√©finit une bijection diff√©rente**. La **taille d'entr√©e du bloc** sur lequel s'applique l'encryption s'appelle aussi **taille nominale de l'algorithme**.

- **Crit√®res pour √©valuer la qualit√©** d'un block cipher:
  - **Taille/Entropie de la cl√©**: Id√©alement, les cl√©s sont **√©quiprobables** et l'espace des cl√©s a une **entropie √©gale √† $k$**. Une **forte entropie** de la cl√© prot√®ge des **attaques brute-force** √† partir de chosen/known plaintexts. Les block ciphers modernes doivent avoir des **cl√©s d'au moins 128 bits**.
  - **Performances**
  - **Taille du bloc**: Un bloc **trop petit** permettrait des attaques o√π des **"dictionnaires" plaintext/ciphertext** seraient construits. De nos jours, des **blocs de taille ‚â• 128 bits** deviennent courants.
  - **R√©sistance cryptographique**: Le block cipher doit se montrer **r√©sistant** √† des techniques de cryptanalyse connues: **cryptanalyse lin√©aire ou diff√©rentielle**, **meet in the middle**, etc. L'**effort inh√©rent** √† ces attaques (complexit√©, stockage, parall√©lisation, etc.) doit √™tre **√©quivalent √† celui d'une attaque brute force**.
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide

**Block cipher** : fonction bijective transformant blocs de $n$ bits avec cl√© $K$ de $k$ bits. **Crit√®res** : entropie cl√© ‚â• 128 bits, taille bloc ‚â• 128 bits, r√©sistance cryptanalyse = effort brute force. **Usage** : confidentialit√©, authentification, hachage, g√©n√©ration al√©atoire.
:::

---

### 2. Modes d'Op√©ration des Block Ciphers

#### 2.1 Electronic Codebook (ECB)

**Principe** : chaque bloc de plaintext est encrypt√© **ind√©pendamment** avec la m√™me cl√©.

$$c_i = E_K(m_i)$$
$$m_i = D_K(c_i)$$

```{mermaid}
graph TB
    subgraph Encryption
        P1[Plaintext Block 1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext Block 1]
        
        P2[Plaintext Block 2] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext Block 2]
    end
    
    style E1 fill:#ffcccc
    style E2 fill:#ffcccc
    style K1 fill:#fff4e1
    style K2 fill:#fff4e1
```

**Caract√©ristiques :**

- ‚úó **Plaintexts identiques** ‚Üí ciphertexts identiques (pr√©visible)
- ‚úì **Pas de propagation d'erreurs** : erreur sur $c_j$ n'affecte que $m_j$
- ‚úó **Patterns visibles** : structure du plaintext transparente dans le ciphertext
- ‚úì **Parall√©lisable** : chaque bloc trait√© ind√©pendamment

**‚ö†Ô∏è Vuln√©rabilit√© majeure** : Ne doit PAS √™tre utilis√© pour des donn√©es redondantes

---

#### 2.2 Cipher Block Chaining (CBC)

**Principe** : chaque bloc de plaintext est **XOR√© avec le ciphertext pr√©c√©dent** avant encryption.

$$c_i = E_K(m_i \oplus c_{i-1})$$
$$m_i = D_K(c_i) \oplus c_{i-1}$$

Avec $c_0 = IV$ (Initialization Vector)

```{mermaid}
graph TB
    subgraph Encryption
        IV[IV] --> X1[‚äï]
        P1[Plaintext m1] --> X1
        X1 --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext c1]
        
        C1 --> X2[‚äï]
        P2[Plaintext m2] --> X2
        X2 --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ccffcc
    style E2 fill:#ccffcc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Caract√©ristiques :**

- ‚úì **Plaintexts identiques** ‚Üí ciphertexts diff√©rents (si IV change)
- ‚úì **Patterns effac√©s** : cha√Ænage masque la structure
- ‚úì **Propagation d'erreurs limit√©e** : erreur sur $c_j$ affecte $m_j$ et $m_{j+1}$ uniquement
- ‚úó **Non parall√©lisable** en encryption (s√©quentiel)
- ‚úì **Parall√©lisable** en d√©cryption

**IV (Initialization Vector)** :

- Doit √™tre **al√©atoire** ou **pseudo-al√©atoire**
- Peut √™tre transmis **en clair**
- Doit √™tre **diff√©rent** pour chaque message avec la m√™me cl√©

---

#### 2.3 Cipher Feedback Mode (CFB)

**Principe** : fonctionne comme un **stream cipher** o√π le keystream est g√©n√©r√© par le block cipher. Le keystream d√©pend des **ciphertexts pr√©c√©dents** (mode **asynchrone**).

$$c_i = m_i \oplus E_K(c_{i-1})$$
$$m_i = c_i \oplus E_K(c_{i-1})$$

Avec $c_0 = IV$

```{mermaid}
graph TB
    subgraph CFB_Encryption
        IV[IV / ci-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[‚äï]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        C1 -.feedback.-> IV
    end
    
    style E1 fill:#ffccff
    style X1 fill:#ffffcc
```

**Caract√©ristiques :**

- ‚úì **Plaintexts identiques** ‚Üí ciphertexts diff√©rents (si IV change)
- ‚úì **Cha√Ænage** : d√©pendances entre ciphertexts
- ‚ö†Ô∏è **Propagation d'erreurs** : erreur sur $c_j$ affecte $\frac{n}{r}$ blocs suivants
  - $n$ = taille nominale du block cipher
  - $r$ = taille des plaintexts
- ‚úó **Non parall√©lisable**
- ‚ö†Ô∏è **IV non confidentiel** mais doit √™tre transmis

**Usage** : adapt√© aux transmissions avec pertes de paquets fr√©quentes

---

#### 2.4 Output Feedback Mode (OFB)

**Principe** : fonctionne comme un **stream cipher synchrone**. Le keystream est **enti√®rement d√©termin√©** par la cl√© et l'IV, **ind√©pendant** du plaintext et du ciphertext.

$$z_i = E_K(z_{i-1})$$
$$c_i = m_i \oplus z_i$$
$$m_i = c_i \oplus z_i$$

Avec $z_0 = IV$

```{mermaid}
graph TB
    subgraph OFB_Mode
        IV[IV / zi-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> Z[zi keystream]
        Z --> X1[‚äï]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        Z -.feedback.-> IV
    end
    
    style E1 fill:#cce5ff
    style X1 fill:#ffffcc
    style Z fill:#e1ffe1
```

**Caract√©ristiques :**

- ‚úì **Plaintexts identiques** ‚Üí ciphertexts diff√©rents (si IV change)
- ‚úì **Pas de propagation d'erreurs** : erreur sur $c_j$ n'affecte que $m_j$
- ‚úì **Keystream pr√©-calculable** : efficace
- ‚ö†Ô∏è **CRITIQUE** : ne JAMAIS r√©utiliser le m√™me IV avec la m√™me cl√© (sinon keystream identique)
- ‚úì **Parall√©lisable** si keystream pr√©-calcul√©

**‚ö†Ô∏è Attention r√©utilisation** : Modifier l'IV pour chaque nouveau message !

::: {.callout-note collapse=true}
### üìÑ Texte original (Modes CFB et OFB)

#### Modes CFB et OFB: Caract√©ristiques

Les modes **CFB et OFB** fonctionnent comme un **stream cipher** avec un **keystream g√©n√©r√© par le bloc de cryptage**. Dans **CFB**, le keystream d√©pend des **ciphertexts pr√©c√©dents** (**asynchrone**) alors que dans **OFB**, le keystream est **enti√®rement d√©termin√© par la cl√© et le IV** (**synchrone**).

**Particularit√©s de CFB**:

- Comme dans le mode CBC, des **plaintext identiques** sont traduits en **ciphertexts diff√©rents** si le **IV change**. Le **IV n'est pas n√©cessairement confidentiel** et peut √™tre √©chang√© en clair entre les parties.
- Le **cha√Ænage** introduit √©galement des **d√©pendances** entre les ciphertexts courants et les ciphertexts pr√©c√©dents. En particulier, si $n$ est la **taille nominale de l'algorithme** et $r$ est la **taille des plaintexts**, le ciphertext courant d√©pendra des $\frac{n}{r}$ **ciphertexts pr√©c√©dents** (chaque it√©ration d√©calera l'entr√©e fautive de $r$ positions, apr√®s $\frac{n}{r}$ it√©rations le ciphertext fautif sera "expuls√©" compl√®tement).
- La **propagation d'erreurs** ob√©it au m√™me principe: une erreur dans un ciphertext se traduira par une mauvaise decryption des $\frac{n}{r}$ ciphertexts suivants.

**Particularit√©s de OFB**:

- OFB a un comportement **identique** aux modes CBC et CFB pour l'**encryption de plaintext identiques**.
- **Pas de propagation d'erreurs** sur les ciphertexts adjacents.
- **Modifiez le IV** si la cl√© ne change pas pour **√©viter la r√©utilisation du keystream** !!!
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide (Modes CFB/OFB)

**CFB** (asynchrone) : keystream = $f$(ciphertexts pr√©c√©dents). Propagation erreur limit√©e ($\frac{n}{r}$ blocs).

**OFB** (synchrone) : keystream = $f$(cl√© + IV uniquement). Pas propagation erreur. 

**CRITIQUE** : ne JAMAIS r√©utiliser m√™me IV avec m√™me cl√©. IV transmissible en clair.
:::

---

#### 2.5 Counter Mode (CTR)

**Principe** : le keystream est g√©n√©r√© par l'**encryption d'un compteur** incr√©ment√© √† chaque bloc.

$$c_i = m_i \oplus E_K(counter + i)$$
$$m_i = c_i \oplus E_K(counter + i)$$

```{mermaid}
graph TB
    subgraph CTR_Mode
        CTR1[Counter + 0] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[‚äï]
        P1[Plaintext m1] --> X1
        X1 --> C1[Ciphertext c1]
        
        CTR2[Counter + 1] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> X2[‚äï]
        P2[Plaintext m2] --> X2
        X2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ffe6cc
    style E2 fill:#ffe6cc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Caract√©ristiques :**

- ‚úì **Mode synchrone** : keystream = $f$(compteur)
- ‚úì **Parall√©lisable** : keystream pr√©-calculable pour encryption ET d√©cryption
- ‚úì **Acc√®s al√©atoire** : chaque bloc d√©cryptable ind√©pendamment
- ‚úì **Pas de propagation d'erreurs**
- ‚úì **Profite des architectures SIMD** : pas de d√©pendances entre blocs
- ‚ö†Ô∏è **Compteur** : doit √™tre de taille $2^b$ ($b$ = taille du bloc)
- ‚ö†Ô∏è **CRITIQUE** : ne JAMAIS r√©utiliser le m√™me compteur avec la m√™me cl√©

**Gestion du compteur** :

- **Incr√©menter modulo** $2^b$ apr√®s chaque it√©ration
- **Solution** : toujours incr√©menter pour chaque flux encrypt√©
- Premier bloc du flux $i+1$ > dernier bloc du flux $i$

**Applications** :

- **ATM** (Asynchronous Transfer Mode)
- **IPsec** (IP security)
- **Lignes √† haut d√©bit** : transmission s√©lective des blocs
- **Transferts de grands volumes** : vid√©o

::: {.callout-note collapse=true}
### üìÑ Texte original (Counter Mode)

#### Counter Mode (CTR Mode)

Fr√©quemment utilis√© comme support d'encryption dans des protocoles de transfert de donn√©es comme **ATM** (Asynchronous Transfer Mode) et **IPsec** (IP security).

#### Counter Mode (II)

- Le **keystream** est g√©n√©r√© par l'**encryption d'un compteur al√©atoire** de taille $2^b$ (avec $b$ la taille du bloc) et n√©cessaire pour la d√©cryption. Ce compteur est **incr√©ment√© modulo** $2^b$ apr√®s chaque it√©ration.
- Travaille en **mode synchrone**. La **r√©utilisation d'un m√™me compteur** se traduit par un **keystream identique** !
- **Solution**: Toujours **incr√©menter le compteur** pour chaque flot encrypt√© de telle sorte que le compteur du premier bloc d'un flot soit **plus grand que le dernier bloc** du flot pr√©c√©dent.
- **Facilement parall√©lisable**: Le keystream peut √™tre **pr√©-calcul√©** aussi bien pour l'encryption que pour la d√©cryption. Profite pleinement des **architectures SIMD** car contrairement aux autres modes de cha√Ænage il n'y a pas des **d√©pendances entre les op√©rations** des diff√©rents blocs.
- **Acc√®s al√©atoire** √† l'encryption/d√©cryption de chaque bloc: Contrairement aux autres modes de cha√Ænage o√π la $i$-√®me op√©ration d√©pend de la $(i-1)$-√®me op√©ration.
- Si √† ceci on ajoute l'**absence de propagation d'erreurs**, le mode compteur facilite la **(re)transmission s√©lective** des blocs de ciphertext, ce qui le rend tr√®s attractif pour la **s√©curisation de lignes √† haut d√©bit** ainsi que pour les **transferts encrypt√©s de grands volumes** d'information (p.ex. vid√©o).
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide (Counter Mode)

**CTR** : keystream = $E_K$(compteur + $i$).

**Avantages** : parall√©lisable (encryption + d√©cryption), acc√®s al√©atoire, pas propagation erreur, SIMD-friendly.

**CRITIQUE** : ne jamais r√©utiliser compteur.

**Usage** : ATM, IPsec, haut d√©bit, vid√©o.
:::

---

### 3. Product Ciphers et Feistel Ciphers

#### Product Ciphers

**D√©finition** : sch√©ma de cryptage combinant une **s√©rie de transformations successives** pour renforcer la r√©sistance √† la cryptanalyse.

**Transformations courantes** :

- Transpositions (permutations)
- Substitutions (S-boxes)
- XORs
- Combinaisons lin√©aires
- Multiplications modulaires

#### Feistel Ciphers

**D√©finition** : product cipher it√©ratif avec structure sp√©cifique.

**Principe de fonctionnement** :

- **Entr√©e** : plaintext de $2t$ bits = $(L_0, R_0)$ (deux sous-blocs de $t$ bits)
- **Sortie** : ciphertext de $2t$ bits = $(R_r, L_r)$ apr√®s $r$ √©tapes (rounds)
- **Chaque √©tape** : bijection inversible (pour d√©cryption unique)

**√âquations d'une √©tape** $i$ ($1 \leq i \leq r$) :

$$(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$$

Avec :

- $L_i = R_{i-1}$
- $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$

```{mermaid}
graph TB
    subgraph Feistel_Round
        L0[Li-1] --> R1[Ri = Li-1 ‚äï f]
        R0[Ri-1] --> L1[Li = Ri-1]
        R0 --> F[Function f]
        K[Key Ki] --> F
        F --> XOR[‚äï]
        L0 --> XOR
        XOR --> R1
    end
    
    style F fill:#ffcccc
    style XOR fill:#ffffcc
    style K fill:#fff4e1
```

**Caract√©ristiques** :

- $K_i$ : sous-cl√©s g√©n√©r√©es √† partir de la cl√© principale $K$
- Nombre d'√©tapes $r$ : g√©n√©ralement **pair** et $\geq 3$
  - Exemple : DES a 16 √©tapes
- **Permutation finale** : $(L_r, R_r) \rightarrow (R_r, L_r)$
- **D√©cryption** : identique √† l'encryption mais sous-cl√©s appliqu√©es en **ordre inverse** (de $K_r$ √† $K_1$)

**Op√©rations fr√©quentes** :

- Permutations
- Substitutions (S-boxes)

::: {.callout-note collapse=true}
### üìÑ Texte original

#### Product Ciphers et Feistel Ciphers

- Un **product cipher** est un **sch√©ma de cryptage** combinant une **s√©rie de transformations successives** dans le but de **renforcer la r√©sistance √† la cryptanalyse**. Des transformations courantes pour un product cipher sont: des **transpositions**, des **substitutions**, des **XORs**, des **combinaisons lin√©aires**, des **multiplications modulaires**, etc.

- Un **Feistel cipher** est un **product cipher it√©ratif** capable de transformer un **plaintext de $2t$ bits** de la forme $(L_0, R_0)$ compos√© par deux **sous-blocs** $L_0$ et $R_0$ de $t$ bits en un **ciphertext de taille $2t$** de la forme $(R_r, L_r)$ apr√®s $r$ **√©tapes (rounds) successives** avec $r \geq 1$. **Chaque √©tape** d√©finit une **bijection (inversible !)** pour permettre une decryption unique.

- Des **permutations** et des **substitutions** sont les op√©rations les plus fr√©quentes.

- Les √©tapes $1 \leq i \leq r$ s'√©crivent: $(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$ avec $L_i = R_{i-1}$ et $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$. Les $K_i$ sont des **sous-cl√©s**, **diff√©rentes pour chaque √©tape**, g√©n√©r√©es √† partir de la **cl√© principale $K$** du sch√©ma de cryptage.

- Le **nombre d'√©tapes** propres √† un Feistel cipher est normalement **pair** et $\geq 3$ (p.ex. **DES a 16 √©tapes**)

- Apr√®s l'ex√©cution de toutes les √©tapes, un Feistel cipher effectue une **permutation** des deux parties $(L_r, R_r)$ en $(R_r, L_r)$.

- La **decryption** d'un Feistel Cipher est **identique √† l'encryption** sauf que les sous-cl√©s $K_i$ sont appliqu√©es en **ordre inverse** (De $K_r$ √† $K_1$).
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide

**Product cipher** : combinaison de transformations successives (transpositions, substitutions, XOR).

**Feistel cipher** :

  - product cipher it√©ratif
  - plaintext $2t$ bits = $(L_0, R_0)$
  - $r$ rounds avec $L_i = R_{i-1}$ et $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$.
  - D√©cryption = encryption avec sous-cl√©s invers√©es.
  - Exemple : DES (16 rounds).
:::

---

### 4. Data Encryption Standard (DES)

#### Pr√©sentation G√©n√©rale

**DES** (Data Encryption Standard) : algorithme cryptographique le plus important jusqu'√† l'av√®nement d'AES en 2001.

**Caract√©ristiques principales** :

- **Type** : Feistel Cipher
- **Taille des blocs** : 64 bits (taille nominale)
- **Taille de la cl√©** : 56 bits effectifs (64 bits totaux avec 8 bits de parit√©)
- **Nombre d'√©tapes** : 16 rounds
- **Sous-cl√©s** : 16 sous-cl√©s de 48 bits (une par √©tape)
- **Modes d'utilisation** : ECB, CBC, CFB, OFB

```{mermaid}
graph TB
    subgraph DES_Overview
        P[Plaintext 64 bits] --> DES[DES Encryption]
        K[Key 56 bits] --> DES
        DES --> C[Ciphertext 64 bits]
        
        C --> DES_INV[DES Decryption]
        K2[Key 56 bits] --> DES_INV
        DES_INV --> P2[Plaintext 64 bits]
    end
    
    style DES fill:#ffcccc
    style DES_INV fill:#ccffcc
    style K fill:#fff4e1
    style K2 fill:#fff4e1
```

#### Structure de DES

**Composants principaux** :

1. **Permutation initiale (IP)** : permutation des 64 bits d'entr√©e
2. **16 rounds Feistel** : transformation it√©rative
3. **Permutation finale (IP‚Åª¬π)** : inverse de IP

**Chaque round applique** :

- Division en deux moiti√©s : $L_{i-1}$ et $R_{i-1}$ (32 bits chacune)
- Fonction $f$ sur $R_{i-1}$ avec sous-cl√© $K_i$
- XOR avec $L_{i-1}$
- √âchange des moiti√©s

```{mermaid}
graph TB
    Plain[Plaintext 64 bits] --> IP[Initial Permutation IP]
    IP --> Split[Split L0, R0]
    
    Split --> Round1[Round 1]
    K1[K1] --> Round1
    Round1 --> Round2[Round 2]
    K2[K2] --> Round2
    Round2 --> Dots[...]
    Dots --> Round16[Round 16]
    K16[K16] --> Round16
    
    Round16 --> Swap[Swap R16, L16]
    Swap --> IP_inv[Final Permutation IP‚Åª¬π]
    IP_inv --> Cipher[Ciphertext 64 bits]
    
    style IP fill:#e1f5ff
    style IP_inv fill:#e1f5ff
    style Round1 fill:#ffcccc
    style Round2 fill:#ffcccc
    style Round16 fill:#ffcccc
```

#### Fonction Cipher de DES

La **fonction $f$** pour chaque round :

1. **Expansion E** : 32 bits ‚Üí 48 bits (table E)
2. **Key Addition** : XOR avec sous-cl√© $K_i$ (48 bits)
3. **S-boxes** : 8 S-boxes transforment 48 bits ‚Üí 32 bits
   - Chaque S-box : 6 bits entr√©e ‚Üí 4 bits sortie
4. **Permutation P** : permutation des 32 bits r√©sultants

```{mermaid}
graph TB
    R[Ri-1 32 bits] --> E[Expansion E]
    E --> E_out[48 bits]
    E_out --> XOR1[‚äï]
    K[Ki 48 bits] --> XOR1
    XOR1 --> S[8 S-boxes]
    S --> S_out[32 bits]
    S_out --> P[Permutation P]
    P --> F_out[f output 32 bits]
    
    style E fill:#cce5ff
    style S fill:#ffcccc
    style P fill:#e1ffe1
    style XOR1 fill:#ffffcc
```

**Fonctionnement des S-boxes** :

Entr√©e : $a_1a_2a_3a_4a_5a_6$ (6 bits)

- **Ligne** : $a_1 + 2a_6$ (bits externes)
- **Colonne** : $a_2 + 2a_3 + 4a_4 + 8a_5$ (bits internes)
- **Sortie** : valeur de la cellule correspondante (4 bits)

#### G√©n√©ration des Sous-cl√©s

**Processus** :

1. Cl√© principale : 64 bits (56 effectifs + 8 parit√©)
2. **Permuted Choice 1 (PC-1)** : s√©lection de 56 bits
3. Division en deux moiti√©s : $C_0$ et $D_0$ (28 bits chacune)
4. Pour chaque round $i$ :
   - Rotation circulaire gauche de $C_{i-1}$ et $D_{i-1}$
   - **Permuted Choice 2 (PC-2)** : s√©lection de 48 bits pour $K_i$

**Rotations** :

- Rounds 1, 2, 9, 16 : 1 position
- Autres rounds : 2 positions

::: {.callout-note collapse=true}
### üìÑ Texte original (DES Fonctionnement)

#### DES: Fonctionnement

**Cipher Fonction**

- **Expansion E**: Les **32 bits de l'entr√©e** sont transform√©s en un vecteur de **48 bits** en utilisant la **table E**. La premi√®re ligne de cette table indique comment sera g√©n√©r√© le premier sous-bloc de 6 bits: on prendra en premier le 32e bit et apr√®s les bits 1,2,3,4,5. Le deuxi√®me sous-bloc commence par le 4e bit ensuite les bits 5,6,7,8,9 et ainsi de suite...

- **Key addition**: **XOR du vecteur de 48 bits** avec la cl√©.

- **S-boxes**: On applique **8 S-boxes** sur le vecteur de 48 bits r√©sultant du XOR pr√©c√©dent. Chacune de ces S-boxes prend un **sous-bloc de 6 bits** et le transforme en un **sous-bloc de 4 bits**. L'op√©ration s'effectue de la mani√®re suivante: Si on d√©note les 6 bits d'input de la S-box comme: $a_1a_2a_3a_4a_5a_6$. La sortie est donn√©e par le contenu de la cellule situ√©e dans la **ligne** $a_1 + 2a_6$ et la **colonne** $a_2 + 2a_3 + 4a_4 + 8a_5$.

- **Permutation P**: La permutation P fonctionne comme suit: Le premier bit est envoy√© √† la 16e position, le deuxi√®me √† la 7e position et ainsi de suite.

**Permutations IP et IP‚Åª¬π**

- Agissent respectivement au **d√©but** et √† la **fin** du traitement du bloc et sur l'**ensemble des 64 bits**.
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide (DES)

**DES** : Feistel cipher, 64 bits blocs, 56 bits cl√© effective, 16 rounds.

**Fonction $f$** : Expansion E (32‚Üí48 bits) ‚Üí XOR $K_i$ ‚Üí 8 S-boxes (48‚Üí32 bits) ‚Üí Permutation P.

**S-box** : 6 bits input ‚Üí 4 bits output via table (ligne = bits externes, colonne = bits internes).

**Permutations** : IP (initiale) et IP‚Åª¬π (finale) sur 64 bits.
:::

---

### 5. Triple-DES et S√©curit√© de DES

#### Vuln√©rabilit√©s de DES

**Probl√®me principal** : taille de l'espace de cl√©s $\{0,1\}^{56}$ insuffisante.

**Attaque brute force** :

- **1999** : cl√© trouv√©e en **24 heures**
- Technique : brute force massivement parall√®le (100'000 PCs sur Internet)
- Known plaintext attack

#### Triple-DES (3DES)

**Solution** : augmenter l'espace des cl√©s √† $\{0,1\}^{112}$.

**Sch√©ma** :

$$C = E_{K_1}(D_{K_2}(E_{K_1}(P)))$$

Avec :

- $E$ : encryption DES
- $D$ : d√©cryption DES
- $K_1, K_2$ : deux cl√©s de 56 bits

```{mermaid}
graph LR
    P[Plaintext 64 bits] --> E1[DES Encrypt K1]
    E1 --> D[DES Decrypt K2]
    D --> E2[DES Encrypt K1]
    E2 --> C[Ciphertext 64 bits]
    
    K1a[Key K1 56 bits] --> E1
    K2[Key K2 56 bits] --> D
    K1b[Key K1 56 bits] --> E2
    
    style E1 fill:#ffcccc
    style D fill:#ccffcc
    style E2 fill:#ffcccc
```

**Avantages** :

- ‚úì **S√©curit√© satisfaisante** : espace de cl√©s $2^{112}$
- ‚úì **Compatibilit√©** : r√©utilisation du hardware/software DES existant
- ‚úì **Migration progressive** : en attendant AES

**Inconv√©nient** :

- ‚úó **Performances** : 3√ó plus lent (3 ex√©cutions DES successives)

#### Propri√©t√©s de DES

**1. DES n'est pas un groupe**

DES n'est PAS un groupe pour la composition :

$$\nexists K_3 \text{ tel que } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)$$

**Cons√©quence** : encryption compos√©e (Triple-DES) augmente consid√©rablement la s√©curit√©.

**Si DES √©tait un groupe** : recherche exhaustive sur $\{0,1\}^{56}$ casserait l'algorithme ind√©pendamment du nombre d'ex√©cutions cons√©cutives.

**2. Cl√©s faibles et semi-faibles**

- **Cl√© faible** : $E_K(E_K(x)) = x$

- **Paire de cl√©s semi-faibles** : $E_{K_1}(E_{K_2}(x)) = x$

**Caract√©ristique** : cl√©s faibles g√©n√®rent des sous-cl√©s identiques par paires :

- $k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$
- Facilite la cryptanalyse

**DES a 4 cl√©s faibles** :

| Cl√© faible (hexad√©cimal) |
|---------------------------|
| 0101 0101 0101 0101 |
| 0101 0101 FEFE FEFE |
| FEFE FEFE FEFE FEFE |
| FEFE FEFE 0101 0101 |

**Et 6 paires de cl√©s semi-faibles**

::: {.callout-note collapse=true}
### üìÑ Texte original (DES et 3DES)

#### DES et Triple-DES

- La **taille de l'ensemble de cl√©s** ($\{0,1\}^{56}$) constitue la **plus grande menace** qui p√®se sur DES avec les ressources de calcul actuels. En **1999** il a suffit de **24 heures** pour trouver la cl√© √† partir d'un **known plaintext** en utilisant une technique **brute force massivement parall√®le** (100'000 PCs connect√©s sur Internet).

- **Triple DES** nous met √† l'abri de ces **attaques brute force** en augmentant l'**espace des cl√©s possibles** √† $\{0,1\}^{112}$. 

- Cette alternative permet de continuer √† utiliser les **"bo√Ætes" DES** (hardware et software) en attendant une migration vers AES.

- Le **niveau de s√©curit√©** obtenu par cette solution est **tr√®s satisfaisant**.

- L'**impact en termes de performances** de trois ex√©cutions successives de DES reste un **inconv√©nient** pour certaines applications.

#### DES: propri√©t√©s

- **DES n'est pas un groupe** (au sens alg√©brique) avec la composition: En d'autres termes, DES √©tant une permutation: $\{0,1\}^{64} \rightarrow \{0,1\}^{64}$, si DES √©tait un groupe pour la composition, ceci voudrait dire que: $\exists K_3$ t.q. $E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)$

  Cette propri√©t√© permet d'assurer que l'**encryption compos√©e** (comme Triple-DES) **augmente consid√©rablement la s√©curit√©** de DES. Si DES √©tait un groupe, la recherche exhaustive sur l'ensemble de cl√©s possibles ($\{0,1\}^{56}$) permettrait de "casser" l'algorithme **ind√©pendamment du nombre d'ex√©cutions cons√©cutives** de DES.

- **Cl√©s faibles et mi-faibles** (weak and semi-weak keys): 
  - Une cl√© $K$ est dite **faible** si $E_K(E_K(x)) = x$. 
  - Une paire de cl√©s $(K_1, K_2)$ est dite **mi-faible** si $E_{K_1}(E_{K_2}(x)) = x$.

- Les cl√©s faibles ont la particularit√© de g√©n√©rer de **sous-cl√©s identiques par paires** ($k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$), ce qui **facilite la cryptanalyse**. 

- **DES a 4 cl√©s faibles** (et 6 paires de cl√©s mi-faibles).
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide (3DES et s√©curit√©)

**Vuln√©rabilit√© DES** : espace cl√©s $2^{56}$ cassable en 24h (1999). **Triple-DES** : $E_{K_1}(D_{K_2}(E_{K_1}(P)))$, espace $2^{112}$, r√©utilise hardware DES, 3√ó plus lent. **DES ‚â† groupe** ‚Üí encryption compos√©e renforce s√©curit√©. **4 cl√©s faibles** g√©n√©rant sous-cl√©s identiques par paires ‚Üí facilite cryptanalyse.
:::

---

### 6. Advanced Encryption Standard (AES)

#### Pr√©sentation G√©n√©rale

**AES** (Advanced Encryption Standard) : standard adopt√© en novembre 2001.

**Conception** : Johan Daemen et Vincent Rijmen (nom original : **Rijndael**)

**Caract√©ristiques principales** :

- **Type** : block cipher it√©ratif (mais **PAS un Feistel Cipher**)
- **Taille des blocs** : 128 bits
- **Taille de cl√© variable** : 128, 192 ou 256 bits
- **Nombre de rounds** : d√©pend de la taille de cl√©
  - 10 rounds pour cl√© 128 bits
  - 12 rounds pour cl√© 192 bits
  - 14 rounds pour cl√© 256 bits
- **Modes d'utilisation** : ECB, CBC, CFB, OFB, CTR

**Avantages par rapport √† DES** :

- ‚úì **Processus ouvert** : consultation et analyse par experts mondiaux
- ‚úì **~2√ó plus performant** en software
- ‚úì **~10¬≤¬≤ fois plus s√ªr** (th√©oriquement)
- ‚úì **√âvolutif** : taille de cl√© augmentable si n√©cessaire

#### Structure d'AES

**Unit√© de base** : matrice **State** de 4 lignes √ó 4 colonnes (pour cl√© 128 bits)

- Chaque √©l√©ment = 1 byte
- **Total** : 16 bytes = 128 bits

**Op√©rations sur le corps** $GF(2^8)$ :

- Byte = √©l√©ment de $GF(2^8)$
- Corps fini de polyn√¥mes de degr√© ‚â§ 7 avec coefficients dans $GF(2)$
- Additions, multiplications d√©finies dans $GF(2^8)$

```{mermaid}
graph TB
    subgraph State_Matrix
        S00[s0,0] --- S01[s0,1]
        S01 --- S02[s0,2]
        S02 --- S03[s0,3]
        
        S10[s1,0] --- S11[s1,1]
        S11 --- S12[s1,2]
        S12 --- S13[s1,3]
        
        S20[s2,0] --- S21[s2,1]
        S21 --- S22[s2,2]
        S22 --- S23[s2,3]
        
        S30[s3,0] --- S31[s3,1]
        S31 --- S32[s3,2]
        S32 --- S33[s3,3]
    end
    
    style S00 fill:#ffe6cc
    style S11 fill:#ffe6cc
    style S22 fill:#ffe6cc
    style S33 fill:#ffe6cc
```

#### D√©tail d'un Round AES

**Quatre op√©rations par round** :

**1. SubBytes (ByteSub)**

- Substitution non lin√©aire via **S-box**
- Chaque byte transform√© ind√©pendamment
- R√©sistance √† la cryptanalyse lin√©aire et diff√©rentielle

**2. ShiftRows**

- **Permutation des bytes** avec d√©calages variables par ligne
- Ligne 0 : pas de d√©calage
- Ligne 1 : d√©calage gauche 1 position
- Ligne 2 : d√©calage gauche 2 positions
- Ligne 3 : d√©calage gauche 3 positions

**3. MixColumns**

- Chaque colonne = combinaison lin√©aire des autres colonnes
- **Multiplication de matrices** dans $GF(2^8)$
- Diffusion maximale

**4. AddRoundKey**

- **XOR** de la matrice State avec la sous-cl√© du round
- Sous-cl√© = r√©sultat du Key Schedule

```{mermaid}
graph TB
    Input[State Input] --> SB[SubBytes]
    SB --> SR[ShiftRows]
    SR --> MC[MixColumns]
    MC --> ARK[AddRoundKey]
    K[Round Key] --> ARK
    ARK --> Output[State Output]
    
    style SB fill:#ffcccc
    style SR fill:#ccffcc
    style MC fill:#cce5ff
    style ARK fill:#ffffcc
```

**Round final** : identique SAUF **pas de MixColumns**

#### Key Schedule (G√©n√©ration des Sous-cl√©s)

**Processus** :

1. **Key Expansion** : g√©n√©ration d'une matrice √©tendue
   - Cl√© 128 bits ‚Üí matrice 4 √ó 4 √ó ($N_e$ + 1) bytes
   - $N_e$ = nombre de rounds
2. **Key Selection** : extraction des sous-cl√©s
   - Premi√®re sous-cl√© : 4 premi√®res colonnes
   - Deuxi√®me sous-cl√© : 4 colonnes suivantes
   - Etc.

**Op√©rations** :

- Rotations de bytes
- Substitutions via S-box
- XOR avec constantes (Rcon)

#### Pseudo-code AES

```
Rijndael(State, CipherKey) {
    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule
    
    AddRoundKey(State, ExpandedKey[0..3]); // XOR initial
    
    for(i = 1; i < Ne; i++) {
        Round(State, ExpandedKey[4*i...(4*i)+3]);
    }
    
    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Sans MixColumns
}
```

#### D√©cryption AES

**Principe** : appliquer les **op√©rations inverses** dans chaque round.

**Op√©rations inverses** :

- **InvSubBytes** : substitution inverse via S-box‚Åª¬π
- **InvShiftRows** : d√©calages droite (au lieu de gauche)
- **InvMixColumns** : multiplication matricielle inverse
- **AddRoundKey** : auto-inverse (XOR)

**Ordre** : inverse de l'encryption avec sous-cl√©s en ordre inverse

::: {.callout-note collapse=true}
### üìÑ Texte original (AES)

#### Advanced Encryption Standard (AES)

- Adopt√© comme **standard en Novembre 2001**, con√ßu par **Johan Daemen et Vincent Rijmen** (d'o√π son nom original **Rijndael**).

- Il s'agit √©galement d'un **block cipher it√©ratif** (comme DES) mais **pas d'un Feistel Cipher**.

- **Blocs Plaintext/Ciphertext**: **128 bits**.

- **Cl√© de longueur variable**: **128, 192, ou 256 bits**.

- Contrairement √† DES, AES est issu d'un **processus de consultation et d'analyse ouvert** √† des experts mondiaux.

- Techniques semblables √† DES (substitutions, permutations, XOR‚Ä¶) compl√©ment√©es par des **op√©rations alg√©briques simples** et tr√®s performantes.

- Toutes les op√©rations s'effectuent dans le **corps** $GF(2^8)$: le corps fini de **polyn√¥mes de degr√© ‚â§ 7** avec des **coefficients dans** $GF(2)$.

- En particulier, un **byte pour AES est un √©l√©ment dans** $GF(2^8)$ et les **op√©rations sur les bytes** (additions, multiplications,...) sont **d√©finies comme sur** $GF(2^8)$.

- **~2 fois plus performant** (en software) et **~10¬≤¬≤ fois (en th√©orie...) plus s√ªr** que DES...

- **√âvolutif**: La taille de la cl√© peut √™tre augment√©e si n√©cessaire.

##### D√©tail d'une Etape (round) AES

L'**unit√© de base** sur laquelle s'appliquent les calculs est une **matrice de 4 lignes et 4 colonnes** (dans le cas d'une cl√© de 128 bits) dont les √©l√©ments sont des **bytes**:

- **ByteSub**: Op√©ration **non lin√©aire (S-box)** con√ßu pour **r√©sister √† la cryptanalyse lin√©aire et diff√©rentielle**.

- **ShiftRow**: **Permutation des bytes** introduisant des **d√©calages variables** sur les lignes.

- **MixColumn**: Chaque colonne est remplac√©e par des **combinaisons lin√©aires** des autres colonnes (**multiplication des matrices** !)

- **AddRoundKey**: **XOR** de la matrice courante avec la **sous-cl√©** correspondante √† l'√©tape courante.

##### AES: Fonctionnement Global

- Le **nombre d'√©tapes** d'AES varie en fonction de la **taille de la cl√©**. Pour une cl√© de **128 bits**, il faut effectuer **10 √©tapes**. Chaque augmentation de 32 bits sur la taille de la cl√©, entra√Æne une **√©tape suppl√©mentaire** (14 √©tapes pour des cl√©s de 256 bits).

- La **decryption** consiste en appliquer les **op√©rations inverses** dans chacune des √©tapes (**InvSubBytes**, **InvShiftRows**, **InvMixColumns**). **AddRoundKey** (√† cause du XOR) est **sa propre inverse**.

- Le **Key Schedule** consiste en:
  - Une op√©ration d'**expansion de la cl√©** principal. Si $N_e$ est le nombre d'√©tapes (d√©pendant de la cl√©), une **matrice de 4 lignes et 4 √ó ($N_e$ + 1) colonnes** est g√©n√©r√©e.
  - Une op√©ration de **s√©lection de la cl√© d'√©tape**: La **premi√®re sous-cl√©** sera constitu√©e des **4 premi√®res colonnes** de la matrice g√©n√©r√©e lors de l'expansion et ainsi de suite.
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide (AES)

**AES** (Rijndael 2001) : block cipher it√©ratif (PAS Feistel), 128 bits blocs, cl√©s 128/192/256 bits ‚Üí 10/12/14 rounds.

**State** : matrice 4√ó4 bytes dans $GF(2^8)$.

**4 op√©rations/round** :

  - SubBytes (S-box non lin√©aire)
  - ShiftRows (d√©calages lignes)
  - MixColumns (combinaisons lin√©aires)
  - AddRoundKey (XOR sous-cl√©). 

2√ó plus rapide que DES, 10¬≤¬≤ fois plus s√ªr.
:::

---

### 7. Attaques et S√©curit√© d'AES

#### Forces d'AES

**Simplicit√© et performances** :

- ‚úì Algorithme simple et efficace
- ‚úì Fonctionne sur plateformes limit√©es (cartes √† puce 8 bits)
- ‚úì Optimisations hardware et software

#### Attaques Publi√©es

**1. Attaques alg√©briques (2002)**

**Technique XSL** (N. Courtois et P. Pieprzyk) :

- Repr√©sente AES comme **syst√®me de 8000 √©quations quadratiques** avec 1600 inconnues binaires
- **Effort estim√©** : $2^{100}$ op√©rations (encore une conjecture)
- **Caract√©ristique** : n√©cessite peu de known plaintexts
- **Distinction** : diff√©rent des attaques lin√©aires/diff√©rentielles

**Critique** : bas√©es sur le caract√®re "fortement alg√©brique" d'AES (largement contest√©)

**2. Related Key Attacks (2009-2011)**

**Principe** : attaques bas√©es sur des **cl√©s similaires**

- R√©sultats int√©ressants sur **versions r√©duites** d'AES
- Ne compromettent pas AES complet

**3. Side Channel Attacks**

**Principe** : attaques sur l'**impl√©mentation** (pas l'algorithme)

**Techniques** :

- **Cache timing attacks** : analyse des acc√®s cache
- **Power analysis** : consommation √©lectrique
- **Electromagnetic analysis** : √©missions √©lectromagn√©tiques

**Exemple** (2005) : Osvik, Shamir, Tromer

- Extraction de cl√© 128 bits avec **6-7 couples plaintext/ciphertext**
- Bas√©e sur analyse des **acc√®s cache**

**4. Meet in the Middle sur structures bicycliques (2011-2015)**

**R√©sultat** :

- R√©duit l'effort pour AES-128 √† **$2^{126}$** (facteur 4 vs brute force)
- **Reste largement au-dessus** des capacit√©s actuelles

#### S√©curit√© Pratique

**Hypoth√®se fondamentale** : cl√© d'**entropie maximale**

**Attaques r√©centes** (WPA2, etc.) :

- Exploitent la **faiblesse des passwords/passphrases**
- Pas de faille dans AES lui-m√™me
- Probl√®me : g√©n√©ration de cl√©s depuis passwords faibles

**‚ö†Ô∏è Rappel critique** : qualit√© de la cl√© = s√©curit√© du syst√®me

::: {.callout-note collapse=true}
### üìÑ Texte original (Attaques AES)

#### AES: Remarques Finales et Attaques (I)

- La plus grande **force de AES** r√©side dans sa **simplicit√©** et dans ses **performances**, y compris sur des plate-formes √† **capacit√© de calcul r√©duite** (p.ex. des **cartes √† puces** avec des processeurs √† 8 bits).

- Depuis sa publication officielle, des **nombreux travaux de cryptanalyse** ont √©t√© publi√©s avec des r√©sultats tr√®s int√©ressants. En particulier, **N. Courtois et P.Pieprzyk** ont pr√©sent√© une technique appel√©e **XSL** permettant de repr√©senter AES comme un **syst√®me de 8000 √©quations quadratiques** avec **1600 inconnues binaires**. L'**effort n√©cessaire** pour casser ce syst√®me est estim√© (il s'agit encore d'une **conjecture**...) √† **$2^{100}$**.

- Ces attaques se basent sur le **caract√®re fortement alg√©brique** (et largement contest√©...) de AES. De plus, il suffit de **quelques known plaintexts** pour les mettre en place, ce qui les distingue des attaques lin√©aires et diff√©rentielles.

- Ces derni√®res ann√©es (2009-2011) des **attaques bas√©es sur des cl√©s similaires** (related key attacks) ont obtenu des r√©sultats int√©ressants sur des **versions r√©duites** d'AES.

- Une autre famille d'attaques d√©nomm√©e **side channel attacks** agissant directement sur l'**impl√©mentation de l'algorithme** permet d'extraire des informations d'int√©r√™t cryptographique lors de l'ex√©cution de l'encryption.

#### AES: Remarques finales et Attaques (II)

- En **2015** une attaque de type **Meet in the Middle** bas√© sur des **structure bicycliques** a montr√© qu'il √©tait possible de r√©duire l'**effort n√©cessaire** pour trouver une cl√© AES-128 √† **$2^{126}$**, soit un **facteur 4** par rapport au brute force. Ceci reste tout de m√™me **largement au dessus** des capacit√©s de calcul actuelles.

- Une autre famille d'attaques d√©nomm√©e **side channel attacks** agissant directement sur l'**impl√©mentation de l'algorithme** permet d'extraire des informations d'int√©r√™t cryptographique lors de l'ex√©cution de l'encryption. En particulier, les auteurs arrivent √† **extraire la cl√© de 128 bits** avec seulement **6-7 couples plaintext/ciphertexts** en se basant sur les **acc√®s cache**.

- La **s√©curit√© de AES** (comme pour tout autre algorithme d'encryption) se base toujours sur l'hypoth√®se d'une **cl√© d'entropie maximale**. Les **attaques publi√©es r√©cemment** sur des protocoles bas√©s sur AES (comme WPA2) exploitent la **faiblesse des passwords/passphrases** qui sont √† l'origine des cl√©s utilis√©es.
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide (S√©curit√© AES)

**Forces** : simplicit√©, performances (m√™me cartes 8 bits). **Attaques** : XSL ($2^{100}$, alg√©brique), related keys (versions r√©duites), side channel (impl√©mentation, cache), Meet-in-Middle bicyclique ($2^{126}$). **S√©curit√©** : hypoth√®se cl√© entropie max. Attaques pratiques = passwords faibles, pas faille AES.
:::

---

### 8. Techniques de Cryptanalyse des Block Ciphers

#### 8.1 Cryptanalyse Diff√©rentielle

**Principe** : attaque **chosen plaintext** analysant la **propagation des diff√©rences** entre deux plaintexts √† travers les rounds.

**M√©thode** :

1. Choisir deux plaintexts avec diff√©rence connue : $x_a$ et $x_b$
2. Observer la propagation : $\Delta x = x_a \oplus x_b$
3. Analyser les ciphertexts : $\Delta y = y_a \oplus y_b$
4. **Attribuer des probabilit√©s aux cl√©s** selon les changements observ√©s
5. **Cl√© la plus probable** = cl√© correcte (apr√®s nombreux essais)

**Caract√©ristiques** :

- N√©cessite **$2^{47}$ couples chosen plaintext** pour DES
- **Probabilit√©s** : d√©pendent des S-boxes et de la structure
- Plus le nombre de couples augmente, plus la probabilit√© de succ√®s augmente

**Sensibilit√©** : tr√®s sensible au **nombre de rounds**

- Chances de r√©ussite augmentent **exponentiellement** quand rounds diminuent

#### 8.2 Cryptanalyse Lin√©aire

**Principe** : attaque **known plaintext** cr√©ant un **simulateur lin√©aire** du block cipher.

**M√©thode** :

1. Cr√©er des **approximations lin√©aires** de l'algorithme
2. Analyser un grand nombre de paires plaintext/ciphertext
3. Les bits de la cl√© du simulateur **tendent √† co√Øncider** avec ceux de la cl√© r√©elle (calcul probabiliste)

**Complexit√© pour DES** :

- **$2^{38}$ known plaintexts** ‚Üí probabilit√© 10% de deviner juste
- **$2^{43}$ known plaintexts** ‚Üí probabilit√© 85% de succ√®s

**Caract√©ristiques** :

- **Attaque analytique la plus puissante** √† ce jour sur block ciphers
- Aussi **sensible au nombre de rounds**

#### 8.3 Comparaison Diff√©rentielle vs Lin√©aire

**Difficult√©s communes** :

- ‚úó **Parall√©lisation** : moins efficace que brute force parall√®le
- ‚ö†Ô∏è **Sensibilit√© aux rounds** : efficacit√© diminue exponentiellement avec le nombre de rounds

**DES et ces attaques** :

- Conjecture r√©pandue : concepteurs de DES **connaissaient ces attaques** (ann√©es 1970, in√©dites √† l'√©poque)
- **Design des S-boxes** : r√©sistance tr√®s grande aux deux techniques

#### 8.4 Attaque Meet-in-the-Middle

**Principe** : exploite les constructions **compos√©es** du type $y = E_{K_2}(E_{K_1}(x))$.

**M√©thode** :

1. Construire liste $L_1$ : $L_1 = \{E_{K_1}(x) \mid K_1 \in \text{KeySpace}\}$
2. Construire liste $L_2$ : $L_2 = \{D_{K_2}(y) \mid K_2 \in \text{KeySpace}\}$
3. Identifier **√©l√©ments r√©p√©t√©s** dans $L_1$ et $L_2$
4. V√©rifier hypoth√®se avec **deuxi√®me known plaintext**
5. Les cl√©s $K_1$ et $K_2$ associ√©es sont probablement les cl√©s recherch√©es

**Exemple pour DES** :

Espace de cl√©s intuitif pour $E_{K_2}(E_{K_1}(x))$ : $\{0,1\}^{112}$

**Effort r√©el** :

- **$2^{57}$ op√©rations** pour √©tablir les deux listes
- **$2^{56}$ blocs** de 64 bits de stockage
- **Nettement inf√©rieur** au $2^{112}$ estim√© intuitivement

**Applications** :

- Attaques sur **constructions compos√©es**
- Cryptanalyse **interne** des block ciphers

```{mermaid}
graph TB
    subgraph Meet_in_Middle
        X[Known Plaintext x] --> E1[Encrypt K1]
        E1 --> M[Middle Value m]
        M --> E2[Encrypt K2]
        E2 --> Y[Known Ciphertext y]
        
        X2[x] --> L1[List L1: EK1 pour tous K1]
        Y2[y] --> L2[List L2: DK2 pour tous K2]
        
        L1 -.match.-> Match[Trouver m commun]
        L2 -.match.-> Match
    end
    
    style M fill:#ffffcc
    style Match fill:#ccffcc
```

::: {.callout-note collapse=true}
### üìÑ Texte original (Cryptanalyse)

#### Techniques de Cryptanalyse sur les Block Ciphers

**Cryptanalyse Diff√©rentielle**

- Il s'agit d'une **attaque chosen plaintext** qui s'int√©resse √† la **propagation des diff√©rences** dans deux plaintexts au fur et √† mesure qu'ils √©voluent dans les diff√©rentes √©tapes de l'algorithme.

- Il **attribue des probabilit√©s aux cl√©s** qu'il "devine" en fonction des **changements** qu'elles induisent sur les ciphertexts. La **cl√© la plus probable** a des bonnes chances d'√™tre la cl√© correcte apr√®s un **grand nombre** de couples plaintext/ciphertext.

- N√©cessite **$2^{47}$ couples chosen plaintext** (pour DES) pour obtenir des r√©sultats corrects.

**Cryptanalyse Lin√©aire**

- Il s'agit d'une **attaque known plaintext** qui cr√©e un **simulateur du bloc** √† partir des **approximations lin√©aires**. En analysant un **grand nombre** de paires plaintext/ciphertexts, les **bits de la cl√© du simulateur** ont tendance √† **co√Øncider** avec ceux du block cipher analys√©s (**calcul probabiliste**)

- Pour DES une attaque bas√©e sur cette technique n√©cessite **$2^{38}$ known plaintexts** pour obtenir une probabilit√© de **10%** de deviner juste et **$2^{43}$ pour un 85%** !

- Il s'agit de l'**attaque analytique la plus puissante** √† ce jour sur les block ciphers.

#### Techniques de Cryptanalyse sur les Block Ciphers (II)

- La mise en pratique des **attaques diff√©rentielles et lin√©aires** pr√©sente des **difficult√©s dans la parall√©lisation** des calculs par rapport √† une recherche exhaustive de la cl√©.

- Ces deux attaques sont **tr√®s sensibles au nombre d'√©tapes** du block cipher: les chances de r√©ussite augmentent **exponentiellement** au fur et √† mesure que le nombre d'√©tapes de l'algorithme diminue.

- Une conjecture tr√®s r√©pandue parmi les cryptographes est que ces attaques, √† l'√©poque **in√©dites**, √©taient **connues par les concepteurs des DES**. En particulier, le **design des S-boxes** offre une **r√©sistance tr√®s grande** aux deux techniques.

**Attaque Meet-in-the-Middle**

- S'applique aux constructions du type $y := E_{K_2}(E_{K_1}(x))$. Pour DES, l'espace de cl√©s pour cette solution serait de $\{0,1\}^{112}$. On construit d'abord **deux listes** $L_1$ et $L_2$ de $2^{56}$ messages de la forme: $L_1 = E_{K_1}(x)$ et $L_2 = D_{K_2}(y)$ avec $E$ et $D$ les op√©rations d'encryption et decryption respectivement. Il faut alors **identifier des √©l√©ments qui se r√©p√®tent** dans les deux listes et **v√©rifier notre hypoth√®se** avec un deuxi√®me known plaintext. Les $K_1$ et $K_2$ associ√©es √† cette paire de known plaintexts seront (en toute vraisemblance) **les cl√©s recherch√©es** !

- **Effort n√©cessaire** √† r√©aliser les attaques (pour DES): **$2^{57}$ op√©rations** pour √©tablir les deux listes + **$2^{56}$ blocs** de 64 bits de stockage pour m√©moriser les r√©sultats interm√©diaires... **nettement inf√©rieur** au $2^{112}$ estim√© intuitivement...

- Ces techniques meet-in-the-middle sont aussi appliqu√©es √† la **cryptanalyse interne** des block ciphers.
:::

::: {.callout-tip collapse=true}
### üìå R√©vision rapide (Cryptanalyse)

**Diff√©rentielle** : chosen plaintext, propagation diff√©rences, probabilit√©s sur cl√©s, $2^{47}$ couples (DES).

**Lin√©aire** : known plaintext, approximations lin√©aires, $2^{38}$-$2^{43}$ plaintexts (DES), attaque la plus puissante.

**Meet-in-Middle** : constructions compos√©es, 2 listes $2^{56}$, effort $2^{57}$ << $2^{112}$.

**Sensibilit√©** : tr√®s d√©pendantes du nombre de rounds.
:::