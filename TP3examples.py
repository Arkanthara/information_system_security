# Information Systems Security TP3 examples

import hashlib


#----------------------------------------------------------------------------
# Using hashlib library and sha256 :
#----------------------------------------------------------------------------

# For signatures, we need to give the SHA-256 function an argument as bytes.
# So we need to transform the integer values to bytes via the following method
# (which transforms an integer into the smallest possible number of bytes) :

example_integer = 4215415646438
size = math.ceil(example_integer.bit_length() / 8)
message_in_bytes = example_integer.to_bytes(size, 'big')

# And then you can use the sha256 function to get a digest as an hexadecimal
# string:

digest = hashlib.sha256(message_in_bytes).hexdigest() 

# And simply convert the hexadecimal string back to an integer when needed :

int_digest = int(digest, base=16)


#----------------------------------------------------------------------------
# Examples values
#----------------------------------------------------------------------------

# for RSA encryption :

p_A = 13109499994810966779468866046493465498469807493634236479294124421385342920350717814807375283698575766763256101470694189234369358996750113963585617491399169
q_A = 9497561827984502554523100157901534504433126034087863778629488755692649311435921364240405549590851856701860175924335776598684751639633322074428628372725777
n_A = p_A * q_A
e_A = 4574830074548708213
m_1 = 123456789132456789

# Expected results :
# 1) Check if p and q are indeed prime, then compute d_A and the ciphertext.
# 2) Expected values for d_A and the ciphertext (d_A is also used for station-to-station later)
d_A = 1685394382767324790326942621450485552187209875614438478305225564629345944620726038114923060947436330701451901921041511234432041036987266468290187679773130363479895993621867708066144608084390089775045890165825736468637468786667820591136139480545376198614216373031208691260339805721685482401743494212035728605
# cipher = 32468932964181322647810913060097066975304467072050643211304428656476623133068329653886195740426516038144100129255895281039142864272296799126753030014464755203797098445143314298922512718785433009136404533290100525054356166805463645892708927694801117827432767298393815743170470207262077229267156532545837844746
# 3) And show the decryption indeed finds the correct message m_1.


# for RSA signatures :

p_B = 10826236673044680963399044397492990517950100496226253527517396594056941773100235891495996442661607934789334573338262984224575279140723546671909015161165841
q_B = 13068724959497413087750499937723404386396234752223421227108292956808841500055256288126351713047692004275186905392145633277656168051780140711564635964305603
n_B = p_B * q_B
e_B = 15363431916099183937
d_B = 99028653602245779845285312307808515171286419911090461439401679147183594769788570637862858627361848873110757184618159656805126920324532303690918472435585415644809804509292960212584309940116204022655165333574427857625598512132465843176880573701404843875750652856715151972981401483364420748866785456380681449953
m_2 = 999888777666555444333222111000


# Expected results :
# 1) Compute the signature, which should have the following result :
# Signature = 139946149260693867607112906574735868062749437621729152371217474062708529251204743665018991444038005832618912915250036414898959900238801293242485481120544999182886616669733899259575955678176133539745600054828147224713714471521374309679085794180533135483883902152178064817185104702608162450188184338147593819800
# 2) And don't forget to test the verification of the signature.


# Finally, for station to station :

pub_Alice = [e_A, n_A]
priv_Alice = [d_A, n_A]
pub_Bob = [e_B, n_B]
priv_Bob = [d_B, n_B]
safe_prime = 2004890248675962691713190610809938766185621168064979413365812239027511292529980906463903581678786848688704872949028858842995789224512221900227664478944051223
alpha = 5
x = 1061775670328897479642045825518654602578846023540121012631031945572796572947245459955958771884051774545117531495156990657757207018855371855532676140389741288
y = 392417823113702585344984211877708879159301551909174807442181089475282662900844681918382176814109732720706300601726300762268420191278884678744009799141009819


# Expected results :
# Proceed to the pseudo Station-to-Station key generation, with every step,
# computing the following elements :
# 1) alpha^x mod p (from Alice) = 686072914171234798069517712764277594421530837248520761454562297567737629274501846654087857110320672185192257738624560988240804394506647168646502643636056310
# 2) alpha^y mod p (from Bob) = 1658758911043428653679670657159403893659858431555423238518923992311175752537434444470667284622227826513095646428663996761247179634768488071743521322105826864
# 3) session_key K = 133319045406894848338625909766918081728670119580456005459847062820377364927299550101232531204505214272971383981615061959224396184823089732799942062031596841
# 4) Signature from Bob on (alpha^x, alpha^y, K) = 63637939875901691094764242278906665544983903077054207988218710640087544761228273045150821483357729338737390290548046762350697337909101721771119707350314342587290126983794881205873189463125171775729781807366888186695684820979887485019292913876833243417638388536805972736525678021591270150561199609942649208004
# 5) Signature from Alice on (alpha^y, alpha^x, K) = 45467152564432701103620506688535942942709188195272432989568457473601022575230584678514742692432145004914876272400870285574876815019240848540253393082439483176306291410816134069425004279929786767259112836051752427213131534826834152132670963428804617973787768260686245775875564276853832786703782164483812397373
# 6) Don't forget that Alice has to verify Bob's signature, and vice-versa !



#----------------------------------------------------------------------------
# TODO - TP 3 - RSA encryption, signatures and station-to-station ! 
#----------------------------------------------------------------------------

