# Les Services de Sécurité Fondamentaux

Les services de sécurité sont les objectifs que l'on cherche à atteindre pour protéger un système.

* **Confidentialité** : Protection contre la divulgation non autorisée.
* **Intégrité** : Protection contre la modification non autorisée.
* **Disponibilité** : Garantie d'accès pour les utilisateurs légitimes.
* **Authentification** : 
    * *Entity authentication* (Entité) : Certifier l'identité d'un acteur.
    * *Data origin authentication* (Origine) : Certifier la source d'une donnée.
* **Non-répudiation** : Impossibilité de nier une transaction.
* **Non-Duplication** : Protection contre les copies illicites.
* **Anonymat** : Préservation de l'identité ou de la source.

::: {.callout collapse="true"}
#### Version originale

* **Confidentialité** : Protection de l'information d'une divulgation non autorisée.
* **Intégrité** : Protection contre la modification non autorisée de l'information.
* **Disponibilité** : S'assurer que les ressources sont accessibles aux utilisateurs légitimes.
* **Authentification** :
    * **Authentification d'entités** *(entity authentication)* : procédé permettant à une entité d'être sûre de l'identité d'une seconde entité à l'appui d'une évidence corroborant (p.ex.: présence physique, cryptographique, biométrique, etc.). Le terme identification est parfois utilisé pour désigner également ce service.
    * **Authentification de l'origine de données** *(data origin authentication)* : procédé permettant à une entité d'être sûre qu'une deuxième entité est la source originale d'un ensemble de données. Par définition, ce service assure également l'intégrité de ces données.
* **Non-répudiation** : Offre la garantie qu'une entité ne pourra pas nier être impliquée dans une transaction.
* **Non-Duplication** : Protection contre les copies illicites.
* **Anonymat (d'entité ou d'origine de données)** : Permet de préserver l'identité d'une entité, de la source d'une information ou d'une transaction.

:::

---

# Synthèse : Services, Menaces et Mécanismes de Protection

| Services de Sécurité | Dangers et Attaques (*Italique*) | Mécanismes Classiques | Mécanismes Digitaux |
|:---|:---|:---|:---|
| **Confidentialité** | Fuite d'informations, *eavesdropping* (écoutes), analyse du trafic | Scellés, coffre-forts, cadenas | Cryptage, autorisation logique |
| **Intégrité** | Modification, *tampering* (altération), création ou destruction illicite | Encre spéciale, hologrammes | Fonctions à sens unique + cryptage |
| **Disponibilité** | *Denial of Service (DoS)*, virus, usage illicite | Contrôle d'accès physique, surveillance vidéo | Contrôle d'accès logique, audit, anti-virus |
| **Authentification d'entités** | Accès non autorisés, vol de mot de passe, faille de protocole | Présence, voix, pièce d'identité, biométrie | Secret + protocole, adresse réseau + userid, carte à puce + PIN |
| **Authentification de données** | Falsification d'informations ou de signature | Sceaux, signature, empreinte digitale | Fonctions à sens unique + cryptage |
| **Non-répudiation** | Nier une transaction (*repudiation*), prétendre un vol de clé | Sceaux, signature notariale, envoi recommandé | Fonctions à sens unique + cryptage + signature digitale |
| **Non-duplication** | Duplication, falsification, imitation | Encre spéciale, hologrammes, tatouage | Tatouage digital (*watermarks*), verrouillage cryptographique |
| **Anonymat** | Identification, analyse de transaction, traçage | Brouilleur de voix, déguisement, argent liquide | *Mixers*, *remailers*, argent électronique, *deep web* |

::: {.callout collapse="true"}
#### Version originale

## Dangers et Attaques : Synthèse

| Services | Dangers | Attaques |
| :--- | :--- | :--- |
| **Confidentialité** | fuite d'informations | écoutes illicites, analyse du trafic |
| **Intégrité** | modification de l'information | création, altération ou destruction illicite |
| **Disponibilité** | denial of service, usage illicite | virus, accès répétés visant à inutiliser un système |
| **Authentification d'entités** | accès non autorisés | Vol de mot de passe, faille dans le protocole d'authentification |
| **Authentification de données** | falsification d'informations | falsification de signature, faille dans le protocole d'authentification |
| **Non-répudiation** | nier la participation à une transaction | prétendre un vol de clé ou une faille dans le protocole de signature |
| **Non-duplication** | duplication | falsification, imitation |
| **Anonymat** | identification | analyse d'une transaction, accès non autorisés permettant l'identification |

## Mécanismes de Protection

| Services | Mécanismes classiques | Mécanismes digitaux |
| :--- | :--- | :--- |
| **Confidentialité** | scellés, coffre-forts, cadenas | cryptage, autorisation logique |
| **Intégrité** | encre spéciale, hologrammes | fonctions à sens unique + cryptage |
| **Disponibilité** | contrôle d'accès physique, surveillance vidéo | contrôle d'accès logique, audit, anti-virus |
| **Auth. d'entités** | présence, voix, pièce d'identité, reconnaissance biométrique | secret + protocole d'authentification, adresse réseau + userid, carte à puce + PIN |
| **Auth. de données** | sceaux, signature, empreinte digitale | fonctions à sens unique + cryptage |
| **Non-répudiation** | sceaux, signature, signature notariale, envoi recommandé | fonctions à sens unique + cryptage + signature digitale |
| **Non-duplication** | encre spéciale, hologrammes, tatouage | tatouage digital (watermarks), verrouillage cryptographique |
| **Anonymat** | brouilleur de voix, déguisement, argent liquide | mixers, remailers, argent électronique, deep web |
:::

---

# Risques Liés à Internet



## Programmes Malveillants Transmis par E-Mail

* Aussi appelés **maliciels** (*malware*).
* E-mails visant à **provoquer une action** (ouvrir une pièce jointe ou cliquer sur un lien).
* Attaques souvent **personnalisées** grâce à l’**ingénierie sociale**.
* **Conséquences principales :**
    * Installation de malware (*ransomware*, *keyloggers*, etc.).
    * **Perte ou vol de données** personnelles.
    * **Détournement du système** et **propagation** du malware.

::: {.callout collapse="true"}
#### Ultra-synthèse
- Malware diffusé par e-mail
- Incitation à cliquer ou ouvrir
- Ingénierie sociale
- Vol, perte de données, détournement
:::

::: {.callout collapse="true"}
#### Version originale
## Programmes Malveillants Transmis par E-Mail
* Aussi appelés **maliciels** ou *malware*.
* E-mails conçus pour **inciter le destinataire** à **ouvrir une pièce jointe** ou à **suivre un lien** contenant de la publicité non souhaitée, des informations offensives, des programmes à risque, etc.
* Souvent ciblés sur la base des intérêts de la victime (travail préliminaire d'ingénierie sociale (*social engineering*)).
* **Conséquences :**
    * Installation de malware (*ransomware*, *keyloggers*, etc.) dans le système de la victime (*ordinateur*, *tablette*, *smartphone*, *smartwatch*, etc.).
    * Destruction de données contenues dans l'ordinateur.
    * Vol d'informations ou de données personnelles.
    * Détournement du système pour des fins malicieuses (p.ex.: minage illicite de *bitcoins*).
    * Diffusion de *malware* (éventuellement à d'autres utilisateurs).
:::


## Programmes Malveillants Transmis sur le Web

* Méthode appelée ***drive-by download*** : **infection automatique lors de la visite d’un site web**.
* L’origine peut être :
    * un **site malveillant** ;
    * un **site légitime compromis** (p. ex. *cross-site scripting*).
* La **prudence des utilisateurs** limite fortement ce mode de propagation.
* Les **impacts sont similaires** aux infections par e-mail.
* La **restriction des scripts** (*java/javascript*) réduit les risques mais peut **affecter la navigation**.

::: {.callout collapse="true"}
#### Ultra-synthèse
- *Drive-by download* = infection sans action de l’utilisateur
- Sites malveillants ou compromis
- Sensibilisation + scripts restreints = protection
:::

::: {.callout collapse="true"}
#### Version originale
## Programmes Malveillants Transmis sur le Web
* Cette technique, souvent appelée ***drive-by download***, permet d’**infecter le système** (*ordinateur*, *tablette*, *smartphone*, *smartwatch*, etc.) **sur lequel s’exécute un client web lors de la simple visite d’un site**.
* Il peut s’agir soit :
    * d’un site malicieux qui contient le *malware*.
    * d’un site web légitime qui aurait été infecté au préalable (par exemple, moyennant une technique appelée *cross-site scripting*). L’infection pouvant affecter seulement certaines pages...
* La sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de *malware*.
* Les conséquences sont semblables à celle des transmissions par e-mail.
* L’exécution restreinte des scripts (*java/javascript*) dans le navigateur peut limiter la portée de l’infection mais risque de contraindre la navigation dans certains sites.
:::


## Hameçonnage (Phishing)

* Technique visant à **collecter des informations privées** par des méthodes de **pêche indiscriminée**.
* Le ***phishing*** peut être :
    * **général** (ciblage large) ;
    * **ciblé** (*spear phishing*) lorsqu’une personne ou organisation précise est visée.
* Le vecteur principal est un **e-mail à adresse falsifiée**, difficilement détectable.
* L’objectif est d’obtenir des **données sensibles** (identifiants, mots de passe, informations personnelles ou bancaires).
* Les attaques reposent sur des **prétextes crédibles ou menaçants** pour pousser la victime à coopérer.

::: {.callout collapse="true"}
#### Ultra-synthèse
- Vol d’informations par tromperie
- E-mails falsifiés
- *Spear phishing* = attaque ciblée
- Prétextes urgents ou menaçants
:::

::: {.callout collapse="true"}
#### Version originale
## Hameçonnage (Phishing)
* Le mot ***phishing*** se compose des mots anglais ***"password"*** (mot de passe), ***"harvesting"*** (moisson) et ***"fishing"*** (pêche).
* Cette composition de mots illustre le but principal de cette technique qui consiste à **récolter un maximum d’informations privées** des utilisateurs via des mécanismes de "pêche indiscriminée".
* Lorsque la pêche aux informations est ciblée vers une personne ou organisation spécifique, la technique est dénommée ***spear phishing*** (qui provient de *spear fishing* ou pêche au harpon).
* Le vecteur de transmission consiste normalement dans un e-mail avec une **adresse d’expédition falsifiée** (mais souvent indétectable...) qui demande à la victime de fournir des informations privées : adresses e-mail, identifiants (*twitter*, *facebook*, etc.), mots de passe, numéros d’identité, numéros de comptes bancaires, etc.
* Les prétextes utilisés sont variés (mise à jour du système informatique, arrêt du service, retrait d’un envoi, etc.) et vont jusqu’à menacer l’utilisateur en cas de refus.
:::

## Pourriels (Spam)

* E-mails **indésirables**, souvent publicitaires, ou **pop-ups** non sollicités lors de la navigation web.
* Représentent environ **60% des e-mails mondiaux**.
* Conséquences principales :
    * **Consommation de ressources** et perte de temps.
    * Certains peuvent **transmettre des malware**.
* Ciblent souvent les adresses courtes ou proviennent de **listes d’adresses vendues/échangées**.
* Les **filtres anti-spam** entraînent des **coûts importants** pour les organisations.

::: {.callout collapse="true"}
#### Ultra-synthèse
- E-mails/publicités indésirables
- Risques : perte de temps, ressources, malware
- Ciblage : adresses courtes ou listes
- Filtrage coûteux pour entreprises
:::

::: {.callout collapse="true"}
#### Version originale
## Pourriels (Spam)
* Englobe tous les **e-mails indésirables** (souvent publicitaires) reçus par les personnes et les organisations.
* Terme utilisé également pour désigner les **pages**/***fenêtres pop-up*** **affichées sans le consentement de l’utilisateur** lors de la navigation web.
* On estime que **60%** des e-mails qui circulent dans le monde appartiennent à cette catégorie.
* Les conséquences sont souvent limitées à la consommation de ressources de calcul et stockage ainsi qu’au gaspillage de temps associé à la lecture et traitement de ces messages mais...
* ... **certains e-mails spam** peuvent également constituer des **vecteurs de transmission de malware**.
* Ils ont tendance à cibler plus particulièrement les adresses e-mail courtes (p.ex: abc@gmail.com) mais fonctionnent également sur la base des listes (souvent échangées / vendues) contenant tous types d’adresses.
* Les opérations de **filtrage anti-spam** entraînent des coûts considérables pour les organisations.
:::

## Rançongiciels (Ransomware)

* Malware type **Cheval de Troie** qui **chiffre les données** pour les rendre inaccessibles.
* Exige une **rançon** (souvent en bitcoins) pour récupérer les fichiers.
* Peut rester **dormant**, déclenché par un événement ou une date.
* Principal vecteur : **e-mails malveillants**.
* Autres effets possibles : **attaques par déni de service, extorsion**.

::: {.callout collapse="true"}
#### Ultra-synthèse
- Chiffrement des données par Cheval de Troie
- Rançon pour restaurer accès
- Dormance programmée possible
- Infection via e-mails malveillants
:::

::: {.callout collapse="true"}
#### Version originale
## Rançongiciels (Ransomware)
* Cette famille spécifique de malware appartient à la catégorie appelée **Chevaux de Troie** (Trojan Horses).
* Leur comportement plus habituel consiste à **chiffrer les données de la victime** (locaux et distants) **afin de les rendre totalement inaccessibles**.
* Un message apparait ensuite pour demander le paiement d’une rançon (souvent en **bitcoins** ou une autre monnaie virtuelle) permettant potentiellement de récupérer l’accès aux fichiers chiffrés.
* Ils peuvent rester en ***état dormant*** dans le système infecté et être déclenchés par un événement spécifique ou à une date donnée (attaques synchronisées).
* Leurs vecteurs d’infection sont variés mais les **e-mails contenant des pièces jointes malicieuses** sont souvent mis en cause lors des infections primaires.
* Des nombreuses variantes existent et continuent à se développer.
* On observe parfois d’autres comportements associés à ces *malware* : **dénis de service**, **extorsions ciblées**, **menaces**, etc.
:::

## Attaques sur les Dispositifs ***Internet of Things (IoT)***

* Attaques visant les **objets connectés** (caméras, TV, capteurs, alarmes, etc.).
* Ces dispositifs sont **faciles à compromettre** à cause de :
    * **failles connues**,
    * **mots de passe par défaut**,
    * **manque de sensibilisation** des utilisateurs.
* La **prise de contrôle à distance** permet :
    * un **point d’entrée** vers le réseau,
    * l’**utilisation de l’appareil** pour des activités illicites (DDoS, hacking, minage).
* Un **inventaire précis** des dispositifs connectés est indispensable.

::: {.callout collapse="true"}
#### Ultra-synthèse
- Cible les objets connectés
- Sécurité faible (failles, mots de passe par défaut)
- Risque d’accès au réseau et d’abus
- Inventaire des IoT nécessaire
:::

::: {.callout collapse="true"}
#### Version originale
## Attaques sur les Dispositifs ***Internet of Things (IoT)***
* Ciblent les **objets connectés** de toute sorte (caméras, TVs, frigos, capteurs et interrupteurs domotiques, installations d’alarme, etc.).
* Ils sont souvent **plus faciles à pirater** que les systèmes traditionnels par cause de :
    * nombreuses failles de sécurité souvent connues des attaquants.
    * mots de passe par défaut.
    * négligence de la part des utilisateurs qui ignorent les risques qui leurs sont propres.
* La **prise de contrôle à distance** de ces appareils par une entité malveillante implique :
    * Une porte d’entrée au réseau domestique/corporatif.
    * Un dispositif pouvant être utilisé pour des activités illicites (hacking, attaques DDoS, minage de bitcoins, etc.).
* L’établissement d’un répertoire précis de tous les dispositifs de ce type connectés au réseau est nécessaire!
:::

## Modification Illicite des Informations Publiées (*Information Spoofing and Website Defacement*)

* Attaques visant à **altérer les informations** sur sites web et réseaux sociaux.
* Impact : **réputation compromise** et **dommages économiques**.
* Sites web : sécurisation du système hôte, configuration restrictive, **audits réguliers**.
* Réseaux sociaux : mots de passe forts, **authentification multi-facteur**, fermeture des sessions, suppression des *cookies*.

::: {.callout collapse="true"}
#### Ultra-synthèse
- Altération des infos sur sites et réseaux sociaux
- Risques : réputation et pertes économiques
- Sites : sécurisation + audits
- Réseaux sociaux : mots de passe forts, MFA, sessions fermées, cookies supprimés
:::

::: {.callout collapse="true"}
#### Version originale
## Modification Illicite des Informations Publiées (*Information Spoofing and Website Defacement*)
* Attaques visant **l’intégrité** de l’information publiée dans les sites web, les réseaux sociaux, etc.
* Elles portent atteinte à la **réputation** et peuvent provoquer d’importants **dommages économiques** pour les sociétés ayant une présence Internet.
* Dans le cas des **sites web**, la **sécurisation du système hôte** est essentielle ainsi qu’une **configuration aussi restrictive que possible**. Des audits des sécurité récurrents sont vivement recommandés.
* La **protection des informations affichées dans les réseaux sociaux** dépend directement du processus d’authentification permettant d’accéder au profil à risque :
    * Éviter les mots de passe trop simples.
    * Privilégier l’authentification forte, si possible *multi-facteur*.
    * Fermer proprement les sessions.
    * Effacer les *cookies*.
:::

## Attaques **Dénis de Service** (*Denial of Service* / *DDoS*)

* Vise à **rendre inaccessibles des systèmes informatiques**, surtout pour les organisations.
* **DDoS** : attaque distribuée par des milliers de dispositifs, générant un trafic massif.
* Protections classiques (*firewalls*, sondes IDS (Intrusion Detection System) / IPS (Intrusion Prevention System)) souvent **insuffisantes**.
* Conséquences :
    * **Réputation affectée**
    * **Pertes financières** (parfois rançons)
    * **Risques élevés** pour les infrastructures critiques (hôpitaux, centrales, Internet backbone)

::: {.callout collapse="true"}
#### Ultra-synthèse
- DDoS = systèmes inaccessibles via attaques massives
- Protections limitées
- Risques : réputation, finances, infrastructures critiques
:::

::: {.callout collapse="true"}
#### Version originale
## Attaques **Dénis de Service** (*Denial of Service* / *DDoS*)
* Attaques destinées à **rendre inaccessibles des systèmes informatiques** de toute sorte visant surtout les organisations privées ou étatiques.
* Le terme **DDoS** (*Distributed Denial of Service*) désigne une famille d’attaques dans laquelle des multiples (**souvent des dizaines de milliers) de dispositifs ciblent simultanément le(s) système(s) victime(s)**.
* Le trafique généré atteint plusieurs centaines de gigabits / seconde.
* L’efficacité des mécanismes de protection traditionnels (*firewalls*, *sondes* de *prévention* et de *détection d’intrusion*, etc.) est limitée.
* L’indisponibilité d’un service peut engendrer :
    * des problèmes **réputationnels**.
    * d’importantes **pertes financières** (des **demandes de rançon** peuvent être exigées pour les désactiver).
    * des **hauts risques de sécurité (même physique!)** lorsque des **infrastructures critiques** (hôpitaux, centrales électriques, *backbone* de l’Internet, etc.) sont ciblées.
:::

# Méthodes Digitales de Sécurité

**Problème :** Protéger des informations digitales

* dans un environnement distribué
* globalement accessible
* sans frontière matérielle

**Solution :**

* Cryptographie
    * Symétrique
    * Asymétrique
    * $+$ fonctions à sens unique
    * $+$ générateurs (pseudo) aléatoires

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Problème** : Sécurité dans un environnement distribué/global.
- **Solutions** :
  - Crypto (symétrique/asymétrique).
  - Fonctions à sens unique (hachage).
  - Générateurs aléatoires (physiques/pseudo).
:::

::: {.callout collapse="true"}
#### Version originale

**Problème :** Protéger des informations digitales

* dans un environnement distribué
* globalement accessible
* sans frontière matérielle

**Solution :**

* Cryptographie
    * Symétrique
    * Asymétrique
    * $+$ fonctions à sens unique
    * $+$ générateurs (pseudo) aléatoires
:::

---

## Fonctions de Hachage Cryptographiques

* **Fonctions faciles à calculer dans un sens mais virtuellement impossibles à inverser**.
* Toute modification du document source change radicalement le **digest** (effet avalanche).
* **Propriétés clés** :
  - **One-way** : impossible de retrouver l'entrée depuis le hash.
  - **Collision-free** : impossible de trouver deux entrées avec le même hash.
* Taille des digests : 160 à 512 bits.
* Algorithmes (très **performants**) : SHA-1, SHA-256, SHA-3.

::: {.callout collapse="true"}
#### Ultra-synthèse
- **One-way + collision-free**.
- Taille : 160-512 bits.
- Algos : SHA-1/256/3.
- Usage : intégrité, signatures.
:::

::: {.callout collapse="true"}
#### Version originale

* **Fonctions faciles à calculer dans un sens mais virtuellement impossibles à calculer dans le sens contraire**.
* Toute modification (même insignifiante) du document source se traduit par un **digest** fondamentalement différent.
* Il est virtuellement impossible de retrouver le document source à l’aide seulement du digest (**one-way**).
* Il est virtuellement impossible de retrouver un deuxième document source produisant le même digest (**collision-free**).
* Longueur habituelle des digests : 160 à 512 bits.
* Les algorithmes à sens unique sont très performants.
* Exemples : SHA-1, SHA-256, SHA-3, etc.
:::

---

## Générateurs (Pseudo) Aléatoires

* **Caractéristiques**
    * **aléatoire**
    * **imprévisible**
    * **non reproductible** 
* **Critique** pour la sécurité (clés, IV, secrets).
* **Types** :
  - **Vrais aléatoires** : basés sur phénomènes physiques (radioactivité, quantique).
  - **Pseudo-aléatoires** : déterministes (basés sur un *seed*: séquence aléatoire initiale).
* **Risque** : "Pseudo-sécurité" si le *seed* est prévisible (citation de Pitkin).
* Applications : clés de session, IV (DES-CBC), signatures (ElGamal).

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Vrais aléatoires** : physiques (quantique).
- **Pseudo-aléatoires** : déterministes (*seed*).
- **Risque** : *seed* prévisible = faille.
- Usages : clés, IV, signatures.
:::

::: {.callout collapse="true"}
#### Version originale

* La génération de nombre aléatoire est un processus très important pouvant compromettre la sécurité d’un bon nombre de systèmes de cryptage.
* Applications : génération de clés de session, vecteurs d’initialisation (DES - CBC mode), secrets pour signatures (ElGamal), etc.
* Un **générateur aléatoire** (random generator) est un dispositif capable de générer des nombres de façon **aléatoire**, **imprévisible** et **non reproductible**. (e.g. basé sur phénomènes physiques: source radioactive ou quantique).
* Les **générateurs pseudo-aléatoires** sont des procédés déterministes développés à partir d’une séquence aléatoire initiale (**seed**) (e.g. frappe utilisateur, accès disque).
* *Citation :* R. Pitkin dans [Kau95]: "The use of pseudo-random processes to generate secret quantities can result in pseudo-security"
:::

---

## Cryptographie Symétrique

* **Historique** : Utilisée depuis Jules César (Iᵉʳ av. J.-C.).
* **Principe** : Une seule clé pour chiffrer/déchiffrer.
* **Schéma** : Plaintext → Cryptage (Clé) → Ciphertext → Décryptage (Clé) → Plaintext.
* **Caractéristiques** :
  - Algorithmes : AES, DES, IDEA, RC4.
  - Services : Confidentialité, Authentification, Intégrité.
  - **Limite** : Pas de signatures (clé partagée).
  - **Problème** : Échange de clé sécurisé requis.

::: {.callout collapse="true"}
#### Ultra-synthèse
- **1 clé** pour chiffrer/déchiffrer.
- **Rapide** (AES, DES).
- **Problème** : échange de clé.
- Usages : documents personnels, groupes fermés.
:::

::: {.callout collapse="true"}
#### Version originale

* Aussi appelée cryptographie conventionnelle ou à clés secrètes (I av. JC, Julius Cesar).
* **Idée :** Sur la base d’une seule clé secrète, réaliser une transformation capable respectivement de rendre illisible et de restituer une pièce d’information.
* **Schéma :** Plaintext $\to$ Cryptage (Clé) $\to$ Ciphertext $\to$ Décryptage (Clé) $\to$ Plaintext.
* **Caractéristiques :**
    * Algorithmes : AES, DES, IDEA, RC4, RC5, etc. (certains sont gratuits et de libre accès)
    * Services : Confidentialité, Authentification, Intégrité.
    * Pas de support direct pour signatures digitales (car clé connue des deux).
    * Nécessite un canal confidentiel pour échanger la clé.
    * Idéal pour la protection de documents personnels ou groupes fermés.
:::

---

## Cryptographie Asymétrique

* Aussi appelée **cryptographie publique** (1976, Diffie & Hellman).
* **Principe**
    - Paire de clés (publique/privée) pour chiffrement et signatures.
* **Deux usages principaux** :
  1. **Confidentialité** :
     - Chiffrement : clé publique du destinataire
     - Déchiffrement : clé privée du destinataire
  2. **Signature numérique** :
     - Signature : clé privée de l'expéditeur
     - Vérification : clé publique de l'expéditeur
     - *Optimisation* : On signe généralement le **hash** du document
     - **Propriétés fondamentales** :
       - **Intégrité** : Toute modification invalide la signature
       - **Non-collision** : Impossible d'avoir 2 documents avec la même signature
       - **Non-répudiation** : Seul le détenteur de la clé privée peut signer

* **Aspects techniques** :
  - **Algorithmes** : RSA, ElGamal
  - **Services** : Intégrité, Authentification, Non-Répudiation
  - **Performance** : beaucoup plus lent que le symétrique (100x plus lent)
  - **Avantage** : Pas besoin de canal confidentiel pour l'échange de clés

::: {.callout collapse="true"}
#### Ultra-synthèse
- **2 clés** : publique (chiffrer/vérifier) + privée (déchiffrer/signer)
- **2 usages** :
  - Confidentialité : chiffrer pour un destinataire
  - Signature : prouver l'authenticité
- **Signatures** :
  - Intégrité + non-répudiation
- **Algorithmes** : RSA/ElGamal
- **Avantage** : Pas besoin de canal sécurisé pour échanger les clés
- **Désavantage** : Lente
:::

::: {.callout collapse="true"}
#### Version originale
## Cryptographie Asymétrique
* Aussi appelée cryptographie publique ou à clés publiques (1976, W. Diffie & M. Hellman).
* **Idée :** Utiliser deux clés différentes - une **secrète** et une **publique** - respectivement pour les opérations de cryptage et décryptage.
* Chaque utilisateur dispose d’un **porte-clés** (keyring).

**Confidentialité :**
* Expéditeur crypte avec la **clé publique du destinataire**.
* Destinataire décrypte avec sa **clé privée**.
* Uniquement clé du destinataire utilisée !

**Signature Digitale :**
* Expéditeur signe avec sa **clé privée**.
* Destinataire vérifie avec la **clé publique de l’expéditeur**.
* Uniquement clé de l'expéditeur utilisée !
* *Note :* On signe généralement le **digest** du document (hash) pour des raisons de performance.

**Caractéristiques des signatures :**
* La signature change si le document change, alors que la clé privée reste la même.
* En cas de modification du document ou de la signature, la vérification échoue (**intégrité garantie**).
* Il est virtuellement impossible, même pour le détenteur de la clé privée, de générer un second document produisant la même signature (fonction à sens unique **sans collisions**).
* Seul le détenteur de la clé privée peut générer une signature vérifiable à l’aide de la clé publique correspondante (**non-répudiation**).
* **Algorithmes** : RSA, ElGamal.
* **Services** : Intégrité, Authentification, Non-Répudiation.
* **Lenteur** : Jusqu’à 50 fois plus lent que la cryptographie symétrique.
* **Avantage** : Pas besoin de canal confidentiel pour échanger les clés (contrairement au symétrique).
:::


---

## Crypto Asymétrique + Symétrique (Hybride)

* **Principe** : Utiliser l'asymétrique pour échanger une clé symétrique (clé de session).
* **Étapes** :
  1. A génère une clé symétrique aléatoire $K_s$.
  2. A chiffre $K_s$ avec la clé publique de B.
  3. A et B communiquent ensuite avec $K_s$ (symétrique).

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Asymétrique** : échange de clé symétrique.
- **Symétrique** : chiffrement des données.
- **Avantage** : combine sécurité + performance.
:::

::: {.callout collapse="true"}
#### Version originale

* **Idée :** Utiliser la cryptographie publique uniquement pour échanger des clés symétriques (Clés de session).
* A génère une clé aléatoire $K_s$ et la transmet à B en l’encryptant avec la clé publique de B.
* A & B communiquent ensuite en utilisant $K_s$ (symétrique).
:::

---

## Cryptographie Asymétrique : Fonctionnement (RSA)

### Construction des clés
1. **Choix des nombres premiers** :
   - $p$ et $q$ : deux grands nombres premiers (> 1024 bits)
   - $n = pq$ : module RSA (taille = 2048+ bits)

2. **Calcul de l'indicatrice d'Euler** :
   - $\phi(n) = (p-1)(q-1)$
   - *Propriété* : Pour tout $a$ premier avec $n$, $a^{\phi(n)} \equiv 1 \pmod{n}$

3. **Sélection des exposants** :
   - $e$ : entier premier avec $\phi(n)$ (exposant public)
   - $d$ : inverse modulaire de $e$ (exposant privé), tel que $ed \equiv 1 \pmod{\phi(n)}$

### Processus de chiffrement/déchiffrement
* **Clé publique** : $(n,e)$
* **Clé privée** : $(d)$
* **Chiffrement** : $C = P^e \pmod{n}$
* **Déchiffrement** : $P = C^d \pmod{n}$

### Preuve mathématique
1. **Congruence fondamentale** :
   - $ed = 1 + k\phi(n)$ (par définition de $d$)

2. **Application du théorème d'Euler** :
   - $P^{\phi(n)} \equiv 1 \pmod{n}$ (si $P$ premier avec $n$)

3. **Démonstration** :

   \begin{align*}
   (P^e)^d &\equiv P^{ed} \pmod{n} \\
   &\equiv P^{1 + k\phi(n)} \pmod{n} \\
   &\equiv P \cdot (P^{\phi(n)})^k \pmod{n} \\
   &\equiv P \cdot 1^k \pmod{n} \\
   &\equiv P \pmod{n}
   \end{align*}

### Sécurité du système
* **Problème difficile** : Factorisation de $n$ en $p$ et $q$
* **Taille recommandée** :
  - $n$ : 2048 bits (minimum pour sécurité actuelle)
  - $p$ et $q$ : 1024+ bits chacun
* **Vulnérabilités connues** :
  - Attaques par canal auxiliaire (timing, power analysis)
  - Choix inapproprié des paramètres ($e$ trop petit, $p$ et $q$ trop proches)

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Clés** :
  - Publique : $(n,e)$ où $n = pq$
  - Privée : $(d)$ avec $ed \equiv 1 \pmod{\phi(n)}$
- **Opérations** :
  - Chiffrement : $P^e \mod n$
  - Déchiffrement : $C^d \mod n$
- **Sécurité** : Factorisation de $n$ difficile
- **Taille** : 2048+ bits pour $n$
:::

::: {.callout collapse="true"}
#### Version originale
## Cryptographie Asymétrique: Fonctionnement (RSA)
* Soit $n := pq$ avec $p$ et $q$ deux nombres premiers grands (> 1024 bits).
* Soit $\phi(n) = (p-1)(q-1)$.
* Soit $e$ et $d$ tels que $ed \equiv 1 \pmod{\phi(n)}$.
* Par définition des congruences: $ed = 1 + k\phi(n)$
* Théorème d’Euler : $a^{\phi(n)} \equiv 1 \pmod n$.
* **Encryption :** $C = P^e \pmod n$. **Clé publique :** $(n,e)$.
* **Décryption :** $P = C^d \pmod n$. **Clé privée :** $(d)$.
* *Preuve :* $(P^e)^d \equiv P^{ed} \equiv P^{1 + k\phi(n)} \equiv (P \pmod n) (P^{\phi(n)} \pmod n)^k \equiv P \pmod n$.
:::


---

## Cryptographie Asymétrique : Conclusions

* **Algorithmes dominants** : RSA (le plus utilisé), Rabin, ElGamal
* **Services complets** :
  - Confidentialité
  - Authentification
  - Intégrité
  - Signature digitale & Non-répudiation
  - Non-duplication

* **Performances** :
  - 50x plus lent que le symétrique
  - **Solution optimale** : Combinaison asymétrique (échange de clés) + symétrique (chiffrement)

* **Gestion des clés** :
  - **Avantage** : Échange de clés publiques sans canal confidentiel
  - **Risque** : Nécessité de vérifier l'authenticité des clés publiques
    - Canal d'acquisition authentifié **ou**
    - Certification par tiers de confiance

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Algos** : RSA (dominant), Rabin, ElGamal
- **Services** : Confidentialité + Authentification + Intégrité + Signatures
- **Lenteur** : 50x vs symétrique → **hybride recommandé**
- **Clés** : Échange public simple mais **authentification cruciale**
:::

::: {.callout collapse="true"}
#### Version originale
## Cryptographie Asymétrique : Conclusions

* Il existe quelques systèmes de cryptage asymétrique (**Rabin**, **ElGamal**, etc.) mais le plus utilisé est **RSA**.

* **Services supportés** : **Confidentialité**, **Authentification**, **Intégrité**, **Signature Digitale & Non-Refus**, (**Non Duplication**).

* Les opérations liées à la **cryptographie asymétrique** sont jusqu’à **50 fois (!) plus lentes** que celles de la **cryptographie symétrique**.
  Une **combinaison des deux méthodes** est souvent souhaitable.

* La **distribution des clés** est simplifiée par le fait que seules des **clés publiques** doivent être échangées entre les intervenants (pas besoin d’un canal confidentiel alternatif) mais…

* … il est nécessaire de **vérifier que la clé publique appartient réellement au destinataire** :
  * Soit le **canal d’acquisition** de la clé publique est protégé contre toute modification (**authentifié**)
  * Soit la clé est **certifiée exacte par un tiers**
:::

---

## Comparaison Symétrique vs Asymétrique

### Avantages comparés

* **Symétrique** :
  - **Performance** : 100x plus rapide
  - **Implémentation** : Facile en hardware
  - **Clés** : Courtes (128 bits = 16 caractères mémorisables)

* **Asymétrique** :
  - **Échange de clés** : Canal authentifié suffisant (pas besoin de confidentialité)
  - **Gestion** : 1 paire de clés pour n correspondants (vs n clés en symétrique)

### Problématiques communes

* **Maillon faible** : Gestion des clés par les utilisateurs
* **Base de sécurité** : Empirique plutôt que théorique
* **Contraintes légales** : Restrictions d'usage et d'exportation

### Recommandations d'usage

| **Cas d'usage**                          | **Solution recommandée**                          | **Justification**                                                                 |
|------------------------------------------|---------------------------------------------------|-----------------------------------------------------------------------------------|
| Documents personnels                     | Symétrique                                        | Vitesse + clés mémorisables                                                      |
| Groupes d'utilisateurs proches           | Symétrique                                        | Vitesse + échange confidentiel facile                                            |
| Utilisateurs distants/inconnus           | Asymétrique                                       | Pas besoin de canal confidentiel                                                 |
| Transactions distantes                   | Hybride (Asymétrique + Symétrique)                | Asymétrique pour l'échange de clé, symétrique pour les données                   |
| Protection logicielle (distribution)     | Hybride                                           | Clé symétrique unique par version, encryptée avec asymétrique                    |
| Segments réseaux                         | Symétrique                                        | Vitesse + environnement contrôlé (échange de clés facile entre administrateurs)  |

::: {.callout collapse="true"}
#### Ultra-synthèse
**Symétrique** :

    ✅ Rapide (100x)
    ✅ Clés courtes (128 bits)  
    ❌ Échange de clés confidentiel requis

**Asymétrique** :

    ✅ Échange de clés simplifié
    ✅ 1 paire de clés pour n correspondants
    ❌ Lent (50x)
    ❌ Clés longues (1024+ bits)

**Hybride** : Meilleur des deux mondes
**Problèmes communs** : Gestion des clés, base empirique, restrictions légales
:::

::: {.callout collapse="true"}
#### Version originale
## Cryptographie Symétrique vs. Asymétrique

* Il existe des **centaines d’algorithmes symétriques et asymétriques** capables de fournir un niveau de **confidentialité suffisant**.

* Les **solutions symétriques** offrent les avantages suivants :
  * **Rapidité** (jusqu’à **100 fois plus rapide** que les solutions asymétriques)
  * **Facilité d’implantation en hardware**
  * **Longueur de clé réduite** : **128 bits** (= 16 caractères ⇒ mémorisable !) au lieu de **1024 bits** pour des équivalents asymétriques.

* Les **solutions asymétriques** ont comme arguments principaux :
  * **Échange de clés simplifié** : les clés doivent être échangées par un **canal authentifié mais non-confidentiel**
  * **Gestion de clés simplifiée** : une seule **paire de clés publique/privée** suffit à un utilisateur pour recevoir des messages confidentiels de **n utilisateurs** (au lieu de **n clés différentes** dans le cas symétrique).

* **Problèmes propres aux deux techniques** :
  * La **gestion de clés par l’utilisateur** reste le **maillon le plus faible**
  * Sécurité (normalement) basée sur des **arguments empiriques** plutôt que **théoriques**
  * **Restrictions légales** d’usage et d’exportation

## Cryptographie Symétrique vs. Asymétrique (II)

| **Activité**                                                                                   | **Recommandation**                                                                                           | **Remarques**                                                                                                                              |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------ |
| Protection de documents personnels                                                             | **Crypto symétrique**                                                                                        | **Vitesse**, clés facilement mémorisables                                                                                                  |
| Protection de documents dans un groupe d’utilisateurs proches                                  | **Crypto symétrique**                                                                                        | **Vitesse**, facilité d’échange des clés confidentielles                                                                                   |
| Établissement de canaux confidentiels entre utilisateurs distants (inconnus)                   | **Crypto asymétrique**                                                                                       | Pas besoin d’avoir un canal confidentiel : **authenticité suffit**                                                                         |
| Transactions entre deux utilisateurs distants, Protection de logiciel (distribution multicast) | **Crypto asymétrique pour protection de clé symétrique** + **Crypto symétrique pour protection des données** | **Vitesse**, Seule la clé symétrique doit être ré-encryptée pour chaque correspondant, Copie cryptée du logiciel peut être rendue publique |
| Protection des segments réseaux                                                                | **Crypto symétrique**                                                                                        | **Vitesse**, Environnement stable → échange confidentiel des clés facile entre sysadmins                                                   |
:::

## Dissection d'une Attaque : Ransomware

### Définition et Impact
* **Définition** : Logiciel malveillant qui chiffre les données et exige une rançon pour leur restitution.
* **Limites de la définition classique** :
  - Ne couvre pas l'impact sur **l'infrastructure critique** (ex : Colonial Pipeline, mai 2021)
  - Sous-estime la **portée systémique** des attaques
* **Statistiques alarmantes** :
  - Milliards d'attaques annuelles
  - Considéré comme la **menace cyber la plus dangereuse** en 2021 ("Ransomware Everywhere")

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Malware** : Chiffre les données → demande rançon
- **Impact** : Infrastructure critique (ex : Colonial Pipeline)
- **Menace n°1** en cybersécurité (2021)
- **Cibles** : Particuliers + entreprises + États
:::

::: {.callout collapse="true"}
#### Version originale
"Un rançongiciel (de l'anglais **ransomware**), logiciel rançonneur, logiciel de rançon ou logiciel d'extorsion, est un logiciel malveillant qui prend en otage des données personnelles. Pour ce faire, un rançongiciel **chiffre des données personnelles** puis demande à leur propriétaire d'envoyer de l'argent en échange de la **clé de déchiffrement**" (Wikipedia 21 septembre 2021).

- **Définition incomplète** car les **ransomwares** portent sur un **vaste spectre de l'infrastructure informatique**

- À titre d'exemple, en mai 2021, une **attaque ransomware** dirigée contre la société **Colonial Pipeline** a provoqué une **coupure d'approvisionnement** de combustible d'une grande partie de la côte des États-Unis

- Avec un nombre d'**attaques global** chiffré en **milliards par année**, "**Ransomware Everywhere**" est globalement considérée comme la **menace la plus directe, visible et dangereuse** pour utilisateurs et entreprises en 2021 !
:::

---

## Cycle de Vie d'une Attaque Ransomware

### Prévention et Réponse
| Phase | Mesures |
|-------|---------|
| **Prévention** | - Patching régulier<br>- Solutions de détection (Firewalls, WAFs, IDS/IPS)<br>- Scans anti-malware (e-mails, fichiers) |
| **Protection** | - **Backups offline** (essentiel !)<br>- Politiques de sécurité strictes<br>- Formation des utilisateurs |
| **Réponse** | - **Ne pas payer** (recommandation officielle)<br>- Analyse forensique<br>- Restauration depuis backups |

### Dissection Technique
1. **Infection** :
   - Vecteurs : Phishing, exploits, RDP vulnérable
   - Propagation : Latérale (réseau) ou verticale (système)

2. **Exécution** :
   - Chiffrement des fichiers ciblés
   - Suppression des shadow copies
   - Persistance (registre, tâches planifiées)

3. **Extorsion** :
   - Affichage de la demande de rançon
   - Paiement en cryptomonnaies (Bitcoin, Monero)
   - Délais de paiement avec majoration

4. **Occultation** :
   - Obfuscation du code
   - Communication via TOR/Deep Web
   - Effacement des logs

::: {.callout collapse="true"}
#### Ultra-synthèse
**Cycle d'attaque** :

1. Infection (phishing/exploits)
2. Exécution (chiffrement + persistance)
3. Extorsion (rançon en crypto)
4. Occultation (TOR + effacement traces)

**Contre-mesures** :

    ✅ Backups offline
    ✅ Patching + détection
    ✅ Formation
    ❌ Ne pas payer
:::

---

## Cryptolocker : Analyse Technique

### Schéma d'Attaque

```{mermaid}
graph TD
    A[Infection initiale] --> B[Chiffrement des fichiers]
    B --> C[Stockage clé privée sur serveurs C2]
    C --> D[Demande de rançon]
    D --> E{Paiement ?}
    E -->|Oui| F[Envoi clé de déchiffrement via TOR]
    E -->|Non| G[Perte définitive des données]
```

### Cibles Privilégiées
* **Extensions critiques** (extrait) :
  - Documents : `.docx`, `.xlsx`, `.pdf`, `.pptx`
  - Bases de données : `.mdb`, `.sql`, `.sqlite`
  - Médias : `.jpg`, `.png`, `.mp4`, `.avi`
  - Développement : `.java`, `.cpp`, `.py`, `.php`
  - Financier : `.qbw`, `.qbb`, `.wallet`

* **Comportement** :
  - Chiffrement **sélectif** (fichiers récents/modifiés)
  - **Double extorsion** : Chiffrement + menace de fuite
  - **RaaS** (Ransomware-as-a-Service) : Modèle économique

::: {.callout collapse="true"}
#### Ultra-synthèse
**Mécanisme** :
- Clé privée stockée sur serveurs C2
- Paiement → clé via TOR
- Cibles : 100+ extensions (docs, DB, médias)

**Évolutions récentes** :
- Double extorsion (chiffrement + fuite)
- RaaS (location de ransomware)
:::

::: {.callout collapse="true"}
#### Version originale
## Ransomware : Vue Intégrale

*(Source : 2017 State of Cybersecurity, F-Secure Inc.)*

## Ransomware : Vue Intégrale

#### Prévision, Remédiation et Réaction
- **Patching**
- **Détection active et passive** (Firewalls, WAFs, IDS, IPS, e-mail malware scan, etc.)
- **Backups offline** !
- **Politique de Sécurité** - Règles de bon usage de la messagerie
- **Formation** !
- **Payer ou pas payer**...

#### Dissection Technique de l'Attaque
- **Infection et propagation**
- **Exécution**
- **Paiement** (Crypto-currencies / Bitcoin)
- **Occultation** (Obfuscation, TOR Networks/Deep Web)

### Schéma Générique d'un Ransomware Cryptolocker

- Les **clés privées de déchiffrement** sont stockées dans les serveurs de l'**attaquant**
- Elles sont envoyées à la **victime** après **paiement en bitcoins**
- La **trace** est broyée à l'aide des **réseaux TOR**

## Ransomware Cryptolocker : Cibles

**Extensions de fichiers ciblées** :
.jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb,
.asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg,
.jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads,
.agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl,
.bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw,
.cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml,
.php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw,
.dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf,
.dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray,
.grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key,
.kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3,
.mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg,
.nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf,
.ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd,
.pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps,
.psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat,
.raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql,
.sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg,
.swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2,
.wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw,
.ycbcra, .yuv

*Source : Intel Security Advanced Threat Research - http://www.intelsecurity.com*
:::

# Notions de base en cryptographie

* Introduction aux **concepts fondamentaux** de la cryptographie.
* Présente les **principes de sécurité**, les **types de systèmes**, et les **modèles d’attaque**.
* Inclut des **systèmes historiques** et des techniques complémentaires.

## Principe de Kerckhoffs

* Principe fondamental : la **sécurité repose uniquement sur la clé**, pas sur le secret de l’algorithme.
* Le système doit rester **sûr même si l’algorithme est public**.
* La clé doit être **facilement modifiable** et le système **simple à utiliser**.
* Rejet explicite de la **sécurité par l’obscurité**.

::: {.callout collapse="true"}
#### Ultra-synthèse
- Sécurité basée sur la clé
- Algorithme public
- Pas de sécurité par l’obscurité
:::

::: {.callout collapse="true"}
#### Version originale
## Principe de Kerckhoffs

**Auguste Kerckhoffs** publie en **1883** deux articles définissant **six principes** pour les chiffrements militaires :

1. Le système doit être **pratiquement, voire mathématiquement indéchiffrable**.
2. Il ne doit **pas nécessiter de confidentialité** et rester sûr même s’il tombe aux mains de l’ennemi.
3. La **clé** doit pouvoir être **mémorisée, transmise et modifiée facilement**, sans notes écrites.
4. Le système doit être **compatible avec les communications télégraphiques**.
5. Il doit être **portable** et utilisable par **une seule personne**.
6. Il doit être **simple à utiliser**, sans procédures complexes ni contraintes excessives.

Kerckhoffs affirme dès le **XIXe siècle** que la sécurité doit être **mathématiquement démontrable** et qu’il **n’existe pas de sécurité par l’obscurité**.
:::

## Classification des systèmes de cryptage

### Sécurité inconditionnelle

(*unconditional security* / *perfect secrecy*)

* Sécurité **indépendante de la puissance de calcul**.
* **Ciphertext** n’apporte aucune info sur le **plaintext**.
* Conditions : **clé ≥ message**, **jamais réutilisée**.
* Usage surtout **théorique**.
* **Exemple** : *one-time pad*.

### As hard as / équivalent / provable security

* Cryptanalyse **aussi difficile** qu’un **problème mathématique difficile**.
* **RSA** et **Rabin** prouvés équivalent à la factorisation.
  * Démontrée par **réduction** (*reduction proof*).
* Concept central mais **controversé**.

### Sécurité calculatoire

(*computational security* / *practical security*)

* Sécurité basée sur le **coût irréaliste des attaques**.
* Catégorie la plus utilisée en pratique.
* **Exemples** : **AES**, **DES**, **IDEA**, **RC4**.

::: {.callout collapse="true"}

#### Ultra-synthèse

* **Inconditionnelle** : parfaite, théorique (*one-time pad*).
* **Provable security** : équivalence à problème mathématique difficile.
* **Calculatoire** : sûre en pratique.
:::

::: {.callout collapse="true"}

#### Version originale

* **Sécurité inconditionnelle** (*unconditional security aussi appelée **perfect secrecy***) :

  * La sécurité du système de cryptage **n’est pas compromise par la puissance de calcul** destinée à la cryptanalyse.
  * Cette catégorie s’appuie sur la **théorie de l’information** publiée par **Shannon en 1949**.
  * Plus précisément, un système de cryptage est **inconditionnellement sûr** si la probabilité de rencontrer un **plaintext x** après l’observation du **ciphertext correspondant y** est identique à la probabilité à priori de rencontrer le plaintext x.
  * En d’autres termes, le fait de disposer de couples **plaintext/ciphertext (x,y)** ne constitue **aucune aide pour la cryptanalyse**.
  * Une condition nécessaire pour qu’un système soit inconditionnellement sûr est que la **clé soit au moins de la même taille que le message** et, surtout, qu’elle **ne soit pas réutilisée** pour encrypter des messages différents.
  * Cette condition rend ces systèmes **peu adaptés aux besoins cryptographiques habituels** et réduit leur domaine d’intérêt à un **cadre théorique**.
  * L’exemple classique est le **one-time pad** inventé en **1917** par **J. Mauborgne** and **G. Vernam**.
  * Fondements théoriques des systèmes inconditionnellement sûrs + d’autres exemples dans **[Sti06]**.

* **As hard as / équivalent / provable security**

  * Lorsqu’on peut prouver que la cryptanalyse de l’algorithme est **aussi difficile que de résoudre un problème mathématique réputé difficile**.
  * Par exemple la **factorisation de grands nombres**, le calcul de **racines carrées modulo un “composite”**, le calcul de **logarithmes discrets dans un groupe fini**, etc.
  * L’algorithme de **Rabin** et **RSA** (cas générique^1 ) sont “prouvés” **équivalents à la factorisation**.
  * Une telle preuve s’appelle de “réduction” (**reduction proof**).
  * La notion de **provable security** est à l’origine d’une **importante controverse** dans le monde cryptographique.

* **Sécurité calculatoire** (*computational security aussi appelé **practical security***)

  * Un système de cryptage est dans cette catégorie si l’**effort calculatoire nécessaire à le “casser”** en utilisant les meilleures techniques possibles est **au delà** (avec une marge raisonnable) des ressources de calcul d’un adversaire hypothétique.
  * La grande majorité de systèmes de cryptage symétriques (**AES, DES, IDEA, RC4**, etc.) sont dans cette catégorie.
:::

## Entropie

* L’**entropie** (Shannon, 1948) mesure la **quantité d’information effective** contenue dans un message.
* L’**entropie conditionnelle** mesure l’incertitude qui reste sur le **plaintext** après observation du **ciphertext**.

### Propriétés

* $0 \le H(X) \le \log n$
* $H(X) = 0$ → aucune incertitude
* $H(X) = \log n$ → tous les résultats équiprobables

### Interprétation

* Approxime le **nombre de bits nécessaires** pour encoder $X$.
* La **redondance** = différence entre codage effectif et entropie.

### Entropie conditionnelle

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$
* Mesure l’incertitude restante sur le **plaintext** après observation du **ciphertext**.

::: {.callout collapse="true"}

#### Ultra-synthèse

* **Entropie** : quantité d’information d’un message.
* **Entropie conditionnelle** : incertitude sur le plaintext après le ciphertext.
* **Redondance** : différence entre codage effectif et entropie.
:::

::: {.callout collapse="true"}

#### Version originale

* Une définition essentielle en cryptographie est la quantité d’information **effective** contenue dans un message.
* Par exemple, les jours de la semaine (*lundi*, …, *dimanche*) peuvent intuitivement être encodés comme des chaînes de caractères de longueur ($\le \text{len}(\text{``mercredi''})$), soit $(8 \times 8 = 64)$ bits. Cependant, la quantité d’information effective de la variable *jour de la semaine* peut être encodée de manière optimale sur **3 bits** (car $(2^3 = 8)$ est suffisant pour représenter les 7 variations possibles).
* L’**entropie** (Shannon, 1948) est la formalisation mathématique de cette définition.

### Définition formelle

Soit $X$ une variable aléatoire avec un ensemble fini de valeurs possibles ${x_1, x_2, \dots, x_n}$, telles que $P(X=x_i) = p_i$, avec $0 \le p_i \le 1$ et $\sum p_i = 1$.
L’entropie de $X$, notée $H(X)$, est définie par

$H(X) = - \sum_{i=1}^{n} p_i \log p_i = \sum_{i=1}^{n} p_i \log \left(\frac{1}{p_i}\right)$

Par convention : $p_i \log p_i = 0$ si $p_i = 0$. Tous les logarithmes sont en **base 2**.

### Interprétation

* Approximation du nombre de bits nécessaires pour encoder les éléments de $X$.
* La **redondance** est la différence entre le codage effectif et l’entropie.

### Propriétés

1. $0 \le H(X) \le \log n$
2. $H(X) = 0 \iff \exists i : p_i = 1, p_j = 0 \ \forall j \ne i$
3. $H(X) = \log n \iff p_i = 1/n \ \forall i$

### Entropie conditionnelle

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$,
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$

*Mesure l’incertitude sur $X$ (plaintext) après avoir observé $Y$ (ciphertext).*
:::

## Attaques sur les systèmes de cryptage

* **Ciphertext-only** : Adversaire a seulement le ciphertext.
* **Known-plaintext** : Adversaire a des couples plaintext/ciphertext.
* **Chosen-plaintext** : Adversaire peut choisir le plaintext et voir le ciphertext (et essaye de trouver le plaintext pour d'autres messages).
* **Adaptive chosen-plaintext** : dépend des ciphertexts reçus.
* **Chosen-ciphertext** : Adversaire choisit le ciphertext et obtient le plaintext (vise à trouver la clé).
* **Adaptive Chosen-ciphertext** : **Chosen-ciphertext** dépend des plaintexts reçus

## Oracles et Modèles de Sécurité

### Oracles Aléatoires et Modèles de Sécurité

* **Oracle Aléatoire (Random Oracle)** : Une fonction théorique "parfaite" qui renvoie une valeur uniforme et aléatoire pour chaque nouvelle entrée, mais reste déterministe pour une entrée déjà vue.
* **ROM (Random Oracle Model - Modèle de l'Oracle Aléatoire)** : Cadre de preuve mathématique utilisant cet oracle idéal comme substitut aux fonctions de hachage.
* **Modèle Standard** : Cadre où la sécurité repose uniquement sur la puissance de calcul de l'adversaire face à des algorithmes réels.
* **Limite** : Une preuve de sécurité en ROM ne garantit pas la sécurité absolue dans le monde réel (avec SHA-256, etc.).

::: {.callout collapse="true"}
#### Version originale
Un **oracle aléatoire** est une entité abstraite accessible aux parties légitimes et aux adversaires.

* **Comportement** : Il répond aux requêtes d'entrée $x$ par des réponses parfaitement aléatoires $Orc(x)$. 
* **Déterminisme** : La seule exception réside dans les entrées précédemment traitées ($x_1, x_2, \dots, x_n$). Si $x_1' = x_1$, alors $Orc(x_1') = Orc(x_1)$.
* **Modélisation** : On le modélise par une fonction $Orc : X \to Y$ où $\forall x \in X, \Pr(Orc(x) = y) = \frac{1}{|Y|}$.
* **Utilité** : Il se comporte comme une **fonction de hachage cryptographique « idéale »**, outil précieux pour prouver la sécurité dans le **Modèle d'Oracle Aléatoire**. 
* **Comparaison** : Le **modèle standard** limite les adversaires par des facteurs computationnels. Un protocole sûr dans le modèle d'oracle aléatoire peut devenir vulnérable s'il est utilisé avec une fonction de hachage « réelle » (SHA-1, SHA-256).
:::

---

### Oracles de Chiffrement, Déchiffrement et Signature

* **Fonction** : Entités qui exécutent des opérations (chiffrer/signer) pour l'adversaire en utilisant des clés secrètes sans jamais les révéler.
* **Cryptographie symétrique** : L'oracle fournit $E_k(x)$ ou $D_k(y)$.
* **Cryptographie asymétrique** : L'oracle est crucial pour les opérations privées (déchiffrement/signature), car les opérations publiques sont déjà libres d'accès.

::: {.callout collapse="true"}
#### Version originale : Oracles Opérationnels
Un **oracle de chiffrement/déchiffrement/signature** est une entité abstraite offrant un service « à la demande ».

* **Accès aux clés** : Il utilise les **mêmes clés que les propriétaires légitimes** (systèmes symétriques et asymétriques) sans les divulguer.
* **Primitives symétriques** : Pour une primitive $E$ et une clé $k$, il renvoie $y = E_k(x)$ ou le clair $x$ correspondant.
* **Systèmes à clé publique** : L'oracle n'est nécessaire que pour les opérations à **clé privée** ($priv_k$).
    * **Déchiffrement** : renvoie $x$ tel que $E'_{pubk}(x) = y$.
    * **Signature** : Pour un système $S$, il renvoie $y = S_{privk}(x)$.
* **Attaques** : Les modèles d'attaques par **texte clair choisi** (CPA) et par **texte chiffré choisi** (CCA) reposent sur la mise à disposition de ces oracles pour l'adversaire.
:::

---

### Indiscernabilité et Sécurité Sémantique (IND-CPA)

* **Propriété** : Un adversaire ne doit pas pouvoir distinguer les chiffrés de deux messages clairs différents.
* **IND-CPA (Indistinguishability under Chosen Plaintext Attack - Indiscernabilité sous attaque à texte clair choisi)** : Si l'adversaire ne devine le bon message qu'avec une probabilité de $1/2 + \epsilon$, le système est considéré comme sûr.
* **Sécurité Sémantique** : Équivalente à l'IND-CPA, elle assure qu'aucune information utile ne fuite du chiffré.

::: {.callout collapse="true"}
#### Version originale : Sécurité Sémantique
**L'indiscernabilité des textes chiffrés** garantit l'incapacité de distinguer les chiffrés de messages clairs donnés.

* **Expérience (Jeu de sécurité IND-CPA)** :
    1.  L'adversaire choisit deux messages $M_0$ et $M_1$.
    2.  L'oracle choisit un indice aléatoire $i \in \{0,1\}$ et renvoie $c_i = E_k(M_i)$.
    3.  L'adversaire peut effectuer d'autres calculs ou appels oracles.
* **Définition IND-CPA** : Le système est sûr si l'avantage de l'adversaire est **négligeable** ($Prob = 1/2 + \epsilon$ avec $\epsilon$ petit).
* **Note** : En clé publique, l'oracle de chiffrement est inutile car l'adversaire possède déjà la clé publique. L'IND-CPA offre la **sécurité sémantique**.
:::

---

### Le Chiffrement Probabiliste et l'OAEP

* **Problème** : Le chiffrement déterministe permet les **attaques par dictionnaire** (comparaison de chiffrés connus).
* **Solution** : Ajouter de l'aléa au message avant chiffrement pour que $E(M)$ soit différent à chaque exécution.
* **OAEP (Optimal Asymmetric Encryption Padding - Remplissage asymétrique optimal)** : Standard utilisé avec RSA. Il combine le message $P$ avec un nombre aléatoire $R$ via des fonctions de hachage $h$ et des XOR ($\oplus$).

::: {.callout collapse="true"}
#### Version originale : Déterminisme vs Probabilisme
Le comportement **déterministe** (mêmes entrées = mêmes sorties) crée des failles.

* **Exemple** : Si Alice envoie "Oui" ou "Non", l'adversaire peut calculer $C_{yes} = E_{pub}(``Oui")$ et comparer. Il peut créer un **livre de codes** (dictionnaire) pour identifier les messages sans casser la clé.
* **Chiffrement probabiliste** : Ajoute un caractère aléatoire. L'objectif est la sécurité sémantique pour la clé publique.
* **OAEP** : Utilisé dans **RSA-PKCS1**. Le texte $P$ est combiné avec un aléa $R$ :
    * $M_1 := P \oplus h(R)$
    * $M_2 := R \oplus h(M_1)$
    * Le chiffrement porte sur $M_1$ et $M_2$. Au déchiffrement, on retrouve $R = M_2 \oplus h(M_1)$, puis $P = h(R) \oplus M_1$.
:::

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Oracle Aléatoire** : Fonction de hachage "idéale" (modèle théorique).
- **Oracles CPA/CCA** : Simulent un accès à la clé secrète pour tester la résistance.
- **IND-CPA** : Impossibilité de distinguer deux chiffrés (Sécurité Sémantique).
- **Chiffrement Probabiliste** : Indispensable pour contrer les livres de codes (attaques par dictionnaire).
- **OAEP** : Méthode de padding (remplissage) ajoutant l'aléa nécessaire au RSA.
:::

## Histoire de la Cryptographie et Sécurité Inconditionnelle

### Systèmes de Cryptage Historiques

La cryptographie a longtemps été limitée à la seule recherche de la **confidentialité**. Les systèmes historiques reposent sur deux principes fondamentaux : la **substitution** et la **transposition**.

* **Chiffre de César** (substitution mono-alphabétique) : Décalage fixe des lettres. Très vulnérable à l'**analyse de fréquences**.
* **Chiffre de Vigenère** (substitution polyalphabétique) : Utilisation d'une clé pour varier le décalage. Plus complexe, mais cassable en identifiant la longueur de la clé.
* **Chiffre de Transposition** : Réorganisation des caractères du texte original selon une permutation définie par une clé.

::: {.callout collapse="true"}
#### Version originale : Cryptographie Historique
Pendant des siècles la **confidentialité** a été la seule application de la cryptographie...

* **I av. JC, Caesar Cipher** : **Cryptage à substitution mono-alphabétique** $e_k(x) = (x + k) \pmod{26}$, $d_k(y) = (y - k) \pmod{26}$ où $x, y, k \in \mathbb{Z}_{26}$.
    * Exemple: $E_1(\text{'bonjour'}) = \text{'cpokpws'}$.
    * **Cryptanalyse** : facile, basée sur la **fréquence des caractères**.
* **XVI siècle, Vigenère** : **Cryptage à substitution polyalphabétique** $e_k(x_1, \dots, x_n) = (x_1 + k_1, \dots, x_m + k_m, x_{m+1} + k_1, \dots) \pmod{26}$.
    * **Cryptanalyse** : trouver la **taille $m$ de la clé** en identifiant les portions de ciphertext répétées et analyser les blocs séparés comme dans le Caesar Cipher.
* **Transposition Ciphers** (Porta, 1563) : La clé définit une **permutation** sur le plaintext.
* Ces techniques sont toujours à la base des systèmes de cryptage actuels (ex: **Enigma**, qualifiée par W. Churchill d'arme secrète ayant gagné la guerre).
:::

### Le One-Time Pad (Masque Jetable)

Le **One-Time Pad** (OTP), ou **chiffre de Vernam**, est le seul système prouvé **inconditionnellement sûr** (sécurité parfaite).

* **Principe** : Le message est combiné à une clé de même longueur via l'opération XOR ($\oplus$).
* **Sécurité Inconditionnelle** : L'observation du message chiffré n'apporte aucune information sur le message clair. Même un adversaire avec une puissance de calcul infinie ne peut pas le briser.
* **Contraintes de Shannon** : La clé doit être **aussi longue que le message**, purement **aléatoire**, et **utilisée une seule fois**.
* **Réutilisation de la clé** : Si une clé est réutilisée pour deux messages, un attaquant peut éliminer la clé par XOR ($y_a \oplus y_b = x_a \oplus x_b$) et retrouver les messages clairs.

::: {.callout collapse="true"}
#### Version originale : Le One-Time Pad
Soit $n \ge 1$ et les espaces $P, C, K$ tels que $P, C, K = (\mathbb{Z}_2)^n$. Les opérations d’encryption et decryption d'un **one-time pad** (Vernam Cipher) sont :
$E_k(x_i) = x_i \oplus k_i$ et $D_k(y_i) = y_i \oplus k_i$ pour $1 \le i \le n$.

* **Sécurité inconditionnelle** : Si $k_i$ sont aléatoires et indépendants, l'observation des ciphertexts n'aide pas la cryptanalyse. L'**entropie** de $X$ ne diminue pas : $H(X|C) = H(X)$.
* **Théorème de Shannon** : Condition nécessaire : $H(K) \ge H(X)$. La longueur de la **clé aléatoire** doit être au moins aussi grande que celle du plaintext.
* **Réutilisation de clé** : $y_a \oplus y_b = x_a \oplus x_b$. Avec des messages de faible entropie, on retrouve les clairs et la clé ($k = y_a \oplus x_a$).
* Vulnérable à l'attaque **Known Plaintext** (si la clé est réutilisée).
* Problème majeur : La **distribution et gestion des clés** de grande taille. Relancé par la **cryptographie quantique** proposant des canaux confidentiels de distribution de clés de longueur illimitées.
:::

### Stéganographie

À l'inverse de la cryptographie qui rend le message illisible, la **stéganographie** dissimule l'existence même du message.

* **Méthode** : Utiliser un "canal subliminal" (un support innocent comme une image ou un texte banal).
* **Technique moderne** : Insertion de données dans les **bits les moins significatifs** (LSB - *Least Significant Bits*) de fichiers multimédias, permettant de cacher de gros volumes de données sans altération visible.

::: {.callout collapse="true"}
#### Version originale : Stéganographie
La **stéganographie** cache un message à l'intérieur d'un autre. Éléments constituants :

1. Un **canal physique ou logique** différent (canal subliminal).
2. Un **mécanisme secret** pour identifier ce canal.

* **Exemples classiques** : Premières lettres des mots d'un texte, encre invisible.
* **Exemple moderne** : Utiliser les **least significant bits** (bits les moins significatifs) des frames d'un CD Photo.
* Pour une image 2048x3072 (RGB 24 bits), cacher un message sur 1 bit permet de stocker **2.3 Mb** sans détériorer la qualité.
:::

::: {.callout collapse="true"}
#### Ultra-synthèse
- **Historique** : Substitution (César/Vigenère) et Transposition (permutation).
- **One-Time Pad** : Sécurité absolue si la clé est aléatoire, unique et aussi longue que le message ($H(K) \ge H(X)$).
- **Stéganographie** : Cacher l'existence du message (ex: technique des LSB dans les images).
:::

# Cryptographie symétrique

## Stream Ciphers (Cryptage en chaîne)

### Introduction aux Stream Ciphers

#### Définition et Principe

Les **stream ciphers** (chiffrements en flux) sont une famille de systèmes de cryptage caractérisés par :

- **Taille de bloc unitaire** : chaque bloc encrypté = 1 bit
- **Architecture en deux phases** :
  1. **Génération du keystream** : production de la séquence de clés
  2. **Substitution** : opération sur les bits du plaintext en fonction du keystream

**Exemple classique** : le *one-time pad*

- Génération : générateur (pseudo-)aléatoire
- Substitution : opération XOR ($\oplus$) avec le keystream

#### Caractéristiques Générales

**Avantages :**

- **Rapidité** : cryptage au niveau des registres, idéal pour le *streaming* en temps réel (vidéo)
- **Légèreté** : fonctionnent sur systèmes à ressources CPU limitées
- **Faible mémoire** : pas ou peu de buffering nécessaire
- **Erreurs non propagées** : retransmission des paquets défectueux suffisante (adapté aux transmissions sans fil - WiFi)

**Inconvénients :**

- **Dépendance à la qualité du keystream** : le caractère aléatoire (randomness) détermine la robustesse
- **Réutilisation dangereuse** : la réutilisation du keystream permet une cryptanalyse facile

::: {.callout-note collapse=true}
## 📄 Texte original

### Cryptage en chaîne (Stream Ciphers)

- Les **stream ciphers** constituent une **famille de systèmes de cryptage** où la **taille du bloc encrypté est égale à 1 bit**.
- Les stream ciphers sont généralement composés de **deux phases**:
    - Une **phase de génération** de la séquence d'éléments formant la clé (le **keystream**).
    - Une **phase de substitution** où les bits du *plaintext* subissent une opération spécifique dépendante du keystream.
- Un exemple évident d'un stream cipher est le **one-time pad** avec:
    - Une phase de génération du keystream effectuée par un **générateur (pséudo-) aléatoire**.
    - Une phase de substitution qui consiste à effectuer un **xor** ($\oplus$) avec le keystream.

### Stream Ciphers: Caractéristiques

- **Rapidité**: Le cryptage se fait directement au niveau des registres. Idéal pour des applications nécessitant un cryptage *"on the fly"* comme le **video streaming**.
- **Facilité**: Les opérations peuvent être effectuées par des systèmes ayant des **ressources CPU limitées**.
- **Pas (ou peu...) besoin de mémoire/buffering**.
- **Propagation des erreurs limitée ou absente**: la retransmission des paquets fautifs suffit normalement (adapté aux applications où les pertes de paquets sont fréquentes comme les **transmissions sans fil (WiFi)**).
- **Inconvénients**:
    - La **qualité en termes de randomness** du keystream généré détermine la **robustesse du système**.
    - La **réutilisation du keystream** permet une **cryptanalyse facile** (cf. le one-time pad).
:::

::: {.callout-tip collapse=true}
## 📌 Révision rapide

**Stream Ciphers** = cryptage bit par bit en 2 phases (génération keystream + substitution). 

**Avantages** : rapides, légers, pas de propagation d'erreurs.

**Inconvénients** : qualité du keystream critique, réutilisation = vulnérabilité.
:::

---

### Stream Ciphers Synchrones

#### Principe de Fonctionnement

Dans un **stream cipher synchrone**, le keystream dépend **uniquement de la clé**, indépendamment du plaintext et du ciphertext.

**Équations du processus :**

$$\sigma_{i+1} = f(\sigma_i, k)$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Où :

- $\sigma_i$ : état à l'instant $i$ (état initial $\sigma_0$ peut dépendre de $k$)
- $k$ : clé secrète
- $f$ : fonction de transition d'état
- $g$ : fonction de production du keystream $z_i$
- $h$ : fonction de sortie produisant le ciphertext $c_i$ à partir du plaintext $m_i$

```{mermaid}
graph LR
    A[Clé k] --> B[État σi]
    B --> C[Fonction f]
    C --> D[État σi+1]
    B --> E[Fonction g]
    E --> F[Keystream zi]
    F --> G[Fonction h]
    H[Plaintext mi] --> G
    G --> I[Ciphertext ci]
    D -.->|boucle| B
```

#### Caractéristiques

**Exigence de synchronisation :**

- Émetteur et récepteur doivent partager la même clé $k$ **ET** le même état $\sigma_i$
- Perte de synchronisation = nécessité de mécanismes externes (marqueurs, analyse de redondance)

**Propriétés :**

- **Pas de propagation d'erreur** : modification du ciphertext n'affecte pas les séquences ultérieures
- **Attention** : suppression d'un ciphertext = désynchronisation du récepteur

**Vulnérabilités aux attaques actives :**

- ✓ Détection : insertion, élimination, replay de fragments
- ✗ Modification de bits : adversaire peut modifier des bits et analyser l'impact sur le plaintext
- **Solution** : mécanismes d'authentification supplémentaires nécessaires

#### Cas particulier : Stream Cipher Additif

Le cas le plus fréquent où :

- Fonctions $f$ et $g$ remplacées par un générateur aléatoire
- Fonction $h$ = addition modulo 2 (XOR : $\oplus$)

**Formule** : $c_i = z_i \oplus m_i$

::: {.callout-note collapse=true}
## 📄 Texte original

### Stream Ciphers Synchrones

- Le **keystream généré dépend seulement de la clé** et non pas du plaintext ni du ciphertext.
- Le processus d'encryption d'un **stream cipher synchrone** est décrit par les équations suivantes: 
  $$\sigma_{i+1} = f(\sigma_i, k)$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  avec $\sigma_i$ l'**état initial** qui peut dépendre de la clé $k$, $f$ la **fonction qui détermine l'état suivant**, $g$ la **fonction qui produit le keystream** $z_i$ et $h$ la **fonction de sortie** qui produit le ciphertext $c_i$ à partir du plaintext $m_i$.

### Stream Ciphers Synchrones: Caractéristiques

- **Nécessitent la synchronisation** de l'émetteur et du récepteur: En plus d'utiliser la même clé $k$, les deux doivent se trouver dans le **même état** pour que le processus fonctionne. Si la synchronisation est perdue il faut des **mécanismes externes** pour la récupérer (marqueurs spéciaux, analyses de redondance du plaintext, etc.)
- **Pas de propagation d'erreur**. La modification du ciphertext pendant la transmission n'entraîne pas des perturbations dans des séquences de ciphertext ultérieures (cependant, la **suppression** d'un ciphertext provoquerait la **désynchronisation** du récepteur).
- **Attaques actives**: L'insertion, l'élimination ou le replay de parties de ciphertext sont **détectés** par le récepteur. Cependant, un adversaire pourrait **modifier certains bits** du ciphertext et analyser l'impact sur le plaintext correspondant. Des **mécanismes d'authentification d'origine** supplémentaires sont nécessaires afin de détecter ces attaques.
- **Cas les plus fréquent** des Stream Cipher Synchrones: le **stream cipher additif** (cf. le one-time pad) où les fonctions $f$ et $g$ générant le keystream sont remplacées par un **générateur aléatoire** et la fonction $h$ est une **addition modulo 2 (xor)**.
:::

::: {.callout-tip collapse=true}
## 📌 Révision rapide

**Synchrone** : keystream = $f$(clé uniquement). Équations : $\sigma_{i+1} = f(\sigma_i, k)$, $z_i = g(\sigma_i, k)$, $c_i = h(z_i, m_i)$. 

**Exige synchronisation** émetteur/récepteur. Pas de propagation d'erreur mais vulnérable aux modifications de bits. 

**Cas fréquent** : cipher additif avec XOR.
:::

---

### Stream Ciphers Asynchrones

#### Principe de Fonctionnement

Aussi appelés **auto-synchronisés** (*self-synchronizing ciphers*).

Le keystream dépend de la clé **ET** d'un nombre fixe de ciphertexts précédents.

**Équations du processus :**

$$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Où $\sigma_i$ représente un buffer des $t$ derniers ciphertexts.

```{mermaid}
graph LR
    A[Clé k] --> B[Fonction g]
    C[Buffer: ci-t...ci-1] --> B
    B --> D[Keystream zi]
    D --> E[Fonction h]
    F[Plaintext mi] --> E
    E --> G[Ciphertext ci]
    G -.->|feedback| C
```

#### Caractéristiques

**Auto-synchronisation :**

- En cas d'insertion/élimination de ciphertexts, le récepteur se **re-synchronise automatiquement**
- Mécanisme : mémorisation (buffer) des derniers ciphertexts

**Propagation d'erreurs limitée :**

- Erreur se propage uniquement sur la **taille du buffer** ($t$ bits)
- Après épuisement du buffer, décryption correcte reprend

**Sécurité face aux attaques actives :**

- **Meilleure détection** : modifications détectées grâce à la propagation d'erreurs
- **Attention** : l'auto-synchronisation permet au récepteur de continuer même après insertions/suppressions
- **Solution** : vérification de l'intégrité et l'authenticité du flux entier nécessaire

**Diffusion des statistiques du plaintext :**

- Chaque bit du plaintext influence **tous les ciphertexts subséquents**
- **Résultat** : meilleure dispersion des statistiques vs. cas synchrone
- **Application** : utiliser pour plaintexts à faible entropie ou fortement redondants

::: {.callout-note collapse=true}
## 📄 Texte original

### Stream Ciphers Asynchrones

- Aussi appelés **auto-synchronisés** (*self synchronizing ciphers*).
- Le **keystream généré dépend de la clé ainsi que d'un nombre fixé de ciphertexts précédents**.
- Le processus d'encryption d'un **stream cipher asynchrone** est décrit par les équations suivantes: 
  $$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  avec $\sigma_i$, $g$ et $h$ comme pour le cas synchrone.

### Stream Ciphers Asynchrones: Caractéristiques

- **Auto-synchronisation**: En cas d'élimination ou d'insertion de ciphertexts en cours de route, le récepteur est capable de **se re-synchroniser avec l'émetteur** grâce à la **mémorisation (buffer)** d'un nombre de ciphertext précédents.
- **Propagation d'erreurs limitée**: La propagation d'erreurs s'étend uniquement au **nombre de bits du ciphertext mémorisés** (taille du buffer). Après, la decryption se déroule à nouveau correctement.
- **Attaques actives**: La modification de fragments du ciphertext sera **plus facilement détecté** que dans le cas synchrone à cause de la propagation d'erreurs. Cependant, comme le récepteur est capable de s'auto-synchroniser avec l'émetteur, même si des ciphertexts sont éliminés ou insérés en cours de route, il convient de **vérifier l'intégrité et l'authenticité du flot entier**.
- **Diffusion des statistiques du plaintext**: Le fait que **chaque bit du plaintext aura une influence sur la totalité des ciphertexts subséquents** se traduit par une **plus grande dispersion des statistiques** du plaintext comparée au cas synchrone...
- ... Il convient, donc, d'utiliser des **stream ciphers asynchrones lorsque l'entropie des plaintexts est limitée** et pourrait permettre des attaques ciblées aux plaintexts fortement redondants.
:::

::: {.callout-tip collapse=true}
## 📌 Révision rapide

**Asynchrone** (auto-synchronisé) : keystream = $f$(clé + derniers ciphertexts). État $\sigma_i$ = buffer de $t$ ciphertexts précédents. 

**Auto-synchronisation** automatique. Propagation d'erreur limitée au buffer. 

**Meilleure diffusion** des statistiques → idéal pour plaintexts redondants/faible entropie.
:::

---

### Générateurs de Keystreams : LSFR

#### Contexte et Nécessité

**Problématique** : générer un keystream de longueur $m$ à partir d'une clé secrète de longueur $l$ avec $l \ll m$.

**Solution** : Linear Feedback Shift Register (**LSFR** ou **LFSR**)

#### Caractéristiques des LSFR

**Avantages :**

- **Implémentation hardware optimale** : circuits très efficaces
- **Périodes longues** : séquences de grande longueur
- **Bonne qualité aléatoire** : randomness notable
- **Base mathématique** : propriétés algébriques des combinaisons linéaires

**Structure générique** : LSFR de longueur $L$

```{mermaid}
graph LR
    A[bit L-1] --> B[bit L-2]
    B --> C[...]
    C --> D[bit 1]
    D --> E[bit 0]
    E --> F[Output]
    A -.->|feedback| G[⊕]
    D -.->|coeff| G
    C -.->|coeff| G
    G --> A
```

#### Remarques Importantes sur les LSFR

**Historique et Usage :**

- Construction très répandue en cryptographie et théorie des codes
- Nombreux stream ciphers militaires basés sur LSFR

**Limites de Sécurité :**

- **Niveau de sécurité insuffisant** comparé aux block ciphers modernes
- **Vulnérabilité** : l'algorithme de Berlekamp-Massey permet de :
  - Déterminer la **complexité linéaire** d'un LSFR
  - Calculer un nombre arbitraire de séquences générées

**Métrique** : Complexité linéaire (*linear complexity*)

**Solution d'Amélioration :**

Remplacer la combinaison linéaire par une **fonction non linéaire** $f$

→ **Non Linear Feedback Shift Registers** (NLFSR)

::: {.callout-note collapse=true}
## 📄 Texte original

### Stream Ciphers: Générateurs de Keystreams

- Lorsqu'il convient de **générer un keystream d'une longueur $m$** à partir d'une **clé secrète de longueur $l$** avec $l \ll m$, on fait appel à des **générateurs de keystreams**.
- Le plus courant de ces générateurs est le **Linear Feedback Shift Register (LSFR)**.
- Un LSFR a les caractéristiques suivantes:
    - S'adapte **très bien aux implantations hardware**.
    - Produit des séquences de **périodes longues** et avec une **qualité aléatoire notable** (randomness assez forte)
    - Se base sur les **propriétés algébriques des combinaisons linéaires**.

### LSFRs: Quelques Remarques

- Les LSFRs sont des constructions **très répandues** dans la cryptographie et dans la théorie de codes.
- Un **grand nombre de stream ciphers** basés sur les LSFRs (surtout dans la **sphère militaire**) ont été développés dans le passé.
- Malheureusement, le **niveau de sécurité offert par ces systèmes est jugé insuffisant** de nos jours (comparé à celui des blocks ciphers...)
- La **métrique** permettant d'analyser un LFSR est sa **complexité linéaire** (*linear complexity*). L'**algorithme de Berlekamp-Massey** permet de déterminer la complexité linéaire d'un LSFR et de calculer ainsi un nombre arbitrairement grand de séquences générées par un LSFR.
- Une solution pour **augmenter la complexité** est de substituer la combinaison linéaire des bits du ciphertext par une **fonction non linéaire** $f$. Ce sont les **Non Linear Feedback Shift Registers**.
:::

::: {.callout-tip collapse=true}
## 📌 Révision rapide

**LSFR** : générateur de keystream long ($m$) depuis clé courte ($l$). Base = combinaisons linéaires. 

**Avantages** : hardware efficace, périodes longues. 

**Problème** : sécurité insuffisante, vulnérable à Berlekamp-Massey (calcul de complexité linéaire). 

**Solution** : NLFSR (fonction non linéaire).
:::

---

### RC4 : Stream Cipher Logiciel

#### Présentation Générale

**RC4™** (*Rivest Cipher 4*) développé en 1987 par Ron Rivest pour RSA Security.

**Caractéristiques principales :**

- **Clé variable** : longueur flexible
- **Extrêmement rapide** : 10× plus rapide que DES
- **Mode synchrone** : keystream indépendant du plaintext/ciphertext

**Historique :**

- 1987-1994 : breveté, détails confidentiels (contrat NDA requis)
- 1994 : publication non officielle dans un newsgroup
- Depuis : analyse intensive par la communauté cryptographique

#### Architecture

**Composants clés :**

- **S-box** : boîte de substitution 8×8 (256 entrées)
  - Contenu : permutation des nombres 0 à 255
  - Dépend de la clé principale de longueur variable : $0 < len(k) \leq 255$
- **Combinaisons** : linéaires et non linéaires
- **Chiffrement final** : XOR entre keystream et plaintext

#### Applications et Sécurité

**Utilisations commerciales (nombreuses) :**

- Lotus Notes
- Oracle SQL
- Microsoft Windows
- SSL/TLS
- Et bien d'autres...

**Analyses et Vulnérabilités :**

- Travaux exhaustifs sur le key scheduling et le PRGA
- **Faille majeure** : implémentation dans WEP (WiFi Wired Equivalent Privacy)
  - Protocole WEP complètement compromis
  - Problème : mode d'utilisation défaillant, pas l'algorithme RC4 lui-même

#### Fonctionnement

RC4 se décompose en **deux étapes** :

1. **Key Scheduling Algorithm (KSA)**
   - Responsable de la permutation initiale de la S-box
   - Fonction de la clé de longueur variable $len(k) = l$

2. **Pseudo Random Generator Algorithm (PRGA)**
   - Génère le keystream de taille arbitraire
   - S'appuie sur la S-box permutée par KSA

```{mermaid}
graph TB
    A[Clé k de longueur variable] --> B[KSA: Key Scheduling]
    B --> C[S-box permutée]
    C --> D[PRGA: Génération]
    D --> E[Keystream zi]
    E --> F[XOR]
    G[Plaintext mi] --> F
    F --> H[Ciphertext ci]
```

::: {.callout-note collapse=true}
## 📄 Texte original

### Software Cipher Streams: RC4

- Le grand **désavantage des stream ciphers basés sur des registres** est qu'ils sont **très lents en version programmée** dans une machine générique. **RC4™** est un **stream cipher à clé variable** développé en **1987 par Ron Rivest** pour la société RSA security. Il est **très rapide** (**10 fois plus rapide que DES** !)
- Pendant 7 ans, cet algorithme était **breveté** et les détails son fonctionnement interne était dévoilés seulement après la **signature d'un contrat de confidentialité**. Depuis sa **publication (non officielle) dans un newsgroup en 1994**, il est globalement discuté et analysé dans toute la communauté cryptographique.
- L'algorithme travaille en **mode synchrone** (le keystream est indépendant du ciphertext et du plaintext).
- Il est composé de **combinaisons linéaires et non linéaires**. L'élément clé est une **boîte de substitution (S-box) de taille 8×8** dont les entrées sont une **permutation des chiffres 0 à 255**. La permutation est une **fonction de la clé principale** de taille variable avec $0 < len(k) \leq 255$. L'**encryption finale est obtenue par un xor** entre le keystream et le plaintext.
- RC4 est utilisé dans un **grand nombre d'applications commerciales**: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. Il est l'objet d'un grand nombre de **travaux analytiques et exhaustifs** qui ont réussi à **compromettre la sécurité** du key scheduling et du PRGA.
- En particulier l'application de RC4 sur les **Wired Equivalent Privacy (WiFi WEP) protocole a été "cassée"** suite à une **faille dans le mode d'utilisation** du protocole.

### RC4: Fonctionnement

- L'algorithme est constitué de **deux étapes**:
    - Le **Key Scheduling Algorithm (KSA)**: Responsable de la **permutation initiale** qui remplira la S-box en fonction de la clé de longueur variable $len(k) = l$.
    - Le **Pseudo Random Generator Algorithm (PRGA)**: Génère le **keystream de taille arbitraire** en s'appuyant sur la S-box.
:::

::: {.callout-tip collapse=true}
## 📌 Révision rapide

**RC4** : stream cipher logiciel, clé variable, 10× plus rapide que DES.

**Architecture** : S-box 8×8 (permutation 0-255) + XOR. 

**2 étapes** : KSA (permutation S-box) + PRGA (génération keystream). Mode synchrone. 

**Vulnérabilité** : WEP cassé (faille d'utilisation). Utilisé dans SSL, Windows, Oracle...
:::

## Block Ciphers (Cryptage par Blocs)

### 1. Introduction aux Block Ciphers

#### Définition et Principe

Un **block cipher** (chiffrement par blocs) est une fonction cryptographique qui :

- **Transforme des blocs de taille fixe** : fait correspondre un bloc de $n$ bits à un autre bloc de la même taille
- **Est paramétrisée par une clé** : la clé $K$ de $k$ bits définit la transformation
- **Doit être bijective** : pour permettre un décryptage unique
- **Chaque clé = bijection différente** : garantit la variabilité

**Taille nominale** : taille d'entrée du bloc sur lequel s'applique l'encryption

#### Critères de Qualité

**1. Taille/Entropie de la clé**

- Clés idéalement **équiprobables** avec entropie = $k$ bits
- Forte entropie protège contre les **attaques brute-force**
- **Minimum requis** : 128 bits pour les block ciphers modernes

**2. Performances**

- Vitesse d'exécution
- Efficacité en software/hardware

**3. Taille du bloc**

- Bloc trop petit = vulnérabilité aux **dictionnaires plaintext/ciphertext**
- **Standard moderne** : blocs ≥ 128 bits

**4. Résistance cryptographique**

- Résistance aux techniques connues :
  - Cryptanalyse linéaire
  - Cryptanalyse différentielle
  - Meet in the middle
- **Effort de cryptanalyse** équivalent au brute force

```{mermaid}
graph LR
    A[Plaintext n bits] --> B[Block Cipher]
    C[Clé K k bits] --> B
    B --> D[Ciphertext n bits]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
```

::: {.callout-note collapse=true}
### 📄 Texte original

#### Cryptage par Blocs (Block Ciphers)

- Les **block ciphers symétriques** constituent la **pierre angulaire de la cryptographie**. Leur fonctionnalité principale est la **confidentialité** mais ils sont également à la base des services d'**authentification**, **fonctions de hachage**, **génération aléatoire**, etc.

- **Définition**: Un block cipher est une **fonction** qui fait correspondre à un **bloc de $n$ bits** un autre bloc de **la même taille**. La fonction est **paramètrée par une clé $K$ de $k$ bits**. Afin de permettre une **decryption unique**, la fonction doit être **bijective**. **Chaque clé définit une bijection différente**. La **taille d'entrée du bloc** sur lequel s'applique l'encryption s'appelle aussi **taille nominale de l'algorithme**.

- **Critères pour évaluer la qualité** d'un block cipher:
  - **Taille/Entropie de la clé**: Idéalement, les clés sont **équiprobables** et l'espace des clés a une **entropie égale à $k$**. Une **forte entropie** de la clé protège des **attaques brute-force** à partir de chosen/known plaintexts. Les block ciphers modernes doivent avoir des **clés d'au moins 128 bits**.
  - **Performances**
  - **Taille du bloc**: Un bloc **trop petit** permettrait des attaques où des **"dictionnaires" plaintext/ciphertext** seraient construits. De nos jours, des **blocs de taille ≥ 128 bits** deviennent courants.
  - **Résistance cryptographique**: Le block cipher doit se montrer **résistant** à des techniques de cryptanalyse connues: **cryptanalyse linéaire ou différentielle**, **meet in the middle**, etc. L'**effort inhérent** à ces attaques (complexité, stockage, parallélisation, etc.) doit être **équivalent à celui d'une attaque brute force**.
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide

**Block cipher** : fonction bijective transformant blocs de $n$ bits avec clé $K$ de $k$ bits. **Critères** : entropie clé ≥ 128 bits, taille bloc ≥ 128 bits, résistance cryptanalyse = effort brute force. **Usage** : confidentialité, authentification, hachage, génération aléatoire.
:::

---

### 2. Modes d'Opération des Block Ciphers

#### 2.1 Electronic Codebook (ECB)

**Principe** : chaque bloc de plaintext est encrypté **indépendamment** avec la même clé.

$$c_i = E_K(m_i)$$
$$m_i = D_K(c_i)$$

```{mermaid}
graph TB
    subgraph Encryption
        P1[Plaintext Block 1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext Block 1]
        
        P2[Plaintext Block 2] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext Block 2]
    end
    
    style E1 fill:#ffcccc
    style E2 fill:#ffcccc
    style K1 fill:#fff4e1
    style K2 fill:#fff4e1
```

**Caractéristiques :**

- ✗ **Plaintexts identiques** → ciphertexts identiques (prévisible)
- ✓ **Pas de propagation d'erreurs** : erreur sur $c_j$ n'affecte que $m_j$
- ✗ **Patterns visibles** : structure du plaintext transparente dans le ciphertext
- ✓ **Parallélisable** : chaque bloc traité indépendamment

**⚠️ Vulnérabilité majeure** : Ne doit PAS être utilisé pour des données redondantes

---

#### 2.2 Cipher Block Chaining (CBC)

**Principe** : chaque bloc de plaintext est **XORé avec le ciphertext précédent** avant encryption.

$$c_i = E_K(m_i \oplus c_{i-1})$$
$$m_i = D_K(c_i) \oplus c_{i-1}$$

Avec $c_0 = IV$ (Initialization Vector)

```{mermaid}
graph TB
    subgraph Encryption
        IV[IV] --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext c1]
        
        C1 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ccffcc
    style E2 fill:#ccffcc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Caractéristiques :**

- ✓ **Plaintexts identiques** → ciphertexts différents (si IV change)
- ✓ **Patterns effacés** : chaînage masque la structure
- ✓ **Propagation d'erreurs limitée** : erreur sur $c_j$ affecte $m_j$ et $m_{j+1}$ uniquement
- ✗ **Non parallélisable** en encryption (séquentiel)
- ✓ **Parallélisable** en décryption

**IV (Initialization Vector)** :

- Doit être **aléatoire** ou **pseudo-aléatoire**
- Peut être transmis **en clair**
- Doit être **différent** pour chaque message avec la même clé

---

#### 2.3 Cipher Feedback Mode (CFB)

**Principe** : fonctionne comme un **stream cipher** où le keystream est généré par le block cipher. Le keystream dépend des **ciphertexts précédents** (mode **asynchrone**).

$$c_i = m_i \oplus E_K(c_{i-1})$$
$$m_i = c_i \oplus E_K(c_{i-1})$$

Avec $c_0 = IV$

```{mermaid}
graph TB
    subgraph CFB_Encryption
        IV[IV / ci-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        C1 -.feedback.-> IV
    end
    
    style E1 fill:#ffccff
    style X1 fill:#ffffcc
```

**Caractéristiques :**

- ✓ **Plaintexts identiques** → ciphertexts différents (si IV change)
- ✓ **Chaînage** : dépendances entre ciphertexts
- ⚠️ **Propagation d'erreurs** : erreur sur $c_j$ affecte $\frac{n}{r}$ blocs suivants
  - $n$ = taille nominale du block cipher
  - $r$ = taille des plaintexts
- ✗ **Non parallélisable**
- ⚠️ **IV non confidentiel** mais doit être transmis

**Usage** : adapté aux transmissions avec pertes de paquets fréquentes

---

#### 2.4 Output Feedback Mode (OFB)

**Principe** : fonctionne comme un **stream cipher synchrone**. Le keystream est **entièrement déterminé** par la clé et l'IV, **indépendant** du plaintext et du ciphertext.

$$z_i = E_K(z_{i-1})$$
$$c_i = m_i \oplus z_i$$
$$m_i = c_i \oplus z_i$$

Avec $z_0 = IV$

```{mermaid}
graph TB
    subgraph OFB_Mode
        IV[IV / zi-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> Z[zi keystream]
        Z --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        Z -.feedback.-> IV
    end
    
    style E1 fill:#cce5ff
    style X1 fill:#ffffcc
    style Z fill:#e1ffe1
```

**Caractéristiques :**

- ✓ **Plaintexts identiques** → ciphertexts différents (si IV change)
- ✓ **Pas de propagation d'erreurs** : erreur sur $c_j$ n'affecte que $m_j$
- ✓ **Keystream pré-calculable** : efficace
- ⚠️ **CRITIQUE** : ne JAMAIS réutiliser le même IV avec la même clé (sinon keystream identique)
- ✓ **Parallélisable** si keystream pré-calculé

**⚠️ Attention réutilisation** : Modifier l'IV pour chaque nouveau message !

::: {.callout-note collapse=true}
### 📄 Texte original (Modes CFB et OFB)

#### Modes CFB et OFB: Caractéristiques

Les modes **CFB et OFB** fonctionnent comme un **stream cipher** avec un **keystream généré par le bloc de cryptage**. Dans **CFB**, le keystream dépend des **ciphertexts précédents** (**asynchrone**) alors que dans **OFB**, le keystream est **entièrement déterminé par la clé et le IV** (**synchrone**).

**Particularités de CFB**:

- Comme dans le mode CBC, des **plaintext identiques** sont traduits en **ciphertexts différents** si le **IV change**. Le **IV n'est pas nécessairement confidentiel** et peut être échangé en clair entre les parties.
- Le **chaînage** introduit également des **dépendances** entre les ciphertexts courants et les ciphertexts précédents. En particulier, si $n$ est la **taille nominale de l'algorithme** et $r$ est la **taille des plaintexts**, le ciphertext courant dépendra des $\frac{n}{r}$ **ciphertexts précédents** (chaque itération décalera l'entrée fautive de $r$ positions, après $\frac{n}{r}$ itérations le ciphertext fautif sera "expulsé" complètement).
- La **propagation d'erreurs** obéit au même principe: une erreur dans un ciphertext se traduira par une mauvaise decryption des $\frac{n}{r}$ ciphertexts suivants.

**Particularités de OFB**:

- OFB a un comportement **identique** aux modes CBC et CFB pour l'**encryption de plaintext identiques**.
- **Pas de propagation d'erreurs** sur les ciphertexts adjacents.
- **Modifiez le IV** si la clé ne change pas pour **éviter la réutilisation du keystream** !!!
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide (Modes CFB/OFB)

**CFB** (asynchrone) : keystream = $f$(ciphertexts précédents). Propagation erreur limitée ($\frac{n}{r}$ blocs).

**OFB** (synchrone) : keystream = $f$(clé + IV uniquement). Pas propagation erreur. 

**CRITIQUE** : ne JAMAIS réutiliser même IV avec même clé. IV transmissible en clair.
:::

---

#### 2.5 Counter Mode (CTR)

**Principe** : le keystream est généré par l'**encryption d'un compteur** incrémenté à chaque bloc.

$$c_i = m_i \oplus E_K(counter + i)$$
$$m_i = c_i \oplus E_K(counter + i)$$

```{mermaid}
graph TB
    subgraph CTR_Mode
        CTR1[Counter + 0] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> C1[Ciphertext c1]
        
        CTR2[Counter + 1] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ffe6cc
    style E2 fill:#ffe6cc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Caractéristiques :**

- ✓ **Mode synchrone** : keystream = $f$(compteur)
- ✓ **Parallélisable** : keystream pré-calculable pour encryption ET décryption
- ✓ **Accès aléatoire** : chaque bloc décryptable indépendamment
- ✓ **Pas de propagation d'erreurs**
- ✓ **Profite des architectures SIMD** : pas de dépendances entre blocs
- ⚠️ **Compteur** : doit être de taille $2^b$ ($b$ = taille du bloc)
- ⚠️ **CRITIQUE** : ne JAMAIS réutiliser le même compteur avec la même clé

**Gestion du compteur** :

- **Incrémenter modulo** $2^b$ après chaque itération
- **Solution** : toujours incrémenter pour chaque flux encrypté
- Premier bloc du flux $i+1$ > dernier bloc du flux $i$

**Applications** :

- **ATM** (Asynchronous Transfer Mode)
- **IPsec** (IP security)
- **Lignes à haut débit** : transmission sélective des blocs
- **Transferts de grands volumes** : vidéo

::: {.callout-note collapse=true}
### 📄 Texte original (Counter Mode)

#### Counter Mode (CTR Mode)

Fréquemment utilisé comme support d'encryption dans des protocoles de transfert de données comme **ATM** (Asynchronous Transfer Mode) et **IPsec** (IP security).

#### Counter Mode (II)

- Le **keystream** est généré par l'**encryption d'un compteur aléatoire** de taille $2^b$ (avec $b$ la taille du bloc) et nécessaire pour la décryption. Ce compteur est **incrémenté modulo** $2^b$ après chaque itération.
- Travaille en **mode synchrone**. La **réutilisation d'un même compteur** se traduit par un **keystream identique** !
- **Solution**: Toujours **incrémenter le compteur** pour chaque flot encrypté de telle sorte que le compteur du premier bloc d'un flot soit **plus grand que le dernier bloc** du flot précédent.
- **Facilement parallélisable**: Le keystream peut être **pré-calculé** aussi bien pour l'encryption que pour la décryption. Profite pleinement des **architectures SIMD** car contrairement aux autres modes de chaînage il n'y a pas des **dépendances entre les opérations** des différents blocs.
- **Accès aléatoire** à l'encryption/décryption de chaque bloc: Contrairement aux autres modes de chaînage où la $i$-ème opération dépend de la $(i-1)$-ème opération.
- Si à ceci on ajoute l'**absence de propagation d'erreurs**, le mode compteur facilite la **(re)transmission sélective** des blocs de ciphertext, ce qui le rend très attractif pour la **sécurisation de lignes à haut débit** ainsi que pour les **transferts encryptés de grands volumes** d'information (p.ex. vidéo).
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide (Counter Mode)

**CTR** : keystream = $E_K$(compteur + $i$).

**Avantages** : parallélisable (encryption + décryption), accès aléatoire, pas propagation erreur, SIMD-friendly.

**CRITIQUE** : ne jamais réutiliser compteur.

**Usage** : ATM, IPsec, haut débit, vidéo.
:::

---

### 3. Product Ciphers et Feistel Ciphers

#### Product Ciphers

**Définition** : schéma de cryptage combinant une **série de transformations successives** pour renforcer la résistance à la cryptanalyse.

**Transformations courantes** :

- Transpositions (permutations)
- Substitutions (S-boxes)
- XORs
- Combinaisons linéaires
- Multiplications modulaires

#### Feistel Ciphers

**Définition** : product cipher itératif avec structure spécifique.

**Principe de fonctionnement** :

- **Entrée** : plaintext de $2t$ bits = $(L_0, R_0)$ (deux sous-blocs de $t$ bits)
- **Sortie** : ciphertext de $2t$ bits = $(R_r, L_r)$ après $r$ étapes (rounds)
- **Chaque étape** : bijection inversible (pour décryption unique)

**Équations d'une étape** $i$ ($1 \leq i \leq r$) :

$$(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$$

Avec :

- $L_i = R_{i-1}$
- $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$

```{mermaid}
graph TB
    subgraph Feistel_Round
        L0[Li-1] --> R1[Ri = Li-1 ⊕ f]
        R0[Ri-1] --> L1[Li = Ri-1]
        R0 --> F[Function f]
        K[Key Ki] --> F
        F --> XOR[⊕]
        L0 --> XOR
        XOR --> R1
    end
    
    style F fill:#ffcccc
    style XOR fill:#ffffcc
    style K fill:#fff4e1
```

**Caractéristiques** :

- $K_i$ : sous-clés générées à partir de la clé principale $K$
- Nombre d'étapes $r$ : généralement **pair** et $\geq 3$
  - Exemple : DES a 16 étapes
- **Permutation finale** : $(L_r, R_r) \rightarrow (R_r, L_r)$
- **Décryption** : identique à l'encryption mais sous-clés appliquées en **ordre inverse** (de $K_r$ à $K_1$)

**Opérations fréquentes** :

- Permutations
- Substitutions (S-boxes)

::: {.callout-note collapse=true}
### 📄 Texte original

#### Product Ciphers et Feistel Ciphers

- Un **product cipher** est un **schéma de cryptage** combinant une **série de transformations successives** dans le but de **renforcer la résistance à la cryptanalyse**. Des transformations courantes pour un product cipher sont: des **transpositions**, des **substitutions**, des **XORs**, des **combinaisons linéaires**, des **multiplications modulaires**, etc.

- Un **Feistel cipher** est un **product cipher itératif** capable de transformer un **plaintext de $2t$ bits** de la forme $(L_0, R_0)$ composé par deux **sous-blocs** $L_0$ et $R_0$ de $t$ bits en un **ciphertext de taille $2t$** de la forme $(R_r, L_r)$ après $r$ **étapes (rounds) successives** avec $r \geq 1$. **Chaque étape** définit une **bijection (inversible !)** pour permettre une decryption unique.

- Des **permutations** et des **substitutions** sont les opérations les plus fréquentes.

- Les étapes $1 \leq i \leq r$ s'écrivent: $(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$ avec $L_i = R_{i-1}$ et $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$. Les $K_i$ sont des **sous-clés**, **différentes pour chaque étape**, générées à partir de la **clé principale $K$** du schéma de cryptage.

- Le **nombre d'étapes** propres à un Feistel cipher est normalement **pair** et $\geq 3$ (p.ex. **DES a 16 étapes**)

- Après l'exécution de toutes les étapes, un Feistel cipher effectue une **permutation** des deux parties $(L_r, R_r)$ en $(R_r, L_r)$.

- La **decryption** d'un Feistel Cipher est **identique à l'encryption** sauf que les sous-clés $K_i$ sont appliquées en **ordre inverse** (De $K_r$ à $K_1$).
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide

**Product cipher** : combinaison de transformations successives (transpositions, substitutions, XOR).

**Feistel cipher** :

  - product cipher itératif
  - plaintext $2t$ bits = $(L_0, R_0)$
  - $r$ rounds avec $L_i = R_{i-1}$ et $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$.
  - Décryption = encryption avec sous-clés inversées.
  - Exemple : DES (16 rounds).
:::

---

### 4. Data Encryption Standard (DES)

#### Présentation Générale

**DES** (Data Encryption Standard) : algorithme cryptographique le plus important jusqu'à l'avènement d'AES en 2001.

**Caractéristiques principales** :

- **Type** : Feistel Cipher
- **Taille des blocs** : 64 bits (taille nominale)
- **Taille de la clé** : 56 bits effectifs (64 bits totaux avec 8 bits de parité)
- **Nombre d'étapes** : 16 rounds
- **Sous-clés** : 16 sous-clés de 48 bits (une par étape)
- **Modes d'utilisation** : ECB, CBC, CFB, OFB

```{mermaid}
graph TB
    subgraph DES_Overview
        P[Plaintext 64 bits] --> DES[DES Encryption]
        K[Key 56 bits] --> DES
        DES --> C[Ciphertext 64 bits]
        
        C --> DES_INV[DES Decryption]
        K2[Key 56 bits] --> DES_INV
        DES_INV --> P2[Plaintext 64 bits]
    end
    
    style DES fill:#ffcccc
    style DES_INV fill:#ccffcc
    style K fill:#fff4e1
    style K2 fill:#fff4e1
```

#### Structure de DES

**Composants principaux** :

1. **Permutation initiale (IP)** : permutation des 64 bits d'entrée
2. **16 rounds Feistel** : transformation itérative
3. **Permutation finale (IP⁻¹)** : inverse de IP

**Chaque round applique** :

- Division en deux moitiés : $L_{i-1}$ et $R_{i-1}$ (32 bits chacune)
- Fonction $f$ sur $R_{i-1}$ avec sous-clé $K_i$
- XOR avec $L_{i-1}$
- Échange des moitiés

```{mermaid}
graph TB
    Plain[Plaintext 64 bits] --> IP[Initial Permutation IP]
    IP --> Split[Split L0, R0]
    
    Split --> Round1[Round 1]
    K1[K1] --> Round1
    Round1 --> Round2[Round 2]
    K2[K2] --> Round2
    Round2 --> Dots[...]
    Dots --> Round16[Round 16]
    K16[K16] --> Round16
    
    Round16 --> Swap[Swap R16, L16]
    Swap --> IP_inv[Final Permutation IP⁻¹]
    IP_inv --> Cipher[Ciphertext 64 bits]
    
    style IP fill:#e1f5ff
    style IP_inv fill:#e1f5ff
    style Round1 fill:#ffcccc
    style Round2 fill:#ffcccc
    style Round16 fill:#ffcccc
```

#### Fonction Cipher de DES

La **fonction $f$** pour chaque round :

1. **Expansion E** : 32 bits → 48 bits (table E)
2. **Key Addition** : XOR avec sous-clé $K_i$ (48 bits)
3. **S-boxes** : 8 S-boxes transforment 48 bits → 32 bits
   - Chaque S-box : 6 bits entrée → 4 bits sortie
4. **Permutation P** : permutation des 32 bits résultants

```{mermaid}
graph TB
    R[Ri-1 32 bits] --> E[Expansion E]
    E --> E_out[48 bits]
    E_out --> XOR1[⊕]
    K[Ki 48 bits] --> XOR1
    XOR1 --> S[8 S-boxes]
    S --> S_out[32 bits]
    S_out --> P[Permutation P]
    P --> F_out[f output 32 bits]
    
    style E fill:#cce5ff
    style S fill:#ffcccc
    style P fill:#e1ffe1
    style XOR1 fill:#ffffcc
```

**Fonctionnement des S-boxes** :

Entrée : $a_1a_2a_3a_4a_5a_6$ (6 bits)

- **Ligne** : $a_1 + 2a_6$ (bits externes)
- **Colonne** : $a_2 + 2a_3 + 4a_4 + 8a_5$ (bits internes)
- **Sortie** : valeur de la cellule correspondante (4 bits)

#### Génération des Sous-clés

**Processus** :

1. Clé principale : 64 bits (56 effectifs + 8 parité)
2. **Permuted Choice 1 (PC-1)** : sélection de 56 bits
3. Division en deux moitiés : $C_0$ et $D_0$ (28 bits chacune)
4. Pour chaque round $i$ :
   - Rotation circulaire gauche de $C_{i-1}$ et $D_{i-1}$
   - **Permuted Choice 2 (PC-2)** : sélection de 48 bits pour $K_i$

**Rotations** :

- Rounds 1, 2, 9, 16 : 1 position
- Autres rounds : 2 positions

::: {.callout-note collapse=true}
### 📄 Texte original (DES Fonctionnement)

#### DES: Fonctionnement

**Cipher Fonction**

- **Expansion E**: Les **32 bits de l'entrée** sont transformés en un vecteur de **48 bits** en utilisant la **table E**. La première ligne de cette table indique comment sera généré le premier sous-bloc de 6 bits: on prendra en premier le 32e bit et après les bits 1,2,3,4,5. Le deuxième sous-bloc commence par le 4e bit ensuite les bits 5,6,7,8,9 et ainsi de suite...

- **Key addition**: **XOR du vecteur de 48 bits** avec la clé.

- **S-boxes**: On applique **8 S-boxes** sur le vecteur de 48 bits résultant du XOR précédent. Chacune de ces S-boxes prend un **sous-bloc de 6 bits** et le transforme en un **sous-bloc de 4 bits**. L'opération s'effectue de la manière suivante: Si on dénote les 6 bits d'input de la S-box comme: $a_1a_2a_3a_4a_5a_6$. La sortie est donnée par le contenu de la cellule située dans la **ligne** $a_1 + 2a_6$ et la **colonne** $a_2 + 2a_3 + 4a_4 + 8a_5$.

- **Permutation P**: La permutation P fonctionne comme suit: Le premier bit est envoyé à la 16e position, le deuxième à la 7e position et ainsi de suite.

**Permutations IP et IP⁻¹**

- Agissent respectivement au **début** et à la **fin** du traitement du bloc et sur l'**ensemble des 64 bits**.
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide (DES)

**DES** : Feistel cipher, 64 bits blocs, 56 bits clé effective, 16 rounds.

**Fonction $f$** : Expansion E (32→48 bits) → XOR $K_i$ → 8 S-boxes (48→32 bits) → Permutation P.

**S-box** : 6 bits input → 4 bits output via table (ligne = bits externes, colonne = bits internes).

**Permutations** : IP (initiale) et IP⁻¹ (finale) sur 64 bits.
:::

---

### 5. Triple-DES et Sécurité de DES

#### Vulnérabilités de DES

**Problème principal** : taille de l'espace de clés $\{0,1\}^{56}$ insuffisante.

**Attaque brute force** :

- **1999** : clé trouvée en **24 heures**
- Technique : brute force massivement parallèle (100'000 PCs sur Internet)
- Known plaintext attack

#### Triple-DES (3DES)

**Solution** : augmenter l'espace des clés à $\{0,1\}^{112}$.

**Schéma** :

$$C = E_{K_1}(D_{K_2}(E_{K_1}(P)))$$

Avec :

- $E$ : encryption DES
- $D$ : décryption DES
- $K_1, K_2$ : deux clés de 56 bits

```{mermaid}
graph LR
    P[Plaintext 64 bits] --> E1[DES Encrypt K1]
    E1 --> D[DES Decrypt K2]
    D --> E2[DES Encrypt K1]
    E2 --> C[Ciphertext 64 bits]
    
    K1a[Key K1 56 bits] --> E1
    K2[Key K2 56 bits] --> D
    K1b[Key K1 56 bits] --> E2
    
    style E1 fill:#ffcccc
    style D fill:#ccffcc
    style E2 fill:#ffcccc
```

**Avantages** :

- ✓ **Sécurité satisfaisante** : espace de clés $2^{112}$
- ✓ **Compatibilité** : réutilisation du hardware/software DES existant
- ✓ **Migration progressive** : en attendant AES

**Inconvénient** :

- ✗ **Performances** : 3× plus lent (3 exécutions DES successives)

#### Propriétés de DES

**1. DES n'est pas un groupe**

DES n'est PAS un groupe pour la composition :

$$\nexists K_3 \text{ tel que } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)$$

**Conséquence** : encryption composée (Triple-DES) augmente considérablement la sécurité.

**Si DES était un groupe** : recherche exhaustive sur $\{0,1\}^{56}$ casserait l'algorithme indépendamment du nombre d'exécutions consécutives.

**2. Clés faibles et semi-faibles**

- **Clé faible** : $E_K(E_K(x)) = x$

- **Paire de clés semi-faibles** : $E_{K_1}(E_{K_2}(x)) = x$

**Caractéristique** : clés faibles génèrent des sous-clés identiques par paires :

- $k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$
- Facilite la cryptanalyse

**DES a 4 clés faibles** :

| Clé faible (hexadécimal) |
|---------------------------|
| 0101 0101 0101 0101 |
| 0101 0101 FEFE FEFE |
| FEFE FEFE FEFE FEFE |
| FEFE FEFE 0101 0101 |

**Et 6 paires de clés semi-faibles**

::: {.callout-note collapse=true}
### 📄 Texte original (DES et 3DES)

#### DES et Triple-DES

- La **taille de l'ensemble de clés** ($\{0,1\}^{56}$) constitue la **plus grande menace** qui pèse sur DES avec les ressources de calcul actuels. En **1999** il a suffit de **24 heures** pour trouver la clé à partir d'un **known plaintext** en utilisant une technique **brute force massivement parallèle** (100'000 PCs connectés sur Internet).

- **Triple DES** nous met à l'abri de ces **attaques brute force** en augmentant l'**espace des clés possibles** à $\{0,1\}^{112}$. 

- Cette alternative permet de continuer à utiliser les **"boîtes" DES** (hardware et software) en attendant une migration vers AES.

- Le **niveau de sécurité** obtenu par cette solution est **très satisfaisant**.

- L'**impact en termes de performances** de trois exécutions successives de DES reste un **inconvénient** pour certaines applications.

#### DES: propriétés

- **DES n'est pas un groupe** (au sens algébrique) avec la composition: En d'autres termes, DES étant une permutation: $\{0,1\}^{64} \rightarrow \{0,1\}^{64}$, si DES était un groupe pour la composition, ceci voudrait dire que: $\exists K_3$ t.q. $E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)$

  Cette propriété permet d'assurer que l'**encryption composée** (comme Triple-DES) **augmente considérablement la sécurité** de DES. Si DES était un groupe, la recherche exhaustive sur l'ensemble de clés possibles ($\{0,1\}^{56}$) permettrait de "casser" l'algorithme **indépendamment du nombre d'exécutions consécutives** de DES.

- **Clés faibles et mi-faibles** (weak and semi-weak keys): 
  - Une clé $K$ est dite **faible** si $E_K(E_K(x)) = x$. 
  - Une paire de clés $(K_1, K_2)$ est dite **mi-faible** si $E_{K_1}(E_{K_2}(x)) = x$.

- Les clés faibles ont la particularité de générer de **sous-clés identiques par paires** ($k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$), ce qui **facilite la cryptanalyse**. 

- **DES a 4 clés faibles** (et 6 paires de clés mi-faibles).
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide (3DES et sécurité)

**Vulnérabilité DES** : espace clés $2^{56}$ cassable en 24h (1999). **Triple-DES** : $E_{K_1}(D_{K_2}(E_{K_1}(P)))$, espace $2^{112}$, réutilise hardware DES, 3× plus lent. **DES ≠ groupe** → encryption composée renforce sécurité. **4 clés faibles** générant sous-clés identiques par paires → facilite cryptanalyse.
:::

---

### 6. Advanced Encryption Standard (AES)

#### Présentation Générale

**AES** (Advanced Encryption Standard) : standard adopté en novembre 2001.

**Conception** : Johan Daemen et Vincent Rijmen (nom original : **Rijndael**)

**Caractéristiques principales** :

- **Type** : block cipher itératif (mais **PAS un Feistel Cipher**)
- **Taille des blocs** : 128 bits
- **Taille de clé variable** : 128, 192 ou 256 bits
- **Nombre de rounds** : dépend de la taille de clé
  - 10 rounds pour clé 128 bits
  - 12 rounds pour clé 192 bits
  - 14 rounds pour clé 256 bits
- **Modes d'utilisation** : ECB, CBC, CFB, OFB, CTR

**Avantages par rapport à DES** :

- ✓ **Processus ouvert** : consultation et analyse par experts mondiaux
- ✓ **~2× plus performant** en software
- ✓ **~10²² fois plus sûr** (théoriquement)
- ✓ **Évolutif** : taille de clé augmentable si nécessaire

#### Structure d'AES

**Unité de base** : matrice **State** de 4 lignes × 4 colonnes (pour clé 128 bits)

- Chaque élément = 1 byte
- **Total** : 16 bytes = 128 bits

**Opérations sur le corps** $GF(2^8)$ :

- Byte = élément de $GF(2^8)$
- Corps fini de polynômes de degré ≤ 7 avec coefficients dans $GF(2)$
- Additions, multiplications définies dans $GF(2^8)$

```{mermaid}
graph TB
    subgraph State_Matrix
        S00[s0,0] --- S01[s0,1]
        S01 --- S02[s0,2]
        S02 --- S03[s0,3]
        
        S10[s1,0] --- S11[s1,1]
        S11 --- S12[s1,2]
        S12 --- S13[s1,3]
        
        S20[s2,0] --- S21[s2,1]
        S21 --- S22[s2,2]
        S22 --- S23[s2,3]
        
        S30[s3,0] --- S31[s3,1]
        S31 --- S32[s3,2]
        S32 --- S33[s3,3]
    end
    
    style S00 fill:#ffe6cc
    style S11 fill:#ffe6cc
    style S22 fill:#ffe6cc
    style S33 fill:#ffe6cc
```

#### Détail d'un Round AES

**Quatre opérations par round** :

**1. SubBytes (ByteSub)**

- Substitution non linéaire via **S-box**
- Chaque byte transformé indépendamment
- Résistance à la cryptanalyse linéaire et différentielle

**2. ShiftRows**

- **Permutation des bytes** avec décalages variables par ligne
- Ligne 0 : pas de décalage
- Ligne 1 : décalage gauche 1 position
- Ligne 2 : décalage gauche 2 positions
- Ligne 3 : décalage gauche 3 positions

**3. MixColumns**

- Chaque colonne = combinaison linéaire des autres colonnes
- **Multiplication de matrices** dans $GF(2^8)$
- Diffusion maximale

**4. AddRoundKey**

- **XOR** de la matrice State avec la sous-clé du round
- Sous-clé = résultat du Key Schedule

```{mermaid}
graph TB
    Input[State Input] --> SB[SubBytes]
    SB --> SR[ShiftRows]
    SR --> MC[MixColumns]
    MC --> ARK[AddRoundKey]
    K[Round Key] --> ARK
    ARK --> Output[State Output]
    
    style SB fill:#ffcccc
    style SR fill:#ccffcc
    style MC fill:#cce5ff
    style ARK fill:#ffffcc
```

**Round final** : identique SAUF **pas de MixColumns**

#### Key Schedule (Génération des Sous-clés)

**Processus** :

1. **Key Expansion** : génération d'une matrice étendue
   - Clé 128 bits → matrice 4 × 4 × ($N_e$ + 1) bytes
   - $N_e$ = nombre de rounds
2. **Key Selection** : extraction des sous-clés
   - Première sous-clé : 4 premières colonnes
   - Deuxième sous-clé : 4 colonnes suivantes
   - Etc.

**Opérations** :

- Rotations de bytes
- Substitutions via S-box
- XOR avec constantes (Rcon)

#### Pseudo-code AES

```
Rijndael(State, CipherKey) {
    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule
    
    AddRoundKey(State, ExpandedKey[0..3]); // XOR initial
    
    for(i = 1; i < Ne; i++) {
        Round(State, ExpandedKey[4*i...(4*i)+3]);
    }
    
    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Sans MixColumns
}
```

#### Décryption AES

**Principe** : appliquer les **opérations inverses** dans chaque round.

**Opérations inverses** :

- **InvSubBytes** : substitution inverse via S-box⁻¹
- **InvShiftRows** : décalages droite (au lieu de gauche)
- **InvMixColumns** : multiplication matricielle inverse
- **AddRoundKey** : auto-inverse (XOR)

**Ordre** : inverse de l'encryption avec sous-clés en ordre inverse

::: {.callout-note collapse=true}
### 📄 Texte original (AES)

#### Advanced Encryption Standard (AES)

- Adopté comme **standard en Novembre 2001**, conçu par **Johan Daemen et Vincent Rijmen** (d'où son nom original **Rijndael**).

- Il s'agit également d'un **block cipher itératif** (comme DES) mais **pas d'un Feistel Cipher**.

- **Blocs Plaintext/Ciphertext**: **128 bits**.

- **Clé de longueur variable**: **128, 192, ou 256 bits**.

- Contrairement à DES, AES est issu d'un **processus de consultation et d'analyse ouvert** à des experts mondiaux.

- Techniques semblables à DES (substitutions, permutations, XOR…) complémentées par des **opérations algébriques simples** et très performantes.

- Toutes les opérations s'effectuent dans le **corps** $GF(2^8)$: le corps fini de **polynômes de degré ≤ 7** avec des **coefficients dans** $GF(2)$.

- En particulier, un **byte pour AES est un élément dans** $GF(2^8)$ et les **opérations sur les bytes** (additions, multiplications,...) sont **définies comme sur** $GF(2^8)$.

- **~2 fois plus performant** (en software) et **~10²² fois (en théorie...) plus sûr** que DES...

- **Évolutif**: La taille de la clé peut être augmentée si nécessaire.

##### Détail d'une Etape (round) AES

L'**unité de base** sur laquelle s'appliquent les calculs est une **matrice de 4 lignes et 4 colonnes** (dans le cas d'une clé de 128 bits) dont les éléments sont des **bytes**:

- **ByteSub**: Opération **non linéaire (S-box)** conçu pour **résister à la cryptanalyse linéaire et différentielle**.

- **ShiftRow**: **Permutation des bytes** introduisant des **décalages variables** sur les lignes.

- **MixColumn**: Chaque colonne est remplacée par des **combinaisons linéaires** des autres colonnes (**multiplication des matrices** !)

- **AddRoundKey**: **XOR** de la matrice courante avec la **sous-clé** correspondante à l'étape courante.

##### AES: Fonctionnement Global

- Le **nombre d'étapes** d'AES varie en fonction de la **taille de la clé**. Pour une clé de **128 bits**, il faut effectuer **10 étapes**. Chaque augmentation de 32 bits sur la taille de la clé, entraîne une **étape supplémentaire** (14 étapes pour des clés de 256 bits).

- La **decryption** consiste en appliquer les **opérations inverses** dans chacune des étapes (**InvSubBytes**, **InvShiftRows**, **InvMixColumns**). **AddRoundKey** (à cause du XOR) est **sa propre inverse**.

- Le **Key Schedule** consiste en:
  - Une opération d'**expansion de la clé** principal. Si $N_e$ est le nombre d'étapes (dépendant de la clé), une **matrice de 4 lignes et 4 × ($N_e$ + 1) colonnes** est générée.
  - Une opération de **sélection de la clé d'étape**: La **première sous-clé** sera constituée des **4 premières colonnes** de la matrice générée lors de l'expansion et ainsi de suite.
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide (AES)

**AES** (Rijndael 2001) : block cipher itératif (PAS Feistel), 128 bits blocs, clés 128/192/256 bits → 10/12/14 rounds.

**State** : matrice 4×4 bytes dans $GF(2^8)$.

**4 opérations/round** :

  - SubBytes (S-box non linéaire)
  - ShiftRows (décalages lignes)
  - MixColumns (combinaisons linéaires)
  - AddRoundKey (XOR sous-clé). 

2× plus rapide que DES, 10²² fois plus sûr.
:::

---

### 7. Attaques et Sécurité d'AES

#### Forces d'AES

**Simplicité et performances** :

- ✓ Algorithme simple et efficace
- ✓ Fonctionne sur plateformes limitées (cartes à puce 8 bits)
- ✓ Optimisations hardware et software

#### Attaques Publiées

**1. Attaques algébriques (2002)**

**Technique XSL** (N. Courtois et P. Pieprzyk) :

- Représente AES comme **système de 8000 équations quadratiques** avec 1600 inconnues binaires
- **Effort estimé** : $2^{100}$ opérations (encore une conjecture)
- **Caractéristique** : nécessite peu de known plaintexts
- **Distinction** : différent des attaques linéaires/différentielles

**Critique** : basées sur le caractère "fortement algébrique" d'AES (largement contesté)

**2. Related Key Attacks (2009-2011)**

**Principe** : attaques basées sur des **clés similaires**

- Résultats intéressants sur **versions réduites** d'AES
- Ne compromettent pas AES complet

**3. Side Channel Attacks**

**Principe** : attaques sur l'**implémentation** (pas l'algorithme)

**Techniques** :

- **Cache timing attacks** : analyse des accès cache
- **Power analysis** : consommation électrique
- **Electromagnetic analysis** : émissions électromagnétiques

**Exemple** (2005) : Osvik, Shamir, Tromer

- Extraction de clé 128 bits avec **6-7 couples plaintext/ciphertext**
- Basée sur analyse des **accès cache**

**4. Meet in the Middle sur structures bicycliques (2011-2015)**

**Résultat** :

- Réduit l'effort pour AES-128 à **$2^{126}$** (facteur 4 vs brute force)
- **Reste largement au-dessus** des capacités actuelles

#### Sécurité Pratique

**Hypothèse fondamentale** : clé d'**entropie maximale**

**Attaques récentes** (WPA2, etc.) :

- Exploitent la **faiblesse des passwords/passphrases**
- Pas de faille dans AES lui-même
- Problème : génération de clés depuis passwords faibles

**⚠️ Rappel critique** : qualité de la clé = sécurité du système

::: {.callout-note collapse=true}
### 📄 Texte original (Attaques AES)

#### AES: Remarques Finales et Attaques (I)

- La plus grande **force de AES** réside dans sa **simplicité** et dans ses **performances**, y compris sur des plate-formes à **capacité de calcul réduite** (p.ex. des **cartes à puces** avec des processeurs à 8 bits).

- Depuis sa publication officielle, des **nombreux travaux de cryptanalyse** ont été publiés avec des résultats très intéressants. En particulier, **N. Courtois et P.Pieprzyk** ont présenté une technique appelée **XSL** permettant de représenter AES comme un **système de 8000 équations quadratiques** avec **1600 inconnues binaires**. L'**effort nécessaire** pour casser ce système est estimé (il s'agit encore d'une **conjecture**...) à **$2^{100}$**.

- Ces attaques se basent sur le **caractère fortement algébrique** (et largement contesté...) de AES. De plus, il suffit de **quelques known plaintexts** pour les mettre en place, ce qui les distingue des attaques linéaires et différentielles.

- Ces dernières années (2009-2011) des **attaques basées sur des clés similaires** (related key attacks) ont obtenu des résultats intéressants sur des **versions réduites** d'AES.

- Une autre famille d'attaques dénommée **side channel attacks** agissant directement sur l'**implémentation de l'algorithme** permet d'extraire des informations d'intérêt cryptographique lors de l'exécution de l'encryption.

#### AES: Remarques finales et Attaques (II)

- En **2015** une attaque de type **Meet in the Middle** basé sur des **structure bicycliques** a montré qu'il était possible de réduire l'**effort nécessaire** pour trouver une clé AES-128 à **$2^{126}$**, soit un **facteur 4** par rapport au brute force. Ceci reste tout de même **largement au dessus** des capacités de calcul actuelles.

- Une autre famille d'attaques dénommée **side channel attacks** agissant directement sur l'**implémentation de l'algorithme** permet d'extraire des informations d'intérêt cryptographique lors de l'exécution de l'encryption. En particulier, les auteurs arrivent à **extraire la clé de 128 bits** avec seulement **6-7 couples plaintext/ciphertexts** en se basant sur les **accès cache**.

- La **sécurité de AES** (comme pour tout autre algorithme d'encryption) se base toujours sur l'hypothèse d'une **clé d'entropie maximale**. Les **attaques publiées récemment** sur des protocoles basés sur AES (comme WPA2) exploitent la **faiblesse des passwords/passphrases** qui sont à l'origine des clés utilisées.
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide (Sécurité AES)

**Forces** : simplicité, performances (même cartes 8 bits). **Attaques** : XSL ($2^{100}$, algébrique), related keys (versions réduites), side channel (implémentation, cache), Meet-in-Middle bicyclique ($2^{126}$). **Sécurité** : hypothèse clé entropie max. Attaques pratiques = passwords faibles, pas faille AES.
:::

---

### 8. Techniques de Cryptanalyse des Block Ciphers

#### 8.1 Cryptanalyse Différentielle

**Principe** : attaque **chosen plaintext** analysant la **propagation des différences** entre deux plaintexts à travers les rounds.

**Méthode** :

1. Choisir deux plaintexts avec différence connue : $x_a$ et $x_b$
2. Observer la propagation : $\Delta x = x_a \oplus x_b$
3. Analyser les ciphertexts : $\Delta y = y_a \oplus y_b$
4. **Attribuer des probabilités aux clés** selon les changements observés
5. **Clé la plus probable** = clé correcte (après nombreux essais)

**Caractéristiques** :

- Nécessite **$2^{47}$ couples chosen plaintext** pour DES
- **Probabilités** : dépendent des S-boxes et de la structure
- Plus le nombre de couples augmente, plus la probabilité de succès augmente

**Sensibilité** : très sensible au **nombre de rounds**

- Chances de réussite augmentent **exponentiellement** quand rounds diminuent

#### 8.2 Cryptanalyse Linéaire

**Principe** : attaque **known plaintext** créant un **simulateur linéaire** du block cipher.

**Méthode** :

1. Créer des **approximations linéaires** de l'algorithme
2. Analyser un grand nombre de paires plaintext/ciphertext
3. Les bits de la clé du simulateur **tendent à coïncider** avec ceux de la clé réelle (calcul probabiliste)

**Complexité pour DES** :

- **$2^{38}$ known plaintexts** → probabilité 10% de deviner juste
- **$2^{43}$ known plaintexts** → probabilité 85% de succès

**Caractéristiques** :

- **Attaque analytique la plus puissante** à ce jour sur block ciphers
- Aussi **sensible au nombre de rounds**

#### 8.3 Comparaison Différentielle vs Linéaire

**Difficultés communes** :

- ✗ **Parallélisation** : moins efficace que brute force parallèle
- ⚠️ **Sensibilité aux rounds** : efficacité diminue exponentiellement avec le nombre de rounds

**DES et ces attaques** :

- Conjecture répandue : concepteurs de DES **connaissaient ces attaques** (années 1970, inédites à l'époque)
- **Design des S-boxes** : résistance très grande aux deux techniques

#### 8.4 Attaque Meet-in-the-Middle

**Principe** : exploite les constructions **composées** du type $y = E_{K_2}(E_{K_1}(x))$.

**Méthode** :

1. Construire liste $L_1$ : $L_1 = \{E_{K_1}(x) \mid K_1 \in \text{KeySpace}\}$
2. Construire liste $L_2$ : $L_2 = \{D_{K_2}(y) \mid K_2 \in \text{KeySpace}\}$
3. Identifier **éléments répétés** dans $L_1$ et $L_2$
4. Vérifier hypothèse avec **deuxième known plaintext**
5. Les clés $K_1$ et $K_2$ associées sont probablement les clés recherchées

**Exemple pour DES** :

Espace de clés intuitif pour $E_{K_2}(E_{K_1}(x))$ : $\{0,1\}^{112}$

**Effort réel** :

- **$2^{57}$ opérations** pour établir les deux listes
- **$2^{56}$ blocs** de 64 bits de stockage
- **Nettement inférieur** au $2^{112}$ estimé intuitivement

**Applications** :

- Attaques sur **constructions composées**
- Cryptanalyse **interne** des block ciphers

```{mermaid}
graph TB
    subgraph Meet_in_Middle
        X[Known Plaintext x] --> E1[Encrypt K1]
        E1 --> M[Middle Value m]
        M --> E2[Encrypt K2]
        E2 --> Y[Known Ciphertext y]
        
        X2[x] --> L1[List L1: EK1 pour tous K1]
        Y2[y] --> L2[List L2: DK2 pour tous K2]
        
        L1 -.match.-> Match[Trouver m commun]
        L2 -.match.-> Match
    end
    
    style M fill:#ffffcc
    style Match fill:#ccffcc
```

::: {.callout-note collapse=true}
### 📄 Texte original (Cryptanalyse)

#### Techniques de Cryptanalyse sur les Block Ciphers

**Cryptanalyse Différentielle**

- Il s'agit d'une **attaque chosen plaintext** qui s'intéresse à la **propagation des différences** dans deux plaintexts au fur et à mesure qu'ils évoluent dans les différentes étapes de l'algorithme.

- Il **attribue des probabilités aux clés** qu'il "devine" en fonction des **changements** qu'elles induisent sur les ciphertexts. La **clé la plus probable** a des bonnes chances d'être la clé correcte après un **grand nombre** de couples plaintext/ciphertext.

- Nécessite **$2^{47}$ couples chosen plaintext** (pour DES) pour obtenir des résultats corrects.

**Cryptanalyse Linéaire**

- Il s'agit d'une **attaque known plaintext** qui crée un **simulateur du bloc** à partir des **approximations linéaires**. En analysant un **grand nombre** de paires plaintext/ciphertexts, les **bits de la clé du simulateur** ont tendance à **coïncider** avec ceux du block cipher analysés (**calcul probabiliste**)

- Pour DES une attaque basée sur cette technique nécessite **$2^{38}$ known plaintexts** pour obtenir une probabilité de **10%** de deviner juste et **$2^{43}$ pour un 85%** !

- Il s'agit de l'**attaque analytique la plus puissante** à ce jour sur les block ciphers.

#### Techniques de Cryptanalyse sur les Block Ciphers (II)

- La mise en pratique des **attaques différentielles et linéaires** présente des **difficultés dans la parallélisation** des calculs par rapport à une recherche exhaustive de la clé.

- Ces deux attaques sont **très sensibles au nombre d'étapes** du block cipher: les chances de réussite augmentent **exponentiellement** au fur et à mesure que le nombre d'étapes de l'algorithme diminue.

- Une conjecture très répandue parmi les cryptographes est que ces attaques, à l'époque **inédites**, étaient **connues par les concepteurs des DES**. En particulier, le **design des S-boxes** offre une **résistance très grande** aux deux techniques.

**Attaque Meet-in-the-Middle**

- S'applique aux constructions du type $y := E_{K_2}(E_{K_1}(x))$. Pour DES, l'espace de clés pour cette solution serait de $\{0,1\}^{112}$. On construit d'abord **deux listes** $L_1$ et $L_2$ de $2^{56}$ messages de la forme: $L_1 = E_{K_1}(x)$ et $L_2 = D_{K_2}(y)$ avec $E$ et $D$ les opérations d'encryption et decryption respectivement. Il faut alors **identifier des éléments qui se répètent** dans les deux listes et **vérifier notre hypothèse** avec un deuxième known plaintext. Les $K_1$ et $K_2$ associées à cette paire de known plaintexts seront (en toute vraisemblance) **les clés recherchées** !

- **Effort nécessaire** à réaliser les attaques (pour DES): **$2^{57}$ opérations** pour établir les deux listes + **$2^{56}$ blocs** de 64 bits de stockage pour mémoriser les résultats intermédiaires... **nettement inférieur** au $2^{112}$ estimé intuitivement...

- Ces techniques meet-in-the-middle sont aussi appliquées à la **cryptanalyse interne** des block ciphers.
:::

::: {.callout-tip collapse=true}
### 📌 Révision rapide (Cryptanalyse)

**Différentielle** : chosen plaintext, propagation différences, probabilités sur clés, $2^{47}$ couples (DES).

**Linéaire** : known plaintext, approximations linéaires, $2^{38}$-$2^{43}$ plaintexts (DES), attaque la plus puissante.

**Meet-in-Middle** : constructions composées, 2 listes $2^{56}$, effort $2^{57}$ << $2^{112}$.

**Sensibilité** : très dépendantes du nombre de rounds.
:::

# Cryptographie Asymétrique (à Clés Publiques)

## Fondements Mathématiques

### Théorème Fondamental de l'Arithmétique et Fonction Phi d'Euler

La cryptographie asymétrique repose sur des fondements mathématiques solides issus de la théorie des nombres. Deux concepts sont essentiels :

**Théorème Fondamental de l'Arithmétique** : Tout nombre entier strictement positif $n$ s'écrit de façon unique (à l'ordre près) comme produit de puissances de nombres premiers :

$$n = p_1^{e_1} \cdot p_2^{e_2} \cdot p_3^{e_3} \cdots p_m^{e_m}$$

**Fonction Phi d'Euler $\phi(n)$** : Nombre d'entiers positifs plus petits que $n$ qui sont premiers avec $n$.

Pour calculer $\phi(n)$ :

$$\phi(n) = \prod_{i=1}^{m} p_i^{e_i} \cdot \left(1 - \frac{1}{p_i}\right)$$

**Cas particulier important** : Si $n = p \cdot q$ avec $p$ et $q$ premiers, alors :

$$\phi(n) = (p-1)(q-1)$$

::: {.callout-note collapse=true title="Texte Original"}
### Fondements Mathématiques

**Théorème Fondamental de l'Arithmétique** : Tout nombre entier strictement positif $n$ s'écrit de façon unique (à l'ordre près) comme un produit de puissances de nombres premiers $p_i$ distincts :

$$n = p_1^{e_1} \cdot p_2^{e_2} \cdot p_3^{e_3} \cdots p_m^{e_m}$$

**Fonction Phi d'Euler** : Soit $n \in \mathbb{Z}^+$, la **fonction phi d'Euler** $\phi(n)$ est égale au nombre d'entiers positifs plus petits que $n$ qui sont **relativement premiers** à $n$.

**Calcul de la fonction phi d'Euler** : D'après le théorème fondamental de l'arithmétique, tout nombre entier $n > 1$ s'écrit :

$$n = \prod_{i=1}^{m} p_i^{e_i}$$

alors $\phi(n)$ se calcule :

$$\phi(n) = \prod_{i=1}^{m} \left(p_i^{e_i} - p_i^{e_i-1}\right)$$

En particulier, si $n = p \cdot q$ avec $p$ et $q$ premiers, alors :

$$\phi(n) = (p-1)(q-1)$$
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Décomposition unique** : tout entier = produit de nombres premiers
- **$\phi(n)$** : compte les entiers $< n$ premiers avec $n$
- **Clé pour RSA** : si $n = pq$ (premiers) alors $\phi(n) = (p-1)(q-1)$
:::

---

### Théorèmes d'Euler et de Fermat

Ces théorèmes sont au cœur du fonctionnement de RSA et d'autres algorithmes asymétriques.

**Théorème d'Euler** : Si $n \in \mathbb{Z}^+$ et $a \in \mathbb{Z}$ avec $\text{pgcd}(a,n) = 1$, alors :

$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**Petit Théorème de Fermat** (cas particulier si $n = p$ premier) : Si $a \in \mathbb{Z}$ et $p$ premier ne divise pas $a$ :

$$a^{p-1} \equiv 1 \pmod{p}$$

**Applications importantes** :

1. **Réduction des exposants** : Si $n$ est produit de premiers distincts et $r \equiv s \pmod{\phi(n)}$, alors :
   $$a^r \equiv a^s \pmod{n}$$

2. **Calcul des inverses** : $a^{\phi(n)-1}$ est l'inverse de $a$ modulo $n$. En particulier, si $p$ est premier, $a^{p-2}$ est l'inverse de $a$ modulo $p$.

::: {.callout-note collapse=true title="Texte Original"}
### Fondements Mathématiques (II)

**Théorème d'Euler** : Soient $n \in \mathbb{Z}^+$ et $a \in \mathbb{Z}$ avec $\text{pgcd}(a,n) = 1$, alors on a :

$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**Petit Théorème de Fermat** (cas particulier du théorème d'Euler si $n$ est premier) : Soient $a \in \mathbb{Z}$ et $p$ un nombre premier tel que $p$ ne divise pas $a$, alors on a :

$$a^{p-1} \equiv 1 \pmod{p}$$

À noter que puisque $p$ est premier, on a $\phi(p) = p-1$.

**Réduction des exposants** $\bmod \phi(n)$ : Si $n$ est le produit de premiers distincts et $r, s \in \mathbb{Z}$ t.q. $r \equiv s \pmod{\phi(n)}$ alors $\forall a \in \mathbb{Z}$ :

$$a^r \equiv a^s \pmod{n}$$

**Application du Théorème d'Euler au calcul des inverses** : Suite au théorème d'Euler, on a que :

$$a \cdot a^{\phi(n)-1} \equiv 1 \pmod{n}$$

ce qui signifie que $a^{\phi(n)-1}$ est l'**inverse de $a$ modulo $n$**. En particulier, $a^{p-2}$ est l'inverse de $a$ modulo $n$ si $p$ est premier.
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Théorème d'Euler** : $a^{\phi(n)} \equiv 1 \pmod{n}$
- **Fermat** : cas spécial si $p$ premier : $a^{p-1} \equiv 1 \pmod{p}$
- **Inverse modulaire** : $a^{-1} \equiv a^{\phi(n)-1} \pmod{n}$
- **Base de RSA** : permet encryption/decryption avec exposants
:::

---

### Groupes Multiplicatifs et Générateurs

**Groupe multiplicatif $\mathbb{Z}_n^*$** : Ensemble des éléments de $\mathbb{Z}_n$ premiers avec $n$ :

$$\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n \mid \text{pgcd}(a,n) = 1\}$$

Si $n$ est premier : $\mathbb{Z}_n^* = \{1, 2, \ldots, n-1\}$

**Ordre d'un élément** : Plus petit entier positif $t$ tel que $a^t \equiv 1 \pmod{n}$

**Générateur** : Un élément $\alpha$ est un générateur de $\mathbb{Z}_n^*$ si son ordre est $\phi(n)$. On dit alors que $\mathbb{Z}_n^*$ est **cyclique**.

**Propriétés des générateurs** :

1. $\mathbb{Z}_n^*$ a un générateur ssi $n = 2, 4, p^k$ ou $2p^k$ (avec $p$ premier, $p \neq 2$ et $k \geq 1$)
2. Si $p$ est premier, $\mathbb{Z}_p^*$ a toujours un générateur
3. Si $\alpha$ est générateur, tous les éléments s'écrivent : $\mathbb{Z}_n^* = \{\alpha^i \bmod n \mid 0 \leq i < \phi(n)\}$
4. Le nombre de générateurs est $\phi(\phi(n))$

**Test de générateur**

- $\alpha$ est un générateur de $\mathbb{Z}_n^*$ ssi $\forall$ premier $p$ divisant $\phi(n)$, $\alpha^{\phi(n)/p} \not\equiv 1 \pmod{n}$
- si $n = 2p+1$ est un "safe prime" avec $p$ premier : $\alpha$ est générateur ssi $\alpha^2 \not\equiv 1 \pmod{n}$ et $\alpha^p \not\equiv 1 \pmod{n}$

::: {.callout-note collapse=true title="Texte Original"}
### Fondements Mathématiques (III)

**Définition** : Le **groupe multiplicatif de $\mathbb{Z}_n$**, noté $\mathbb{Z}_n^*$ est :

$$\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n \mid \text{pgcd}(a,n) = 1\}$$

En particulier, si $n$ est premier : $\mathbb{Z}_n^* = \{a \mid 1 \leq a \leq n-1\}$

Le **nombre d'éléments ou ordre** du groupe multiplicatif $\mathbb{Z}_n^*$ est $\phi(n)$ (par définition de $\phi$).

**Définition** : Soit $a \in \mathbb{Z}_n$, l'**ordre de $a$** est le plus petit entier positif $t$ pour lequel :

$$a^t \equiv 1 \pmod{n}$$

**Définition** : Soit $\alpha \in \mathbb{Z}_n^*$, si l'ordre de $\alpha$ est $\phi(n)$, alors $\alpha$ est un **générateur de $\mathbb{Z}_n^*$**. Lorsqu'un groupe $\mathbb{Z}_n^*$ a un générateur, on dit qu'il est **cyclique**.

**Propriétés des générateurs** :

- $\mathbb{Z}_n^*$ a un générateur ssi $n = 2, 4, p^k$ ou $2p^k$, avec $p$ premier, $p \neq 2$ et $k \geq 1$. En particulier, si $p$ est premier, $\mathbb{Z}_p^*$ a un générateur.

- Si $\alpha$ est un générateur de $\mathbb{Z}_n^*$, alors tous les éléments de $\mathbb{Z}_n^*$ s'écrivent :
  $$\mathbb{Z}_n^* = \{\alpha^i \bmod n \mid 0 \leq i \leq \phi(n)-1\}$$

- Le nombre de générateurs de $\mathbb{Z}_n^*$ est $\phi(\phi(n))$.

- $\alpha$ est un générateur de $\mathbb{Z}_n^*$ ssi pour tout premier $p$ divisant $\phi(n)$, on a :
  $$\alpha^{\phi(n)/p} \not\equiv 1 \pmod{n}$$

En particulier si $n$ est un premier de la forme $n = 2p+1$ avec $p$ premier (un tel $n$ est appelé un **safe prime**), $\alpha$ est générateur de $\mathbb{Z}_n^*$ ssi $\alpha^2 \not\equiv 1 \pmod{n}$ et $\alpha^p \not\equiv 1 \pmod{n}$.
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **$\mathbb{Z}_n^*$** : éléments premiers avec $n$, cardinal = $\phi(n)$
- **Générateur** : élément d'ordre $\phi(n)$ (génère tout le groupe)
- **Crucial pour DH et ElGamal** : sécurité basée sur logarithme discret dans groupe cyclique
- **Safe prime** : $n = 2p+1$ avec $p$ et $n$ premiers
:::

---

### Fast Exponentiation (Exponentiation Rapide)

Calcul efficace de $a^k \bmod n$ en temps polynomial, essentiel pour tous les algorithmes asymétriques.

**Principe** : Utiliser la représentation binaire de l'exposant $k$.

**Exemple** : Calcul de $2^{644} \bmod 645$

1. Représentation binaire : $(644)_{10} = (1010000100)_2$

2. Calculer les puissances de 2 successives modulo 645 :
   - $2^1 \bmod 645$
   - $2^2 \bmod 645$
   - $2^4 \bmod 645$
   - $2^8 \bmod 645$
   - ...
   - $2^{512} \bmod 645$

3. Combiner selon les bits à 1 : $2^{644} = 2^{512} \cdot 2^{128} \cdot 2^4$

**Complexité** : $O(\log^3 n)$ - très efficace !

**Application** : Calcul de l'inverse avec le théorème d'Euler en temps polynomial.

Alternative : **Algorithme d'Euclide étendu** pour trouver $x$ tel que $ax \equiv 1 \pmod{n}$ en résolvant $ax - kn = 1 = \text{pgcd}(a,n)$. Complexité également $O(\log^3 n)$.

::: {.callout-note collapse=true title="Texte Original"}
### Fast Exponentiation

**Fast exponentiation** : En utilisant la représentation binaire d'un nombre, on peut calculer des puissances très efficacement.

**Exemple** : calcul de $2^{644} \bmod 645$

$(644)_{10} = (1010000100)_2$

Maintenant, on calcule les exposants correspondants aux puissances de 2, soient :

$$2^1 \bmod 645, \quad 2^2 \bmod 645, \quad 2^4 \bmod 645, \quad \ldots, \quad 2^{512} \bmod 645$$

D'après la représentation binaire, on calcule :

$$2^{644} = 2^{512+128+4} = 2^{512} \cdot 2^{128} \cdot 2^4 = 160 \cdot 153 \cdot 6 \bmod 645$$

**La complexité de cet algorithme** fast exponentiation est $O(\log^3 n)$.

En s'appuyant sur le **théorème d'Euler**, le calcul de l'**inverse d'un nombre** dans un tel groupe est donc effectué en temps polynomial.

**L'algorithme d'Euclide étendu** peut être également utilisé pour trouver un $x$ tel que :

$$ax \equiv 1 \pmod{n}$$

puisque cette congruence s'écrit : $ax - 1 = kn$ et donc :

$$ax - kn = 1 = \text{pgcd}(a,n)$$

La complexité de cet algorithme est également $O(\log^3 n)$.
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Idée** : représentation binaire de l'exposant
- **Complexité** : $O(\log^3 n)$ - polynomial !
- **Essentiel** : rend RSA, ElGamal, DH praticables
- **Alternative** : algorithme d'Euclide étendu pour inverses
:::

---

### Théorème des Restes Chinois (CRT)

Le CRT permet de résoudre des systèmes de congruences simultanées, avec des applications importantes en cryptographie.

**Théorème** : Soient $n_1, n_2, \ldots, n_t \in \mathbb{Z}^+$ premiers deux à deux (pgcd$(n_i, n_j) = 1$ si $i \neq j$) et $a_1, a_2, \ldots, a_t \in \mathbb{Z}$. Alors le système :

$$\begin{cases}
x \equiv a_1 \pmod{n_1} \\
x \equiv a_2 \pmod{n_2} \\
\vdots \\
x \equiv a_t \pmod{n_t}
\end{cases}$$

a une solution unique $x \bmod N$ avec $N := n_1 \cdot n_2 \cdots n_t$.

**Algorithme de Gauss** (1801) pour calculer $x$ :

$$x = \sum_{i=1}^{t} a_i N_i M_i \bmod N$$

avec :

- $N_i = N/n_i$
- $M_i = N_i^{-1} \bmod n_i$ (inverse modulaire)

**Complexité** : $O(\log^3 n)$ - polynomial !

**Applications cryptographiques** :

1. Accélération des calculs RSA (utiliser $p$ et $q$ séparément)
2. Partage de secret (secret sharing schemes)
3. Certaines attaques sur RSA (si exposant petit et messages multiples)

::: {.callout-note collapse=true title="Texte Original"}
### Théorème des Restes Chinois

Le **Théorème des Restes Chinois** (IIIe siècle!) permet de résoudre des systèmes linéaires de congruences simultanées. Il résout des problèmes soulevés dans des anciens puzzles chinois. Il s'agissait, par exemple, de trouver un nombre qui produit un reste de 1 lorsqu'il est divisé par 3, de 2 lorsqu'il est divisé par 5 et de 3 lorsqu'il est divisé par 7... Il fut également utilisé pour calculer le moment exact d'alignement de plusieurs astres ayant des orbites (et donc des périodes) différentes.

**Théorème des Restes Chinois** : Soient $n_1, n_2, \ldots, n_t \in \mathbb{Z}^+$ premiers deux à deux (c.à.d. pgcd$(n_i, n_j) = 1$, $\forall i \neq j$) et $a_1, a_2, \ldots, a_t \in \mathbb{Z}$. Alors, le système de congruences :

$$\begin{cases}
x \equiv a_1 \pmod{n_1} \\
x \equiv a_2 \pmod{n_2} \\
\vdots \\
x \equiv a_t \pmod{n_t}
\end{cases}$$

a une solution unique $x \bmod N := n_1 n_2 \cdots n_t$

**Algorithme de Gauss** (1801) pour le calcul de $x$ :

$$x = \sum_{i=1}^{t} a_i N_i M_i \bmod N$$

avec $N_i = N/n_i$ et $M_i = N_i^{-1} \bmod n_i$.

La **complexité** de cet algorithme est $O(\log^3 n)$.

Il est donc possible en **temps polynomial** de passer des congruences mod $n_i$ aux congruences mod $N$ !
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Résout** : systèmes de congruences avec moduli premiers entre eux
- **Solution unique** : modulo produit des moduli
- **Complexité** : $O(\log^3 n)$ (polynomial)
- **Usage crypto** : optimisation RSA, attaques si petit exposant
:::

---

## Problèmes de Base et Complexité

### Classification des Problèmes Difficiles

La sécurité de la cryptographie asymétrique repose sur des problèmes mathématiques réputés difficiles :

**Problèmes génériques** :

1. **Factorisation (FACTP)** : Étant donné $n$, trouver sa factorisation en nombres premiers
   - Base de **RSA** et **Rabin**

2. **Logarithmes discrets (DLP)** : Étant donné $p$ premier, un générateur $\alpha \in \mathbb{Z}_p^*$ et $\beta \in \mathbb{Z}_p^*$, trouver $x$ tel que :
   $$\alpha^x \equiv \beta \pmod{p}$$
   - Base de **ElGamal** et **Diffie-Hellman**

3. **Racine carrée modulo composite (SQROOTP)** : Étant donné $n$ composite et un résidu quadratique $a$, trouver $\sqrt{a} \bmod n$
   - Base de **Rabin**

**Problèmes spécifiques** :

1. **RSA Problem (RSAP)** : Étant donné $n = pq$, $e$ avec pgcd$(e, \phi(n)) = 1$ et $c$, trouver $m$ tel que $m^e \equiv c \pmod{n}$

2. **Diffie-Hellman Problem (DHP)** : Étant donné $p$ premier, $\alpha$ générateur, $\alpha^a \bmod p$ et $\alpha^b \bmod p$, trouver $\alpha^{ab} \bmod p$

**Équivalences prouvées** :

- **DHP ⟺ DLP** (équivalent sous certaines conditions)
- **RSAP ⟺ FACTP** (prouvé équivalent pour le cas générique)
- **SQROOTP ⟺ FACTP**

::: {.callout-note collapse=true title="Texte Original"}
### Problèmes de Base

**Problèmes génériques principaux** :

- **Factorisation (FACTP)** : Étant donné un entier positif $n$, trouver sa factorisation en nombres premiers.

- **Logarithmes discrets (DLP)** : Étant donné un nombre premier $p$, un générateur $\alpha \in \mathbb{Z}_p^*$ et un élément $\beta \in \mathbb{Z}_p^*$, trouver l'entier $x$, $0 \leq x \leq p-2$, tel que : $\alpha^x \equiv \beta \pmod{p}$.

- **Racine carrée dans $\mathbb{Z}_n$ si $n$ est composite (SQROOTP)** : Étant donné un entier composite $n$ et un résidu quadratique $a$, trouver la racine carrée de $a$ mod $n$.

**Problèmes spécifiques** (propres à un système de cryptage) :

- **RSA (RSAP)** : Étant donné un entier positif $n = pq$, un entier positif $e$ avec gcd$(e, (p-1)(q-1)) = 1$ et un entier $c$, trouver un entier $m$ avec $m^e \equiv c \pmod{n}$.

- **Diffie-Hellman (DHP)** : Étant donné un nombre premier $p$, un générateur $\alpha \in \mathbb{Z}_p^*$ et les éléments $\alpha^a \bmod p$ et $\alpha^b \bmod p$, trouver $\alpha^{ab} \bmod p$.

**Résultats prouvés** :

- **DHP ⟺ DLP** (Équivalent sous certaines conditions)
- **RSAP ⟺ FACTP** (Prouvé équivalent pour le problème générique)
- **SQROOTP ⟺ FACTP**
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **FACTP** : factoriser $n$ → base de RSA/Rabin
- **DLP** : trouver logarithme discret → base ElGamal/DH
- **SQROOTP** : racine carrée mod composite → Rabin
- **Équivalences** : cassage = résolution du problème de base
:::

---

### Techniques de Factorisation

La sécurité de RSA dépend de la difficulté de factoriser de grands nombres.

**Méthodes à temps exponentiel** : $O(\exp(c \cdot \ln(n)))$

- Trial Division (division successive)
- Crible d'Ératosthène (IIe siècle av. J.-C.)
- Méthode de Fermat (~1650)
- Méthode $\rho$ de Pollard (1975)
- Méthode $p-1$ de Pollard (1974)

**Méthodes à temps sous-exponentiel** : $O(\exp(c \cdot (\ln(n))^{1/3}))$

- Continued Fractions (1975)
- **Quadratic Sieve (1981)** - très efficace en pratique
- **Number Field Sieve - NFS (1990)** - le plus rapide actuellement
- General Number Field Sieve - GNFS (2006)

**Méthodes à temps polynomial** :

- **Algorithme de Shor** (1994) : $O(\log^c n)$ sur **ordinateur quantique**

**Records actuels (2020)** :

- Plus grand nombre factorisé : **RSA-829** (250 chiffres, 829 bits)
- Temps de calcul : 2700 années-cœur (CPUs Intel Xeon Gold 6130)
- Méthode : General Number Field Sieve

**Implications** :

- Clés RSA < 1024 bits : **vulnérables**
- Clés RSA 1024 bits : **limites** (états avec ressources importantes)
- Recommandation : **2048 bits minimum** (3072-4096 pour long terme)

::: {.callout-note collapse=true title="Texte Original"}
### Classical Factoring Techniques et New Developments

**Temps exponentiel** : $O(\exp(c \cdot \ln(n)))$

- Trial Division
- Eratosthenes' Sieve (II B.C.)
- Fermat's Difference of Squares Method (~1650)
- Square Form Factorization (1971)
- Pollard's p-1 method (1974)
- Pollard's Rho Method (1975)

**Temps sous-exponentiel** : $O(\exp(c \cdot (\ln(n))^{1/3}))$

- Continued Fractions (1975)
- **Quadratic Sieve (1981)**
- **Number Field Sieve - NFS (1990)**
- **General Number Field Sieve - GNFS (2006)**

**Temps polynomial** :

- **Shor's Algorithm in a Quantum Computer (1994)** : $O(\log^c n)$

**Développements récents** :

- L'ordinateur NFS spécifique de Bernstein pour factoriser un nombre de 1536 bits prendrait le même temps qu'un calcul 512 bits sur machine conventionnelle
- **Plus grande factorisation à ce jour (2020)** : RSA-829 (nombre de 250 chiffres) utilisant NFS
- Temps de calcul total : **2700 années-cœur** (CPUs Intel Xeon Gold 6130 à 2.1GHz)

**Factorisation sur ordinateur quantique** :

- Problèmes significatifs (erreurs, dispersion, etc.)
- 2001 : ordinateur 7 qubits (IBM Almaden)
- Faisabilité d'un ordinateur avec millions de qubits... ?
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Sous-exponentiel** : NFS actuellement le plus rapide
- **Record 2020** : RSA-829 (829 bits) en 2700 années-cœur
- **Recommandation** : clés ≥ 2048 bits pour RSA
- **Menace future** : ordinateurs quantiques (Shor)
:::

---

## L'Algorithme RSA

### Fonctionnement de RSA (Encryption/Decryption)

RSA (Rivest-Shamir-Adleman, 1978) est l'algorithme asymétrique le plus utilisé.

**Génération des clés** :

1. Choisir deux nombres premiers **grands** $p$ et $q$ (≥ 1024 bits chacun)
2. Calculer $n := p \cdot q$ et $\phi(n) = (p-1)(q-1)$
3. Choisir exposant d'encryption $e$ avec :
   - $1 < e < \phi(n)$
   - pgcd$(e, \phi(n)) = 1$
4. Calculer exposant de décryption $d$ tel que :
   $$e \cdot d \equiv 1 \pmod{\phi(n)}$$
   (avec algorithme d'Euclide étendu ou fast exponentiation)

**Clés résultantes** :

- Clé **publique** : $(n, e)$
- Clé **privée** : $d$ (garder $p$ et $q$ secrets aussi !)

**Encryption** (par Bob, vers Alice) :

1. Obtenir clé publique authentique $(n, e)$ d'Alice
2. Transformer plaintext en entiers $m_i \in [0, n-1]$
3. Calculer ciphertexts : $c_i := m_i^e \bmod n$
4. Envoyer les $c_i$ à Alice

**Decryption** (par Alice) :

- Utiliser clé privée $d$ pour calculer :
   $$m_i = c_i^d \bmod n$$

**Preuve de fonctionnement** :

$$c^d \equiv (m^e)^d \equiv m^{ed} \pmod{n}$$

Comme $ed \equiv 1 \pmod{\phi(n)}$, il existe $k$ tel que $ed = 1 + k\phi(n)$, donc :

$$c^d \equiv m^{1+k\phi(n)} \equiv m \cdot (m^{\phi(n)})^k \equiv m \cdot 1^k \equiv m \pmod{n}$$

(par le théorème d'Euler)

::: {.callout-note collapse=true title="Texte Original"}
### Procédé d'Encryption/Decryption de RSA et Preuve

**Génération des clés** :

- Chaque entité (A) crée une paire de clés (publique et privée) comme suit :
  - A choisit la taille du modulus $n$ (p.ex. taille$(n) = 1024$ ou taille$(n) = 2048$).
  - A génère deux nombres premiers $p$ et $q$ de grande taille $(n/2)$.
  - A calcule $n := pq$ et $\phi(n) = (p-1)(q-1)$.
  - A génère l'exposant d'encryption $e$, avec $1 < e < \phi(n)$ t.q. pgcd$(e, \phi(n)) = 1$.
  - A calcule l'exposant de decryption $d$, t.q. : $ed \equiv 1 \pmod{\phi(n)}$ avec l'algorithme d'Euclide étendu ou avec l'algorithme fast exponentiation.
- Le couple $(n,e)$ est la clé **publique** de A ; $d$ est la clé **privée** de A.

**Encryption** :

- L'entité B obtient $(n,e)$, la clé publique **authentique** de A.
- B transforme son plaintext en une série d'entiers $m_i$, t.q. $m_i \in [0, n-1]$ $\forall i$.
- B calcule le ciphertext $c_i := m_i^e \bmod n$, $\forall i$ avec l'algorithme fast exponentiation.
- B envoie à A tous les ciphertext $c_i$.

**Decryption** :

- A utilise sa clé privée pour calculer les plaintexts $m_i = c_i^d \bmod n$.

**Preuve** : Soit $m$ le plaintext et $c$ le ciphertext avec $c := m^e \bmod n$, il s'agit de prouver : $m \stackrel{!}{=} c^d \bmod n$

En substituant $c$ par sa valeur on obtient :
$$c^d \bmod n = m^{ed} \bmod n \quad (*)$$

mais, on sait que :
$$ed \equiv 1 \pmod{\phi(n)}$$

et donc par définition des congruences, il existe un entier $k$ avec :
$$ed - 1 = k\phi(n)$$

en substituant dans (*) :
$$c^d \equiv m^{k\phi(n)+1} \equiv m^{k\phi(n)} \cdot m \pmod{n}$$

Si pgcd$(m,n) = 1$, on a par le **théorème d'Euler** :
$$m^{\phi(n)} \equiv 1 \pmod{n}$$

donc :
$$c^d \equiv (m^{\phi(n)})^k \cdot m \equiv m \pmod{n}$$ c.q.f.d. !

Si pgcd$(m,n) \neq 1$, $m$ est nécessairement multiple de $p$ ou de $q$ (cas très peu probable...), on peut montrer en faisant les calculs mod $p$ et mod $q$ que la congruence reste vraie.
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Clé publique** : $(n, e)$ avec $n = pq$
- **Clé privée** : $d$ tel que $ed \equiv 1 \pmod{\phi(n)}$
- **Chiffrement** : $c = m^e \bmod n$
- **Déchiffrement** : $m = c^d \bmod n$
- **Sécurité** : basée sur difficulté de factoriser $n$
:::

```{mermaid}
graph LR
    A[Plaintext m] -->|Encryption: m^e mod n| B[Ciphertext c]
    B -->|Decryption: c^d mod n| C[Plaintext m]
    D[Clé publique: n, e] -.->|utilisée pour| A
    E[Clé privée: d] -.->|utilisée pour| B
    F[p, q premiers secrets] -->|n = pq| D
    F -->|φn = p-1q-1| E
```

---

### Sécurité de RSA

**Équivalence problème RSA ⟺ Factorisation** :

- Trouver $d$ ⟺ factoriser $n$ (prouvé équivalent)
- Décrypter sans $d$ n'est **pas prouvé** aussi difficile que factoriser, mais...
- Aucune méthode plus rapide que factorisation n'est connue

**Complexité de la factorisation** :

- Méthodes les plus rapides : $O(\exp(c \cdot (\ln(n))^{1/3}))$ (sous-exponentiel)
- Calculatoirement impossible pour $n \geq 1024$ bits
- **Recommandation actuelle** : 2048 bits minimum (3072-4096 pour sécurité durable)

**Choix des exposants** :

- **Exposant d'encryption $e$** :

  - Souvent **petit** pour accélérer : $e = 3, 17, 65537$ (commun)
  - Attention : si $e$ trop petit ET $m < n^{1/e}$, attaque possible (racine $e$-ième dans $\mathbb{Z}$)
  - Solution : **randomization** (padding) du message

- **Exposant de décryption $d$** :

  - Doit être **grand** : au moins la moitié de la taille de $n$
  - Si $d$ petit : vulnérable à l'attaque de Wiener

**Conséquence performance** :

- **Encryption rapide** ($e$ petit)
- **Decryption lente** ($d$ grand)

::: {.callout-note collapse=true title="Texte Original"}
### RSA: Sécurité

Le problème **RSAP** consistant à trouver $m$ à partir de $c$ n'est pas prouvé comme étant aussi difficile que la factorisation mais... :

- On peut prouver que si on trouve $d$ on peut facilement calculer $p$ et $q$. Ceci équivaut à dire que **factoriser $n$ et trouver $d$ nécessitent un effort de calcul équivalent**.

- On sait que les méthodes les plus rapides pour factoriser ont une **complexité sub-exponentielle** $O(\exp(c \cdot (\ln(n))^{1/3}))$. Le problème reste donc **calculatoirement impossible** pour des modulus $\geq 1048$ bits (2048 bits est un choix fréquent pour une sécurité durable...).

- Afin d'améliorer la vitesse d'encryption, on a tendance à choisir des **exposants $e$ assez petits** (typiquement : $e := 3$, $e := 17$ et $e := 19$). On a cependant prouvé que le calcul d'une $i$-ème racine (avec $i$ petit) modulo un composite $n$ peut être nettement plus facile que la factorisation de $n$. Par contre, en 2008 on a prouvé que la résolution générique du problème RSA est équivalent à la factorisation.

- L'**exposant de decryption $d$ doit impérativement être de grande taille** (au moins la moitié de la taille de $n$) pour garantir la sécurité du système.

- Par conséquent, l'**encryption est normalement nettement plus rapide que la decryption** puisque les exposants utilisés sont beaucoup plus petits !
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Sécurité** : basée sur difficulté de FACTP (factorisation)
- **Taille recommandée** : $n \geq 2048$ bits
- **$e$ petit** : encryption rapide (3, 17, 65537)
- **$d$ grand** : au moins $\text{taille}(n)/2$
- **Clés séparées** : encryption ≠ signature
:::

---

### Attaques sur RSA

#### Attaque sur exposant petit avec même message

Si on envoie le même message $m$ à 3 destinataires avec $e = 3$ :

- $c_1 \equiv m^3 \pmod{n_1}$
- $c_2 \equiv m^3 \pmod{n_2}$
- $c_3 \equiv m^3 \pmod{n_3}$

Le **Théorème des Restes Chinois** donne une solution unique $x \bmod n_1n_2n_3$ telle que :
$$x \equiv c_1 \pmod{n_1}, \quad x \equiv c_2 \pmod{n_2}, \quad x \equiv c_3 \pmod{n_3}$$

Si $m^3 < n_1n_2n_3$ (souvent vrai), alors $x = m^3$ dans $\mathbb{Z}$ et on peut calculer $m$ en prenant simplement la racine cubique entière !

**Protection** : toujours randomizer le message avant encryption (padding OAEP)

#### Attaque si message petit

Si $m < n^{1/e}$, alors $m^e < n$, donc $c = m^e$ (dans $\mathbb{Z}$, pas modulo). On peut calculer directement la racine $e$-ième !

**Protection** : padding obligatoire

#### Propriété multiplicative

$$E(m_1) \cdot E(m_2) \equiv (m_1 \cdot m_2)^e \equiv E(m_1 \cdot m_2) \pmod{n}$$

Permet des attaques de type chosen-ciphertext et blind signatures.

#### Attaque générale

La méthode la plus efficace reste la **factorisation de $n$** (si paramètres bien choisis et implémentation correcte).

::: {.callout-note collapse=true title="Texte Original"}
### RSA: Attaques

Lors qu'on souhaite encrypter le **même message pour un groupe de correspondants**, il convient d'introduire des variations (**randomization**) avant l'encryption pour éviter l'attaque suivante :

Admettons qu'on calcule des ciphertexts $c_1, c_2, c_3$ à partir du même plaintext $m$ et du même exposant $e := 3$ adressés à trois entités avec des modulus : $n_1, n_2, n_3$.

Le **Théorème des Restes Chinois** nous dit qu'il existe une solution $x \bmod n_1n_2n_3$, t.q. :
$$x \equiv c_1 \pmod{n_1}, \quad x \equiv c_2 \pmod{n_2}, \quad x \equiv c_3 \pmod{n_3}$$

Mais si $m$ ne change pas pour les trois encryptions, on a que $x = m^3 \bmod n_1n_2n_3$ et, de plus : $m^3 < n_1n_2n_3$. On peut, donc, trouver $m$ en calculant la **racine cubique entière** de $m^3$, en sachant que pour ce calcul il existe des algorithmes efficaces !

Plus généralement, si $m < n^{1/e}$, on peut appliquer des algorithmes rapides (dans $\mathbb{Z}$) pour calculer les racines $e$-ièmes de $m^e$. Il convient donc d'effectuer des opérations de **"randomization" de $m$ avant d'encrypter** !

**La propriété multiplicative de RSA** : $(m_1 m_2)^e \equiv m_1^e \cdot m_2^e \equiv c_1 \cdot c_2 \pmod{n}$

donne lieu à des **failles dangereuses** (voir signatures aveugles).

En admettant que les paramètres sont correctement choisis et que l'implantation n'a pas de failles, **la méthode la plus efficace pour "casser" l'algorithme générique RSA reste la factorisation de $n$**.
:::

::: {.callout-tip collapse=true title="Révision Rapide"}
- **Même message, petit $e$** : CRT permet d'extraire $m$ !
- **Message trop petit** : $m < n^{1/e}$ → racine directe
- **Propriété multiplicative** : $E(m_1) \cdot E(m_2) = E(m_1 m_2)$
- **Protection** : toujours padding/randomization (OAEP)
:::

---

## L'Algorithme ElGamal

Système asymétrique (1985) basé sur le **problème du logarithme discret (DLP)**.

**Clés :**

- Choisir premier $p$, générateur $\alpha \in \mathbb{Z}_p^*$, secret $a$
- Calculer $y = \alpha^a \bmod p$
- **Publique** : $(p, \alpha, y)$ | **Privée** : $a$

**Chiffrement :** Pour message $m$, choisir aléatoire $k$ unique

- $\gamma = \alpha^k \bmod p$
- $\delta = m \cdot y^k \bmod p$
- Envoyer $(\gamma, \delta)$

**Déchiffrement :** $m = \delta \cdot \gamma^{-a} \bmod p$

::: {.callout-note collapse="true" title="Texte original du cours"}
## Procédé d'Encryption/Decryption d'ElGamal

**Génération des clés**

Chaque entité (A) crée une paire de clés (publique et privée) comme suit:

- A génère un nombre premier $p$ (len($p$) ≥ 1024 bits) et un **générateur $\alpha$** du groupe multiplicatif $\mathbb{Z}_p^*$
- A génère un nombre aléatoire $a$, t.q. $1 \leq a \leq p-2$ et calcule $y := \alpha^a \bmod p$
- La **clé publique** de A est $(p, \alpha, y)$, la **clé privée** de A est $a$

**Encryption**

- L'entité B obtient $(p, \alpha, \alpha^a \bmod p)$, la clé publique authentique de A
- B transforme son plaintext en une série d'entiers $m_i$, t.q. $m_i \in [0, p-1]$ $\forall i$
- Pour chaque message $m_i$ :
  - B génère un nombre aléatoire **unique** $k$, t.q. $1 \leq k \leq p-2$
  - B calcule $\gamma := \alpha^k \bmod p$ et $\delta := m_i \cdot (\alpha^a)^k \bmod p$ et envoie le ciphertext $c := (\gamma, \delta)$

**Decryption**

- A utilise sa clé privée $a$ pour calculer $\gamma^{p-1-a} \bmod p$ (à noter que: $\gamma^{p-1-a} \equiv \gamma^{-a} \equiv \alpha^{-ak} \bmod p$)
- A retrouve le plaintext en calculant: $\delta \cdot \gamma^{-ak} \bmod p$
:::

::: {.callout-tip collapse="true"}
## Révision rapide

**Base** : DLP dans $\mathbb{Z}_p^*$

**Chiffré** : $(\alpha^k, m \cdot y^k)$

**Sécurité** : $k$ doit être unique et grand

**Inconvénient** : double la taille du message
:::

### Remarques essentielles

- **Preuve** : $\delta \cdot \gamma^{-a} = m \cdot (\alpha^a)^k \cdot (\alpha^k)^{-a} = m \bmod p$
- **Sécurité** : basée sur DLP (complexité sub-exponentielle proche de la factorisation)
- **Exposants** : $k$ et $a$ doivent être grands (sinon vulnérable à baby-step giant-step)
- **Réutilisation interdite** : si $k$ répété, $\delta_1/\delta_2 = m_1/m_2$ révèle les messages
- **Inconvénient majeur** : expansion ×2 de la taille du chiffré
- **Généralisation** : fonctionne sur $GF(2^n)$ ou courbes elliptiques

::: {.callout-note collapse="true"}
## Texte original - Remarques

**Preuve** que le schéma fonctionne : Si $s \equiv k^{-1}(m_h - ar) \bmod (p-1)$, on a que: $m_h \equiv (ar + ks) \bmod (p-1)$ et $v_2 = \alpha^{H(m)} \bmod p$. Si, comme on souhaite montrer $m_h = H(m)$, en réduisant les exposants mod $(p-1)$, on peut réécrire $v_2$: $v_2 \equiv \alpha^{ar+ks} \bmod p$. D'autre part: $v_1 = y^r\alpha^{rs} \equiv \alpha^{ar}\alpha^{ks} \equiv \alpha^{ar+ks} \bmod p$.

Le procédé d'ElGamal se base sur la difficulté de calculer des **logarithmes discrets modulo un nombre premier** (problème DLP) même s'il n'a pas été prouvé qu'il soit strictement équivalent à ce problème.

Les **algorithmes les plus efficaces** connus ont une complexité sub-exponentielle très proche de celle de la factorisation (on utilise souvent les mêmes algorithmes).

Les **exposants choisis** ($k$, $a$) doivent être de grande taille car il existe des algorithmes efficaces pour calculer des logarithmes discrets modulo un nombre premier lorsque l'exposant est petit (baby-step giant-step algorithm).

Un **inconvénient d'ElGamal** est qu'il multiplie par 2 la longueur du ciphertext.

Il est **essentiel** pour la sécurité du procédé que le nombre aléatoire $k$ ne soit pas répété, autrement: soient $(\gamma_1, \delta_1)$ et $(\gamma_2, \delta_2)$ les deux ciphertexts générés, on a que $\delta_1/\delta_2 = m_1/m_2$ et par conséquent, il est trivial de retrouver un plaintext à partir de l'autre.

Le procédé d'ElGamal peut se **généraliser** à d'autres groupes comme $GF(2^n)$ ou les courbes elliptiques.
:::

::: {.callout-tip collapse="true"}
## Révision rapide - Remarques

**Équivalence** : basé sur DLP (non prouvé équivalent)

**$k$ unique** : CRITIQUE - sinon $m_1/m_2$ révélé

**Taille clés** : exposants grands nécessaires

**Extensions** : $GF(2^n)$, courbes elliptiques
:::

---

## Algorithme de Rabin

Système asymétrique **équivalent à la factorisation** (provably secure).

**Clés :**

- Générer deux premiers $p$, $q$ (≥1024 bits total), calculer $n = pq$
  - **Publique** : $n$
  - **Privée** : $(p, q)$

**Chiffrement :** $c = m^2 \bmod n$

**Déchiffrement :** 

- Calculer les 4 racines carrées de $c \bmod n$ (via racines mod $p$ et mod $q$)
- Identifier le bon message par redondance

::: {.callout-note collapse="true" title="Texte original du cours"}
## Procédé d'Encryption/Decryption de Rabin

**Génération des clés**

Chaque entité (A) crée une paire de clés (publique et privée) comme suit:

- A génère deux nombres premiers aléatoires $p$ et $q$ de grande taille (len($pq$) ≥ 1024)
- A calcule $n := pq$
- La **clé publique** de A est $n$, la **clé privée** de A est $(p, q)$

**Encryption**

- L'entité B obtient $n$, la clé publique authentique de A
- B transforme son plaintext en une série d'entiers $m_i$, t.q. $m_i \in [0, n-1]$ $\forall i$
- B calcule $c_i = m_i^2 \bmod n$ pour chaque message $m_i$
- B envoie tous les ciphertext $c_i$ à A

**Decryption**

- A utilise sa clé privée $(p, q)$ pour retrouver les **4 solutions** de l'équation: $c_i = x^2 \bmod n$ en utilisant des **algorithmes efficaces** pour calculer des racines carrées $\bmod p$ et $\bmod q$
- A détermine soit par une **indication supplémentaire** de B, soit par une **analyse de redondance** lequel des 4 messages $m_1, m_2, m_3, m_4$ est le plaintext original
:::

::: {.callout-tip collapse="true"}
## Révision rapide

**Base** : SQROOTP (racine carrée mod composite)

**Avantage** : équivalent prouvé à factorisation

**Problème** : 4 solutions possibles, nécessite redondance

**Vulnérabilité** : attaque chosen-ciphertext révèle facteurs
:::

### Remarques essentielles

- **Sécurité prouvée** : SQROOTP ⟺ FACTP (seul algorithme avec équivalence prouvée)
- **Attaque chosen-ciphertext** : si A décrypte $c = m^2 \bmod n$ choisi par adversaire M
  - M reçoit une racine $m_x$ parmi 4 possibles
  - Si $m \neq m_x \bmod n$ (prob. 0.5), alors $\gcd(m - m_x, n)$ donne un facteur de $n$
- **Solution** : exiger redondance suffisante pour identifier solution unique sans ambiguïté

::: {.callout-note collapse="true"}
## Texte original - Remarques

Le procédé de Rabin est basé sur l'**impossibilité de trouver des racines carrées modulo un composite de factorisation inconnue** (problème SQROOTP).

L'**intérêt principal** de cet algorithme réside dans le fait qu'il a été **prouvé comme étant équivalent à la factorisation** (SQROOTP ⟺ FACTP). Cet algorithme appartient donc à la catégorie **provably secure** pour toute attaque passive.

Les **attaques actives** peuvent, dans certains cas, compromettre la sécurité de l'algorithme. Plus précisément, si on monte l'attaque **chosen ciphertext** suivant:

- L'attaquant M génère un $m$ et envoie à A le ciphertext $c = m^2 \bmod n$.
- A répond avec une racine $m_x$ parmi les 4 possibles $m_1, m_2, m_3, m_4$.
- Si $m \neq m_x \bmod n$ (probabilité 0.5), M recommence avec un nouveau $m$.
- Sinon, A calcule $\gcd(m - m_x, n)$ et obtient ainsi un des deux facteurs de $n$.

Cette attaque pourrait être **évitée** si le procédé exigeait une **redondance suffisante** dans les plaintexts permettant à A d'identifier sans ambiguïté laquelle des solutions possibles est le plaintext original. Dans ce cas, A répondrait toujours $m$ et jetterait les autres solutions n'ayant pas le niveau de redondance préétabli.
:::

::: {.callout-tip collapse="true"}
## Révision rapide - Remarques

**Unique** : seul algorithme prouvé équivalent à FACTP

**Attaque** : chosen-ciphertext donne facteurs (prob. 0.5)

**Parade** : redondance obligatoire dans messages
:::

---

## Comparaison RSA - ElGamal - Rabin

| Critère | RSA | ElGamal | Rabin |
|---------|-----|---------|-------|
| **Problème** | RSAP | DLP | SQROOTP |
| **Sécurité** | Équiv. factorisation (cas générique) | Basée sur DLP | **Prouvée** ⟺ factorisation |
| **Expansion** | 1:1 | **1:2** | 1:1 |
| **Déchiffrement** | Déterministe | Déterministe | **4 solutions** |
| **Signature** | Oui | Oui | Oui (avec précautions) |

---

## Courbes Elliptiques (Idée de base)

### Concept fondamental

Une **courbe elliptique** $E$ est définie par : $y^2 = x^3 + ax + b$ (avec discriminant $4a^3 + 27b^2 \neq 0$).

**Opération clé : Addition de points**

- Géométriquement : tracer une droite entre deux points $P$ et $Q$, trouver le 3ᵉ point d'intersection, puis prendre son symétrique
- Forme un **groupe commutatif** avec point à l'infini $\mathcal{O}$ comme identité
- **Multiplication scalaire** : $kP = P + P + ... + P$ ($k$ fois)

**Avantage cryptographique :**

- Le **problème ECDLP** : trouver $k$ tel que $Q = kP$ est très difficile (effort exponentiel)
- **Clés plus courtes** pour même sécurité qu'en $\mathbb{Z}_p^*$

::: {.callout-note collapse="true"}
## Texte original - Définition

Une **courbe elliptique** est un ensemble de points $E$ défini par l'équation: $y^2 = x^3 + ax + b$, avec $x, y, a$ et $b$ des nombres rationnels, entiers ou entiers modulo $m$ ($m > 1$). L'ensemble $E$ contient également un "point à l'infini" noté $\mathcal{O}$. Le point $\mathcal{O}$ n'est pas dans la courbe mais il est l'élément identité de $E$.

On choisira pour nos calculs les courbes elliptiques n'ayant pas de racines multiples ou, en d'autres termes, des courbes où le **discriminant** $4a^3 + 27b^2 \neq 0$.
:::

::: {.callout-tip collapse="true"}
## Révision rapide - Concept

**Équation** : $y^2 = x^3 + ax + b$

**Structure** : groupe avec $\mathcal{O}$

**Opération** : addition géométrique

**Problème dur** : ECDLP
:::

### Addition sur courbes elliptiques

Soit $P := (x, y) \in E$, on définit $-P := (x, -y)$ (symétrique par rapport à l'axe des $x$). On a $P + (-P) = \mathcal{O}$.

Pour deux points $P, Q \in E$ avec $Q \neq -P$, on définit $P + Q := R$ où $-R$ est le 3ᵉ point d'intersection entre la courbe et la droite passant par $P$ et $Q$.

Pour le **doublement** : $2P = R$ où $-R$ est le point d'intersection de la courbe avec la tangente à la courbe au point $P$.

::: {.callout-note collapse="true"}
## Texte original - Addition

Soit $P := (x, y) \in E$, on définit $-P$ comme $-P := (x, -y)$. Graphiquement, $-P$ est le point symétrique de $P$ par rapport à l'axe des $x$. À noter que $P + (-P) = \mathcal{O}$.

Soient deux points $P, Q \in E$, tels que $Q \neq -P$, on définit l'addition $P + Q := R$ où $R \in E$ tel que $-R$ est le 3ᵉ point d'intersection entre la courbe et la droite qui passe par $P$ et $Q$.

L'ensemble $E$ avec $\oplus$ définit un **groupe commutatif** pour l'addition.

Soit $P \in E$, le point $2P = R$, tel que $-R$ est le point d'intersection de la courbe avec la droite tangente à la courbe au point $P$.
:::

::: {.callout-tip collapse="true"}
## Révision rapide - Addition

**Inverse** : $-P = (x, -y)$

**Addition** : 3ᵉ point d'intersection + symétrie

**Doublement** : tangente + symétrie

**Propriété** : groupe commutatif
:::

### ECDLP et avantages cryptographiques

Lorsque la courbe elliptique est définie sur le corps $\mathbb{Z}_p$ avec $p$ premier de grande taille ($y^2 \equiv x^3 + ax + b \bmod p$), le calcul de $k \in \mathbb{Z}_p$ tel que $Q = kP$ avec $(P, Q)$ connus est **très difficile** (effort exponentiel). Ce problème est le **Elliptic Curve Discrete Logarithm Problem (ECDLP)**.

**Avantage principal** : taille des clés beaucoup plus petite pour une sécurité équivalente.

::: {.callout-note collapse="true"}
## Texte original - ECDLP et avantages

Lorsque la courbe elliptique est définie sur le corps $\mathbb{Z}_p$ avec $p$ un nombre premier de grande taille ($y^2 \equiv x^3 + ax + b \bmod p$), le calcul de $k \in \mathbb{Z}_p$ tel que $Q = kP$ avec $(P, Q)$ connus, est très difficile (nécessite un effort exponentiel). Ce problème est connu comme: **Elliptic Curve Discrete Logarithm Problem (ECDLP)**.

L'**avantage principal** de la cryptographie publique basée sur des courbes elliptiques est que la taille des nombres utilisés (et donc, des clés) est plus petite.

Ceci est dû à la **complexité accrue** des calculs sur $E_p$ (courbe elliptique définie sur le corps $\mathbb{Z}_p$) par rapport aux corps habituels tels que $\mathbb{Z}_p$ ou $GF(2^m)$.

La **représentation d'un plaintext en points** de la courbe reste une opération complexe.

En Octobre 2003, la **US National Security Agency (NSA)** a acheté un brevet de Certicom pour l'utilisation de la cryptographie à courbes elliptiques.

En Septembre 2013 Claus Diem montré que sous certaines conditions le problème ECDLP pouvait être résolu en temps **sub-exponentiel**.
:::

::: {.callout-tip collapse="true"}
## Révision rapide - ECDLP

**Problème** : trouver $k$ dans $Q = kP$ (exponentiel)

**Gain** : clés ~6-10× plus courtes

**Limite** : représenter messages en points difficile

**NSA** : adopté en 2003
:::

### Tableau de comparaison des tailles de clés

| AES (symétrique) | RSA/DH | Courbes Elliptiques | Rapport |
|---------------------|---------|---------------------|---------|
| 56 bits | 512 bits | 112 bits | 1:4.6 |
| 80 bits | 1024 bits | 160 bits | 1:6.4 |
| 112 bits | 2048 bits | 224 bits | 1:9.1 |
| 128 bits | 3072 bits | 256 bits | 1:12 |
| 256 bits | 15360 bits | 512 bits | 1:30 |

::: {.callout-note collapse="true"}
## Texte original - Tableau

Ce tableau montre les rapports des tailles des clés par rapport à celles de RSA pour une sécurité équivalente.

*(Tableau extrait du document original)*
:::

---

## ElGamal sur Courbes Elliptiques

### Adaptation directe

Remplacer opérations dans $\mathbb{Z}_p^*$ par opérations sur $E_p$

**Clés :**

- Choisir courbe $E_p$ et point $P_0 \in E_p$ de grand ordre
- Secret $x$, calculer $P_a = xP_0$
- **Publique** : $(E_p, P_0, P_a)$ | **Privée** : $x$

**Chiffrement :** Pour message $m_i \in E_p$

- Choisir $k$ aléatoire
- $\gamma = kP_0$, $\delta = kP_a + m_i$
- Envoyer $(\gamma, \delta)$

**Déchiffrement :** $m_i = \delta - x\gamma$

::: {.callout-note collapse="true"}
## Texte original - ElGamal EC

**Génération des clés**

Chaque entité (A) crée une paire de clés (publique et privée) comme suit:

- A choisit une courbe elliptique $E_p$ avec $p$, un nombre premier de grande taille (len($p$) bits) et un point $P_0 \in E_p$.
- A génère un nombre aléatoire $x$, tel que $1 \leq x \leq p$ et calcule $P_a = xP_0$ (multiplication par un scalaire sur $E_p$, pour laquelle, il existe des algorithmes efficaces).
- La clé publique de A est $(E_p, P_0, P_a)$, la clé privée de A est $x$.

**Encryption**

L'entité B obtient $(E_p, P_0, P_a)$, la clé publique authentique de A.

- B transforme son plaintext en une série d'entiers $m_i$, tel que $m_i \in E_p$ pour tout $i$.
- Pour chaque message $m_i$ :
  - B génère un nombre aléatoire unique $k$, tel que $1 \leq k \leq p$.
  - B calcule $\gamma := kP_0$ et $\delta := kP_a + m_i$ et envoie le ciphertext $c := (\gamma, \delta)$.

**Decryption**

- A utilise sa clé privée $x$ pour calculer: $x\gamma = xkP_0 = kP_a$.
- A retrouve le plaintext en calculant: $\delta - kP_a = kP_a + m_i - kP_a = m_i$.

La sécurité du schéma s'appuie sur **ECDLP** !

Il est également nécessaire d'**authentifier** les parties publiques échangées afin d'éviter les attaques man-in-the middle précédemment décrites.

Les propriétés du protocole sont identiques au cas $\mathbb{Z}_p^*$.
:::

::: {.callout-tip collapse="true"}
## Révision rapide - ElGamal EC

**Principe** : même qu'ElGamal sur $E_p$

**Opérations** : + et × scalaire sur points

**Sécurité** : ECDLP

**Authentification** : nécessaire contre MitM

**Avantage** : clés courtes
:::

# Fonctions de Hachage Cryptographiques et MACs

## Fonctions à Sens Unique (One-Way Functions)

Une fonction $f$ est à sens unique si $f(x) = y$ est facile à calculer, mais trouver $x$ à partir de $y$ est calculatoirement impossible pour la majorité des valeurs.

**Exemples :**

- Carrés modulo composite : $f(x) = x^2 \bmod n$ avec $n = pq$
- Construction DES : $y = E_k(x) \oplus x$ avec $k$ fixée et connue

**Note :** OWF ≠ OWHF (les hash functions imposent compression et 2nd-preimage resistance).

::: {.callout-note collapse=true title="Texte original"}
Une **fonction f est dite à sens unique** (one-way function ou **OWF**) si $x \in X$ on peut facilement calculer $f(x) = y$ mais pour la grande majorité des $y \in Y$ il est **calculatoirement impossible** de trouver un $x$ tel que $f(x) = y$.

**Exemples:**

- calcul des carrées modulo un composite: $f(x) = x^2 \bmod n$ avec $n = pq$ (p et q inconnus) est une **one-way function** car l'inverse est difficile (voir le problème de base **SQROOTP**).
- on peut construire une one-way function sur la base de DES ou de n'importe quel autre système de cryptage à blocs $E$ comme suit: $y = f(x) = E_k(x) \oplus x$, $\forall x$, avec $k$ une clé fixée et connue. On peut considérer que $E_k(x) \oplus x$ a un comportement (pseudo) aléatoire par construction de $E$. Le calcul de l'inverse revient à trouver un $x$ tel que: $x = E_k^{-1}(x \oplus y)$, ce qui est considéré difficile avec les propriétés de $E$. A noter que $f(x) = E_k(x)$ ne suffirait pas pour en faire une OWF car, en connaissant la clé, DES est réversible.

**OWF ≠ OWHF**: A noter qu'une OWHF en tant que hash function impose des restrictions supplémentaires sur les domaines sources et image ainsi que sur la 2nd-preimage resistance qui ne sont pas forcement respectés par des OWFs.

**Exemple**: $f(x) = x^2 \bmod n$ avec $n = pq$ (p et q inconnus) n'est pas une OWHF car étant donné $x$, $-x$ est une collision triviale.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**OWF** : facile dans un sens ($f(x) \to y$), impossible dans l'autre ($y \to x$).

Exemples : carrés modulaires, $E_k(x) \oplus x$.

OWF ≠ OWHF (hash functions = plus de contraintes).
:::

## Hash Functions : Définitions

Une hash function $h$ possède deux propriétés essentielles :

- **Compression** : transforme des données de longueur arbitraire en sortie de longueur fixe
- **Facilité de calcul** : $h(x)$ est rapide à calculer

**Classification :**

- **Unkeyed** (sans clé) : MDC (Manipulation Detection Code)
- **Keyed** (avec clé) : MAC (Message Authentication Code)

**Propriétés de sécurité :**

1. **Preimage resistance** : étant donné $y$, impossible de trouver $x$ tel que $h(x) = y$
2. **2nd-preimage resistance** (weak collision) : étant donné $x$, impossible de trouver $x' \neq x$ tel que $h(x) = h(x')$
3. **Collision resistance** (strong collision) : impossible de trouver $x \neq x'$ quelconques avec $h(x) = h(x')$

**Terminologie :**

- **OWHF** (weak one-way) : satisfait (1) et (2)
- **CRHF** (strong one-way) : satisfait (2) et (3)

::: {.callout-note collapse=true title="Texte original"}
Une **fonction de hachage** (hash function) est une fonction $h$ ayant les propriétés suivantes:

- **compression**: la fonction $h$ fait correspondre à un ensemble $X$ composée par des chaînes de bits de longueur finie mais arbitraire, un ensemble $Y$ composé par des chaînes de bits de longueur finie et fixée (et normalement inférieur à la taille de $X$) avec $h(x) = y$, et $x \in X$, $y \in Y$.
- **facile à calculer**: partant de $h$ et $x \in X$, $h(x)$ est facile à calculer.

Une hash function est dite **"à clé"** (keyed hash function) si une clé intervient dans le calcul de la fonction ($h_k(x) = y$); sinon on l'appelle **"sans clé"** (unkeyed hash function).

Les hash functions ont des nombreuses applications informatiques dont l'archivage structuré facilitant la recherche. Coté sécurité nous allons étudier deux catégories principales:

- **codes détecteurs d'altérations** (manipulation detection codes (**MDC**) or message integrity codes (**MIC**)): ce sont des unkeyed functions permettant de fournir un service d'intégrité sous certaines conditions. Le résultat d'une telle fonction est appelée **MDC-value** ou, simplement, **digest**.
- **codes d'authentification de message** (message authentication codes ou **MAC**) qui sont des keyed functions permettant d'authentifier la source du message et d'assurer son intégrité sans utiliser des mécanismes (cryptage) additionnels.

**Quelques propriétés de base des hash functions:**

- **1) preimage resistance**: étant donné un $y \in Y$, il est calculatoirement impossible de trouver une pré-image $x \in X$ satisfaisant $h(x) = y$.
- **2) 2nd-preimage resistance**: étant donné un $x \in X$ et son image $y \in Y$, avec $h(x) = y$, il est calculatoirement impossible de trouver un $x' \neq x$ tel que $h(x) = h(x')$. Aussi appelée **weak collision resistance**.
- **3) collision résistance**: il est calculatoirement impossible de trouver deux pré-images $x, x' \in X$ distinctes pour lesquels $h(x) = h(x')$ (pas de restriction sur le choix des valeurs). Aussi appelée **strong collision resistance**.

Une **fonction de hachage à sens unique** (one way hash function ou **OWHF**) est un MDC satisfaisant 1) et 2). Aussi appelée: **weak one-way hash function**.

Une **fonction de hachage résistante aux collisions** (collision resistant hash function ou **CRHF**) est un MDC satisfaisant le propriétés 2) et 3). (A noter que 3) ⇒ 2)). Aussi appelée: **strong one-way hash function**.

**OWF ≠ OWHF**: A noter qu'une OWHF en tant que hash function impose des restrictions supplémentaires sur les domaines sources et image ainsi que sur la 2nd-preimage resistance qui ne sont pas forcement respectés par des OWFs.

**Exemple**: $f(x) = x^2 \bmod n$ avec $n = pq$ (p et q inconnus) n'est pas une OWHF car étant donné $x$, $-x$ est une collision triviale.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**Hash function** : compression + calcul facile

**MDC** (sans clé) pour intégrité

**MAC** (avec clé) pour authentification

**Propriétés**

1. preimage resistance
2. 2nd-preimage resistance
3. collision resistance

**OWHF** = (1)+(2)

**CRHF** = (2)+(3).
:::

## Message Authentication Codes (MACs)

Un MAC est une famille de fonctions $h_k$ paramétrées par une clé secrète $k$ :

**Propriétés :**

1. **Compression** : entrée arbitraire → sortie fixe
2. **Facile à calculer** : avec $k$ connue, $h_k(x)$ est rapide
3. **Computation-resistance** : sans $k$, impossible de calculer des paires $(x, h_k(x))$ valides

**Implications :**

- Key non-recovery : impossible de retrouver $k$ à partir de paires $(x_i, h_k(x_i))$
- Preimage et collision resistance pour quiconque ne possède pas $k$

**Usage :** Authentification d'origine + intégrité des messages sans révéler de secret directement.

::: {.callout-note collapse=true title="Texte original"}
Un **Message Authentication Code** (**MAC**) est une famille de fonctions $h_k$ paramétrisées par une clé secrète $k$ ayant les propriétés suivantes:

- **1) compression**: comme pour les fonctions de hash génériques mais appliqué à $h_k$.
- **2) facile à calculer**: à partir d'une fonction $h_k$, et d'une clé connue $k$, on peut facilement calculer $h_k(x)$. Le résultat est appelée un **MAC-value** ou, simplement, un **MAC**.
- **3) résistance calculatoire** (computation-resistance): sans connaissance de la clé symétrique $k$, il est (calculatoirement) impossible de calculer des paires $(x, h_k(x))$ à partir de 0 ou plusieurs paires connus $(x_i, h_k(x_i))$ pour tout $x \neq x_i$.

La propriété 3) implique que les paires $(x_i, h_k(x_i))$ ne peuvent non plus servir à calculer la clé $k$ (**key non-recovery**). Cependant la propriété key non-recovery n'implique pas computation-resistance car des attaques chosen/known-plaintext pourraient mener à des paires $(x, h_k(x))$ falsifiées.

L'impossibilité de calculer des paires $(x, h_k(x))$ se traduit également en preimage et collision resistance (cf. transparent précédent) pour toute entité ne possédant pas la clé $k$.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**MAC** = hash avec clé $k$

Sans $k$ : impossible de forger $(x, h_k(x))$ ou retrouver $k$

Garantit authentification d'origine + intégrité.
:::

## Attaques sur les MDCs

### Attaque 2nd-Preimage Resistance

**Problème :** Étant donné $h(x) = y$, trouver $x'$ tel que $h(x') = h(x)$.

**Analyse probabiliste :**

Pour un digest de $m$ bits ($n = 2^m$ sorties possibles), la probabilité d'avoir au moins une collision après $k$ essais est :

$$P(\text{collision}) \approx 1 - (1-1/n)^k \approx k/n$$

Pour $P = 0.5$ : $k = n/2 = 2^{m-1}$

**Conclusion :** Pour un digest de $m$ bits, il faut environ $2^{m-1}$ essais pour trouver une 2nd-preimage avec probabilité 0.5.

::: {.callout-note collapse=true title="Texte original"}
**Problème**: étant donné $h(x) = y$, trouver $x'$ tel que $h(x')=h(x)$.

**Exemple pratique**: on a un texte avec un digest associé portant une signature digitale; on veut créer un faux texte portant la même signature (sans avoir le contrôle sur le texte original). Quelles sont nos chances d'un point de vue probabiliste?

Soit une hash function $h$ avec $n$ sorties possibles et une valeur donnée $h(x)$. Si $h$ est appliquée à $k$ valeurs aléatoires, quelle doit être la valeur de $k$ pour que la probabilité d'avoir au moins un $y$ tel que $h(x) = h(y)$ soit 0.5?

Pour la première valeur de $y$, la probabilité que $h(x) = h(y)$ est $1/n$. Inversement, la probabilité que $h(x) \neq h(y)$ est $1-1/n$. Pour $k$ valeurs, la probabilité de n'avoir aucune collision est de: $(1-1/n)^k$, soit:

$$\left(1 - \frac{1}{n}\right)^k = 1 - \frac{k}{n} + \frac{1}{2!}\left(\frac{k}{n}\right)^2 - \frac{1}{3!}\left(\frac{k}{n}\right)^3 + \ldots$$

ce qui pour $n$ très grand peut être approché par $1 - k/n$. Par conséquent, la probabilité complémentaire d'avoir au moins une collision est d'environ $k/n$; c'est qui nous donne $k = n/2$ pour une probabilité de 0.5.

**Conclusion**: pour un digest de $m$ bits, le nombre d'essais nécessaires à trouver un $y$ tel que $h(x) = h(y)$ avec une probabilité de 0.5 est $2^{m-1}$.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
Pour casser 2nd-preimage resistance avec digest de $m$ bits : $2^{m-1}$ essais (prob 0.5).
:::

### Attaque Collision Resistance : Birthday Paradox

**Problème :** Trouver deux valeurs distinctes $x, x'$ telles que $h(x) = h(x')$.

**Paradoxe d'anniversaire :** Dans un groupe de 23 personnes, probabilité > 0.5 d'avoir deux anniversaires identiques.

**Résultat mathématique :**

Pour $n$ sorties possibles, la probabilité de collision après $k$ calculs :

$$P(\text{au moins 1 collision}) = 1 - e^{-k(k-1)/(2n)}$$

Pour $P \geq 0.5$ : $k \approx 1.17\sqrt{n}$

**Conséquence cryptographique :** Pour un digest de $m$ bits ($n = 2^m$ sorties), il faut environ $2^{m/2}$ calculs pour trouver une collision avec probabilité > 0.5.

**Exemple pratique :** Modification d'un contrat en 237 variations pour trouver une version frauduleuse ayant le même digest que la version légitime.

::: {.callout-note collapse=true title="Texte original"}
**Problème**: trouver deux valeurs $x, x'$ distincts tel que $h(x) = h(x')$.

**Exemple pratique**: On doit faire signer un texte à quelqu'un et on veut appliquer cette signature à un texte falsifié (on contrôle le texte original). Quelles sont nos chances de trouver deux textes originaux satisfaisant ce critère?

Le **birthday paradox** est un problème probabiliste classique qui montre que dans une réunion de 23 personnes seulement, on a déjà une chance sur deux d'avoir deux personnes ayant leur anniversaire le même jour.

Soit $y_1, y_2,..., y_n$ toutes les sorties possibles d'une hash function. Combien des $h(x_i)$: $h(x_1), h(x_2),...,h(x_k)$ devons nous calculer pour avoir une probabilité de collision égale ou supérieure à 0.5 ?

Le premier choix pour $h(x_1)$ est arbitraire (prob = 1), le deuxième $h(x_2) \neq h(x_1)$ a une probabilité de $1 - 1/n$, le troisième de $1 - 2/n$, etc. Ce qui nous donne une probabilité de ne pas avoir des collisions égale à:

$$P_{\text{no collision}} = \prod_{i=1}^{k-1}\left(1 - \frac{i}{n}\right)$$

On prouve facilement (développement en série de $e^{-x}$) que pour $0 \leq x \leq 1$: $1-x \leq e^{-x}$ et donc:

$$P_{\text{no coll}} \leq \prod_{i=1}^{k-1}\left(1 - \frac{i}{n}\right) \leq \prod_{i=1}^{k-1} e^{-i/n} = e^{-k(k-1)/(2n)}$$

La probabilité d'avoir au moins une collision est $P_{\text{au-moins1}} = 1 - P_{\text{no-coll}}$. Pour connaître la valeur de $k$ pour laquelle $P_{\text{au-moins1}}$ est plus grand que 0.5, il suffit de calculer:

$$\frac{1}{2} \leq 1 - e^{-k(k-1)/(2n)}$$

Si $k$ est grand, on remplace $k(k-1)$ par $k^2$ et on obtient après des calculs simples:

$$k \geq \sqrt{2\ln(2) \cdot n} \approx 1.17\sqrt{n}$$

En prenant $n = 365$ pour l'anniversaire, on obtient $k = 22.3$, ce qui confirme l'énoncé du problème.

**Conséquence pour les hash functions**: Soit une hash function avec $2^m$ sorties possibles. Si $h$ est appliqué à $k = 2^{m/2}$ entrées on a une probabilité supérieur à 0.5 d'obtenir $h(x_i) = h(x_j)$.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**Birthday paradox** : pour casser collision resistance avec digest de $m$ bits : $2^{m/2}$ essais (prob > 0.5).

Exemple : 23 personnes suffisent pour anniversaires identiques.
:::

## Résistance Calculatoire : Récapitulatif

Pour une hash function avec digest de $n$ bits et clé MAC de $t$ bits :

| Type | Propriété | Difficulté | Taille conseillée |
|------|-----------|------------|-------------------|
| **OWHF** | Preimage | $2^n$ | $n \geq 128$ bits |
| | 2nd-preimage | $2^{n-1}$ | |
| **CRHF** | Collision | $2^{n/2}$ | $n \geq 256$ bits |
| **MAC** | Key recovery | $2^t$ | $t \geq 256$ bits |
| | Computation | $\min(2^t, 2^n)$ | $n \geq 128$ bits |

**Implications pratiques :**

- Pour intégrité seule (OWHF) : 128 bits suffisent
- Pour résistance aux collisions (CRHF) : minimum 256 bits
- MACs : clé de 256 bits, digest de 128 bits minimum

::: {.callout-note collapse=true title="Texte original"}
$n$: taille du MDC-value ou du MAC-value résultant de l'application de la hash function

$t$: taille de la clé du MAC

| Type de Hash Fct. | Caractéristique | Difficulté Calculatoire | But de l'attaque | Taille conseillée du digest/clé |
|-------------------|-----------------|-------------------------|------------------|--------------------------------|
| **OWHF** | preimage resistance | $2^n$ | trouver une préimage | $n \geq 128$ bits |
| | 2nd-preimage résistance | $2^{n-1}$ | trouver $x'$ avec $h(x') = h(x)$ | |
| **CRHF** | collision resistance | $2^{n/2}$ | trouver une collision | $n \geq 256$ bits |
| **MAC** | key non-recovery | $2^t$ | trouver la clé | $n \geq 128$ |
| | computation resistance | $\min(2^t,2^n)$ | produire un $(x, h_k(x))$ | $t \geq 256$ |
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**Efforts** : preimage $2^n$, 2nd-preimage $2^{n-1}$, collision $2^{n/2}$.

**Tailles** : OWHF ≥128 bits, CRHF ≥256 bits, MAC clé ≥256 bits.
:::

## MDCs Basés sur des Systèmes de Cryptage

**Principe :** Utiliser un algorithme de cryptage symétrique (DES, AES) pour construire un MDC.

**Défis à résoudre :**

- Casser la réversibilité des algorithmes symétriques
- Augmenter la largeur nominale (DES = 64 bits insuffisant pour CRHF)

**Fonctionnement :**

- Traitement séquentiel des blocs
- Opérations de chaînage avec XOR
- Combinaison de $n$ boîtes pour digests de taille $n \times$ largeur nominale

**Modèles classiques :**

1. **Matyas-Meyer-Oseas** : $H_i = E_{m_i}(H_{i-1}) \oplus H_{i-1}$
2. **Davies-Meyer** : $H_i = E_{m_i}(H_{i-1}) \oplus m_i$
3. **Miyaguchi-Preneel** : $H_i = E_{m_i}(H_{i-1}) \oplus H_{i-1} \oplus m_i$

**Exemples pratiques :**

- **MDC-2** : utilise 2 boîtes DES → digest 128 bits
- **MDC-4** : utilise 4 boîtes DES → digest 128 bits

**Limitation :** Sécurité fortement dépendante de l'algorithme sous-jacent.

::: {.callout-note collapse=true title="Texte original"}
**Idée**: utiliser un système de cryptage symétrique connu pour construire un MDC.

**Problèmes à résoudre**:

- il faut "casser" la réversibilité des algorithmes symétriques pour en faire des OWHF ou des CRHF.
- La "largeur nominale" de certains systèmes de cryptage (eg. DES) est de 64 bits, ce qui n'est pas suffisant pour construire des CRHF.

**Principe de fonctionnement**:

- les blocs de texte sont séquentiellement traités par la "boîte" de cryptage.
- la compression se base sur des opérations de chaînage avec les blocs résultant des itérations précédentes et des fonctions logiques (fondamentalement XOR). Ceci rend également le procédé irréversible.
- Si nécessaire, $n$ boîtes de cryptage seront combinées pour obtenir des longueurs de digests $n$ fois supérieures à la largeur nominale des boîtes utilisées.

**Attention**: la sécurité de ces algorithmes est fortement dépendante des propriétés des boîtes de cryptage sous-jacents.

**Exemples**: 

- Les modèles de **Matyas-Meyer-Oseas**, **Davies-Meyer** et **Miyaguchi-Preneel**.
- **MDC-2** et **MDC-4** utilisant respectivement 2 et 4 boîtes DES. Digest = 128 bits.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
MDCs à partir de crypto symétrique : casser réversibilité + chaînage XOR.

Modèles : Matyas-Meyer-Oseas, Davies-Meyer, Miyaguchi-Preneel.

MDC-2/4 avec DES → 128 bits.
:::

## Customized MDCs

Fonctions conçues spécifiquement pour la génération de digests, optimisées pour vitesse et sécurité.

**Éléments de construction :**

- Padding + ajout de la longueur du message
- Constantes prédéfinies pour augmenter la dispersion
- Rounds successifs avec opérations logiques et rotations
- Chaînage des sorties entre rounds
- Chaque bit du digest dépend de chaque bit d'entrée

**Algorithmes principaux :**

| Algorithme | Année | Digest | Statut |
|------------|-------|--------|--------|
| **MD5** | 1992 | 128 bits | ❌ Cassé |
| **SHA-0** | 1993 | 160 bits | ❌ Collisions en $2^{39}$ |
| **SHA-1** | 1995 | 160 bits | ⚠️ Collisions en $2^{63}$ |
| **SHA-2** | - | 224-512 bits | ✓ Sûr actuellement |
| **SHA-3** (Keccak) | 2012 | 224-512 bits | ✓ Standard actuel |

**Évolution des attaques :**

- 2004 : Collisions complètes sur MD5 (X. Wang)
- 2005 : SHA-1 cassé théoriquement ($2^{63}$ opérations)
- 2008 : Création de certificats CA frauduleux via MD5
- 2012 : SHA-3 adopté comme nouveau standard

::: {.callout-note collapse=true title="Texte original"}
Il s'agit de fonctions conçues exclusivement pour générer des codes d'intégrité (des digests) avec un soucis principal de vitesse et sécurité.

Leur fonctionnement se base sur les éléments suivants:

- des opérations d'initialisation (**padding** + rajouter la longueur).
- un ensemble de **constantes prédéfinies** choisies spécialement pour augmenter la dispersion.
- un ensemble "d'étapes" (**rounds**) qui vont séquentiellement s'appliquer a tous les blocs des données originaux. Ces rounds vont effectuer une combinaison d'opérations logiques et des rotations sur les données et les constantes.
- des opérations de **chaînage** impliquant les sorties des rounds précédents.

Dans ces fonctions, chaque bit du digest est une fonction de chaque bit des entrées.

Les plus connues sont:

- **MD5**: R. Rivest, 1992; RFC 1321. Digest = 128 bits. **Cassé!**
- **SHA-0**: NIST, 1993. Digest = 160 bits. Collisions en $2^{39}$ opérations au lieu de $2^{80}$
- **SHA-1**: NIST, 1995. Digest = 160 bits. Révision de SHA-0 avec rotation de bits additionnelle. Collisions en $2^{63}$ opérations (au lieu de $2^{80}$).
- **SHA-2**: NIST (FIPS 190-3). Comprend: SHA-224, SHA-256, SHA-384 et SHA-512. Les tailles du digest vont de 224 à 512 bits.
- **SHA-3**: Keccak Algorithm (taille du digest variable de 224 à 512 bits)

**Derniers Développements**:

- X.Wang et al. culminent en 2004 un long travail visant à trouver des collisions dans l'algorithme MD5. Ils publient deux paires de collisions pour des messages de 1024 bits.
- En 2005, X.Wang et al. prouvent dans la conférence CRYPTO'05 que le nombre d'opérations nécessaires pour trouver des collisions sur SHA-1 (standard actuel pour les fonctions de hashage sécurisées) est seulement de $2^{63}$.
- Ces attaques ont pour cible la recherche de collisions arbitraires mais lors de CRYPTO'06 des chercheurs de l'Université de Graz en Autriche proposent une méthode pour contrôler partiellement le contenu des collisions.
- En Décembre 2008 on montre qu'on peut générer des collisions contrôlées sur MD5 et créer ainsi une Certification Authority illicite permettant des forger des certificats acceptés par n'importe quel browser.
- Ces résultats s'appuient sur des approches **analytiques** (par opposition au brute force!)
- Le processus de sélection de successeur de SHA-1 est semblable à celui ayant désigné AES comme standard de cryptage en blocs. Le NIST a décidé (Octobre 2012) que **Keccak** serait l'algorithme de base pour **SHA-3**.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**Customized MDCs**

- MD5 (cassé)
- SHA-0 (cassé)
- SHA-1 (faible)
- SHA-2 (sûr)
- SHA-3/Keccak (standard actuel).

Construction : padding + constantes + rounds + chaînage.
:::

## MACs Basés sur des Systèmes de Cryptage

**CBC-MAC :** Utilise un algorithme de chiffrement par blocs en mode CBC.

**Fonctionnement :**

- Mode CBC avec IV = 0
- Élimination des ciphertexts intermédiaires
- Seul le dernier bloc chiffré est conservé comme MAC

**Avec DES :**

- Longueur clé : 56 bits (112 en Triple-DES optionnel)
- Longueur MAC : 64 bits

**Avantages :**

- Réutilisation de l'infrastructure de chiffrement existante
- Performances acceptables

**Limitations :**

- Sécurité limitée par la taille du bloc (64 bits pour DES)
- Vulnérable si utilisé incorrectement (ex: sans IV variable)

::: {.callout-note collapse=true title="Texte original"}
**Algorithme CBC-MAC basé sur DES-CBC avec IV = 0 et élimination des ciphertext intermédiaires**

- longueur de clé = 56 bits (112 en cas d'utilisation de la partie optionnelle)
- Longueur du MAC-value = 64 bits

Le schéma montre le traitement séquentiel des blocs de message $M_1, M_2, M_3$ avec l'algorithme de cryptage $E$ et la clé $k$. Les ciphertexts intermédiaires $C_1, C_2$ sont éliminés. Seul le dernier bloc $C_3$ constitue le MAC.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**CBC-MAC** : mode CBC + IV=0, seul dernier bloc gardé. DES : clé 56/112 bits, MAC 64 bits.
:::

## Nested MACs et HMACs

**Nested MAC (NMAC) :** Composition de deux familles de MACs $G$ et $H$ :

$$\text{NMAC}_{k,l}(x) = g_k(h_l(x))$$

**Sécurité :** Dépend de deux critères :

- $G$ résistante aux collisions
- $H$ résistante aux attaques spécifiques MACs

**HMAC (standard FIPS 198, 2002) :** Nested MAC utilisant des MDCs sans clé (SHA-1, SHA-256).

**Construction :**

- Constantes : `ipad = 0x363636...36` et `opad = 0x5C5C5C...5C` (512 bits)
- Clé $k$ de 512 bits

$$\text{HMAC-256}_k(x) = \text{SHA-256}((k \oplus \text{opad}) \parallel \text{SHA-256}((k \oplus \text{ipad}) \parallel x))$$

**Avantages :**

- MACs les plus utilisés en pratique
- Attaques sur SHA plus difficiles avec clé secrète
- Performance excellente
- Standardisé et largement supporté

::: {.callout-note collapse=true title="Texte original"}
Un **Nested MAC** ou **NMAC** est une composition de 2 familles de fonctions MACs $G$ et $H$ paramètrès par les clés $k$ et $l$ tel que:

$$G \circ H = \{ g \circ h \text{ avec } g \in G \text{ et } h \in H \} \text{ avec } g \circ h_{(k,l)}(x) = g_k(h_l(x))$$

La sécurité d'un NMAC dépend de deux critères:

- La famille de fonctions $G$ est résistante aux collisions.
- La famille de fonctions $H$ est résistante aux attaques spécifiques pour MACs, i.e.: Il est impossible de trouver un couple $(x,y)$ et une clé $m$ fixée mais inconnue, telle que: $\text{MAC}_m(x) = y$.

Un **HMAC** (FIPS 198, 2002) est un Nested MAC utilisant à la base des MDCs sans clé dédiées comme SHA-1 ou SHA-256.

Un HMAC utilise deux constantes de 512 bits dénommés `ipad` et `opad` telles que:

- `opad := 363636 ... 36` 
- `ipad := 5C5C5C ... 5C`

et une clé $k$ de 512 bits.

Le schéma de fonctionnement de HMAC-256 (sur la base de SHA-256) est le suivant:

$$\text{HMAC-256}_k(x) := \text{SHA-256}((k \oplus \text{opad}) \parallel \text{SHA-256}((k \oplus \text{ipad}) \parallel x))$$

Les **HMACs** sont les MACs les plus utilisés. Les attaques mentionnées sur les fonctions de la famille SHA sont plus difficiles à réaliser sur un HMAC par cause de la clé $k$.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**HMAC** : double hash avec clés dérivées (`ipad`/`opad`). $\text{HMAC}_k(x) = H((k \oplus \text{opad}) \parallel H((k \oplus \text{ipad}) \parallel x))$. Standard, sûr, performant.
:::

## Applications des Hash Functions

### Intégrité des Données

**Trois approches principales :**

1. **MAC seul :**
   - $A \to B: X, \text{MAC}_k(X)$
   - Authentification + intégrité garanties
   - Nécessite clé partagée

2. **MDC + Encryption :**
   - $A \to B: E_k(X, \text{MDC}(X))$
   - Confidentialité + intégrité
   - Clé symétrique partagée

3. **MDC + Canal authentique :**
   - $A \to B: X$ (canal normal)
   - $A \to B: \text{MDC}(X)$ (canal authentique)
   - Séparation des canaux

**Limitations :** Ces protocoles simples n'offrent pas de protection contre les replay attacks.

**Solution :** ajouter timestamps ou numéros de séquence.

::: {.callout-note collapse=true title="Texte original"}
**MAC Seul**:
$$A \to B: X, \text{MAC}_k(X)$$
Si $B$ calcule de son coté $\text{MAC}_k(X)$ et obtient la même valeur ⇒ le message provient de $A$.

**MDC + cryptage symétrique** (clé $k$ connue de $A$ et $B$)
$$A \to B: X, E_k(\text{MDC}(X))$$
$B$ calcule $\text{MDC}(X)$ et puis $E_k(\text{MDC}(X))$. Si égal ⇒ message vient de $A$.

**Comme 2) avec confidentialité de $X$ en plus**:
$$A \to B: E_k(X,\text{MDC}(X))$$

**MDC + signature digitale**:
$$A \to B: X, \text{Sig}_{\text{priv-A}}(\text{MDC}(X))$$
$B$ calcule $\text{MDC}(X)$ et vérifie $\text{Sig}_{\text{priv-A}}(\text{MDC}(X))$ avec une copie authentique de `pub-A`. Si égalité ⇒ $A$ est à l'origine du message. Cette solution offre en plus la **non-répudiation d'origine**.

Ces protocoles simples n'offrent aucun support sur l'unicité ni sur l'actualité (timeliness) des messages reçus et sont exposés à des **replay attacks**! Ils nécessitent des mécanismes tenant compte du temps ou du contexte de la transaction (cf. authentification d'entités).
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**Intégrité** : MAC seul, MDC+crypto, MDC+signature.

⚠️ Vulnérable aux replay sans timestamps/nonces.
:::

### Blockchains et Proof of Work

**Bitcoin et blockchains :** Utilisation de hash functions pour chaîner les blocs de transactions.

**Caractéristiques :**

- Transactions publiques et visibles
- Blocs chaînés via fonctions de hachage cryptographiques
- Minage = résolution d'un puzzle cryptographique (proof of work)

**Proof of Work :**

- Trouver un nonce tel que $\text{hash}(\text{bloc} \parallel \text{nonce}) < \text{target}$
- Puzzle coûteux en calcul, validation rapide
- Premier mineur à résoudre reçoit récompense en bitcoins

**Sécurité :**

- Blockchain = registre public, décentralisé, immuable
- Falsification nécessiterait effort > tous mineurs honnêtes
- Protection basée sur propriétés CRHF

**Statistiques Bitcoin (octobre 2025) :**

- Difficulty : 150.84 T
- Target : $\approx 2^{177}$ (pseudo-collision sur 79 bits)
- Hashrate : ~1.1 ZH/sec ($1.1 \times 10^{21}$ hash/sec)
- Temps moyen génération bloc : 10 minutes

::: {.callout-note collapse=true title="Texte original"}
Les transactions bitcoin sont publiées et visibles par tous les intervenants. Elles sont encapsulées dans des blocs chaînés à l'aide de fonctions de hachage cryptographiques.

Le **minage** (mining) consiste à rajouter itérativement des nouveaux blocs contenant les transactions courantes.

La génération d'un bloc valable nécessite la résolution d'un **puzzle cryptographique** (proof of work) très coûteux en temps de calcul (trouver des pseudo-collisions dans les fonctions de hachage cryptographiques). La validation reste très efficace.

Le premier mineur capable de générer un bloc valable recevra une récompense monétaire (en bitcoins). Le processus de minage est ouvert à tous les mineurs mais seul le premier est récompensé.

La chaine de blocs résultante (**blockchain**) devient alors un registre publique (public ledger), décentralisé et **immuable** protégeant toutes les transactions passées. La falsification/modification des données protégées par la blockchain nécessiterait un effort calculatoire supérieur à celui effectué par tous les mineurs honnêtes.

**Statistiques Bitcoin 13/10/2025**:

- **Difficulty**: 150.84 T
- **Target**: $2^{224} / \text{Difficulty} = \approx 2^{177}$. Le digest valable pour générer un bloc doit être inférieur à $2^{177}$, ce qui signifie une pseudo-collision sur les 79 bits de poids plus fort. La variation sur les inputs dépend du **nonce**.
- **Hashrate**: ~ 1.1 ZH/sec ($1.1 \times 10^{21}$ hashes /sec)
- **Fonctions de hachage exécutées pour obtenir un bloc**: ~ $660 \times 10^{21}$
- **Temps moyen de génération d'un bloc**: 10 min
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**Blockchain** : chaînage de blocs via hash.

**Proof of Work** : trouver nonce pour hash < target. 

Sécurité = effort > tous mineurs.

Bitcoin : ~10 min/bloc, $10^{21}$ hash/sec.
:::

### Autres Applications

**1. Authentification :**

- Data origin authentication (DOA)
- Transaction authentication (DOA + paramètres temporels)

**2. Virus checking :**

- Créateur publie $\text{digest} = h(\text{logiciel})$ via canal sûr
- Utilisateurs vérifient intégrité en recalculant le digest

**3. Distribution des clés publiques :**

- Publier $h(\text{clé publique})$ au lieu de la clé complète
- Vérification d'authenticité simplifiée

**4. Timestamp sur documents :**

- Timestamp appliqué au digest plutôt qu'au document complet
- Réduction des données à signer

**5. One-time password (S-Key) :**

- Chaîne de hash : $x_1 = h(x_0), x_2 = h(x_1), \ldots, x_n = h(x_{n-1})$
- Système stocke $x_n$, utilisateur fournit $x_{n-1}$
- Vérification : $h(x_{n-1}) = x_n$
- Après validation, système stocke $x_{n-1}$ pour prochaine fois

::: {.callout-note collapse=true title="Texte original"}
**Authentification**:

- data origin authentication (DOA)
- transaction authentication (= DOA + time-variant parameters)

**Virus checking**:

- Le créateur d'un logiciel crée un digest = $h(x)$ avec $x$ étant l'original et le distribue par un canal sûr (eg. CD-ROM).

**Distribution des clés publiques**:

- Permet de contrôler l'authenticité d'une clé publique.

**Timestamp sur un document**:

- Le document sur lequel on veut effectuer le timestamp est d'abord soumis à une hash function. Le timestamp (avec la signature de l'entité correspondante) s'applique alors seulement au digest.

**One-time password (S-Key)** (mécanisme d'identification):

- A partir d'un seed secret $x_0$, on crée une chaîne de hash-values: $x_1 = h(x_0)$, $x_2 = h(x_1)$, ... $x_n = h(x_{n-1})$.
- Le système mémorise $x_n$ et l'utilsateur rentre $x_{n-1}$. Si $h(x_{n-1}) == x_n$ ⇒ OK.
- Le système mémorise alors $x_{n-1}$ et ainsi de suite.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**Applications**

- authentification
- virus checking
- distribution clés publiques
- timestamp
- one-time passwords (chaîne de hash)
:::

## Randomized Hash Functions : Exemple UNIX

**Problème :** Fonctions de hachage déterministes produisent toujours le même résultat pour le même mot de passe.

**Risques :**

- Détection de mots de passe identiques
- Attaques par dictionnaire offline (codebooks pré-calculés)
- Rainbow tables

**Solution UNIX : Salt**

- Ajout d'un élément pseudo-aléatoire de 12 bits (salt) avant hachage
- Salt différent pour chaque utilisateur
- 4096 possibilités ($2^{12}$) pour chaque mot de passe

**Avantages :**

- Empêche détection des duplications
- Codebooks pré-calculés deviennent inefficaces
- Chaque mot de passe nécessite 4096 entrées dans le dictionnaire

**Implémentation UNIX :**

- Fichier `/etc/passwd` accessible globalement
- Format : `username:hash(salt+password):uid:gid:...`
- Hash basé sur DES modifié (25 itérations)
- Salt stocké en clair (2 premiers caractères du hash)

**Exemple :**
```
root:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh
pp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs
```

**Limitations :**

- Protection efficace contre dictionnaires pré-calculés
- Attaques online limitées par le système (nombre d'essais)
- Attaques offline possibles si fichier compromis

::: {.callout-note collapse=true title="Texte original"}
UNIX garde ses mots de passe dans un fichier globalement accessible (ou éventuellement distribué par NIS). L'information stockée correspond au résultat produit par une hash function.

**Exemple (fictif)**:
```
root:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh
pp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs
```

**Problèmes**:

- la hash function étant déterministe, elle produit le même résultat pour des mots de passe identiques.
- on pourrait créer des "cahiers" (codebooks) contenant le résultat de l'application de la hash function à des entrées données (p.ex. un dictionnaire) et les comparer facilement (off-line) avec les chaînes stockées par UNIX (**brute force dictionnary attack**).

**Solution**:

- Rajouter un élément (pseudo) aléatoire de **12 bits** différent pour chaque mot de passe (appelé **salt**) avant de calculer la hash function et lors de la vérification.
- Cet élément permet de rajouter un facteur aléatoire de **4096 possibilités** pour chaque mot de passe et de prévenir la détection des duplications.

Le schéma de fonctionnement utilise DES avec 25 itérations, le password comme clé, et le salt pour modifier les E-boxes. Le résultat final de 64 bits est converti en 11 caractères ASCII.

La sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l'efficacité de cette technique dans la transmission de malware.

Les attaques dictionnaire sont normalement moins efficaces **online** car les systèmes d'exploitation limitent le nombre d'essais infructueux d'authentification.
:::

::: {.callout-tip collapse=true title="Révision rapide"}
**UNIX salt** : 12 bits aléatoires ajoutés au password avant hash.

4096 variations possibles.

Empêche codebooks pré-calculés et détection duplications.
:::

# Signatures Digitales

## Introduction et Définitions

Une **signature digitale** est une chaîne de données associant un message à une entité d'origine, équivalent numérique d'une signature manuscrite.

**Classification :**

- **Avec appendice** : nécessite le message original pour vérification (ElGamal, DSS)
- **Avec reconstitution** : permet de reconstruire le message (RSA, Rabin)

Les signatures utilisent principalement la **cryptographie asymétrique** pour identifier explicitement une entité.

**arbitrated digital signatures**: technologie symétrique + Thrusted Third Parties (TTP)

::: {.callout collapse=true}
## Texte original

**Signature digitale** : chaîne de données permettant d'associer un message (sous forme digitale) à une entité d'origine.

**Schéma de signature digitale** : algorithme de génération + algorithme de vérification.

**Procédé de signature** : formatage du message + algorithme de génération de signature.

**Procédé de vérification** : algorithme de vérification + (reconstruction du message).

**Classification des signatures digitales** :

- **Signatures digitales avec appendice** qui nécessitent la présence du message original pour vérifier la validité de la signature. Ce sont les plus couramment utilisées. Exemples : ElGamal, DSS.
- **Signatures digitales avec reconstitution du message** qui offrent, en plus, la possibilité de reconstruire le message à partir de la signature. Exemples : RSA, Rabin.

Les signatures digitales sont pour la plupart basées sur la **crypto asymétrique** du fait que la notion clé partagée n'est pas adaptée aux besoins d'identifier une entité de façon explicite.

Des engagements semblables à ceux obtenus par une signature à clé publique (comme la non-répudiation d'origine) peuvent cependant être obtenus avec la technologie symétrique et des tierces de confiance (Trusted Third Parties ou TTP). Ces méthodes sont nommées : **arbitrated digital signatures**.
:::

::: {.callout collapse=true}
## Révision rapide

**Signature digitale** = chaîne associant message + entité

**Deux types**

- avec appendice (nécessite message original)
- avec reconstitution (reconstruit le message)

Basée sur crypto asymétrique
:::

---

## Cadre Formel : Signatures avec Appendice

**Espaces de travail :**

- $M$ : espace des messages
- $M_h$ : messages hashés où $m_h = H(m)$ avec $H$ une fonction de hachage
- $S$ : espace des signatures possibles

**Fonctionnement :**

Chaque entité A définit :

- $S_A : M_h \rightarrow S$ (application de signature, utilise clé privée)
- $V_A : M_h \times S \rightarrow \{\text{vrai}, \text{faux}\}$ (vérification, utilise clé publique)

Avec $V_A(m_h, s) = \text{vrai}$ si et seulement si $S_A(m_h) = s$

**Propriétés essentielles :**

- $S_A$ et $V_A$ faciles à calculer avec les bonnes clés
- Impossible de trouver $(m', s')$ valide sans la clé privée de A

::: {.callout collapse=true}
## Texte original

On admet que chaque entité a une clé privée pour signer des messages et une copie authentique des clés publiques des correspondants.

**Notation :**
- M : Espace de messages
- $M_h$ : $m_h = H(m)$ avec $m \in M$, $m_h \in M_h$ et $H$ une hash function
- S : Espace des valeurs pouvant être obtenues par un procédé de signature

**Description :**

Chaque entité définit une application injective $S_A : M_h \rightarrow S$ (ie. la signature)

L'application $S_A$ donne lieu à une application $V_A$ :
$V_A : M_h \times S \rightarrow \{\text{vrai}, \text{faux}\}$ (ie. la vérification)

tel que $\forall m_h \in M_h$, $s \in S$, on a :
$V_A(m_h, s) = \text{vrai}$ si $S_A(m_h) = s$ et
$V_A(m_h, s) = \text{faux}$ sinon

Les opérations $S_A$ nécessitent la clé privée de A alors que les opérations $V_A$ utilisent la clé publique de A.

**Quelques propriétés simples :**

- Les opérations $S_A$ et $V_A$ doivent être faciles à calculer (en ayant les clés corresp.)
- Il est impossible (calculatoirement) pour une entité n'ayant pas la clé privée de A de trouver un $m'$ et un $s'$ avec $m' \in M$ et $s' \in S$ tel que $V_A(m'_h, s') = \text{vrai}$ avec $m'_h = H(m')$.
:::

::: {.callout collapse=true}
## Révision rapide

Signature : $S_A(m_h) = s$ (clé privée).

Vérification : $V_A(m_h, s)$ (clé publique).

Impossible de forger sans clé privée.
:::

---

## Cadre Formel : Signatures avec Reconstitution

**Espaces additionnels :**

- $M_S$ : espace sur lequel s'applique la signature
- $R : M \rightarrow M_S$ : fonction de redondance (injective, inversible, publique)
- $M_R = \text{Im}(R)$ : image de $R$

**Fonctionnement :**

- Signature : $S_A : M_S \rightarrow S$ (injective)
- Vérification : $V_A : S \rightarrow M_S$ avec $V_A \circ S_A = \text{Identité}$

**Génération :**

1. Calculer $m_R = R(m)$ et $s = S_A(m_R)$
2. Publier $s$ comme signature de A sur $m$

**Vérification :**

1. Calculer $m_R = V_A(s)$ avec clé publique
2. Vérifier $m_R \in M_R$ (sinon rejeter)
3. Reconstituer $m = R^{-1}(m_R)$

**Fonction de redondance :**

Essentielle pour la sécurité. Si $M_R = M_S$, il devient trivial de forger des signatures.

**Exemple :** $R(m) = m \parallel m$ (concaténation). Probabilité de forger : $(1/2)^n$ pour un message de $n$ bits.

::: {.callout collapse=true}
## Texte original

**Notation :** en plus des définitions précédentes, on a :

$M_S$ : L'espace des éléments sur lesquels peut s'appliquer une signature.

$R$ : Une application injective : $M \rightarrow M_S$, appelée fonction de redondance. Elle doit être inversible et publique.

$M_R = \text{Im}(R)$

**Description :**

Chaque entité définit une application injective $S_A : M_S \rightarrow S$ (ie. la signature)

L'application $S_A$ donne lieu à une application $V_A : S \rightarrow M_S$ (ie. la vérification) tel que $V_A \circ S_A = \text{Identité}$ sur $M_S$

A noter que la vérification s'effectue sans la clé privée de A

**Génération de signature :**
1. Calculer $m_R = R(m)$ et $s = S_A(m_R)$
2. Rendre publique $s$ en tant que signature de A sur $m$. Ceci permet aux autres entités de vérifier la signature et reconstituer $m$.

**Vérification :**
1. Calculer $m_R = V_A(s)$ (avec la clé publique de A)
2. Vérifier que $m_R \in M_R$ (sinon rejeter la signature)
3. Reconstituer $m$ en calculant : $R^{-1}(m_R)$

**Propriétés :**

- Les opérations $S_A$ et $V_A$ doivent être faciles à calculer (en ayant les clés corresp.)
- Il est impossible (calculatoirement) pour une entité n'ayant pas la clé privée de A de trouver un $s' \in S$ tel que $V_A(s') \in M_R$

**Remarques sur la fonction de redondance :**

- Le choix d'une fonction de redondance est **essentiel pour la sécurité** du système.
- Si $M_R = M_S$ et $R$ et $S_A$ sont des bijections respectivement de $M$ dans $M_R$ et de $M_S$ dans $S$, alors $M$ et $S$ ont une taille identique et, par conséquent, il est trivial de forger des messages portant la signature de A.

**Exemple de fonction de redondance :** soit $M = \{m : m \in \{0,1\}^n\}$ (n taille du message) et $M_S = \{t : t \in \{0,1\}^{2n}\}$. Soit $R : M \rightarrow M_S$ tel que $R(m) = m \parallel m$ ($\parallel$ étant la concaténation de 2 messages). La probabilité de tomber sur un tel message en essayant de forger un message à partir d'une signature est de : $|M_R| / |M_S| = (1/2)^n$, ce qui est négligeable pour des grands messages.

**Attention !** : Une fonction de redondance adaptée pour un schéma de signature digitale peut provoquer des failles dans un autre différent !
:::

::: {.callout collapse=true}
## Révision rapide

**Avec reconstitution :** Fonction redondance $R(m) = m_R$.

Signature $s = S_A(m_R)$.

Vérification : $m_R = V_A(s)$, reconstituer $m = R^{-1}(m_R)$.

Redondance cruciale pour sécurité.
:::

---

## Signature RSA

**Génération des clés :**

- Choisir deux grands nombres premiers $p$ et $q$
- Calculer $n = pq$ et $\phi(n) = (p-1)(q-1)$
- Choisir $e$ avec $\text{pgcd}(e, \phi(n)) = 1$
- Calculer $d$ tel que $ed \equiv 1 \pmod{\phi(n)}$
- **Clé publique** : $(n, e)$ ; **Clé privée** : $d$

**Signature :**

1. Calculer $m_R = R(m)$ (fonction de redondance)
2. Calculer $s = m_R^d \bmod n$
3. Envoyer $s$

**Vérification :**

1. Calculer $m'_R = s^e \bmod n$
2. Vérifier $m'_R \in M_R$ (rejeter sinon)
3. Reconstituer $m = R^{-1}(m'_R)$

**Variante avec appendice :**

- **Signature** : $m_h = H(m)$, puis $s = m_h^d \bmod n$
- **Vérification** : $m'_h = s^e \bmod n$, accepter si $m'_h = H(m)$

**Caractéristiques :**

- Signature plus lente que vérification ($d$ grand, $e$ petit)
- Différencier clés signature/encryption
- Vulnérable aux mêmes attaques que RSA encryption

::: {.callout collapse=true}
## Texte original

**Génération des clés :**

- Chaque entité (A) crée une paire de clés (publique et privée) comme suit :
- A choisit la taille du modulus $n$ (p.ex. taille$(n) = 1024$ ou taille$(n) = 2048$).
- A génère deux nombres premiers $p$ et $q$ de grande taille $(n/2)$.
- A calcule $n := pq$ et $\phi(n) = (p-1)(q-1)$.
- A génère l'exposant de vérification $e$, avec $1 < e < \phi(n)$ tel que $\text{pgcd}(e, \phi(n)) = 1$.
- A calcule l'exposant de signature $d$, tel que : $ed \equiv 1 \pmod{\phi(n)}$ avec l'algorithme d'Euclide étendu ou avec l'algorithme fast exponentiation.
- Le couple $(n,e)$ est la clé publique de A ; $d$ est la clé privée de A.

**Signature :**

- A calcule la fonction de redondance du message $m$ : $m_R := R(m)$.
- A calcule la signature : $s := m_R^d \bmod n$ et envoie $s$ à B.

**Vérification :**

- L'entité B obtient $(n,e)$, la clé publique authentique de A.
- B calcule $m'_R = s^e \bmod n$, vérifie $m'_R \in M_R$ et rejette la signature si $m'_R \notin M_R$
- B retrouve le message correctement signé par A en calculant : $m = R^{-1}(m'_R)$.

**Remarques :**

La preuve de fonctionnement est identique à celle du procédé d'encryption. L'ordre d'exponentiation n'a pas d'influence puisque :
$$ed \equiv de \equiv 1 \pmod{\phi(n)}$$

Le procédé peut également être utilisé pour produire des **signatures avec appendice** avec les modifications suivantes :

**Signature :**
- A utilise une fonction de hachage $H$ et calcule $m_h := H(m)$.
- A calcule la signature de $m_h$ : $s := m_h^d \bmod n$ et envoie le couple $(m,s)$ à B.

**Vérification :**
- B calcule $m'_h = s^e \bmod n$ et $H(m)$ et vérifie l'égalité $m'_h = H(m)$.
- Si l'égalité est vérifiée, B accepte la signature $s$ de A sur le message M.

Le calcul de signature est **plus lent** que la vérification à cause de différence de taille entre l'exposant $d$ (taille$(d) \approx$ taille$(\phi(n))$) et $e$.

Les risques et attaques mentionnés dans le procédé d'encryption s'appliquent également pour la signature.

Il convient de **différencier les paires de clés d'encryption et de signature** puisqu'elles nécessitent des politiques de stockage, sauvegarde et mise à jour distinctes.
:::

::: {.callout collapse=true}
## Révision rapide

**RSA signature :** $s = m_R^d \bmod n$ (privée).

Vérif : $m'_R = s^e \bmod n$ (publique).

Avec appendice : $s = H(m)^d \bmod n$.

Signature lente, vérif rapide.
:::

---

## Signatures Aveugles (Blind Signatures)

**Principe :** A envoie une information à B pour signature. À partir de la réponse, A peut calculer la signature de B sur un message différent, que B n'a jamais vu.

**Exploitation de la propriété multiplicative RSA :**

$$(m_1 m_2)^e \equiv m_1^e m_2^e \equiv c_1 c_2 \pmod{n}$$

**Fonctions de camouflage :**

Soit $k$ un entier avec $\text{pgcd}(n,k) = 1$ :

- **Blinding** : $f(m) = m \cdot k^e \bmod n$
- **Unblinding** : $g(m) = k^{-1} \cdot m \bmod n$

Résultat : $g(S_B(f(m))) = g(S_B(mk^e \bmod n)) = g(m^dk \bmod n) = m^d \bmod n = S_B(m)$

**Protocole :**

1. A → B : $m' = f(m)$ (message camouflé)
2. A ← B : $s' = S_B(m')$ (signature du message camouflé)
3. A calcule $g(s')$ et obtient $S_B(m)$ (signature du message original)

**Applications :** Argent électronique anonyme, systèmes de vote électronique.

::: {.callout collapse=true}
## Texte original

**Schéma inventé par Chaum.**

**Idée :** A envoie une information à B pour signature. B retourne à A l'information signée. A partir de cette signature, A peut calculer la signature de B sur un autre message choisi à priori par A. Ceci permet à A d'avoir une signature de B sur un message que B n'a jamais vu (d'où le nom de signature aveugle...).

En fait il s'agit d'une faille basée sur la **propriété multiplicative de RSA** : $(m_1m_2)^e \equiv m_1^e m_2^e \equiv c_1 c_2 \pmod{n}$ qui a été exploitée pour en faire un nouveau procédé de signature.

**Algorithme :** Soit $S_B$ la signature de RSA de B avec $(n,e)$ et $d$, resp. les clés publiques et privées de B. Soit $k$ un entier fixé avec $\text{pgcd}(n,k) = 1$ :

$f : \mathbb{Z}_n \rightarrow \mathbb{Z}_n$ avec $f(m) = m \cdot k^e \bmod n$ (blinding function)

$g : \mathbb{Z}_n \rightarrow \mathbb{Z}_n$ avec $g(m) = k^{-1} \cdot m \bmod n$ (unblinding function)

ce qui donne :

$$g(S_B(f(m))) = g(S_B(mk^e \bmod n)) = g(m^dk \bmod n) = m^d \bmod n = S_B(m)$$

**Protocole :**

- A → B : $m' = f(m)$
- A ← B : $s' = S_B(m')$
- A calcule $g(s')$ et obtient la signature souhaitée en utilisant (*).
:::

::: {.callout collapse=true}
## Révision rapide

**Blind signature :** Exploite multiplicativité RSA.

Camouflage $f(m) = m \cdot k^e$

Décamouflage $g(m) = k^{-1} \cdot m$.

B signe $f(m)$, A obtient $S_B(m)$ sans que B voie $m$.
:::

---

## Signature Rabin

**Génération des clés :**

- Générer deux grands nombres premiers $p$ et $q$
- Calculer $n = pq$
- **Clé publique** : $n$ ; **Clé privée** : $(p, q)$

**Signature :**

1. Calculer $m_R = R(m)$ (fonction de redondance)
2. Calculer $s = \sqrt{m_R} \bmod n$ (racine carrée mod $n$)
3. Envoyer $s$ (une des 4 racines carrées)

**Vérification :**

1. Calculer $m'_R = s^2 \bmod n$
2. Vérifier $m'_R \in M_R$ (rejeter sinon)
3. Reconstituer $m = R^{-1}(m'_R)$

**Caractéristiques :**

- Basé sur le problème SQROOTP (racines carrées mod composite)
- **Provably secure** : équivalent à la factorisation
- Vulnérable aux attaques chosen-ciphertext actives

::: {.callout collapse=true}
## Texte original

**Génération des clés :**

- Chaque entité (A) crée une paire de clés (publique et privée) comme suit :
- A génère deux nombres premiers aléatoires $p$ et $q$ de grande taille (len$(pq) \geq 1024$).
- A calcule $n := pq$.
- La clé publique de A est $n$, la clé privée de A est $(p,q)$.

**Signature :**

- A calcule la fonction de redondance du message $m$ : $m_R := R(m)$.
- A utilise sa clé privée pour calculer la signature : $s := m_R^{1/2} \bmod n$ en utilisant des algorithmes efficaces pour calculer des racines carrées mod $p$ et mod $q$.
- A envoie $s$ à B ($s$ est une des 4 racines carrées obtenues).

**Vérification :**

- L'entité B obtient $n$, la clé publique authentique de A.
- B calcule $m'_R = s^2 \bmod n$, vérifie $m'_R \in M_R$ et rejette la signature si $m'_R \notin M_R$
- B retrouve le message correctement signé par A en calculant : $m = R^{-1}(m'_R)$.

**Remarques :**

Le procédé de Rabin est basé sur l'**impossibilité de trouver des racines carrées modulo un composite de factorisation inconnue** (problème SQROOTP).

L'intérêt principal de cet algorithme réside dans le fait qu'il a été **prouvé comme étant équivalent à la factorisation** (SQROOTP ⇔ FACTP). Cet algorithme appartient donc à la catégorie **provably secure** pour toute attaque passive.

Les **attaques actives** peuvent, dans certains cas, compromettre la sécurité de l'algorithme. Plus précisément, si on monte l'attaque chosen ciphertext (on demande à A de décrypter un ciphertext choisi) suivant :

- L'attaquant M génère un $m$ et envoie à A le ciphertext $c = m^2 \bmod n$.
- A répond avec une racine $m_x$ parmi les 4 possibles $m_1, m_2, m_3, m_4$.
- Si $m \not\equiv m_x \pmod{n}$ (probabilité 0.5), M recommence avec un nouveau $m$.
- Sinon, A calcule $\text{pgcd}(m - m_x, n)$ et obtient ainsi un des deux facteurs de $n$...

Cette attaque pourrait être évitée si le procédé exigeait une redondance suffisante dans les plaintexts permettant à A d'identifier sans ambiguïté laquelle des solutions possibles est le plaintext original. Dans ce cas, A répondrait toujours $m$ et jetterait les autres solutions n'ayant pas le niveau de redondance préétabli.
:::

::: {.callout collapse=true}
## Révision rapide

**Rabin :** $s = \sqrt{m_R} \bmod n$.

Vérif : $m'_R = s^2 \bmod n$.

**Provably secure** (équivalent factorisation).

Vulnérable attaques actives chosen-ciphertext.
:::

---

## Signature ElGamal

**Génération des clés :**

- Générer premier $p$ et générateur $\alpha \in \mathbb{Z}_p^*$
- Générer secret $a$ aléatoire, calculer $y = \alpha^a \bmod p$
- **Clé publique** : $(p, \alpha, y)$ ; **Clé privée** : $a$

**Signature :**

1. Calculer $m_h = H(m)$
2. Générer $k$ aléatoire avec $\text{pgcd}(k, p-1) = 1$
3. Calculer $r = \alpha^k \bmod p$
4. Calculer $s = k^{-1}(m_h - ar) \bmod (p-1)$
5. Signature : $(r, s)$

**Vérification :**

1. Vérifier $1 \leq r \leq p-2$ (rejeter sinon)
2. Calculer $v_1 = y^r r^s \bmod p$
3. Calculer $v_2 = \alpha^{H(m)} \bmod p$
4. Accepter si $v_1 = v_2$

**Preuve :** Si $s \equiv k^{-1}(m_h - ar) \pmod{p-1}$, alors $m_h \equiv ar + ks \pmod{p-1}$

Donc $v_2 = \alpha^{m_h} \equiv \alpha^{ar+ks} \equiv (\alpha^a)^r (\alpha^k)^s \equiv y^r r^s = v_1 \pmod{p}$

**Caractéristiques :**

- Fonctionne uniquement avec appendice (hash)
- Base du DSA (Digital Signature Algorithm)
- $k$ doit être unique pour chaque signature

::: {.callout collapse=true}
## Texte original

**Génération des clés :**

- Chaque entité (A) crée une paire de clés (publique et privée) comme suit :
- A génère un nombre premier $p$ (len$(p) \geq 1024$ bits) et un générateur $\alpha$ de $\mathbb{Z}_p^*$.
- A génère un nombre aléatoire $a$, tel que $1 \leq a \leq p-2$ et calcule $y := \alpha^a \bmod p$.
- La clé publique de A est $(p, \alpha, y)$, la clé privée de A est $a$.

**Signature :**

- A utilise une fonction de hachage $H$ et calcule $m_h := H(m)$.
- A génère un nombre aléatoire $k$ ($1 \leq k \leq p-2$ et $\text{pgcd}(k,p-1) = 1$) et calcule $k^{-1} \bmod (p-1)$
- A calcule $r := \alpha^k \bmod p$ et ensuite $s := k^{-1}(m_h - ar) \bmod (p-1)$
- La signature de A sur le message $m$ est le couple $(r,s)$.

**Vérification :**

- L'entité B obtient $(p, \alpha, \alpha^a \bmod p)$, la clé publique authentique de A.
- B vérifie que $1 \leq r \leq p-2$, sinon rejette la signature.
- B calcule $v_1 := y^r r^s \bmod p$.
- B calcule $H(m)$ et $v_2 := \alpha^{H(m)} \bmod p$
- B accepte la signature ssi. $v_1 = v_2$.

**Remarques :**

**Preuve que le schéma fonctionne :** Si $s \equiv k^{-1}(m_h - ar) \pmod{p-1}$, on a que :
$$m_h \equiv (ar + ks) \pmod{p-1}$$ 
et
$$v_2 = \alpha^{H(m)} \bmod p$$

si, comme on souhaite montrer $m_h = H(m)$, en réduisant les exposants mod $(p-1)$, on peut réécrire $v_2$ :
$$v_2 \equiv \alpha^{ar+ks} \pmod{p}$$

D'autre part :
$$v_1 = y^r r^s \equiv \alpha^{ar} \alpha^{ks} \equiv \alpha^{ar+ks} \pmod{p}$$ 
c.q.f.d.

Par construction, le schéma d'ElGamal fonctionne **uniquement avec appendice** (résultat de l'application d'une fonction de hachage). Le schéma de Nyberg-Rueppel introduit une variation permettant la reconstitution du message.

Le **Digital Signature Algorithm (DSA)**, approuvé par le US National Institute of Standards and Technology est devenu le standard de signature le plus couramment utilisé. Il est construit sur la base d'un dérivé direct du schéma d'ElGamal avec la fonction de hachage SHA-1.
:::

::: {.callout collapse=true}
## Révision rapide

**ElGamal :** $(r,s)$ avec $r = \alpha^k \bmod p$, $s = k^{-1}(m_h - ar) \bmod (p-1)$.

Vérif : $y^r r^s \stackrel{?}{=} \alpha^{H(m)} \bmod p$.

Base de DSA.

$k$ unique crucial.
:::

---

## Signatures et Crypto-monnaies

Les crypto-monnaies utilisent massivement les signatures digitales pour authentifier les transactions.

**Bitcoin et Ethereum :**

- Utilisent **ECDSA** (Elliptic Curve Digital Signature Algorithm)
- Dérivé d'ElGamal sur courbes elliptiques
- Sécurité basée sur ECDLP

**Processus de transaction :**

Chaque dépense/transmission nécessite :

- Signature avec la **clé privée du détenteur** actuel
- Le détenteur était le destinataire de la transaction précédente
- Chaque transaction forme une chaîne d'authentification

**Avantages ECDSA :**

- Clés plus courtes pour sécurité équivalente
- Calculs plus efficaces
- Adapté aux contraintes des blockchains

::: {.callout collapse=true}
## Texte original

La plupart des crypto-monnaies se basent sur la cryptographie asymétrique. Le bitcoin p.ex. utilise des signatures digitales pour authentifier ses transactions.

La dépense ou la transmission de bitcoins nécessite la signature avec la clé privée du détenteur (qui était à son tour le destinataire de la transaction précédente).

Bitcoin et Ethereum utilisent l'algorithme **ECDSA (Elliptic Curve Digital Signature Algorithm)** dérivé de algorithme de signature de ElGamal sur les courbes elliptiques dont la sécurité repose sur ECDLP.

[Image : Schéma montrant la chaîne de transactions Bitcoin avec signatures]

Source Image : Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto
:::

::: {.callout collapse=true}
## Révision rapide

**Crypto-monnaies :** Bitcoin/Ethereum utilisent **ECDSA** (ElGamal sur courbes elliptiques).

Chaque transaction signée avec clé privée détenteur.

Sécurité basée ECDLP.
:::

---

## Tableau Récapitulatif des Schémas

| Classe | Schéma | Message Recovery | Problème de base |
|--------|---------|------------------|------------------|
| **Signatures Classiques** | RSA | Oui | RSAP |
| | Rabin | Oui | SQROOTP |
| | ElGamal | Non | DLP |
| | DSS | Non | DLP |
| **One-time Signatures** | Lamport | Non | dépend de la OWF |
| | Bos-Chaum | Non | dépend de la OWF |
| **Undeniable Signatures** | Chaum-van Antwerpen | Non | DLP |
| **Fail-Stop Signatures** | van Heyst-Pedersen | Non | DLP |
| **Blind Signatures** | Chaum | Oui | RSAP |

::: {.callout collapse=true}
## Texte original

[Tableau complet avec toutes les informations ci-dessus]

Le fonctionnement des procédés de signature One-time, Undeniable et Fail-Stop peut être consulté dans [Men97].
:::

::: {.callout collapse=true}
## Révision rapide

**Signatures classiques :**

- RSA/Rabin (recovery)
- ElGamal/DSS (appendice)

**Spécialisées :**

- One-time
- Undeniable
- Fail-Stop
- Blind

Problèmes base : RSAP, SQROOTP, DLP, dépend de la OWF.
:::

---

## Types d'Attaques

**Critères pour "casser" un schéma :**

- **Total Break** : Calculer la clé privée ou algorithme efficace de génération
- **Falsification sélective** : Générer signature pour message/classe fixé(e)
- **Falsification existentielle** : Forger au moins une signature (sans contrôle du message)

**Attaques de base :**

- **Key-only** : Seule la clé publique est connue
- **Known-messages** : Accès à signatures de messages connus
- **Chosen-messages** : Attaquant choisit messages à signer
- **Adaptive chosen-messages** : Choix dépend des réponses précédentes

Ces attaques sont équivalentes aux attaques sur systèmes d'encryption (known/chosen-plaintext/ciphertext) mais appliquées aux messages.

::: {.callout collapse=true}
## Texte original

**Critères pour "casser" un schéma de signature digitale :**

- **Total Break** : Calculer la clé privée du signataire ou un algorithme efficace (polynomial) pour générer des signatures.
- **Falsification sélective (selective forgery)** : L'adversaire est capable de générer une signature valide pour un message (ou une classe de messages) fixé.
- **Falsification existentielle (existential forgery)** : L'adversaire est capable de forger une signature pour (au moins) un message (dont il n'a pas le contrôle).

**Attaques de base :**

- **Attaques key-only** : L'adversaire a seulement connaissance de la clé publique du signataire.
- **Attaques basées sur les messages** : L'adversaire a accès à des signatures correspondantes à des :
  - known-messages
  - chosen-messages
  - adaptive chosen-messages

Equivalents à des attaques x-ciphertext mais avec des messages !
:::

::: {.callout collapse=true}
## Révision rapide

**Casser signature :**

- Total break (clé privée)
- falsification sélective (message fixé)
- existentielle (un message)

**Attaques :**

- key-only
- known/chosen/adaptive-chosen-messages.
:::