# Fundamental Security Services

Security services are the objectives aimed at protecting a system.

* **Confidentiality**: Protection against unauthorized disclosure.
* **Integrity**: Protection against unauthorized modification.
* **Availability**: Guarantee of access for legitimate users.
* **Authentication**:

  * *Entity authentication*: Certifying the identity of an actor.
  * *Data origin authentication*: Certifying the source of data.
* **Non-repudiation**: Inability to deny a transaction.
* **Non-duplication**: Protection against illicit copying.
* **Anonymity**: Preservation of identity or source.

::: {.callout collapse="true"}

#### Original version

* **Confidentiality**: Protection of information from unauthorized disclosure.
* **Integrity**: Protection against unauthorized modification of information.
* **Availability**: Ensuring that resources are accessible to legitimate users.
* **Authentication**:

  * **Entity authentication** *(entity authentication)*: Process allowing one entity to be certain of the identity of a second entity, supported by corroborating evidence (e.g., physical presence, cryptographic, biometric, etc.). The term identification is sometimes also used for this service.
  * **Data origin authentication** *(data origin authentication)*: Process allowing one entity to be certain that a second entity is the original source of a set of data. By definition, this service also ensures the integrity of the data.
* **Non-repudiation**: Guarantees that an entity cannot deny being involved in a transaction.
* **Non-duplication**: Protection against illicit copying.
* **Anonymity (entity or data origin)**: Preserves the identity of an entity, the source of information, or a transaction.

:::

---

# Summary: Services, Threats, and Protection Mechanisms

| Security Services         | Threats and Attacks (*Italic*)                             | Classic Mechanisms                          | Digital Mechanisms                                            |
| :------------------------ | :--------------------------------------------------------- | :------------------------------------------ | :------------------------------------------------------------ |
| **Confidentiality**       | Information leakage, *eavesdropping*, traffic analysis     | Seals, safes, padlocks                      | Encryption, logical authorization                             |
| **Integrity**             | Modification, *tampering*, illicit creation or destruction | Special ink, holograms                      | One-way functions + encryption                                |
| **Availability**          | *Denial of Service (DoS)*, viruses, illicit use            | Physical access control, video surveillance | Logical access control, audit, antivirus                      |
| **Entity Authentication** | Unauthorized access, password theft, protocol flaw         | Presence, voice, ID card, biometrics        | Secret + protocol, network address + userid, smart card + PIN |
| **Data Authentication**   | Falsification of information or signature                  | Seals, signature, fingerprint               | One-way functions + encryption                                |
| **Non-repudiation**       | Denying a transaction (*repudiation*), claiming key theft  | Seals, notary signature, registered mail    | One-way functions + encryption + digital signature            |
| **Non-duplication**       | Duplication, falsification, imitation                      | Special ink, holograms, tagging             | Digital watermarking, cryptographic locking                   |
| **Anonymity**             | Identification, transaction analysis, tracing              | Voice scramblers, disguise, cash            | *Mixers*, *remailers*, e-money, *deep web*                    |

::: {.callout collapse="true"}

#### Original version

## Threats and Attacks: Summary

| Services                  | Threats                              | Attacks                                                           |
| :------------------------ | :----------------------------------- | :---------------------------------------------------------------- |
| **Confidentiality**       | Information leakage                  | Unauthorized eavesdropping, traffic analysis                      |
| **Integrity**             | Information modification             | Illicit creation, alteration, or destruction                      |
| **Availability**          | Denial of service, illicit use       | Viruses, repeated access attempts to disable a system             |
| **Entity Authentication** | Unauthorized access                  | Password theft, authentication protocol flaw                      |
| **Data Authentication**   | Information falsification            | Signature forgery, protocol flaw                                  |
| **Non-repudiation**       | Denying involvement in a transaction | Claiming key theft or signature protocol flaw                     |
| **Non-duplication**       | Duplication                          | Falsification, imitation                                          |
| **Anonymity**             | Identification                       | Transaction analysis, unauthorized access enabling identification |

## Protection Mechanisms

| Services                  | Classic Mechanisms                                  | Digital Mechanisms                                                           |
| :------------------------ | :-------------------------------------------------- | :--------------------------------------------------------------------------- |
| **Confidentiality**       | Seals, safes, padlocks                              | Encryption, logical authorization                                            |
| **Integrity**             | Special ink, holograms                              | One-way functions + encryption                                               |
| **Availability**          | Physical access control, video surveillance         | Logical access control, audit, antivirus                                     |
| **Entity Authentication** | Presence, voice, ID card, biometric recognition     | Secret + authentication protocol, network address + userid, smart card + PIN |
| **Data Authentication**   | Seals, signature, fingerprint                       | One-way functions + encryption                                               |
| **Non-repudiation**       | Seals, signature, notary signature, registered mail | One-way functions + encryption + digital signature                           |
| **Non-duplication**       | Special ink, holograms, tagging                     | Digital watermarking, cryptographic locking                                  |
| **Anonymity**             | Voice scrambler, disguise, cash                     | Mixers, remailers, e-money, deep web                                         |

:::
---

# Internet-Related Risks

## Malware Delivered via E-Mail

* Also called **malware**.
* Emails designed to **trigger an action** (open attachment or click a link).
* Often **personalized** using **social engineering**.
* **Main consequences:**

  * Malware installation (*ransomware*, *keyloggers*, etc.).
  * **Loss or theft of personal data**.
  * **System hijacking** and **malware propagation**.

::: {.callout collapse="true"}

#### Ultra-summary

* Malware spread by email
* Prompting clicks or opens
* Social engineering
* Data theft, loss, hijacking
:::

::: {.callout collapse="true"}

#### Original version

## Malware Delivered via E-Mail

* Also called **malware**.
* Emails designed to **incite the recipient** to **open an attachment** or **follow a link** containing ads, offensive info, risky programs, etc.
* Often targeted based on victim interests (preliminary social engineering).
* **Consequences:**

  * Malware installation (*ransomware*, *keyloggers*, etc.) on victim systems (*computer*, *tablet*, *smartphone*, *smartwatch*, etc.).
  * Data destruction.
  * Theft of personal information or data.
  * System hijacking for malicious purposes (e.g., illegal bitcoin mining).
  * Malware propagation (potentially to other users).
:::

## Malware Delivered via Web

* Method called ***drive-by download***: **automatic infection when visiting a website**.
* Sources can be:

  * A **malicious website**
  * A **compromised legitimate site** (e.g., *cross-site scripting*).
* **User caution** greatly reduces this propagation method.
* **Impacts are similar** to email-borne infections.
* **Script restriction** (*Java/JavaScript*) reduces risk but can **affect browsing**.

::: {.callout collapse="true"}

#### Ultra-summary

* *Drive-by download* = infection without user action
* Malicious or compromised sites
* Awareness + restricted scripts = protection
:::

::: {.callout collapse="true"}

#### Original version

## Malware Delivered via Web

* Often called ***drive-by download***, allows **infecting the system** (*computer*, *tablet*, *smartphone*, *smartwatch*, etc.) **simply by visiting a website**.
* Sources may be:

  * Malicious site containing malware
  * Legitimate website previously infected (e.g., *cross-site scripting*). Infection may only affect certain pages.
* User awareness (avoiding suspicious sites) reduces the effectiveness.
* Consequences are similar to email infections.
* Restricted script execution (*Java/JavaScript*) in browsers can limit infection but may constrain navigation.
:::

## Phishing

* Technique to **collect private information** through **indiscriminate fishing**.
* ***Phishing*** can be:

  * **General** (broad targeting)
  * **Targeted** (*spear phishing*) for a specific person or organization.
* Main vector: **forged email address**, hard to detect.
* Goal: obtain **sensitive data** (credentials, passwords, personal or banking info).
* Attacks use **credible or threatening pretexts** to prompt victim cooperation.

::: {.callout collapse="true"}

#### Ultra-summary

* Information theft by deception
* Forged emails
* *Spear phishing* = targeted attack
* Urgent or threatening pretexts
:::

::: {.callout collapse="true"}

#### Original version

## Phishing

* The word ***phishing*** comes from English ***"password"***, ***"harvesting"***, and ***"fishing"***.
* Shows the technique’s main goal: **collect as much private info** via indiscriminate fishing.
* Targeted attacks are called ***spear phishing*** (from *spear fishing*).
* Transmission vector: email with **forged sender address** requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.
* Pretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored.
:::

## Spam

* **Unwanted emails**, often ads, or **unsolicited pop-ups** during web browsing.
* Represent about **60% of global emails**.
* Main consequences:

  * **Resource consumption** and time loss.
  * Some can **transmit malware**.
* Often target short addresses or come from **sold/exchanged address lists**.
* **Anti-spam filters** incur **significant costs** for organizations.

::: {.callout collapse="true"}

#### Ultra-summary

* Unwanted emails/ads
* Risks: time/resource loss, malware
* Targeting: short addresses or lists
* Filtering costly for organizations
:::

::: {.callout collapse="true"}

#### Original version

## Spam

* Includes all **unwanted emails** (often ads) received by people and organizations.
* Also applies to **pages/pop-up windows** **shown without user consent** during web browsing.
* Around **60%** of global emails belong to this category.
* Consequences: resource consumption and wasted time, but some spam can also **transmit malware**.
* Often target short email addresses or list-based addresses (sold/exchanged).
* **Anti-spam filtering** incurs high organizational costs.
:::

## Ransomware

* Trojan-type malware that **encrypts data** to make it inaccessible.
* Demands a **ransom** (often in bitcoins) to recover files.
* Can remain **dormant**, triggered by an event or date.
* Main vector: **malicious emails**.
* Other effects: **DoS attacks, extortion**.

::: {.callout collapse="true"}

#### Ultra-summary

* Data encrypted by Trojan
* Ransom to restore access
* Possible programmed dormancy
* Infection via malicious emails
:::

::: {.callout collapse="true"}

#### Original version

## Ransomware

* Trojan malware family.
* Typically **encrypts victim’s data** to make it completely inaccessible.
* Then displays a message requesting **ransom payment** (often in **bitcoins**).
* May stay in **dormant state** triggered by event or date.
* Infection vectors vary, but **malicious email attachments** often responsible.
* Variants exist and continue to evolve.
* Other behaviors: **DoS, targeted extortion, threats**, etc.
:::

## Attacks on ***Internet of Things (IoT)*** Devices

* Target **connected objects** (cameras, TVs, sensors, alarms, etc.).
* Devices are **easy to compromise** due to:

  * **Known vulnerabilities**
  * **Default passwords**
  * **User unawareness**
* **Remote control** enables:

  * **Entry point** to the network
  * **Device abuse** for illicit activities (DDoS, hacking, mining)
* A **precise inventory** of connected devices is essential.

::: {.callout collapse="true"}

#### Ultra-summary

* Targets connected objects
* Weak security (vulnerabilities, default passwords)
* Risk of network access and abuse
* IoT inventory needed
:::

::: {.callout collapse="true"}

#### Original version

## Attacks on IoT Devices

* Target connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).
* Often **easier to hack** than traditional systems due to:

  * Many vulnerabilities known to attackers
  * Default passwords
  * User negligence
* Remote takeover allows:

  * Entry point to home/corporate network
  * Device use for illicit activities (hacking, DDoS, bitcoin mining)
* Maintaining a detailed directory of all connected devices is necessary.
:::

## Information Spoofing and Website Defacement

* Attacks aiming to **alter information** on websites and social media.
* Impact: **compromised reputation** and **economic damage**.
* Websites: secure host system, restrictive configuration, **regular audits**.
* Social media: strong passwords, **multi-factor authentication**, session closure, cookie deletion.

::: {.callout collapse="true"}

#### Ultra-summary

* Altered info on websites and social media
* Risks: reputation, economic losses
* Websites: security + audits
* Social media: strong passwords, MFA, closed sessions, cookies cleared
:::

::: {.callout collapse="true"}

#### Original version

## Information Spoofing and Website Defacement

* Target **integrity** of published info on websites and social media.
* Affects **reputation** and can cause **economic damage**.
* **Websites**: secure host system, as restrictive configuration as possible, recurring security audits recommended.
* **Social media**: depends on authentication process:

  * Avoid simple passwords
  * Prefer strong, possibly multi-factor authentication
  * Close sessions properly
  * Clear cookies
:::

## Denial of Service (DoS / DDoS) Attacks

* Aim to **make IT systems inaccessible**, especially for organizations.
* **DDoS**: distributed attack using thousands of devices, generating massive traffic.
* Classic protections (*firewalls*, IDS/IPS sensors) often **insufficient**.
* Consequences:

  * **Affected reputation**
  * **Financial losses** (sometimes ransom)
  * **High risk for critical infrastructure** (hospitals, power plants, Internet backbone)

::: {.callout collapse="true"}

#### Ultra-summary

* DDoS = inaccessible systems via massive attacks
* Limited protections
* Risks: reputation, finances, critical infrastructures
:::

::: {.callout collapse="true"}

#### Original version

## Denial of Service (DoS / DDoS) Attacks

* Aim to **render IT systems inaccessible**, mainly targeting private or governmental organizations.
* **DDoS** (*Distributed Denial of Service*): multiple devices (**often tens of thousands**) simultaneously target victim system(s).
* Traffic can reach several hundred Gbps.
* Traditional protection (*firewalls*, *intrusion detection/prevention sensors*) has limited effectiveness.
* Service unavailability can cause:

  * **Reputational issues**
  * Significant **financial losses** (ransom demands)
  * **High security risks (even physical)** for **critical infrastructures** (hospitals, power plants, Internet backbone).
:::

# Digital Security Methods

**Problem:** Protecting digital information

* in a distributed environment
* globally accessible
* without physical boundaries

**Solution:**

* Cryptography
    * Symmetric
    * Asymmetric
    * $+$ One-way functions
    * $+$ (Pseudo) random generators

::: {.callout collapse="true"}
#### Ultra-summary
- **Problem:** Security in a distributed/global environment.
- **Solutions:**
  - Crypto (symmetric/asymmetric).
  - One-way functions (hashing).
  - Random generators (physical/pseudo).
:::

::: {.callout collapse="true"}
#### Original version

**Problem:** Protecting digital information

* in a distributed environment
* globally accessible
* without physical boundaries

**Solution:**

* Cryptography
    * Symmetric
    * Asymmetric
    * $+$ One-way functions
    * $+$ (Pseudo) random generators
:::

---

## Cryptographic Hash Functions

* **Functions easy to compute in one direction but virtually impossible to reverse**.
* Any modification of the source document radically changes the **digest** (avalanche effect).
* **Key properties**:
  - **One-way**: impossible to retrieve the input from the hash.
  - **Collision-free**: impossible to find two inputs with the same hash.
* Digest size: 160 to 512 bits.
* Algorithms (very **performant**): SHA-1, SHA-256, SHA-3.

::: {.callout collapse="true"}
#### Ultra-summary
- **One-way + collision-free**.
- Size: 160-512 bits.
- Algos: SHA-1/256/3.
- Usage: integrity, signatures.
:::

::: {.callout collapse="true"}
#### Original version

* **Functions easy to compute in one direction but virtually impossible to compute in the reverse direction**.
* Any modification (even insignificant) of the source document results in a fundamentally different **digest**.
* It is virtually impossible to retrieve the source document using only the digest (**one-way**).
* It is virtually impossible to find a second source document producing the same digest (**collision-free**).
* Usual digest length: 160 to 512 bits.
* One-way algorithms are very performant.
* Examples: SHA-1, SHA-256, SHA-3, etc.
:::

---

## (Pseudo) Random Generators

* **Characteristics**
    * **random**
    * **unpredictable**
    * **non-reproducible**
* **Critical** for security (keys, IV, secrets).
* **Types**:
  - **True random**: based on physical phenomena (radioactivity, quantum).
  - **Pseudo-random**: deterministic (based on a *seed*: initial random sequence).
* **Risk**: "Pseudo-security" if the *seed* is predictable (Pitkin quote).
* Applications: session keys, IV (DES-CBC), signatures (ElGamal).

::: {.callout collapse="true"}
#### Ultra-summary
- **True random**: physical (quantum).
- **Pseudo-random**: deterministic (*seed*).
- **Risk**: predictable *seed* = vulnerability.
- Uses: keys, IV, signatures.
:::

::: {.callout collapse="true"}
#### Original version

* Random number generation is a very important process that can compromise the security of many encryption systems.
* Applications: session key generation, initialization vectors (DES - CBC mode), secrets for signatures (ElGamal), etc.
* A **random generator** is a device capable of generating numbers in a **random**, **unpredictable** and **non-reproducible** way. (e.g. based on physical phenomena: radioactive or quantum source).
* **Pseudo-random generators** are deterministic processes developed from an initial random sequence (**seed**) (e.g. user keystrokes, disk access).
* *Quote:* R. Pitkin in [Kau95]: "The use of pseudo-random processes to generate secret quantities can result in pseudo-security"
:::

---

## Symmetric Cryptography

* **History**: Used since Julius Caesar (1st century BC).
* **Principle**: A single key for encryption/decryption.
* **Scheme**: Plaintext → Encryption (Key) → Ciphertext → Decryption (Key) → Plaintext.
* **Characteristics**:
  - Algorithms: AES, DES, IDEA, RC4.
  - Services: Confidentiality, Authentication, Integrity.
  - **Limit**: No signatures (shared key).
  - **Problem**: Secure key exchange required.

::: {.callout collapse="true"}
#### Ultra-summary
- **1 key** to encrypt/decrypt.
- **Fast** (AES, DES).
- **Problem**: key exchange.
- Uses: personal documents, closed groups.
:::

::: {.callout collapse="true"}
#### Original version

* Also called conventional cryptography or secret key cryptography (1st century BC, Julius Caesar).
* **Idea:** Based on a single secret key, perform a transformation capable of respectively making information unreadable and restoring it.
* **Scheme:** Plaintext $\to$ Encryption (Key) $\to$ Ciphertext $\to$ Decryption (Key) $\to$ Plaintext.
* **Characteristics:**
    * Algorithms: AES, DES, IDEA, RC4, RC5, etc. (some are free and openly available)
    * Services: Confidentiality, Authentication, Integrity.
    * No direct support for digital signatures (because key known by both).
    * Requires a confidential channel to exchange the key.
    * Ideal for protection of personal documents or closed groups.
:::

---

## Asymmetric Cryptography

* Also called **public cryptography** (1976, Diffie & Hellman).
* **Principle**
    - Key pair (public/private) for encryption and signatures.
* **Two main uses**:
  1. **Confidentiality**:
     - Encryption: recipient's public key
     - Decryption: recipient's private key
  2. **Digital signature**:
     - Signature: sender's private key
     - Verification: sender's public key
     - *Optimization*: Generally sign the **hash** of the document
     - **Fundamental properties**:
       - **Integrity**: Any modification invalidates the signature
       - **Non-collision**: Impossible to have 2 documents with the same signature
       - **Non-repudiation**: Only the holder of the private key can sign

* **Technical aspects**:
  - **Algorithms**: RSA, ElGamal
  - **Services**: Integrity, Authentication, Non-Repudiation
  - **Performance**: much slower than symmetric (100x slower)
  - **Advantage**: No need for a confidential channel for key exchange

::: {.callout collapse="true"}
#### Ultra-summary
- **2 keys**: public (encrypt/verify) + private (decrypt/sign)
- **2 uses**:
  - Confidentiality: encrypt for a recipient
  - Signature: prove authenticity
- **Signatures**:
  - Integrity + non-repudiation
- **Algorithms**: RSA/ElGamal
- **Advantage**: No need for secure channel to exchange keys
- **Disadvantage**: Slow
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography
* Also called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).
* **Idea:** Use two different keys - one **secret** and one **public** - respectively for encryption and decryption operations.
* Each user has a **keyring**.

**Confidentiality:**
* Sender encrypts with the **recipient's public key**.
* Recipient decrypts with their **private key**.
* Only the recipient's key is used!

**Digital Signature:**
* Sender signs with their **private key**.
* Recipient verifies with the **sender's public key**.
* Only the sender's key is used!
* *Note:* Generally sign the **digest** of the document (hash) for performance reasons.

**Signature characteristics:**
* The signature changes if the document changes, while the private key remains the same.
* If the document or signature is modified, verification fails (**integrity guaranteed**).
* It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function **without collisions**).
* Only the holder of the private key can generate a signature verifiable using the corresponding public key (**non-repudiation**).
* **Algorithms**: RSA, ElGamal.
* **Services**: Integrity, Authentication, Non-Repudiation.
* **Slowness**: Up to 50 times slower than symmetric cryptography.
* **Advantage**: No need for a confidential channel to exchange keys (unlike symmetric).
:::


---

## Asymmetric + Symmetric Cryptography (Hybrid)

* **Principle**: Use asymmetric to exchange a symmetric key (session key).
* **Steps**:
  1. A generates a random symmetric key $K_s$.
  2. A encrypts $K_s$ with B's public key.
  3. A and B then communicate using $K_s$ (symmetric).

::: {.callout collapse="true"}
#### Ultra-summary
- **Asymmetric**: exchange of symmetric key.
- **Symmetric**: data encryption.
- **Advantage**: combines security + performance.
:::

::: {.callout collapse="true"}
#### Original version

* **Idea:** Use public cryptography only to exchange symmetric keys (Session keys).
* A generates a random key $K_s$ and transmits it to B by encrypting it with B's public key.
* A & B then communicate using $K_s$ (symmetric).
:::

---

## Asymmetric Cryptography: Operation (RSA)

### Key Construction
1. **Choice of prime numbers**:
   - $p$ and $q$: two large prime numbers (> 1024 bits)
   - $n = pq$: RSA modulus (size = 2048+ bits)

2. **Calculation of Euler's totient function**:
   - $\phi(n) = (p-1)(q-1)$
   - *Property*: For any $a$ coprime with $n$, $a^{\phi(n)} \equiv 1 \pmod{n}$

3. **Selection of exponents**:
   - $e$: integer coprime with $\phi(n)$ (public exponent)
   - $d$: modular inverse of $e$ (private exponent), such that $ed \equiv 1 \pmod{\phi(n)}$

### Encryption/decryption process
* **Public key**: $(n,e)$
* **Private key**: $(d)$
* **Encryption**: $C = P^e \pmod{n}$
* **Decryption**: $P = C^d \pmod{n}$

### Mathematical proof
1. **Fundamental congruence**:
   - $ed = 1 + k\phi(n)$ (by definition of $d$)

2. **Application of Euler's theorem**:
   - $P^{\phi(n)} \equiv 1 \pmod{n}$ (if $P$ coprime with $n$)

3. **Demonstration**:

   \begin{align*}
   (P^e)^d &\equiv P^{ed} \pmod{n} \\
   &\equiv P^{1 + k\phi(n)} \pmod{n} \\
   &\equiv P \cdot (P^{\phi(n)})^k \pmod{n} \\
   &\equiv P \cdot 1^k \pmod{n} \\
   &\equiv P \pmod{n}
   \end{align*}

### System security
* **Hard problem**: Factorization of $n$ into $p$ and $q$
* **Recommended size**:
  - $n$: 2048 bits (minimum for current security)
  - $p$ and $q$: 1024+ bits each
* **Known vulnerabilities**:
  - Side-channel attacks (timing, power analysis)
  - Inappropriate parameter choices ($e$ too small, $p$ and $q$ too close)

::: {.callout collapse="true"}
#### Ultra-summary
- **Keys**:
  - Public: $(n,e)$ where $n = pq$
  - Private: $(d)$ with $ed \equiv 1 \pmod{\phi(n)}$
- **Operations**:
  - Encryption: $P^e \mod n$
  - Decryption: $C^d \mod n$
- **Security**: Factorization of $n$ difficult
- **Size**: 2048+ bits for $n$
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography: Operation (RSA)
* Let $n := pq$ with $p$ and $q$ two large prime numbers (> 1024 bits).
* Let $\phi(n) = (p-1)(q-1)$.
* Let $e$ and $d$ such that $ed \equiv 1 \pmod{\phi(n)}$.
* By definition of congruences: $ed = 1 + k\phi(n)$
* Euler's theorem: $a^{\phi(n)} \equiv 1 \pmod n$.
* **Encryption:** $C = P^e \pmod n$. **Public key:** $(n,e)$.
* **Decryption:** $P = C^d \pmod n$. **Private key:** $(d)$.
* *Proof:* $(P^e)^d \equiv P^{ed} \equiv P^{1 + k\phi(n)} \equiv (P \pmod n) (P^{\phi(n)} \pmod n)^k \equiv P \pmod n$.
:::


---

## Asymmetric Cryptography: Conclusions

* **Dominant algorithms**: RSA (most used), Rabin, ElGamal
* **Complete services**:
  - Confidentiality
  - Authentication
  - Integrity
  - Digital signature & Non-repudiation
  - Non-duplication

* **Performance**:
  - 50x slower than symmetric
  - **Optimal solution**: Combination of asymmetric (key exchange) + symmetric (encryption)

* **Key management**:
  - **Advantage**: Public key exchange without confidential channel
  - **Risk**: Need to verify authenticity of public keys
    - Authenticated acquisition channel **or**
    - Certification by trusted third party

::: {.callout collapse="true"}
#### Ultra-summary
- **Algos**: RSA (dominant), Rabin, ElGamal
- **Services**: Confidentiality + Authentication + Integrity + Signatures
- **Slowness**: 50x vs symmetric → **hybrid recommended**
- **Keys**: Simple public exchange but **authentication crucial**
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography: Conclusions

* There are a few asymmetric encryption systems (**Rabin**, **ElGamal**, etc.) but the most used is **RSA**.

* **Supported services**: **Confidentiality**, **Authentication**, **Integrity**, **Digital Signature & Non-Repudiation**, (**Non-Duplication**).

* Operations related to **asymmetric cryptography** are up to **50 times (!) slower** than those of **symmetric cryptography**.
  A **combination of the two methods** is often desirable.

* **Key distribution** is simplified by the fact that only **public keys** need to be exchanged between participants (no need for an alternative confidential channel) but…

* … it is necessary to **verify that the public key actually belongs to the recipient**:
  * Either the **acquisition channel** of the public key is protected against any modification (**authenticated**)
  * Or the key is **certified accurate by a third party**
:::

---

## Symmetric vs Asymmetric Comparison

### Comparative advantages

* **Symmetric**:
  - **Performance**: 100x faster
  - **Implementation**: Easy in hardware
  - **Keys**: Short (128 bits = 16 memorable characters)

* **Asymmetric**:
  - **Key exchange**: Authenticated channel sufficient (no need for confidentiality)
  - **Management**: 1 key pair for n correspondents (vs n keys in symmetric)

### Common issues

* **Weak link**: Key management by users
* **Security basis**: Empirical rather than theoretical
* **Legal constraints**: Usage and export restrictions

### Usage recommendations

| **Use case**                          | **Recommended solution**                          | **Justification**                                                                 |
|--------------------------------------|--------------------------------------------------|----------------------------------------------------------------------------------|
| Personal documents                    | Symmetric                                        | Speed + memorable keys                                                          |
| Groups of close users                 | Symmetric                                        | Speed + easy confidential exchange                                              |
| Distant/unknown users                 | Asymmetric                                       | No need for confidential channel                                                 |
| Remote transactions                  | Hybrid (Asymmetric + Symmetric)                 | Asymmetric for key exchange, symmetric for data                                 |
| Software protection (distribution)   | Hybrid                                           | Unique symmetric key per version, encrypted with asymmetric                    |
| Network segments                     | Symmetric                                        | Speed + controlled environment (easy key exchange between administrators)        |

::: {.callout collapse="true"}
#### Ultra-summary
**Symmetric**:

    ✅ Fast (100x)
    ✅ Short keys (128 bits)
    ❌ Confidential key exchange required

**Asymmetric**:

    ✅ Simplified key exchange
    ✅ 1 key pair for n correspondents
    ❌ Slow (50x)
    ❌ Long keys (1024+ bits)

**Hybrid**: Best of both worlds
**Common problems**: Key management, empirical basis, legal restrictions
:::

::: {.callout collapse="true"}
#### Original version
## Symmetric vs. Asymmetric Cryptography

* There are **hundreds of symmetric and asymmetric algorithms** capable of providing a sufficient level of **confidentiality**.

* **Symmetric solutions** offer the following advantages:
  * **Speed** (up to **100 times faster** than asymmetric solutions)
  * **Ease of hardware implementation**
  * **Reduced key length**: **128 bits** (= 16 characters ⇒ memorable!) instead of **1024 bits** for asymmetric equivalents.

* **Asymmetric solutions** have as main arguments:
  * **Simplified key exchange**: keys must be exchanged through an **authenticated but non-confidential channel**
  * **Simplified key management**: a single **public/private key pair** is sufficient for a user to receive confidential messages from **n users** (instead of **n different keys** in the symmetric case).

* **Problems common to both techniques**:
  * **Key management by the user** remains the **weakest link**
  * Security (normally) based on **empirical arguments** rather than **theoretical** ones
  * **Legal restrictions** on usage and export

## Symmetric vs. Asymmetric Cryptography (II)

| **Activity**                                                                                   | **Recommendation**                                                                                           | **Remarks**                                                                                                                              |
| --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| Protection of personal documents                                                             | **Symmetric crypto**                                                                                        | **Speed**, easily memorable keys                                                                                                  |
| Protection of documents in a group of close users                                            | **Symmetric crypto**                                                                                        | **Speed**, ease of exchanging confidential keys                                                                                   |
| Establishment of confidential channels between distant users (unknown)                       | **Asymmetric crypto**                                                                                       | No need to have a confidential channel: **authenticity suffices**                                                                         |
| Transactions between two distant users, Software protection (multicast distribution)         | **Asymmetric crypto for symmetric key protection** + **Symmetric crypto for data protection**              | **Speed**, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public |
| Protection of network segments                                                                | **Symmetric crypto**                                                                                        | **Speed**, Stable environment → easy confidential key exchange between sysadmins                                                   |
:::

# Dissection of an Attack: Ransomware

### Definition and Impact
* **Definition**: Malicious software that encrypts data and demands a ransom for its restoration.
* **Limitations of the classic definition**:
  - Does not cover the impact on **critical infrastructure** (e.g., Colonial Pipeline, May 2021)
  - Underestimates the **systemic scope** of attacks
* **Alarming statistics**:
  - Billions of annual attacks
  - Considered the **most dangerous cyber threat** in 2021 ("Ransomware Everywhere")

::: {.callout collapse="true"}
#### Ultra-summary
- **Malware**: Encrypts data → demands ransom
- **Impact**: Critical infrastructure (e.g., Colonial Pipeline)
- **Threat #1** in cybersecurity (2021)
- **Targets**: Individuals + businesses + states
:::

::: {.callout collapse="true"}
#### Original version
"Ransomware (from English **ransomware**), ransom software, extortion software, is malicious software that holds personal data hostage. To do this, ransomware **encrypts personal data** then asks their owner to send money in exchange for the **decryption key**" (Wikipedia September 21, 2021).

- **Incomplete definition** because **ransomware** affects a **vast spectrum of IT infrastructure**

- For example, in May 2021, a **ransomware attack** against the **Colonial Pipeline** company caused a **fuel supply disruption** for a large part of the US coast

- With a **total number of attacks** counted in **billions per year**, "**Ransomware Everywhere**" is globally considered the **most direct, visible and dangerous threat** for users and companies in 2021!
:::

---

## Ransomware Attack Lifecycle

### Prevention and Response
| Phase | Measures |
|-------|---------|
| **Prevention** | - Regular patching<br>- Detection solutions (Firewalls, WAFs, IDS/IPS)<br>- Anti-malware scans (emails, files) |
| **Protection** | - **Offline backups** (essential!)<br>- Strict security policies<br>- User training |
| **Response** | - **Do not pay** (official recommendation)<br>- Forensic analysis<br>- Restoration from backups |

### Technical Dissection
1. **Infection**:
   - Vectors: Phishing, exploits, vulnerable RDP
   - Propagation: Lateral (network) or vertical (system)

2. **Execution**:
   - Encryption of targeted files
   - Deletion of shadow copies
   - Persistence (registry, scheduled tasks)

3. **Extortion**:
   - Display of ransom demand
   - Payment in cryptocurrencies (Bitcoin, Monero)
   - Payment deadlines with penalties

4. **Obfuscation**:
   - Code obfuscation
   - Communication via TOR/Deep Web
   - Log erasure

::: {.callout collapse="true"}
#### Ultra-summary
**Attack cycle**:

1. Infection (phishing/exploits)
2. Execution (encryption + persistence)
3. Extortion (ransom in crypto)
4. Obfuscation (TOR + trace erasure)

**Countermeasures**:

    ✅ Offline backups
    ✅ Patching + detection
    ✅ Training
    ❌ Do not pay
:::

---

## Cryptolocker: Technical Analysis

### Attack Scheme

```{mermaid}
graph TD
    A[Initial infection] --> B[File encryption]
    B --> C[Private key storage on C2 servers]
    C --> D[Ransom demand]
    D --> E{Payment ?}
    E -->|Yes| F[Decryption key sent via TOR]
    E -->|No| G[Permanent data loss]
```

### Preferred Targets
* **Critical extensions** (extract):
  - Documents: `.docx`, `.xlsx`, `.pdf`, `.pptx`
  - Databases: `.mdb`, `.sql`, `.sqlite`
  - Media: `.jpg`, `.png`, `.mp4`, `.avi`
  - Development: `.java`, `.cpp`, `.py`, `.php`
  - Financial: `.qbw`, `.qbb`, `.wallet`

* **Behavior**:
  - **Selective** encryption (recent/modified files)
  - **Double extortion**: Encryption + threat of leakage
  - **RaaS** (Ransomware-as-a-Service): Economic model

::: {.callout collapse="true"}
#### Ultra-summary
**Mechanism**:
- Private key stored on C2 servers
- Payment → key via TOR
- Targets: 100+ extensions (docs, DB, media)

**Recent evolutions**:
- Double extortion (encryption + leakage)
- RaaS (ransomware rental)
:::

::: {.callout collapse="true"}
#### Original version
## Ransomware: Complete View

*(Source: 2017 State of Cybersecurity, F-Secure Inc.)*

## Ransomware: Complete View

#### Prevention, Remediation and Response
- **Patching**
- **Active and passive detection** (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)
- **Offline backups** !
- **Security Policy** - Rules for proper email usage
- **Training** !
- **To pay or not to pay**...

#### Technical Dissection of the Attack
- **Infection and propagation**
- **Execution**
- **Payment** (Crypto-currencies / Bitcoin)
- **Obfuscation** (Obfuscation, TOR Networks/Deep Web)

### Generic Scheme of a Cryptolocker Ransomware

- **Decryption private keys** are stored on the **attacker's** servers
- They are sent to the **victim** after **bitcoin payment**
- The **trace** is shredded using **TOR networks**

## Ransomware Cryptolocker: Targets

**Targeted file extensions**:
.jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb,
.asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg,
.jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads,
.agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl,
.bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw,
.cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml,
.php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw,
.dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf,
.dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray,
.grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key,
.kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3,
.mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg,
.nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf,
.ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd,
.pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps,
.psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat,
.raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql,
.sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg,
.swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2,
.wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw,
.ycbcra, .yuv

*Source: Intel Security Advanced Threat Research - http://www.intelsecurity.com*
:::

# Basic Cryptography Concepts

* Introduction to the **fundamental concepts** of cryptography.
* Presents **security principles**, **system types**, and **attack models**.
* Includes **historical systems** and complementary techniques.

## Kerckhoffs' Principle

* Fundamental principle: **security relies solely on the key**, not on the secrecy of the algorithm.
* The system must remain **secure even if the algorithm is public**.
* The key must be **easily modifiable** and the system **simple to use**.
* Explicit rejection of **security through obscurity**.

::: {.callout collapse="true"}
#### Ultra-summary
- Security based on the key
- Public algorithm
- No security through obscurity
:::

::: {.callout collapse="true"}
#### Original version
## Kerckhoffs' Principle

**Auguste Kerckhoffs** published in **1883** two articles defining **six principles** for military ciphers:

1. The system must be **practically, if not mathematically, undecipherable**.
2. It must **not require confidentiality** and remain secure even if it falls into enemy hands.
3. The **key** must be able to be **memorized, transmitted and modified easily**, without written notes.
4. The system must be **compatible with telegraphic communications**.
5. It must be **portable** and usable by **a single person**.
6. It must be **simple to use**, without complex procedures or excessive constraints.

Kerckhoffs stated as early as the **19th century** that security must be **mathematically demonstrable** and that **there is no security through obscurity**.
:::

## Classification of Encryption Systems

### Unconditional Security

(*unconditional security* / *perfect secrecy*)

* Security **independent of computing power**.
* **Ciphertext** provides no information about the **plaintext**.
* Conditions: **key ≥ message**, **never reused**.
* Mostly **theoretical** use.
* **Example**: *one-time pad*.

### As hard as / equivalent / provable security

* Cryptanalysis **as difficult** as a **hard mathematical problem**.
* **RSA** and **Rabin** proven equivalent to factorization.
  * Demonstrated by **reduction** (*reduction proof*).
* Central but **controversial** concept.

### Computational Security

(*computational security* / *practical security*)

* Security based on **unrealistic cost of attacks**.
* Most used category in practice.
* **Examples**: **AES**, **DES**, **IDEA**, **RC4**.

::: {.callout collapse="true"}

#### Ultra-summary

* **Unconditional**: perfect, theoretical (*one-time pad*).
* **Provable security**: equivalence to hard mathematical problem.
* **Computational**: secure in practice.
:::

::: {.callout collapse="true"}

#### Original version

* **Unconditional security** (*unconditional security also called **perfect secrecy***):

  * The security of the encryption system **is not compromised by the computing power** intended for cryptanalysis.
  * This category relies on **information theory** published by **Shannon in 1949**.
  * More precisely, an encryption system is **unconditionally secure** if the probability of encountering a **plaintext x** after observing the **corresponding ciphertext y** is identical to the a priori probability of encountering plaintext x.
  * In other words, having **plaintext/ciphertext pairs (x,y)** provides **no help for cryptanalysis**.
  * A necessary condition for a system to be unconditionally secure is that the **key be at least the same size as the message** and, above all, that it **not be reused** to encrypt different messages.
  * This condition makes these systems **poorly suited to usual cryptographic needs** and reduces their domain of interest to a **theoretical framework**.
  * The classic example is the **one-time pad** invented in **1917** by **J. Mauborgne** and **G. Vernam**.
  * Theoretical foundations of unconditionally secure systems + other examples in **[Sti06]**.

* **As hard as / equivalent / provable security**

  * When it can be proven that cryptanalyzing the algorithm is **as difficult as solving a reputedly hard mathematical problem**.
  * For example **factorization of large numbers**, calculation of **square roots modulo a composite**, calculation of **discrete logarithms in a finite group**, etc.
  * The **Rabin** and **RSA** algorithms (generic case^1) are "proven" **equivalent to factorization**.
  * Such a proof is called a "reduction" (**reduction proof**).
  * The notion of **provable security** is at the origin of an **important controversy** in the cryptographic world.

* **Computational security** (*computational security also called **practical security***)

  * An encryption system is in this category if the **computational effort needed to "break" it** using the best possible techniques is **beyond** (with a reasonable margin) the computing resources of a hypothetical adversary.
  * The vast majority of symmetric encryption systems (**AES, DES, IDEA, RC4**, etc.) are in this category.
:::

## Entropy

* **Entropy** (Shannon, 1948) measures the **effective amount of information** contained in a message.
* **Conditional entropy** measures the uncertainty that remains about the **plaintext** after observing the **ciphertext**.

### Properties

* $0 \le H(X) \le \log n$
* $H(X) = 0$ → no uncertainty
* $H(X) = \log n$ → all outcomes equally probable

### Interpretation

* Approximates the **number of bits needed** to encode $X$.
* **Redundancy** = difference between effective encoding and entropy.

### Conditional Entropy

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$
* Measures the remaining uncertainty about the **plaintext** after observing the **ciphertext**.

---

::: {.callout collapse="true"}

#### Ultra-summary

* **Entropy**: amount of information in a message.
* **Conditional entropy**: uncertainty about plaintext after ciphertext.
* **Redundancy**: difference between effective encoding and entropy.
:::

::: {.callout collapse="true"}

#### Original version

* An essential definition in cryptography is the **effective** amount of information contained in a message.
* For example, days of the week (*Monday*, ..., *Sunday*) can intuitively be encoded as character strings of length ($\le \text{len}(\text{``Wednesday''})$), i.e., $(8 \times 8 = 64)$ bits. However, the effective amount of information of the variable *day of the week* can be optimally encoded on **3 bits** (since $(2^3 = 8)$ is sufficient to represent the 7 possible variations).
* **Entropy** (Shannon, 1948) is the mathematical formalization of this definition.

### Formal Definition

Let $X$ be a random variable with a finite set of possible values ${x_1, x_2, \dots, x_n}$, such that $P(X=x_i) = p_i$, with $0 \le p_i \le 1$ and $\sum p_i = 1$.
The entropy of $X$, denoted $H(X)$, is defined by

$H(X) = - \sum_{i=1}^{n} p_i \log p_i = \sum_{i=1}^{n} p_i \log \left(\frac{1}{p_i}\right)$

By convention: $p_i \log p_i = 0$ if $p_i = 0$. All logarithms are in **base 2**.

### Interpretation

* Approximation of the number of bits needed to encode the elements of $X$.
* **Redundancy** is the difference between the effective encoding and entropy.

### Properties

1. $0 \le H(X) \le \log n$
2. $H(X) = 0 \iff \exists i : p_i = 1, p_j = 0 \ \forall j \ne i$
3. $H(X) = \log n \iff p_i = 1/n \ \forall i$

### Conditional Entropy

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$,
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$

*Measures the uncertainty about $X$ (plaintext) after having observed $Y$ (ciphertext).*
:::

## Attacks on Encryption Systems

* **Ciphertext-only**: Adversary has only the **ciphertext**.
* **Known-plaintext**: Adversary has **plaintext/ciphertext pairs**.
* **Chosen-plaintext**: Adversary **chooses** the **plaintext** and see the ciphertext (and tries to find the plaintext for other messages).
* **Adaptive chosen-plaintext**: **depends on** the **received** ciphertexts.
* **Chosen-ciphertext**: Adversary **chooses** the **ciphertext** and obtains the plaintext (aims to find the key).
* **Adaptive Chosen-ciphertext**: **Chosen-ciphertext** depends on the received plaintexts.

## Oracles and Security Models

### Random Oracles and Security Models

* **Random Oracle**: A theoretical "perfect" function that returns a uniform and random value for each new input, but remains deterministic for an input already seen.
* **ROM (Random Oracle Model)**: Mathematical proof framework using this ideal oracle as a substitute for hash functions.
* **Standard Model**: Framework where security relies solely on the adversary's computing power against real algorithms.
* **Limit**: A security proof in ROM does not guarantee absolute security in the real world (with SHA-256, etc.).

::: {.callout collapse="true"}
#### Original version
A **random oracle** is an abstract entity accessible to legitimate parties and adversaries.

* **Behavior**: It responds to input queries $x$ with perfectly random responses $Orc(x)$. 
* **Determinism**: The only exception lies in previously processed inputs ($x_1, x_2, \dots, x_n$). If $x_1' = x_1$, then $Orc(x_1') = Orc(x_1)$.
* **Modeling**: It is modeled by a function $Orc : X \to Y$ where $\forall x \in X, \Pr(Orc(x) = y) = \frac{1}{|Y|}$.
* **Utility**: It behaves like an **"ideal" cryptographic hash function**, a valuable tool for proving security in the **Random Oracle Model**. 
* **Comparison**: The **standard model** limits adversaries by computational factors. A protocol secure in the random oracle model can become vulnerable if used with a "real" hash function (SHA-1, SHA-256).
:::

---

### Encryption, Decryption and Signature Oracles

* **Function**: Entities that perform operations (encrypt/sign) for the adversary using secret keys without ever revealing them.
* **Symmetric cryptography**: The oracle provides $E_k(x)$ or $D_k(y)$.
* **Asymmetric cryptography**: The oracle is crucial for private operations (decryption/signature), as public operations are already freely accessible.

::: {.callout collapse="true"}
#### Original version: Operational Oracles
An **encryption/decryption/signature oracle** is an abstract entity offering an "on-demand" service.

* **Key access**: It uses the **same keys as the legitimate owners** (symmetric and asymmetric systems) without disclosing them.
* **Symmetric primitives**: For a primitive $E$ and a key $k$, it returns $y = E_k(x)$ or the corresponding plaintext $x$.
* **Public key systems**: The oracle is only needed for operations with the **private key** ($priv_k$).
    * **Decryption**: returns $x$ such that $E'_{pubk}(x) = y$.
    * **Signature**: For a system $S$, it returns $y = S_{privk}(x)$.
* **Attacks**: The attack models using **chosen plaintext** (CPA) and **chosen ciphertext** (CCA) rely on making these oracles available to the adversary.
:::

---

### Indistinguishability and Semantic Security (IND-CPA)

* **Property**: An adversary must not be able to distinguish the ciphertexts of two different plaintext messages.
* **IND-CPA (Indistinguishability under Chosen Plaintext Attack)**: If the adversary guesses the correct message only with a probability of $1/2 + \epsilon$, the system is considered secure.
* **Semantic Security**: Equivalent to IND-CPA, it ensures that no useful information leaks from the ciphertext.

::: {.callout collapse="true"}
#### Original version: Semantic Security
**Ciphertext indistinguishability** guarantees the inability to distinguish the ciphertexts of given plaintexts.

* **Experiment (IND-CPA Security Game)**:
    1. The adversary chooses two messages $M_0$ and $M_1$.
    2. The oracle chooses a random index $i \in \{0,1\}$ and returns $c_i = E_k(M_i)$.
    3. The adversary can perform other calculations or oracle calls.
* **IND-CPA Definition**: The system is secure if the adversary's advantage is **negligible** ($Prob = 1/2 + \epsilon$ with $\epsilon$ small).
* **Note**: In public key, the encryption oracle is useless because the adversary already possesses the public key. IND-CPA provides **semantic security**.
:::

---

### Probabilistic Encryption and OAEP

* **Problem**: Deterministic encryption allows **dictionary attacks** (comparison of known ciphertexts).
* **Solution**: Add randomness to the message before encryption so that $E(M)$ is different each time.
* **OAEP (Optimal Asymmetric Encryption Padding)**: Standard used with RSA. It combines the message $P$ with a random number $R$ via hash functions $h$ and XOR operations ($\oplus$).

::: {.callout collapse="true"}
#### Original version: Determinism vs. Probabilism
**Deterministic** behavior (same inputs = same outputs) creates vulnerabilities.

* **Example**: If Alice sends "Yes" or "No", the adversary can compute $C_{yes} = E_{pub}(``Yes")$ and compare. They can create a **codebook** (dictionary) to identify messages without breaking the key.
* **Probabilistic encryption**: Adds randomness. The goal is semantic security for the public key.
* **OAEP**: Used in **RSA-PKCS1**. The text $P$ is combined with randomness $R$:
    * $M_1 := P \oplus h(R)$
    * $M_2 := R \oplus h(M_1)$
    * Encryption applies to $M_1$ and $M_2$. During decryption, we recover $R = M_2 \oplus h(M_1)$, then $P = h(R) \oplus M_1$.
:::

::: {.callout collapse="true"}
#### Ultra-summary
- **Random Oracle**: "Ideal" hash function (theoretical model).
- **CPA/CCA Oracles**: Simulate access to the secret key to test resistance.
- **IND-CPA**: Inability to distinguish two ciphertexts (Semantic Security).
- **Probabilistic Encryption**: Essential to counter codebooks (dictionary attacks).
- **OAEP**: Padding method adding the necessary randomness to RSA.
:::

## History of Cryptography and Unconditional Security

### Historical Encryption Systems

Cryptography was for a long time limited to the sole pursuit of **confidentiality**. Historical systems are based on two fundamental principles: **substitution** and **transposition**.

* **Caesar Cipher** (mono-alphabetic substitution): Fixed letter shift. Very vulnerable to **frequency analysis**.
* **Vigenère Cipher** (polyalphabetic substitution): Uses a key to vary the shift. More complex, but breakable by identifying the key length.
* **Transposition Cipher**: Reorganization of the original text characters according to a permutation defined by a key.

::: {.callout collapse="true"}
#### Original version: Historical Cryptography
For centuries **confidentiality** was the only application of cryptography...

* **1st century BC, Caesar Cipher**: **Mono-alphabetic substitution encryption** $e_k(x) = (x + k) \pmod{26}$, $d_k(y) = (y - k) \pmod{26}$ where $x, y, k \in \mathbb{Z}_{26}$.
    * Example: $E_1(\text{'hello'}) = \text{'ifmmp'}$.
    * **Cryptanalysis**: easy, based on **character frequency**.
* **16th century, Vigenère**: **Polyalphabetic substitution encryption** $e_k(x_1, \dots, x_n) = (x_1 + k_1, \dots, x_m + k_m, x_{m+1} + k_1, \dots) \pmod{26}$.
    * **Cryptanalysis**: find the **key length $m$** by identifying repeated ciphertext portions and analyzing separate blocks as in the Caesar Cipher.
* **Transposition Ciphers** (Porta, 1563): The key defines a **permutation** on the plaintext.
* These techniques are still the basis of modern encryption systems (ex: **Enigma**, qualified by W. Churchill as the secret weapon that won the war).
:::

### The One-Time Pad (OTP)

The **One-Time Pad** (OTP), or **Vernam cipher**, is the only system proven to be **unconditionally secure** (perfect secrecy).

* **Principle**: The message is combined with a key of the same length via the XOR operation ($\oplus$).
* **Unconditional Security**: Observation of the encrypted message provides no information about the plaintext message. Even an adversary with infinite computing power cannot break it.
* **Shannon's Constraints**: The key must be **as long as the message**, purely **random**, and **used only once**.
* **Key Reuse**: If a key is reused for two messages, an attacker can eliminate the key by XOR ($y_a \oplus y_b = x_a \oplus x_b$) and recover the plaintext messages.

::: {.callout collapse="true"}
#### Original version: The One-Time Pad
Let $n \ge 1$ and the spaces $P, C, K$ such that $P, C, K = (\mathbb{Z}_2)^n$. The encryption and decryption operations of a **one-time pad** (Vernam Cipher) are:
$E_k(x_i) = x_i \oplus k_i$ and $D_k(y_i) = y_i \oplus k_i$ for $1 \le i \le n$.

* **Unconditional security**: If $k_i$ are random and independent, observation of ciphertexts does not help cryptanalysis. The **entropy** of $X$ does not decrease: $H(X|C) = H(X)$.
* **Shannon's Theorem**: Necessary condition: $H(K) \ge H(X)$. The length of the **random key** must be at least as large as that of the plaintext.
* **Key reuse**: $y_a \oplus y_b = x_a \oplus x_b$. With low-entropy messages, the plaintexts and the key ($k = y_a \oplus x_a$) can be recovered.
* Vulnerable to the **Known Plaintext** attack (if the key is reused).
* Major problem: The **distribution and management** of large keys. Revived by **quantum cryptography** proposing confidential channels for unlimited-length key distribution.
:::

### Steganography

In contrast to cryptography, which makes the message unreadable, **steganography** conceals the very existence of the message.

* **Method**: Use a "subliminal channel" (an innocent medium like an image or a banal text).
* **Modern technique**: Insertion of data into the **least significant bits** (LSB) of multimedia files, allowing the hiding of large volumes of data without visible alteration.

::: {.callout collapse="true"}
#### Original version: Steganography
**Steganography** hides a message inside another. Constituent elements:

1. A different **physical or logical channel** (subliminal channel).
2. A **secret mechanism** to identify this channel.

* **Classic examples**: First letters of words in a text, invisible ink.
* **Modern example**: Use the **least significant bits** of the frames of a Photo CD.
* For a 2048x3072 image (RGB 24 bits), hiding a message using 1 bit allows storing **2.3 Mb** without deteriorating quality.
:::

::: {.callout collapse="true"}
#### Ultra-summary
- **History**: Substitution (Caesar/Vigenère) and Transposition (permutation).
- **One-Time Pad**: Absolute security if the key is random, unique, and as long as the message ($H(K) \ge H(X)$).
- **Steganography**: Hiding the existence of the message (ex: LSB technique in images).
:::
# Symmetric Cryptography

## Stream Ciphers (Stream Encryption)

### Introduction to Stream Ciphers

#### Definition and Principle

**Stream ciphers** are a family of encryption systems characterized by:

- **Unit block size**: each encrypted block = 1 bit
- **Two-phase architecture**:
  1. **Keystream generation**: production of the key sequence
  2. **Substitution**: operation on plaintext bits based on the keystream

**Classic example**: the *one-time pad*

- Generation: (pseudo-)random generator
- Substitution: XOR operation ($\oplus$) with the keystream

#### General Characteristics

**Advantages:**

- **Speed**: encryption at register level, ideal for real-time *streaming* (video)
- **Lightweight**: work on systems with limited CPU resources
- **Low memory**: little or no buffering needed
- **Non-propagated errors**: retransmission of defective packets is sufficient (suitable for wireless transmissions - WiFi)

**Disadvantages:**

- **Dependency on keystream quality**: randomness determines robustness
- **Dangerous reuse**: keystream reuse allows easy cryptanalysis

::: {.callout-note collapse=true}
## 📄 Original text

### Stream Ciphers

- **Stream ciphers** constitute a **family of encryption systems** where the **size of the encrypted block is equal to 1 bit**.
- Stream ciphers are generally composed of **two phases**:
    - A **generation phase** of the sequence of elements forming the key (the **keystream**).
    - A **substitution phase** where the *plaintext* bits undergo a specific operation dependent on the keystream.
- An obvious example of a stream cipher is the **one-time pad** with:
    - A keystream generation phase performed by a **(pseudo-)random generator**.
    - A substitution phase consisting of performing a **xor** ($\oplus$) with the keystream.

### Stream Ciphers: Characteristics

- **Speed**: Encryption is done directly at the register level. Ideal for applications requiring *"on the fly"* encryption like **video streaming**.
- **Ease**: Operations can be performed by systems with **limited CPU resources**.
- **No (or little...) need for memory/buffering**.
- **Limited or absent error propagation**: retransmission of faulty packets is normally sufficient (suitable for applications where packet loss is frequent like **wireless transmissions (WiFi)**).
- **Disadvantages**:
    - The **quality in terms of randomness** of the generated keystream determines the **system's robustness**.
    - **Keystream reuse** allows **easy cryptanalysis** (cf. the one-time pad).
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Stream Ciphers** = encryption bit by bit in 2 phases (keystream generation + substitution).

**Advantages**: fast, lightweight, no error propagation.

**Disadvantages**: keystream quality critical, reuse = vulnerability.
:::

---

### Synchronous Stream Ciphers

#### Operating Principle

In a **synchronous stream cipher**, the keystream depends **only on the key**, independent of the plaintext and ciphertext.

**Process equations:**

$$\sigma_{i+1} = f(\sigma_i, k)$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Where:

- $\sigma_i$: state at time $i$ (initial state $\sigma_0$ may depend on $k$)
- $k$: secret key
- $f$: state transition function
- $g$: keystream production function producing $z_i$
- $h$: output function producing ciphertext $c_i$ from plaintext $m_i$

```{mermaid}
graph LR
    A[Key k] --> B[State σi]
    B --> C[Function f]
    C --> D[State σi+1]
    B --> E[Function g]
    E --> F[Keystream zi]
    F --> G[Function h]
    H[Plaintext mi] --> G
    G --> I[Ciphertext ci]
    D -.->|loop| B
```

#### Characteristics

**Synchronization requirement:**

- Transmitter and receiver must share the same key $k$ **AND** the same state $\sigma_i$
- Loss of synchronization = need for external mechanisms (markers, redundancy analysis)

**Properties:**

- **No error propagation**: modification of ciphertext does not affect subsequent sequences
- **Attention**: deletion of a ciphertext = receiver desynchronization

**Vulnerabilities to active attacks:**

- ✓ Detection: insertion, elimination, replay of fragments
- ✗ Bit modification: adversary can modify bits and analyze impact on plaintext
- **Solution**: additional authentication mechanisms necessary

#### Special case: Additive Stream Cipher

The most frequent case where:

- Functions $f$ and $g$ replaced by a random generator
- Function $h$ = modulo 2 addition (XOR: $\oplus$)

**Formula**: $c_i = z_i \oplus m_i$

::: {.callout-note collapse=true}
## 📄 Original text

### Synchronous Stream Ciphers

- The **generated keystream depends only on the key** and not on the plaintext nor the ciphertext.
- The encryption process of a **synchronous stream cipher** is described by the following equations:
  $$\sigma_{i+1} = f(\sigma_i, k)$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  with $\sigma_i$ the **initial state** which may depend on the key $k$, $f$ the **function determining the next state**, $g$ the **function producing the keystream** $z_i$ and $h$ the **output function** producing the ciphertext $c_i$ from the plaintext $m_i$.

### Synchronous Stream Ciphers: Characteristics

- **Require synchronization** of the transmitter and receiver: In addition to using the same key $k$, both must be in the **same state** for the process to work. If synchronization is lost, **external mechanisms** are needed to recover it (special markers, plaintext redundancy analysis, etc.)
- **No error propagation**. Modification of the ciphertext during transmission does not cause disturbances in subsequent ciphertext sequences (however, the **deletion** of a ciphertext would cause **desynchronization** of the receiver).
- **Active attacks**: Insertion, elimination or replay of parts of ciphertext are **detected** by the receiver. However, an adversary could **modify certain bits** of the ciphertext and analyze the impact on the corresponding plaintext. Additional **origin authentication mechanisms** are necessary to detect these attacks.
- **Most frequent case** of Synchronous Stream Ciphers: the **additive stream cipher** (cf. the one-time pad) where the functions $f$ and $g$ generating the keystream are replaced by a **random generator** and the function $h$ is a **modulo 2 addition (xor)**.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Synchronous**: keystream = $f$(key only). Equations: $\sigma_{i+1} = f(\sigma_i, k)$, $z_i = g(\sigma_i, k)$, $c_i = h(z_i, m_i)$.

**Requires synchronization** transmitter/receiver. No error propagation but vulnerable to bit modifications.

**Frequent case**: additive cipher with XOR.
:::

---

### Asynchronous Stream Ciphers

#### Operating Principle

Also called **self-synchronizing ciphers**.

The keystream depends on the key **AND** a fixed number of previous ciphertexts.

**Process equations:**

$$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Where $\sigma_i$ represents a buffer of the last $t$ ciphertexts.

```{mermaid}
graph LR
    A[Key k] --> B[Function g]
    C[Buffer: ci-t...ci-1] --> B
    B --> D[Keystream zi]
    D --> E[Function h]
    F[Plaintext mi] --> E
    E --> G[Ciphertext ci]
    G -.->|feedback| C
```

#### Characteristics

**Self-synchronization:**

- In case of insertion/elimination of ciphertexts, the receiver **automatically re-synchronizes**
- Mechanism: memorization (buffer) of the last ciphertexts

**Limited error propagation:**

- Error propagates only over the **buffer size** ($t$ bits)
- After buffer exhaustion, correct decryption resumes

**Security against active attacks:**

- **Better detection**: modifications detected thanks to error propagation
- **Attention**: self-synchronization allows receiver to continue even after insertions/deletions
- **Solution**: verification of integrity and authenticity of entire stream necessary

**Diffusion of plaintext statistics:**

- Each plaintext bit influences **all subsequent ciphertexts**
- **Result**: better dispersion of statistics vs. synchronous case
- **Application**: use for low entropy or highly redundant plaintexts

::: {.callout-note collapse=true}
## 📄 Original text

### Asynchronous Stream Ciphers

- Also called **self-synchronizing ciphers**.
- The **generated keystream depends on the key as well as a fixed number of previous ciphertexts**.
- The encryption process of an **asynchronous stream cipher** is described by the following equations:
  $$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  with $\sigma_i$, $g$ and $h$ as for the synchronous case.

### Asynchronous Stream Ciphers: Characteristics

- **Self-synchronization**: In case of elimination or insertion of ciphertexts along the way, the receiver is capable of **re-synchronizing with the transmitter** thanks to the **memorization (buffer)** of a number of previous ciphertexts.
- **Limited error propagation**: Error propagation extends only to the **number of ciphertext bits memorized** (buffer size). Afterwards, decryption proceeds correctly again.
- **Active attacks**: Modification of ciphertext fragments will be **more easily detected** than in the synchronous case because of error propagation. However, since the receiver is capable of self-synchronizing with the transmitter, even if ciphertexts are eliminated or inserted along the way, it is necessary to **verify the integrity and authenticity of the entire stream**.
- **Diffusion of plaintext statistics**: The fact that **each plaintext bit will influence all subsequent ciphertexts** results in a **greater dispersion of statistics** compared to the synchronous case...
- ... It is therefore advisable to use **asynchronous stream ciphers when the entropy of plaintexts is limited** and could allow targeted attacks on highly redundant plaintexts.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Asynchronous** (self-synchronizing): keystream = $f$(key + last ciphertexts). State $\sigma_i$ = buffer of $t$ previous ciphertexts.

**Automatic self-synchronization**. Limited error propagation to buffer.

**Better diffusion** of statistics → ideal for redundant/low entropy plaintexts.
:::

---

### Keystream Generators: LSFR

#### Context and Necessity

**Problem**: generate a keystream of length $m$ from a secret key of length $l$ with $l \ll m$.

**Solution**: Linear Feedback Shift Register (**LSFR** or **LFSR**)

#### LSFR Characteristics

**Advantages:**

- **Optimal hardware implementation**: very efficient circuits
- **Long periods**: sequences of great length
- **Good random quality**: notable randomness
- **Mathematical basis**: algebraic properties of linear combinations

**Generic structure**: LSFR of length $L$

```{mermaid}
graph LR
    A[bit L-1] --> B[bit L-2]
    B --> C[...]
    C --> D[bit 1]
    D --> E[bit 0]
    E --> F[Output]
    A -.->|feedback| G[⊕]
    D -.->|coeff| G
    C -.->|coeff| G
    G --> A
```

#### Important Remarks on LSFR

**History and Usage:**

- Very widespread construction in cryptography and coding theory
- Many military stream ciphers based on LSFR

**Security Limits:**

- **Insufficient security level** compared to modern block ciphers
- **Vulnerability**: the Berlekamp-Massey algorithm allows to:
  - Determine the **linear complexity** of an LSFR
  - Calculate an arbitrary number of generated sequences

**Metric**: Linear complexity (*linear complexity*)

**Improvement Solution:**

Replace the linear combination with a **non-linear function** $f$

→ **Non Linear Feedback Shift Registers** (NLFSR)

::: {.callout-note collapse=true}
## 📄 Original text

### Stream Ciphers: Keystream Generators

- When it is necessary to **generate a keystream of length $m$** from a **secret key of length $l$** with $l \ll m$, we call upon **keystream generators**.
- The most common of these generators is the **Linear Feedback Shift Register (LSFR)**.
- An LSFR has the following characteristics:
    - **Adapts very well to hardware implementations**.
    - Produces sequences of **long periods** and with **notable random quality** (quite strong randomness)
    - Based on the **algebraic properties of linear combinations**.

### LSFRs: Some Remarks

- LSFRs are **very widespread constructions** in cryptography and coding theory.
- A **large number of stream ciphers** based on LSFRs (especially in the **military sphere**) were developed in the past.
- Unfortunately, the **security level offered by these systems is deemed insufficient** nowadays (compared to that of block ciphers...)
- The **metric** allowing analysis of an LFSR is its **linear complexity**. The **Berlekamp-Massey algorithm** allows determining the linear complexity of an LSFR and thus calculating an arbitrarily large number of sequences generated by an LSFR.
- A solution to **increase complexity** is to substitute the linear combination of ciphertext bits with a **non-linear function** $f$. These are the **Non Linear Feedback Shift Registers**.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**LSFR**: long keystream generator ($m$) from short key ($l$). Base = linear combinations.

**Advantages**: efficient hardware, long periods.

**Problem**: insufficient security, vulnerable to Berlekamp-Massey (linear complexity calculation).

**Solution**: NLFSR (non-linear function).
:::

---

### RC4: Software Stream Cipher

#### General Presentation

**RC4™** (*Rivest Cipher 4*) developed in 1987 by Ron Rivest for RSA Security.

**Main characteristics:**

- **Variable key**: flexible length
- **Extremely fast**: 10× faster than DES
- **Synchronous mode**: keystream independent of plaintext/ciphertext

**History:**

- 1987-1994: patented, details confidential (NDA contract required)
- 1994: unofficial publication in a newsgroup
- Since then: intensive analysis by cryptographic community

#### Architecture

**Key components:**

- **S-box**: 8×8 substitution box (256 entries)
  - Content: permutation of numbers 0 to 255
  - Depends on the main key of variable length: $0 < len(k) \leq 255$
- **Combinations**: linear and non-linear
- **Final encryption**: XOR between keystream and plaintext

#### Applications and Security

**Commercial uses (numerous):**

- Lotus Notes
- Oracle SQL
- Microsoft Windows
- SSL/TLS
- And many more...

**Analyses and Vulnerabilities:**

- Exhaustive work on key scheduling and PRGA
- **Major flaw**: implementation in WEP (WiFi Wired Equivalent Privacy)
  - WEP protocol completely compromised
  - Problem: faulty usage mode, not the RC4 algorithm itself

#### Operation

RC4 decomposes into **two steps**:

1. **Key Scheduling Algorithm (KSA)**
   - Responsible for initial permutation of the S-box
   - Function of the variable length key $len(k) = l$

2. **Pseudo Random Generator Algorithm (PRGA)**
   - Generates keystream of arbitrary size
   - Relies on S-box permuted by KSA

```{mermaid}
graph TB
    A[Variable length key k] --> B[KSA: Key Scheduling]
    B --> C[Permuted S-box]
    C --> D[PRGA: Generation]
    D --> E[Keystream zi]
    E --> F[XOR]
    G[Plaintext mi] --> F
    F --> H[Ciphertext ci]
```

::: {.callout-note collapse=true}
## 📄 Original text

### Software Cipher Streams: RC4

- The major **disadvantage of stream ciphers based on registers** is that they are **very slow in programmed version** on a generic machine. **RC4™** is a **variable key stream cipher** developed in **1987 by Ron Rivest** for RSA security. It is **very fast** (**10 times faster than DES** !)
- For 7 years, this algorithm was **patented** and its internal operational details were disclosed only after **signing a confidentiality contract**. Since its **(unofficial) publication in a newsgroup in 1994**, it has been widely discussed and analyzed by the entire cryptographic community.
- The algorithm works in **synchronous mode** (the keystream is independent of the ciphertext and plaintext).
- It is composed of **linear and non-linear combinations**. The key element is an **8×8 substitution box (S-box)** whose entries are a **permutation of the numbers 0 to 255**. The permutation is a **function of the main key** of variable size with $0 < len(k) \leq 255$. The **final encryption is obtained by a xor** between the keystream and the plaintext.
- RC4 is used in a **large number of commercial applications**: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. It is the subject of a **large number of analytical and exhaustive works** that have managed to **compromise the security** of the key scheduling and the PRGA.
- In particular the application of RC4 to the **Wired Equivalent Privacy (WiFi WEP) protocol has been "broken"** due to a **flaw in the protocol's usage mode**.

### RC4: Operation

- The algorithm consists of **two steps**:
    - The **Key Scheduling Algorithm (KSA)**: Responsible for the **initial permutation** that will fill the S-box depending on the variable length key $len(k) = l$.
    - The **Pseudo Random Generator Algorithm (PRGA)**: Generates the **keystream of arbitrary size** relying on the S-box.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**RC4**: software stream cipher, variable key, 10× faster than DES.

**Architecture**: 8×8 S-box (permutation 0-255) + XOR.

**2 steps**: KSA (S-box permutation) + PRGA (keystream generation). Synchronous mode.

**Vulnerability**: WEP broken (usage flaw). Used in SSL, Windows, Oracle...
:::

## Block Ciphers (Block Encryption)

### 1. Introduction to Block Ciphers

#### Definition and Principle

A **block cipher** is a cryptographic function that:

- **Transforms fixed-size blocks**: maps a block of $n$ bits to another block of the same size
- **Is parameterized by a key**: the key $K$ of $k$ bits defines the transformation
- **Must be bijective**: to allow unique decryption
- **Each key = different bijection**: guarantees variability

**Nominal size**: input block size on which encryption is applied

#### Quality Criteria

**1. Key size/Entropy**

- Keys ideally **equiprobable** with entropy = $k$ bits
- Strong entropy protects against **brute-force attacks**
- **Minimum required**: 128 bits for modern block ciphers

**2. Performance**

- Execution speed
- Software/hardware efficiency

**3. Block size**

- Too small block = vulnerability to **plaintext/ciphertext dictionaries**
- **Modern standard**: blocks ≥ 128 bits

**4. Cryptographic resistance**

- Resistance to known techniques:
  - Linear cryptanalysis
  - Differential cryptanalysis
  - Meet in the middle
- **Cryptanalysis effort** equivalent to brute force

```{mermaid}
graph LR
    A[Plaintext n bits] --> B[Block Cipher]
    C[Key K k bits] --> B
    B --> D[Ciphertext n bits]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
```

::: {.callout-note collapse=true}
### 📄 Original text

#### Block Ciphers

- **Symmetric block ciphers** constitute the **cornerstone of cryptography**. Their main functionality is **confidentiality** but they are also the basis for **authentication**, **hashing functions**, **random generation**, etc.

- **Definition**: A block cipher is a **function** that maps a **block of $n$ bits** to another block of **the same size**. The function is **parameterized by a key $K$ of $k$ bits**. To allow **unique decryption**, the function must be **bijective**. **Each key defines a different bijection**. The **input block size** on which encryption is applied is also called **nominal algorithm size**.

- **Criteria to evaluate the quality** of a block cipher:
  - **Key size/Entropy**: Ideally, keys are **equiprobable** and the key space has an **entropy equal to $k$**. A **strong key entropy** protects against **brute-force attacks** from chosen/known plaintexts. Modern block ciphers must have **keys of at least 128 bits**.
  - **Performance**
  - **Block size**: A **too small block** would allow attacks where **plaintext/ciphertext "dictionaries"** could be built. Nowadays, **blocks of size ≥ 128 bits** are becoming common.
  - **Cryptographic resistance**: The block cipher must show **resistance** to known cryptanalysis techniques: **linear or differential cryptanalysis**, **meet in the middle**, etc. The **inherent effort** of these attacks (complexity, storage, parallelization, etc.) must be **equivalent to that of a brute force attack**.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision

**Block cipher**: bijective function transforming blocks of $n$ bits with key $K$ of $k$ bits. **Criteria**: key entropy ≥ 128 bits, block size ≥ 128 bits, cryptanalysis resistance = brute force effort. **Usage**: confidentiality, authentication, hashing, random generation.
:::

---

### 2. Block Cipher Modes of Operation

#### 2.1 Electronic Codebook (ECB)

**Principle**: each plaintext block is encrypted **independently** with the same key.

$$c_i = E_K(m_i)$$
$$m_i = D_K(c_i)$$

```{mermaid}
graph TB
    subgraph Encryption
        P1[Plaintext Block 1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext Block 1]
        
        P2[Plaintext Block 2] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext Block 2]
    end
    
    style E1 fill:#ffcccc
    style E2 fill:#ffcccc
    style K1 fill:#fff4e1
    style K2 fill:#fff4e1
```

**Characteristics:**

- ✗ **Identical plaintexts** → identical ciphertexts (predictable)
- ✓ **No error propagation**: error on $c_j$ affects only $m_j$
- ✗ **Visible patterns**: plaintext structure transparent in ciphertext
- ✓ **Parallelizable**: each block processed independently

**⚠️ Major vulnerability**: Should NOT be used for redundant data

---

#### 2.2 Cipher Block Chaining (CBC)

**Principle**: each plaintext block is **XORed with the previous ciphertext** before encryption.

$$c_i = E_K(m_i \oplus c_{i-1})$$
$$m_i = D_K(c_i) \oplus c_{i-1}$$

With $c_0 = IV$ (Initialization Vector)

```{mermaid}
graph TB
    subgraph Encryption
        IV[IV] --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext c1]
        
        C1 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ccffcc
    style E2 fill:#ccffcc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **Patterns erased**: chaining masks the structure
- ✓ **Limited error propagation**: error on $c_j$ affects $m_j$ and $m_{j+1}$ only
- ✗ **Not parallelizable** in encryption (sequential)
- ✓ **Parallelizable** in decryption

**IV (Initialization Vector):**

- Must be **random** or **pseudo-random**
- Can be transmitted **in clear**
- Must be **different** for each message with the same key

---

#### 2.3 Cipher Feedback Mode (CFB)

**Principle**: works like a **stream cipher** where the keystream is generated by the block cipher. The keystream depends on **previous ciphertexts** (**asynchronous** mode).

$$c_i = m_i \oplus E_K(c_{i-1})$$
$$m_i = c_i \oplus E_K(c_{i-1})$$

With $c_0 = IV$

```{mermaid}
graph TB
    subgraph CFB_Encryption
        IV[IV / ci-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        C1 -.feedback.-> IV
    end
    
    style E1 fill:#ffccff
    style X1 fill:#ffffcc
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **Chaining**: dependencies between ciphertexts
- ⚠️ **Error propagation**: error on $c_j$ affects $\frac{n}{r}$ following blocks
  - $n$ = nominal size of block cipher
  - $r$ = size of plaintexts
- ✗ **Not parallelizable**
- ⚠️ **IV non-confidential** but must be transmitted

**Usage**: suitable for transmissions with frequent packet loss

---

#### 2.4 Output Feedback Mode (OFB)

**Principle**: works like a **synchronous stream cipher**. The keystream is **entirely determined** by the key and IV, **independent** of plaintext and ciphertext.

$$z_i = E_K(z_{i-1})$$
$$c_i = m_i \oplus z_i$$
$$m_i = c_i \oplus z_i$$

With $z_0 = IV$

```{mermaid}
graph TB
    subgraph OFB_Mode
        IV[IV / zi-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> Z[zi keystream]
        Z --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        Z -.feedback.-> IV
    end
    
    style E1 fill:#cce5ff
    style X1 fill:#ffffcc
    style Z fill:#e1ffe1
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **No error propagation**: error on $c_j$ affects only $m_j$
- ✓ **Pre-computable keystream**: efficient
- ⚠️ **CRITICAL**: NEVER reuse the same IV with the same key (otherwise identical keystream)
- ✓ **Parallelizable** if keystream pre-computed

**⚠️ Reuse warning**: Change IV for each new message!

::: {.callout-note collapse=true}
### 📄 Original text (CFB and OFB Modes)

#### CFB and OFB Modes: Characteristics

The **CFB and OFB modes** work as a **stream cipher** with a **keystream generated by the encryption block**. In **CFB**, the keystream depends on **previous ciphertexts** (**asynchronous**) whereas in **OFB**, the keystream is **entirely determined by the key and the IV** (**synchronous**).

**Particularities of CFB:**

- As in CBC mode, **identical plaintexts** are translated into **different ciphertexts** if the **IV changes**. The **IV is not necessarily confidential** and can be exchanged in clear between parties.
- **Chaining** also introduces **dependencies** between current ciphertexts and previous ciphertexts. In particular, if $n$ is the **nominal algorithm size** and $r$ is the **plaintext size**, the current ciphertext will depend on the $\frac{n}{r}$ **previous ciphertexts** (each iteration will shift the faulty input by $r$ positions, after $\frac{n}{r}$ iterations the faulty ciphertext will be completely "expelled").
- **Error propagation** follows the same principle: an error in a ciphertext will result in incorrect decryption of the $\frac{n}{r}$ following ciphertexts.

**Particularities of OFB:**

- OFB has **identical behavior** to CBC and CFB modes for **encryption of identical plaintexts**.
- **No error propagation** on adjacent ciphertexts.
- **Modify the IV** if the key does not change to **avoid keystream reuse** !!!
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (CFB/OFB)

**CFB** (asynchronous): keystream = $f$(previous ciphertexts). Limited error propagation ($\frac{n}{r}$ blocks).

**OFB** (synchronous): keystream = $f$(key + IV only). No error propagation.

**CRITICAL**: NEVER reuse same IV with same key. IV transmissible in clear.
:::

---

#### 2.5 Counter Mode (CTR)

**Principle**: the keystream is generated by **encryption of a counter** incremented at each block.

$$c_i = m_i \oplus E_K(counter + i)$$
$$m_i = c_i \oplus E_K(counter + i)$$

```{mermaid}
graph TB
    subgraph CTR_Mode
        CTR1[Counter + 0] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> C1[Ciphertext c1]
        
        CTR2[Counter + 1] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ffe6cc
    style E2 fill:#ffe6cc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Characteristics:**

- ✓ **Synchronous mode**: keystream = $f$(counter)
- ✓ **Parallelizable**: keystream pre-computable for encryption AND decryption
- ✓ **Random access**: each block decryptable independently
- ✓ **No error propagation**
- ✓ **Benefits from SIMD architectures**: no dependencies between blocks
- ⚠️ **Counter**: must be of size $2^b$ ($b$ = block size)
- ⚠️ **CRITICAL**: NEVER reuse the same counter with the same key

**Counter management:**

- **Increment modulo** $2^b$ after each iteration
- **Solution**: always increment for each encrypted stream
- First block of stream $i+1$ > last block of stream $i$

**Applications:**

- **ATM** (Asynchronous Transfer Mode)
- **IPsec** (IP security)
- **High-speed lines**: selective transmission of blocks
- **Large volume transfers**: video

::: {.callout-note collapse=true}
### 📄 Original text (Counter Mode)

#### Counter Mode (CTR Mode)

Frequently used as encryption support in data transfer protocols like **ATM** (Asynchronous Transfer Mode) and **IPsec** (IP security).

#### Counter Mode (II)

- The **keystream** is generated by the **encryption of a random counter** of size $2^b$ (with $b$ the block size) and necessary for decryption. This counter is **incremented modulo** $2^b$ after each iteration.
- Works in **synchronous mode**. **Reuse of the same counter** results in an **identical keystream** !
- **Solution**: Always **increment the counter** for each encrypted stream such that the counter of the first block of a stream is **larger than the last block** of the previous stream.
- **Easily parallelizable**: The keystream can be **pre-calculated** both for encryption and decryption. Fully benefits from **SIMD architectures** because unlike other chaining modes there are no **dependencies between operations** of different blocks.
- **Random access** to encryption/decryption of each block: Unlike other chaining modes where the $i$-th operation depends on the $(i-1)$-th operation.
- If we add **absence of error propagation**, the counter mode facilitates **selective (re)transmission** of ciphertext blocks, making it very attractive for **securing high-speed lines** as well as for **encrypted transfers of large volumes** of information (e.g. video).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (Counter Mode)

**CTR**: keystream = $E_K$(counter + $i$).

**Advantages**: parallelizable (encryption + decryption), random access, no error propagation, SIMD-friendly.

**CRITICAL**: never reuse counter.

**Usage**: ATM, IPsec, high speed, video.
:::

---

### 3. Product Ciphers and Feistel Ciphers

#### Product Ciphers

**Definition**: encryption scheme combining a **series of successive transformations** to strengthen resistance to cryptanalysis.

**Common transformations:**

- Transpositions (permutations)
- Substitutions (S-boxes)
- XORs
- Linear combinations
- Modular multiplications

#### Feistel Ciphers

**Definition**: iterative product cipher with specific structure.

**Operating principle:**

- **Input**: plaintext of $2t$ bits = $(L_0, R_0)$ (two sub-blocks of $t$ bits)
- **Output**: ciphertext of $2t$ bits = $(R_r, L_r)$ after $r$ steps (rounds)
- **Each step**: invertible bijection (for unique decryption)

**Equations of step** $i$ ($1 \leq i \leq r$):

$$(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$$

With:

- $L_i = R_{i-1}$
- $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$

```{mermaid}
graph TB
    subgraph Feistel_Round
        L0[Li-1] --> R1[Ri = Li-1 ⊕ f]
        R0[Ri-1] --> L1[Li = Ri-1]
        R0 --> F[Function f]
        K[Key Ki] --> F
        F --> XOR[⊕]
        L0 --> XOR
        XOR --> R1
    end
    
    style F fill:#ffcccc
    style XOR fill:#ffffcc
    style K fill:#fff4e1
```

**Characteristics:**

- $K_i$: subkeys generated from the main key $K$
- Number of steps $r$: generally **even** and $\geq 3$
  - Example: DES has 16 steps
- **Final permutation**: $(L_r, R_r) \rightarrow (R_r, L_r)$
- **Decryption**: identical to encryption but subkeys applied in **reverse order** (from $K_r$ to $K_1$)

**Frequent operations:**

- Permutations
- Substitutions (S-boxes)

::: {.callout-note collapse=true}
### 📄 Original text

#### Product Ciphers and Feistel Ciphers

- A **product cipher** is an **encryption scheme** combining a **series of successive transformations** to **strengthen resistance to cryptanalysis**. Common transformations for a product cipher are: **transpositions**, **substitutions**, **XORs**, **linear combinations**, **modular multiplications**, etc.

- A **Feistel cipher** is an **iterative product cipher** capable of transforming a **plaintext of $2t$ bits** of the form $(L_0, R_0)$ composed of two **sub-blocks** $L_0$ and $R_0$ of $t$ bits into a **ciphertext of size $2t$** of the form $(R_r, L_r)$ after $r$ **successive steps (rounds)** with $r \geq 1$. **Each step** defines a **bijection (inversible !)** to allow unique decryption.

- **Permutations** and **substitutions** are the most frequent operations.

- The steps $1 \leq i \leq r$ are written: $(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$ with $L_i = R_{i-1}$ and $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$. The $K_i$ are **sub-keys**, **different for each step**, generated from the **main key $K$** of the encryption scheme.

- The **number of steps** proper to a Feistel cipher is normally **even** and $\geq 3$ (e.g. **DES has 16 steps**)

- After execution of all steps, a Feistel cipher performs a **permutation** of the two parts $(L_r, R_r)$ into $(R_r, L_r)$.

- The **decryption** of a Feistel Cipher is **identical to encryption** except that the sub-keys $K_i$ are applied in **reverse order** (From $K_r$ to $K_1$).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision

**Product cipher**: combination of successive transformations (transpositions, substitutions, XOR).

**Feistel cipher**:

  - iterative product cipher
  - plaintext $2t$ bits = $(L_0, R_0)$
  - $r$ rounds with $L_i = R_{i-1}$ and $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$.
  - Decryption = encryption with reversed sub-keys.
  - Example: DES (16 rounds).
:::

---

### 4. Data Encryption Standard (DES)

#### General Presentation

**DES** (Data Encryption Standard): most important cryptographic algorithm until the advent of AES in 2001.

**Main characteristics:**

- **Type**: Feistel Cipher
- **Block size**: 64 bits (nominal size)
- **Key size**: 56 effective bits (64 total bits with 8 parity bits)
- **Number of steps**: 16 rounds
- **Subkeys**: 16 subkeys of 48 bits (one per step)
- **Usage modes**: ECB, CBC, CFB, OFB

```{mermaid}
graph TB
    subgraph DES_Overview
        P[Plaintext 64 bits] --> DES[DES Encryption]
        K[Key 56 bits] --> DES
        DES --> C[Ciphertext 64 bits]
        
        C --> DES_INV[DES Decryption]
        K2[Key 56 bits] --> DES_INV
        DES_INV --> P2[Plaintext 64 bits]
    end
    
    style DES fill:#ffcccc
    style DES_INV fill:#ccffcc
    style K fill:#fff4e1
    style K2 fill:#fff4e1
```

#### DES Structure

**Main components:**

1. **Initial permutation (IP)**: permutation of the 64 input bits
2. **16 Feistel rounds**: iterative transformation
3. **Final permutation (IP⁻¹)**: inverse of IP

**Each round applies:**

- Division into two halves: $L_{i-1}$ and $R_{i-1}$ (32 bits each)
- Function $f$ on $R_{i-1}$ with subkey $K_i$
- XOR with $L_{i-1}$
- Exchange of halves

```{mermaid}
graph TB
    Plain[Plaintext 64 bits] --> IP[Initial Permutation IP]
    IP --> Split[Split L0, R0]
    
    Split --> Round1[Round 1]
    K1[K1] --> Round1
    Round1 --> Round2[Round 2]
    K2[K2] --> Round2
    Round2 --> Dots[...]
    Dots --> Round16[Round 16]
    K16[K16] --> Round16
    
    Round16 --> Swap[Swap R16, L16]
    Swap --> IP_inv[Final Permutation IP⁻¹]
    IP_inv --> Cipher[Ciphertext 64 bits]
    
    style IP fill:#e1f5ff
    style IP_inv fill:#e1f5ff
    style Round1 fill:#ffcccc
    style Round2 fill:#ffcccc
    style Round16 fill:#ffcccc
```

#### DES Cipher Function

The **function $f$** for each round:

1. **Expansion E**: 32 bits → 48 bits (table E)
2. **Key Addition**: XOR with subkey $K_i$ (48 bits)
3. **S-boxes**: 8 S-boxes transform 48 bits → 32 bits
   - Each S-box: 6 bits input → 4 bits output
4. **Permutation P**: permutation of the resulting 32 bits

```{mermaid}
graph TB
    R[Ri-1 32 bits] --> E[Expansion E]
    E --> E_out[48 bits]
    E_out --> XOR1[⊕]
    K[Ki 48 bits] --> XOR1
    XOR1 --> S[8 S-boxes]
    S --> S_out[32 bits]
    S_out --> P[Permutation P]
    P --> F_out[f output 32 bits]
    
    style E fill:#cce5ff
    style S fill:#ffcccc
    style P fill:#e1ffe1
    style XOR1 fill:#ffffcc
```

**S-box operation:**

Input: $a_1a_2a_3a_4a_5a_6$ (6 bits)

- **Row**: $a_1 + 2a_6$ (external bits)
- **Column**: $a_2 + 2a_3 + 4a_4 + 8a_5$ (internal bits)
- **Output**: value of the corresponding cell (4 bits)

#### Subkey Generation

**Process:**

1. Main key: 64 bits (56 effective + 8 parity)
2. **Permuted Choice 1 (PC-1)**: selection of 56 bits
3. Division into two halves: $C_0$ and $D_0$ (28 bits each)
4. For each round $i$:
   - Left circular rotation of $C_{i-1}$ and $D_{i-1}$
   - **Permuted Choice 2 (PC-2)**: selection of 48 bits for $K_i$

**Rotations:**

- Rounds 1, 2, 9, 16: 1 position
- Other rounds: 2 positions

::: {.callout-note collapse=true}
### 📄 Original text (DES Operation)

#### DES: Operation

**Cipher Function**

- **Expansion E**: The **32 bits of the input** are transformed into a vector of **48 bits** using the **table E**. The first line of this table indicates how the first sub-block of 6 bits will be generated: first take the 32nd bit then bits 1,2,3,4,5. The second sub-block starts with the 4th bit then bits 5,6,7,8,9 and so on...

- **Key addition**: **XOR of the 48-bit vector** with the key.

- **S-boxes**: Apply **8 S-boxes** on the resulting 48-bit vector. Each of these S-boxes takes a **6-bit sub-block** and transforms it into a **4-bit sub-block**. The operation is performed as follows: If we denote the 6 input bits of the S-box as: $a_1a_2a_3a_4a_5a_6$. The output is given by the content of the cell located in the **row** $a_1 + 2a_6$ and the **column** $a_2 + 2a_3 + 4a_4 + 8a_5$.

- **Permutation P**: Permutation P works as follows: The first bit is sent to the 16th position, the second to the 7th position and so on.

**Permutations IP and IP⁻¹**

- Act respectively at the **beginning** and at the **end** of the block processing and on the **entirety of the 64 bits**.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (DES)

**DES**: Feistel cipher, 64-bit blocks, 56-bit effective key, 16 rounds.

**Function $f$**: Expansion E (32→48 bits) → XOR $K_i$ → 8 S-boxes (48→32 bits) → Permutation P.

**S-box**: 6 bits input → 4 bits output via table (row = external bits, column = internal bits).

**Permutations**: IP (initial) and IP⁻¹ (final) on 64 bits.
:::

---

### 5. Triple-DES and DES Security

#### DES Vulnerabilities

**Main problem**: key space size $\{0,1\}^{56}$ insufficient.

**Brute force attack:**

- **1999**: key found in **24 hours**
- Technique: massively parallel brute force (100,000 PCs on Internet)
- Known plaintext attack

#### Triple-DES (3DES)

**Solution**: increase key space to $\{0,1\}^{112}$.

**Scheme:**

$$C = E_{K_1}(D_{K_2}(E_{K_1}(P)))$$

With:

- $E$: DES encryption
- $D$: DES decryption
- $K_1, K_2$: two 56-bit keys

```{mermaid}
graph LR
    P[Plaintext 64 bits] --> E1[DES Encrypt K1]
    E1 --> D[DES Decrypt K2]
    D --> E2[DES Encrypt K1]
    E2 --> C[Ciphertext 64 bits]
    
    K1a[Key K1 56 bits] --> E1
    K2[Key K2 56 bits] --> D
    K1b[Key K1 56 bits] --> E2
    
    style E1 fill:#ffcccc
    style D fill:#ccffcc
    style E2 fill:#ffcccc
```

**Advantages:**

- ✓ **Satisfactory security**: key space $2^{112}$
- ✓ **Compatibility**: reuse of existing DES hardware/software
- ✓ **Gradual migration**: while waiting for AES

**Disadvantage:**

- ✗ **Performance**: 3× slower (3 successive DES executions)

#### DES Properties

**1. DES is not a group**

DES is NOT a group under composition:

$$\nexists K_3 \text{ such that } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)$$

**Consequence**: composite encryption (Triple-DES) considerably increases security.

**If DES were a group**: exhaustive search on $\{0,1\}^{56}$ would break the algorithm regardless of the number of consecutive executions.

**2. Weak and semi-weak keys**

- **Weak key**: $E_K(E_K(x)) = x$

- **Pair of semi-weak keys**: $E_{K_1}(E_{K_2}(x)) = x$

**Characteristic**: weak keys generate identical subkeys in pairs:

- $k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$
- Facilitates cryptanalysis

**DES has 4 weak keys:**

| Weak key (hexadecimal) |
|---------------------------|
| 0101 0101 0101 0101 |
| 0101 0101 FEFE FEFE |
| FEFE FEFE FEFE FEFE |
| FEFE FEFE 0101 0101 |

**And 6 pairs of semi-weak keys**

::: {.callout-note collapse=true}
### 📄 Original text (DES and 3DES)

#### DES and Triple-DES

- The **size of the key set** ($\{0,1\}^{56}$) constitutes the **greatest threat** weighing on DES with current computing resources. In **1999** it took only **24 hours** to find the key from a **known plaintext** using a **massively parallel brute force technique** (100,000 PCs connected to the Internet).

- **Triple DES** protects us from these **brute force attacks** by increasing the **possible key space** to $\{0,1\}^{112}$.

- This alternative allows continuing to use **DES "boxes"** (hardware and software) while waiting for migration to AES.

- The **security level** obtained by this solution is **very satisfactory**.

- The **performance impact** of three successive DES executions remains a **disadvantage** for some applications.

#### DES: properties

- **DES is not a group** (in the algebraic sense) under composition: In other words, DES being a permutation: $\{0,1\}^{64} \rightarrow \{0,1\}^{64}$, if DES were a group under composition, this would mean that: $\exists K_3$ such that $E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)$

  This property ensures that **composite encryption** (like Triple-DES) **considerably increases the security** of DES. If DES were a group, exhaustive search on the possible key set ($\{0,1\}^{56}$) would allow "breaking" the algorithm **regardless of the number of consecutive executions** of DES.

- **Weak and semi-weak keys** (weak and semi-weak keys):
  - A key $K$ is said to be **weak** if $E_K(E_K(x)) = x$.
  - A pair of keys $(K_1, K_2)$ is said to be **semi-weak** if $E_{K_1}(E_{K_2}(x)) = x$.

- Weak keys have the particularity of generating **identical subkeys in pairs** ($k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$), which **facilitates cryptanalysis**.

- **DES has 4 weak keys** (and 6 pairs of semi-weak keys).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (3DES and security)

**DES vulnerability**: key space $2^{56}$ breakable in 24h (1999). **Triple-DES**: $E_{K_1}(D_{K_2}(E_{K_1}(P)))$, space $2^{112}$, reuses DES hardware, 3× slower. **DES ≠ group** → composite encryption strengthens security. **4 weak keys** generating identical subkeys in pairs → facilitates cryptanalysis.
:::

---

### 6. Advanced Encryption Standard (AES)

#### General Presentation

**AES** (Advanced Encryption Standard): standard adopted in November 2001.

**Design**: Johan Daemen and Vincent Rijmen (original name: **Rijndael**)

**Main characteristics:**

- **Type**: iterative block cipher (but **NOT a Feistel Cipher**)
- **Block size**: 128 bits
- **Variable key size**: 128, 192 or 256 bits
- **Number of rounds**: depends on key size
  - 10 rounds for 128-bit key
  - 12 rounds for 192-bit key
  - 14 rounds for 256-bit key
- **Usage modes**: ECB, CBC, CFB, OFB, CTR

**Advantages over DES:**

- ✓ **Open process**: consultation and analysis by worldwide experts
- ✓ **~2× more performant** in software
- ✓ **~10²² times more secure** (theoretically)
- ✓ **Scalable**: key size can be increased if necessary

#### AES Structure

**Basic unit**: **State** matrix of 4 rows × 4 columns (for 128-bit key)

- Each element = 1 byte
- **Total**: 16 bytes = 128 bits

**Operations on field** $GF(2^8)$:

- Byte = element of $GF(2^8)$
- Finite field of polynomials of degree ≤ 7 with coefficients in $GF(2)$
- Additions, multiplications defined in $GF(2^8)$

```{mermaid}
graph TB
    subgraph State_Matrix
        S00[s0,0] --- S01[s0,1]
        S01 --- S02[s0,2]
        S02 --- S03[s0,3]
        
        S10[s1,0] --- S11[s1,1]
        S11 --- S12[s1,2]
        S12 --- S13[s1,3]
        
        S20[s2,0] --- S21[s2,1]
        S21 --- S22[s2,2]
        S22 --- S23[s2,3]
        
        S30[s3,0] --- S31[s3,1]
        S31 --- S32[s3,2]
        S32 --- S33[s3,3]
    end
    
    style S00 fill:#ffe6cc
    style S11 fill:#ffe6cc
    style S22 fill:#ffe6cc
    style S33 fill:#ffe6cc
```

#### AES Round Detail

**Four operations per round:**

**1. SubBytes (ByteSub)**

- Non-linear substitution via **S-box**
- Each byte transformed independently
- Resistance to linear and differential cryptanalysis

**2. ShiftRows**

- **Permutation of bytes** with variable shifts per row
- Row 0: no shift
- Row 1: left shift 1 position
- Row 2: left shift 2 positions
- Row 3: left shift 3 positions

**3. MixColumns**

- Each column = linear combination of other columns
- **Matrix multiplication** in $GF(2^8)$
- Maximum diffusion

**4. AddRoundKey**

- **XOR** of the State matrix with the round subkey
- Subkey = result of Key Schedule

```{mermaid}
graph TB
    Input[State Input] --> SB[SubBytes]
    SB --> SR[ShiftRows]
    SR --> MC[MixColumns]
    MC --> ARK[AddRoundKey]
    K[Round Key] --> ARK
    ARK --> Output[State Output]
    
    style SB fill:#ffcccc
    style SR fill:#ccffcc
    style MC fill:#cce5ff
    style ARK fill:#ffffcc
```

**Final round**: identical EXCEPT **no MixColumns**

#### Key Schedule (Subkey Generation)

**Process:**

1. **Key Expansion**: generation of an extended matrix
   - Key 128 bits → matrix 4 × 4 × ($N_e$ + 1) bytes
   - $N_e$ = number of rounds
2. **Key Selection**: extraction of subkeys
   - First subkey: first 4 columns
   - Second subkey: next 4 columns
   - Etc.

**Operations:**

- Byte rotations
- Substitutions via S-box
- XOR with constants (Rcon)

#### AES Pseudo-code

```
Rijndael(State, CipherKey) {
    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule
    
    AddRoundKey(State, ExpandedKey[0..3]); // Initial XOR
    
    for(i = 1; i < Ne; i++) {
        Round(State, ExpandedKey[4*i...(4*i)+3]);
    }
    
    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Without MixColumns
}
```

#### AES Decryption

**Principle**: apply the **inverse operations** in each round.

**Inverse operations:**

- **InvSubBytes**: inverse substitution via S-box⁻¹
- **InvShiftRows**: right shifts (instead of left)
- **InvMixColumns**: inverse matrix multiplication
- **AddRoundKey**: self-inverse (XOR)

**Order**: inverse of encryption with subkeys in reverse order

::: {.callout-note collapse=true}
### 📄 Original text (AES)

#### Advanced Encryption Standard (AES)

- Adopted as **standard in November 2001**, designed by **Johan Daemen and Vincent Rijmen** (hence its original name **Rijndael**).

- It is also an **iterative block cipher** (like DES) but **not a Feistel Cipher**.

- **Plaintext/Ciphertext Blocks**: **128 bits**.

- **Variable key length**: **128, 192, or 256 bits**.

- Unlike DES, AES comes from an **open consultation and analysis process** involving worldwide experts.

- Techniques similar to DES (substitutions, permutations, XOR…) complemented by **simple and very performant algebraic operations**.

- All operations are performed in the **field** $GF(2^8)$: the finite field of **polynomials of degree ≤ 7** with **coefficients in** $GF(2)$.

- In particular, a **byte for AES is an element in** $GF(2^8)$ and the **operations on bytes** (additions, multiplications,...) are **defined as in** $GF(2^8)$.

- **~2 times more performant** (in software) and **~10²² times (in theory...) more secure** than DES...

- **Scalable**: The key size can be increased if necessary.

##### Detail of an AES Step (round)

The **basic unit** on which calculations are applied is a **matrix of 4 rows and 4 columns** (in the case of a 128-bit key) whose elements are **bytes**:

- **ByteSub**: **Non-linear operation (S-box)** designed to **resist linear and differential cryptanalysis**.

- **ShiftRow**: **Permutation of bytes** introducing **variable shifts** on the rows.

- **MixColumn**: Each column is replaced by **linear combinations** of the other columns (**matrix multiplication** !)

- **AddRoundKey**: **XOR** of the current matrix with the **subkey** corresponding to the current step.

##### AES: Global Operation

- The **number of steps** of AES varies depending on the **key size**. For a **128-bit key**, **10 steps** must be performed. Each increase of 32 bits in the key size entails an **additional step** (14 steps for 256-bit keys).

- **Decryption** consists of applying the **inverse operations** in each of the steps (**InvSubBytes**, **InvShiftRows**, **InvMixColumns**). **AddRoundKey** (because of XOR) is **its own inverse**.

- The **Key Schedule** consists of:
  - An operation of **key expansion** of the main key. If $N_e$ is the number of steps (depending on the key), a **matrix of 4 rows and 4 × ($N_e$ + 1) columns** is generated.
  - An operation of **step key selection**: The **first subkey** will be constituted by the **first 4 columns** of the matrix generated during expansion and so on.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (AES)

**AES** (Rijndael 2001): iterative block cipher (NOT Feistel), 128-bit blocks, keys 128/192/256 bits → 10/12/14 rounds.

**State**: 4×4 byte matrix in $GF(2^8)$.

**4 operations/round**:

  - SubBytes (non-linear S-box)
  - ShiftRows (row shifts)
  - MixColumns (linear combinations)
  - AddRoundKey (XOR subkey).

2× faster than DES, 10²² times more secure.
:::

---

### 7. Attacks and AES Security

#### AES Strengths

**Simplicity and performance:**

- ✓ Simple and efficient algorithm
- ✓ Works on limited platforms (8-bit smart cards)
- ✓ Hardware and software optimizations

#### Published Attacks

**1. Algebraic attacks (2002)**

**XSL technique** (N. Courtois and P. Pieprzyk):

- Represents AES as **system of 8000 quadratic equations** with 1600 binary unknowns
- **Estimated effort**: $2^{100}$ operations (still a conjecture)
- **Characteristic**: requires few known plaintexts
- **Distinction**: different from linear/differential attacks

**Critique**: based on the "highly algebraic" character of AES (largely contested)

**2. Related Key Attacks (2009-2011)**

**Principle**: attacks based on **similar keys**

- Interesting results on **reduced versions** of AES
- Do not compromise full AES

**3. Side Channel Attacks**

**Principle**: attacks on **implementation** (not the algorithm)

**Techniques:**

- **Cache timing attacks**: cache access analysis
- **Power analysis**: power consumption
- **Electromagnetic analysis**: electromagnetic emissions

**Example** (2005): Osvik, Shamir, Tromer

- Extraction of 128-bit key with **6-7 plaintext/ciphertext pairs**
- Based on **cache access** analysis

**4. Meet in the Middle on biclique structures (2011-2015)**

**Result:**

- Reduces effort for AES-128 to **$2^{126}$** (factor 4 vs brute force)
- **Remains well above** current capabilities

#### Practical Security

**Fundamental assumption**: key of **maximum entropy**

**Recent attacks** (WPA2, etc.):

- Exploit **weakness of passwords/passphrases**
- No flaw in AES itself
- Problem: key generation from weak passwords

**⚠️ Critical reminder**: key quality = system security

::: {.callout-note collapse=true}
### 📄 Original text (AES Attacks)

#### AES: Final Remarks and Attacks (I)

- The greatest **strength of AES** lies in its **simplicity** and its **performance**, including on **reduced computing capacity platforms** (e.g. **smart cards** with 8-bit processors).

- Since its official publication, **many cryptanalysis works** have been published with very interesting results. In particular, **N. Courtois and P.Pieprzyk** presented a technique called **XSL** allowing to represent AES as a **system of 8000 quadratic equations** with **1600 binary unknowns**. The **effort needed** to break this system is estimated (it is still a **conjecture**...) to be **$2^{100}$**.

- These attacks are based on the **highly algebraic character** (and largely contested...) of AES. Moreover, only **a few known plaintexts** are needed to set them up, which distinguishes them from linear and differential attacks.

- In recent years (2009-2011) **attacks based on similar keys** (related key attacks) have obtained interesting results on **reduced versions** of AES.

- Another family of attacks called **side channel attacks** acting directly on the **algorithm implementation** allows extracting cryptographically relevant information during encryption execution.

#### AES: Final remarks and Attacks (II)

- In **2015** a **Meet in the Middle** type attack based on **biclique structures** showed that it was possible to reduce the **effort needed** to find an AES-128 key to **$2^{126}$**, i.e., a **factor of 4** compared to brute force. This nevertheless remains **well above** current computing capabilities.

- Another family of attacks called **side channel attacks** acting directly on the **algorithm implementation** allows extracting cryptographically relevant information during encryption execution. In particular, the authors manage to **extract the 128-bit key** with only **6-7 plaintext/ciphertext pairs** based on **cache accesses**.

- The **security of AES** (as for any other encryption algorithm) is always based on the assumption of a **key of maximum entropy**. The **attacks published recently** on protocols based on AES (like WPA2) exploit the **weakness of passwords/passphrases** that are the origin of the keys used.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (AES Security)

**Strengths**: simplicity, performance (even 8-bit cards). **Attacks**: XSL ($2^{100}$, algebraic), related keys (reduced versions), side channel (implementation, cache), Meet-in-Middle biclique ($2^{126}$). **Security**: assumption of max entropy key. Practical attacks = weak passwords, not AES flaw.
:::

---

### 8. Block Cipher Cryptanalysis Techniques

#### 8.1 Differential Cryptanalysis

**Principle**: **chosen plaintext** attack analyzing the **propagation of differences** between two plaintexts through the rounds.

**Method:**

1. Choose two plaintexts with known difference: $x_a$ and $x_b$
2. Observe propagation: $\Delta x = x_a \oplus x_b$
3. Analyze ciphertexts: $\Delta y = y_a \oplus y_b$
4. **Assign probabilities to keys** according to observed changes
5. **Most probable key** = correct key (after many trials)

**Characteristics:**

- Requires **$2^{47}$ chosen plaintext pairs** for DES
- **Probabilities**: depend on S-boxes and structure
- The more pairs increase, the more success probability increases

**Sensitivity**: very sensitive to **number of rounds**

- Chances of success increase **exponentially** when rounds decrease

#### 8.2 Linear Cryptanalysis

**Principle**: **known plaintext** attack creating a **linear simulator** of the block cipher.

**Method:**

1. Create **linear approximations** of the algorithm
2. Analyze a large number of plaintext/ciphertext pairs
3. The bits of the simulator key **tend to coincide** with those of the real key (probabilistic calculation)

**Complexity for DES:**

- **$2^{38}$ known plaintexts** → 10% probability of guessing correctly
- **$2^{43}$ known plaintexts** → 85% success probability

**Characteristics:**

- **Most powerful analytical attack** to date on block ciphers
- Also **sensitive to number of rounds**

#### 8.3 Differential vs Linear Comparison

**Common difficulties:**

- ✗ **Parallelization**: less efficient than parallel brute force
- ⚠️ **Sensitivity to rounds**: efficiency decreases exponentially with number of rounds

**DES and these attacks:**

- Widespread conjecture: DES designers **knew these attacks** (1970s, unpublished at the time)
- **S-box design**: very high resistance to both techniques

#### 8.4 Meet-in-the-Middle Attack

**Principle**: exploits **composite constructions** of type $y = E_{K_2}(E_{K_1}(x))$.

**Method:**

1. Build list $L_1$: $L_1 = \{E_{K_1}(x) \mid K_1 \in \text{KeySpace}\}$
2. Build list $L_2$: $L_2 = \{D_{K_2}(y) \mid K_2 \in \text{KeySpace}\}$
3. Identify **repeated elements** in $L_1$ and $L_2$
4. Verify hypothesis with **second known plaintext**
5. The associated keys $K_1$ and $K_2$ are probably the sought keys

**Example for DES:**

Intuitive key space for $E_{K_2}(E_{K_1}(x))$: $\{0,1\}^{112}$

**Actual effort:**

- **$2^{57}$ operations** to establish the two lists
- **$2^{56}$ blocks** of 64 bits storage
- **Significantly lower** than the intuitive $2^{112}$

**Applications:**

- Attacks on **composite constructions**
- **Internal** cryptanalysis of block ciphers

```{mermaid}
graph TB
    subgraph Meet_in_Middle
        X[Known Plaintext x] --> E1[Encrypt K1]
        E1 --> M[Middle Value m]
        M --> E2[Encrypt K2]
        E2 --> Y[Known Ciphertext y]
        
        X2[x] --> L1[List L1: EK1 for all K1]
        Y2[y] --> L2[List L2: DK2 for all K2]
        
        L1 -.match.-> Match[Find common m]
        L2 -.match.-> Match
    end
    
    style M fill:#ffffcc
    style Match fill:#ccffcc
```

::: {.callout-note collapse=true}
### 📄 Original text (Cryptanalysis)

#### Block Cipher Cryptanalysis Techniques

**Differential Cryptanalysis**

- This is a **chosen plaintext attack** that focuses on the **propagation of differences** in two plaintexts as they evolve through the different steps of the algorithm.

- It **assigns probabilities to keys** it "guesses" based on the **changes** they induce on the ciphertexts. The **most probable key** has a good chance of being the correct key after a **large number** of plaintext/ciphertext pairs.

- Requires **$2^{47}$ chosen plaintext pairs** (for DES) to obtain correct results.

**Linear Cryptanalysis**

- This is a **known plaintext attack** that creates a **block simulator** from **linear approximations**. By analyzing a **large number** of plaintext/ciphertext pairs, the **bits of the simulator key** tend to **coincide** with those of the analyzed block cipher (**probabilistic calculation**)

- For DES an attack based on this technique requires **$2^{38}$ known plaintexts** to obtain a probability of **10%** of guessing correctly and **$2^{43}$ for 85%** !

- It is the **most powerful analytical attack** to date on block ciphers.

#### Block Cipher Cryptanalysis Techniques (II)

- The practical implementation of **differential and linear attacks** presents **difficulties in parallelizing** calculations compared to an exhaustive key search.

- These two attacks are **very sensitive to the number of steps** of the block cipher: chances of success increase **exponentially** as the number of algorithm steps decreases.

- A widespread conjecture among cryptographers is that these attacks, at the time **unpublished**, were **known to the designers of DES**. In particular, the **design of the S-boxes** offers a **very high resistance** to both techniques.

**Meet-in-the-Middle Attack**

- Applies to constructions of the type $y := E_{K_2}(E_{K_1}(x))$. For DES, the key space for this solution would be $\{0,1\}^{112}$. First build **two lists** $L_1$ and $L_2$ of $2^{56}$ messages of the form: $L_1 = E_{K_1}(x)$ and $L_2 = D_{K_2}(y)$ with $E$ and $D$ the encryption and decryption operations respectively. Then **identify elements that repeat** in both lists and **verify our hypothesis** with a second known plaintext. The $K_1$ and $K_2$ associated with this pair of known plaintexts will (in all likelihood) be **the sought keys** !

- **Effort required** to carry out the attacks (for DES): **$2^{57}$ operations** to establish the two lists + **$2^{56}$ blocks** of 64 bits of storage to memorize intermediate results... **significantly lower** than the intuitive $2^{112}$...

- These meet-in-the-middle techniques are also applied to the **internal cryptanalysis** of block ciphers.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (Cryptanalysis)

**Differential**: chosen plaintext, difference propagation, probabilities on keys, $2^{47}$ pairs (DES).

**Linear**: known plaintext, linear approximations, $2^{38}$-$2^{43}$ plaintexts (DES), most powerful attack.

**Meet-in-Middle**: composite constructions, 2 lists $2^{56}$, effort $2^{57}$ << $2^{112}$.

**Sensitivity**: very dependent on number of rounds.
:::
# Asymmetric Cryptography (Public Key Cryptography)

## Mathematical Foundations

### Fundamental Theorem of Arithmetic and Euler's Totient Function

Asymmetric cryptography relies on solid mathematical foundations from number theory. Two concepts are essential:

**Fundamental Theorem of Arithmetic**: Every positive integer greater than 1 can be written uniquely (up to order) as a product of prime powers:

$$n = p_1^{e_1} \cdot p_2^{e_2} \cdot p_3^{e_3} \cdots p_m^{e_m}$$

**Euler's Totient Function $\phi(n)$**: Number of positive integers smaller than $n$ that are coprime with $n$.

To compute $\phi(n)$:

$$\phi(n) = \prod_{i=1}^{m} p_i^{e_i} \cdot \left(1 - \frac{1}{p_i}\right)$$

**Important special case**: If $n = p \cdot q$ with $p$ and $q$ prime, then:

$$\phi(n) = (p-1)(q-1)$$

::: {.callout-note collapse=true title="Original Text"}
### Mathematical Foundations

**Fundamental Theorem of Arithmetic**: Every positive integer $n$ can be written uniquely (up to order) as a product of powers of distinct prime numbers $p_i$:

$$n = p_1^{e_1} \cdot p_2^{e_2} \cdot p_3^{e_3} \cdots p_m^{e_m}$$

**Euler's Totient Function**: Let $n \in \mathbb{Z}^+$, the **Euler's totient function** $\phi(n)$ is equal to the number of positive integers smaller than $n$ that are **relatively prime** to $n$.

**Calculation of Euler's totient function**: According to the fundamental theorem of arithmetic, every integer $n > 1$ can be written as:

$$n = \prod_{i=1}^{m} p_i^{e_i}$$

then $\phi(n)$ is calculated as:

$$\phi(n) = \prod_{i=1}^{m} \left(p_i^{e_i} - p_i^{e_i-1}\right)$$

In particular, if $n = p \cdot q$ with $p$ and $q$ prime, then:

$$\phi(n) = (p-1)(q-1)$$
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Unique decomposition**: every integer = product of prime numbers
- **$\phi(n)$**: counts integers $< n$ coprime with $n$
- **Key for RSA**: if $n = pq$ (primes) then $\phi(n) = (p-1)(q-1)$
:::

---

### Euler's Theorem and Fermat's Little Theorem

These theorems are at the heart of RSA and other asymmetric algorithms.

**Euler's Theorem**: If $n \in \mathbb{Z}^+$ and $a \in \mathbb{Z}$ with $\text{gcd}(a,n) = 1$, then:

$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**Fermat's Little Theorem** (special case if $n = p$ prime): If $a \in \mathbb{Z}$ and $p$ prime does not divide $a$:

$$a^{p-1} \equiv 1 \pmod{p}$$

**Important applications**:

1. **Exponent reduction**: If $n$ is a product of distinct primes and $r \equiv s \pmod{\phi(n)}$, then:
   $$a^r \equiv a^s \pmod{n}$$

2. **Calculation of inverses**: $a^{\phi(n)-1}$ is the inverse of $a$ modulo $n$. In particular, if $p$ is prime, $a^{p-2}$ is the inverse of $a$ modulo $p$.

::: {.callout-note collapse=true title="Original Text"}
### Mathematical Foundations (II)

**Euler's Theorem**: Let $n \in \mathbb{Z}^+$ and $a \in \mathbb{Z}$ with $\text{gcd}(a,n) = 1$, then we have:

$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**Fermat's Little Theorem** (special case of Euler's theorem if $n$ is prime): Let $a \in \mathbb{Z}$ and $p$ a prime number such that $p$ does not divide $a$, then we have:

$$a^{p-1} \equiv 1 \pmod{p}$$

Note that since $p$ is prime, we have $\phi(p) = p-1$.

**Exponent reduction** $\bmod \phi(n)$: If $n$ is the product of distinct primes and $r, s \in \mathbb{Z}$ such that $r \equiv s \pmod{\phi(n)}$ then $\forall a \in \mathbb{Z}$:

$$a^r \equiv a^s \pmod{n}$$

**Application of Euler's Theorem to inverse calculation**: From Euler's theorem, we have that:

$$a \cdot a^{\phi(n)-1} \equiv 1 \pmod{n}$$

which means that $a^{\phi(n)-1}$ is the **inverse of $a$ modulo $n$**. In particular, $a^{p-2}$ is the inverse of $a$ modulo $n$ if $p$ is prime.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Euler's Theorem**: $a^{\phi(n)} \equiv 1 \pmod{n}$
- **Fermat**: special case if $p$ prime: $a^{p-1} \equiv 1 \pmod{p}$
- **Modular inverse**: $a^{-1} \equiv a^{\phi(n)-1} \pmod{n}$
- **Base of RSA**: enables encryption/decryption with exponents
:::

---

### Multiplicative Groups and Generators

**Multiplicative group $\mathbb{Z}_n^*$**: Set of elements of $\mathbb{Z}_n$ coprime with $n$:

$$\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n \mid \text{gcd}(a,n) = 1\}$$

If $n$ is prime: $\mathbb{Z}_n^* = \{1, 2, \ldots, n-1\}$

**Order of an element**: Smallest positive integer $t$ such that $a^t \equiv 1 \pmod{n}$

**Generator**: An element $\alpha$ is a generator of $\mathbb{Z}_n^*$ if its order is $\phi(n)$. Then $\mathbb{Z}_n^*$ is said to be **cyclic**.

**Properties of generators**:

1. $\mathbb{Z}_n^*$ has a generator iff $n = 2, 4, p^k$ or $2p^k$ (with $p$ prime, $p \neq 2$ and $k \geq 1$)
2. If $p$ is prime, $\mathbb{Z}_p^*$ always has a generator
3. If $\alpha$ is a generator, all elements can be written as: $\mathbb{Z}_n^* = \{\alpha^i \bmod n \mid 0 \leq i < \phi(n)\}$
4. The number of generators is $\phi(\phi(n))$

**Generator test**

- $\alpha$ is a generator of $\mathbb{Z}_n^*$ iff for every prime $p$ dividing $\phi(n)$, $\alpha^{\phi(n)/p} \not\equiv 1 \pmod{n}$
- if $n = 2p+1$ is a "safe prime" with $p$ prime: $\alpha$ is a generator iff $\alpha^2 \not\equiv 1 \pmod{n}$ and $\alpha^p \not\equiv 1 \pmod{n}$

::: {.callout-note collapse=true title="Original Text"}
### Mathematical Foundations (III)

**Definition**: The **multiplicative group of $\mathbb{Z}_n$**, denoted $\mathbb{Z}_n^*$ is:

$$\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n \mid \text{gcd}(a,n) = 1\}$$

In particular, if $n$ is prime: $\mathbb{Z}_n^* = \{a \mid 1 \leq a \leq n-1\}$

The **number of elements or order** of the multiplicative group $\mathbb{Z}_n^*$ is $\phi(n)$ (by definition of $\phi$).

**Definition**: Let $a \in \mathbb{Z}_n$, the **order of $a$** is the smallest positive integer $t$ for which:

$$a^t \equiv 1 \pmod{n}$$

**Definition**: Let $\alpha \in \mathbb{Z}_n^*$, if the order of $\alpha$ is $\phi(n)$, then $\alpha$ is a **generator of $\mathbb{Z}_n^*$**. When a group $\mathbb{Z}_n^*$ has a generator, it is said to be **cyclic**.

**Properties of generators**:

- $\mathbb{Z}_n^*$ has a generator iff $n = 2, 4, p^k$ or $2p^k$, with $p$ prime, $p \neq 2$ and $k \geq 1$. In particular, if $p$ is prime, $\mathbb{Z}_p^*$ has a generator.

- If $\alpha$ is a generator of $\mathbb{Z}_n^*$, then all elements of $\mathbb{Z}_n^*$ can be written as:
  $$\mathbb{Z}_n^* = \{\alpha^i \bmod n \mid 0 \leq i \leq \phi(n)-1\}$$

- The number of generators of $\mathbb{Z}_n^*$ is $\phi(\phi(n))$.

- $\alpha$ is a generator of $\mathbb{Z}_n^*$ iff for every prime $p$ dividing $\phi(n)$, we have:
  $$\alpha^{\phi(n)/p} \not\equiv 1 \pmod{n}$$

In particular if $n$ is a prime of the form $n = 2p+1$ with $p$ prime (such $n$ is called a **safe prime**), $\alpha$ is a generator of $\mathbb{Z}_n^*$ iff $\alpha^2 \not\equiv 1 \pmod{n}$ and $\alpha^p \not\equiv 1 \pmod{n}$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **$\mathbb{Z}_n^*$**: elements coprime with $n$, cardinality = $\phi(n)$
- **Generator**: element of order $\phi(n)$ (generates the entire group)
- **Crucial for DH and ElGamal**: security based on discrete logarithm in cyclic group
- **Safe prime**: $n = 2p+1$ with $p$ and $n$ prime
:::

---

### Fast Exponentiation

Efficient computation of $a^k \bmod n$ in polynomial time, essential for all asymmetric algorithms.

**Principle**: Use the binary representation of the exponent $k$.

**Example**: Computation of $2^{644} \bmod 645$

1. Binary representation: $(644)_{10} = (1010000100)_2$

2. Compute successive powers of 2 modulo 645:
   - $2^1 \bmod 645$
   - $2^2 \bmod 645$
   - $2^4 \bmod 645$
   - $2^8 \bmod 645$
   - ...
   - $2^{512} \bmod 645$

3. Combine according to bits set to 1: $2^{644} = 2^{512} \cdot 2^{128} \cdot 2^4$

**Complexity**: $O(\log^3 n)$ - very efficient!

**Application**: Computation of the inverse using Euler's theorem in polynomial time.

Alternative: **Extended Euclidean algorithm** to find $x$ such that $ax \equiv 1 \pmod{n}$ by solving $ax - kn = 1 = \text{gcd}(a,n)$. Complexity also $O(\log^3 n)$.

::: {.callout-note collapse=true title="Original Text"}
### Fast Exponentiation

**Fast exponentiation**: Using the binary representation of a number, we can compute powers very efficiently.

**Example**: computation of $2^{644} \bmod 645$

$(644)_{10} = (1010000100)_2$

Now, we compute the exponents corresponding to the powers of 2, namely:

$$2^1 \bmod 645, \quad 2^2 \bmod 645, \quad 2^4 \bmod 645, \quad \ldots, \quad 2^{512} \bmod 645$$

From the binary representation, we compute:

$$2^{644} = 2^{512+128+4} = 2^{512} \cdot 2^{128} \cdot 2^4 = 160 \cdot 153 \cdot 6 \bmod 645$$

**The complexity of this algorithm** fast exponentiation is $O(\log^3 n)$.

By relying on **Euler's theorem**, the computation of the **inverse of a number** in such a group is therefore performed in polynomial time.

**The extended Euclidean algorithm** can also be used to find an $x$ such that:

$$ax \equiv 1 \pmod{n}$$

since this congruence can be written as: $ax - 1 = kn$ and therefore:

$$ax - kn = 1 = \text{gcd}(a,n)$$

The complexity of this algorithm is also $O(\log^3 n)$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Idea**: binary representation of the exponent
- **Complexity**: $O(\log^3 n)$ - polynomial!
- **Essential**: makes RSA, ElGamal, DH practical
- **Alternative**: extended Euclidean algorithm for inverses
:::

---

### Chinese Remainder Theorem (CRT)

The CRT allows solving systems of simultaneous congruences, with important applications in cryptography.

**Theorem**: Let $n_1, n_2, \ldots, n_t \in \mathbb{Z}^+$ pairwise coprime (gcd$(n_i, n_j) = 1$ if $i \neq j$) and $a_1, a_2, \ldots, a_t \in \mathbb{Z}$. Then the system:

$$\begin{cases}
x \equiv a_1 \pmod{n_1} \\
x \equiv a_2 \pmod{n_2} \\
\vdots \\
x \equiv a_t \pmod{n_t}
\end{cases}$$

has a unique solution $x \bmod N$ with $N := n_1 \cdot n_2 \cdots n_t$.

**Gauss's algorithm** (1801) to compute $x$:

$$x = \sum_{i=1}^{t} a_i N_i M_i \bmod N$$

with:

- $N_i = N/n_i$
- $M_i = N_i^{-1} \bmod n_i$ (modular inverse)

**Complexity**: $O(\log^3 n)$ - polynomial!

**Cryptographic applications**:

1. Acceleration of RSA computations (use $p$ and $q$ separately)
2. Secret sharing (secret sharing schemes)
3. Certain attacks on RSA (if small exponent and multiple messages)

::: {.callout-note collapse=true title="Original Text"}
### Chinese Remainder Theorem

The **Chinese Remainder Theorem** (3rd century!) allows solving linear systems of simultaneous congruences. It solves problems raised in ancient Chinese puzzles. It was, for example, about finding a number that produces a remainder of 1 when divided by 3, of 2 when divided by 5 and of 3 when divided by 7... It was also used to calculate the exact moment of alignment of several celestial bodies having different orbits (and therefore periods).

**Chinese Remainder Theorem**: Let $n_1, n_2, \ldots, n_t \in \mathbb{Z}^+$ be pairwise coprime (i.e., gcd$(n_i, n_j) = 1$, $\forall i \neq j$) and $a_1, a_2, \ldots, a_t \in \mathbb{Z}$. Then, the system of congruences:

$$\begin{cases}
x \equiv a_1 \pmod{n_1} \\
x \equiv a_2 \pmod{n_2} \\
\vdots \\
x \equiv a_t \pmod{n_t}
\end{cases}$$

has a unique solution $x \bmod N := n_1 n_2 \cdots n_t$

**Gauss's algorithm** (1801) for the computation of $x$:

$$x = \sum_{i=1}^{t} a_i N_i M_i \bmod N$$

with $N_i = N/n_i$ and $M_i = N_i^{-1} \bmod n_i$.

The **complexity** of this algorithm is $O(\log^3 n)$.

It is therefore possible in **polynomial time** to go from congruences mod $n_i$ to congruences mod $N$!
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Solves**: systems of congruences with pairwise coprime moduli
- **Unique solution**: modulo product of moduli
- **Complexity**: $O(\log^3 n)$ (polynomial)
- **Crypto usage**: RSA optimization, attacks if small exponent
:::

---

## Basic Problems and Complexity

### Classification of Hard Problems

The security of asymmetric cryptography relies on mathematical problems reputed to be hard:

**Generic problems**:

1. **Factorization (FACTP)**: Given $n$, find its factorization into prime numbers
   - Base of **RSA** and **Rabin**

2. **Discrete Logarithms (DLP)**: Given prime $p$, a generator $\alpha \in \mathbb{Z}_p^*$ and $\beta \in \mathbb{Z}_p^*$, find $x$ such that:
   $$\alpha^x \equiv \beta \pmod{p}$$
   - Base of **ElGamal** and **Diffie-Hellman**

3. **Square Root modulo composite (SQROOTP)**: Given composite $n$ and a quadratic residue $a$, find $\sqrt{a} \bmod n$
   - Base of **Rabin**

**Specific problems**:

1. **RSA Problem (RSAP)**: Given $n = pq$, $e$ with gcd$(e, \phi(n)) = 1$ and $c$, find $m$ such that $m^e \equiv c \pmod{n}$

2. **Diffie-Hellman Problem (DHP)**: Given prime $p$, generator $\alpha$, $\alpha^a \bmod p$ and $\alpha^b \bmod p$, find $\alpha^{ab} \bmod p$

**Proven equivalences**:

- **DHP ⟺ DLP** (equivalent under certain conditions)
- **RSAP ⟺ FACTP** (proven equivalent for the generic case)
- **SQROOTP ⟺ FACTP**

::: {.callout-note collapse=true title="Original Text"}
### Basic Problems

**Main generic problems**:

- **Factorization (FACTP)**: Given a positive integer $n$, find its factorization into prime numbers.

- **Discrete Logarithms (DLP)**: Given a prime number $p$, a generator $\alpha \in \mathbb{Z}_p^*$ and an element $\beta \in \mathbb{Z}_p^*$, find the integer $x$, $0 \leq x \leq p-2$, such that: $\alpha^x \equiv \beta \pmod{p}$.

- **Square Root in $\mathbb{Z}_n$ if $n$ is composite (SQROOTP)**: Given a composite integer $n$ and a quadratic residue $a$, find the square root of $a$ mod $n$.

**Specific problems** (proper to an encryption system):

- **RSA (RSAP)**: Given a positive integer $n = pq$, a positive integer $e$ with gcd$(e, (p-1)(q-1)) = 1$ and an integer $c$, find an integer $m$ with $m^e \equiv c \pmod{n}$.

- **Diffie-Hellman (DHP)**: Given a prime number $p$, a generator $\alpha \in \mathbb{Z}_p^*$ and the elements $\alpha^a \bmod p$ and $\alpha^b \bmod p$, find $\alpha^{ab} \bmod p$.

**Proven results**:

- **DHP ⟺ DLP** (Equivalent under certain conditions)
- **RSAP ⟺ FACTP** (Proven equivalent for the generic problem)
- **SQROOTP ⟺ FACTP**
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **FACTP**: factor $n$ → base of RSA/Rabin
- **DLP**: find discrete logarithm → base ElGamal/DH
- **SQROOTP**: square root mod composite → Rabin
- **Equivalences**: breaking = solving the base problem
:::

---

### Factorization Techniques

The security of RSA depends on the difficulty of factoring large numbers.

**Exponential time methods**: $O(\exp(c \cdot \ln(n)))$

- Trial Division (successive division)
- Sieve of Eratosthenes (2nd century BC)
- Fermat's Method (~1650)
- Pollard's $\rho$ Method (1975)
- Pollard's $p-1$ Method (1974)

**Sub-exponential time methods**: $O(\exp(c \cdot (\ln(n))^{1/3}))$

- Continued Fractions (1975)
- **Quadratic Sieve (1981)** - very effective in practice
- **Number Field Sieve - NFS (1990)** - currently the fastest
- General Number Field Sieve - GNFS (2006)

**Polynomial time methods**:

- **Shor's Algorithm** (1994): $O(\log^c n)$ on **quantum computer**

**Current records (2020)**:

- Largest number factored: **RSA-829** (250 digits, 829 bits)
- Computation time: 2700 core-years (Intel Xeon Gold 6130 CPUs)
- Method: General Number Field Sieve

**Implications**:

- RSA keys < 1024 bits: **vulnerable**
- RSA keys 1024 bits: **limits** (states with significant resources)
- Recommendation: **2048 bits minimum** (3072-4096 for long term)

::: {.callout-note collapse=true title="Original Text"}
### Classical Factoring Techniques and New Developments

**Exponential time**: $O(\exp(c \cdot \ln(n)))$

- Trial Division
- Eratosthenes' Sieve (II B.C.)
- Fermat's Difference of Squares Method (~1650)
- Square Form Factorization (1971)
- Pollard's p-1 method (1974)
- Pollard's Rho Method (1975)

**Sub-exponential time**: $O(\exp(c \cdot (\ln(n))^{1/3}))$

- Continued Fractions (1975)
- **Quadratic Sieve (1981)**
- **Number Field Sieve - NFS (1990)**
- **General Number Field Sieve - GNFS (2006)**

**Polynomial time**:

- **Shor's Algorithm in a Quantum Computer (1994)**: $O(\log^c n)$

**Recent developments**:

- Bernstein's specific NFS computer to factor a 1536-bit number would take the same time as a 512-bit computation on a conventional machine
- **Largest factorization to date (2020)**: RSA-829 (250-digit number) using NFS
- Total computation time: **2700 core-years** (Intel Xeon Gold 6130 CPUs at 2.1GHz)

**Factorization on quantum computer**:

- Significant problems (errors, dispersion, etc.)
- 2001: 7-qubit computer (IBM Almaden)
- Feasibility of a computer with millions of qubits... ?
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Sub-exponential**: NFS currently the fastest
- **Record 2020**: RSA-829 (829 bits) in 2700 core-years
- **Recommendation**: keys ≥ 2048 bits for RSA
- **Future threat**: quantum computers (Shor)
:::

---

## The RSA Algorithm

### RSA Operation (Encryption/Decryption)

RSA (Rivest-Shamir-Adleman, 1978) is the most used asymmetric algorithm.

**Key generation**:

1. Choose two **large** prime numbers $p$ and $q$ (≥ 1024 bits each)
2. Compute $n := p \cdot q$ and $\phi(n) = (p-1)(q-1)$
3. Choose encryption exponent $e$ with:
   - $1 < e < \phi(n)$
   - gcd$(e, \phi(n)) = 1$
4. Compute decryption exponent $d$ such that:
   $$e \cdot d \equiv 1 \pmod{\phi(n)}$$
   (using extended Euclidean algorithm or fast exponentiation)

**Resulting keys**:

- **Public** key: $(n, e)$
- **Private** key: $d$ (keep $p$ and $q$ secret too!)

**Encryption** (by Bob, to Alice):

1. Obtain authentic public key $(n, e)$ of Alice
2. Transform plaintext into integers $m_i \in [0, n-1]$
3. Compute ciphertexts: $c_i := m_i^e \bmod n$
4. Send the $c_i$ to Alice

**Decryption** (by Alice):

- Use private key $d$ to compute:
   $$m_i = c_i^d \bmod n$$

**Proof of operation**:

$$c^d \equiv (m^e)^d \equiv m^{ed} \pmod{n}$$

Since $ed \equiv 1 \pmod{\phi(n)}$, there exists $k$ such that $ed = 1 + k\phi(n)$, therefore:

$$c^d \equiv m^{1+k\phi(n)} \equiv m \cdot (m^{\phi(n)})^k \equiv m \cdot 1^k \equiv m \pmod{n}$$

(by Euler's theorem)

::: {.callout-note collapse=true title="Original Text"}
### RSA Encryption/Decryption Procedure and Proof

**Key generation**:

- Each entity (A) creates a key pair (public and private) as follows:
  - A chooses the size of the modulus $n$ (e.g., size$(n) = 1024$ or size$(n) = 2048$).
  - A generates two prime numbers $p$ and $q$ of large size $(n/2)$.
  - A computes $n := pq$ and $\phi(n) = (p-1)(q-1)$.
  - A generates the encryption exponent $e$, with $1 < e < \phi(n)$ such that gcd$(e, \phi(n)) = 1$.
  - A computes the decryption exponent $d$, such that: $ed \equiv 1 \pmod{\phi(n)}$ using the extended Euclidean algorithm or fast exponentiation.
- The pair $(n,e)$ is A's **public** key; $d$ is A's **private** key.

**Encryption**:

- Entity B obtains $(n,e)$, the **authentic** public key of A.
- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in [0, n-1]$ $\forall i$.
- B computes the ciphertext $c_i := m_i^e \bmod n$, $\forall i$ using fast exponentiation.
- B sends to A all the ciphertexts $c_i$.

**Decryption**:

- A uses its private key to compute the plaintexts $m_i = c_i^d \bmod n$.

**Proof**: Let $m$ be the plaintext and $c$ the ciphertext with $c := m^e \bmod n$, we need to prove: $m \stackrel{!}{=} c^d \bmod n$

Substituting $c$ by its value we obtain:
$$c^d \bmod n = m^{ed} \bmod n \quad (*)$$

but, we know that:
$$ed \equiv 1 \pmod{\phi(n)}$$

and therefore by definition of congruences, there exists an integer $k$ with:
$$ed - 1 = k\phi(n)$$

substituting in (*):
$$c^d \equiv m^{k\phi(n)+1} \equiv m^{k\phi(n)} \cdot m \pmod{n}$$

If gcd$(m,n) = 1$, we have by **Euler's theorem**:
$$m^{\phi(n)} \equiv 1 \pmod{n}$$

therefore:
$$c^d \equiv (m^{\phi(n)})^k \cdot m \equiv m \pmod{n}$$ Q.E.D. !

If gcd$(m,n) \neq 1$, $m$ is necessarily a multiple of $p$ or $q$ (very unlikely case...), we can show by doing the calculations mod $p$ and mod $q$ that the congruence remains true.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Public key**: $(n, e)$ with $n = pq$
- **Private key**: $d$ such that $ed \equiv 1 \pmod{\phi(n)}$
- **Encryption**: $c = m^e \bmod n$
- **Decryption**: $m = c^d \bmod n$
- **Security**: based on difficulty of factoring $n$
:::

```{mermaid}
graph LR
    A[Plaintext m] -->|Encryption: m^e mod n| B[Ciphertext c]
    B -->|Decryption: c^d mod n| C[Plaintext m]
    D[Public key: n, e] -.->|used for| A
    E[Private key: d] -.->|used for| B
    F[p, q secret primes] -->|n = pq| D
    F -->|φn = p-1q-1| E
```

---

### RSA Security

**Equivalence RSA problem ⟺ Factorization**:

- Finding $d$ ⟺ factoring $n$ (proven equivalent)
- Decrypting without $d$ is **not proven** as hard as factoring, but...
- No method faster than factoring is known

**Factorization complexity**:

- Fastest methods: $O(\exp(c \cdot (\ln(n))^{1/3}))$ (sub-exponential)
- Computationally impossible for $n \geq 1024$ bits
- **Current recommendation**: 2048 bits minimum (3072-4096 for long-term security)

**Choice of exponents**:

- **Encryption exponent $e$**:

  - Often **small** for speed: $e = 3, 17, 65537$ (common)
  - Caution: if $e$ too small AND $m < n^{1/e}$, attack possible ($e$-th root in $\mathbb{Z}$)
  - Solution: **randomization** (padding) of the message

- **Decryption exponent $d$**:

  - Must be **large**: at least half the size of $n$
  - If $d$ small: vulnerable to Wiener's attack

**Performance consequence**:

- **Fast encryption** ($e$ small)
- **Slow decryption** ($d$ large)

::: {.callout-note collapse=true title="Original Text"}
### RSA: Security

The **RSAP** problem of finding $m$ from $c$ is not proven to be as hard as factorization but...:

- We can prove that if we find $d$ we can easily compute $p$ and $q$. This is equivalent to saying that **factoring $n$ and finding $d$ require equivalent computational effort**.

- We know that the fastest methods for factoring have a **sub-exponential complexity** $O(\exp(c \cdot (\ln(n))^{1/3}))$. The problem therefore remains **computationally impossible** for modulus $\geq 1048$ bits (2048 bits is a frequent choice for long-term security...).

- To improve encryption speed, we tend to choose **relatively small exponents $e$** (typically: $e := 3$, $e := 17$ and $e := 19$). However, it has been proven that computing an $i$-th root (with small $i$) modulo a composite $n$ can be significantly easier than factoring $n$. On the other hand, in 2008 it was proven that the generic RSA problem is equivalent to factorization.

- The **decryption exponent $d$ must imperatively be large** (at least half the size of $n$) to guarantee the system's security.

- Consequently, **encryption is normally significantly faster than decryption** since the exponents used are much smaller!
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Security**: based on difficulty of FACTP (factorization)
- **Recommended size**: $n \geq 2048$ bits
- **Small $e$**: fast encryption (3, 17, 65537)
- **Large $d$**: at least $\text{size}(n)/2$
- **Separate keys**: encryption ≠ signature
:::

---

### Attacks on RSA

#### Attack on small exponent with same message

If the same message $m$ is sent to 3 recipients with $e = 3$:

- $c_1 \equiv m^3 \pmod{n_1}$
- $c_2 \equiv m^3 \pmod{n_2}$
- $c_3 \equiv m^3 \pmod{n_3}$

The **Chinese Remainder Theorem** gives a unique solution $x \bmod n_1n_2n_3$ such that:
$$x \equiv c_1 \pmod{n_1}, \quad x \equiv c_2 \pmod{n_2}, \quad x \equiv c_3 \pmod{n_3}$$

If $m^3 < n_1n_2n_3$ (often true), then $x = m^3$ in $\mathbb{Z}$ and we can compute $m$ by simply taking the integer cube root!

**Protection**: always randomize the message before encryption (OAEP padding)

#### Attack if message small

If $m < n^{1/e}$, then $m^e < n$, so $c = m^e$ (in $\mathbb{Z}$, not modulo). We can directly compute the $e$-th root!

**Protection**: padding mandatory

#### Multiplicative property

$$E(m_1) \cdot E(m_2) \equiv (m_1 \cdot m_2)^e \equiv E(m_1 \cdot m_2) \pmod{n}$$

Allows chosen-ciphertext attacks and blind signatures.

#### General attack

The most effective method remains **factoring $n$** (if parameters well chosen and implementation correct).

::: {.callout-note collapse=true title="Original Text"}
### RSA: Attacks

When we want to encrypt the **same message for a group of correspondents**, it is advisable to introduce variations (**randomization**) before encryption to avoid the following attack:

Assume we compute ciphertexts $c_1, c_2, c_3$ from the same plaintext $m$ and the same exponent $e := 3$ addressed to three entities with modulus: $n_1, n_2, n_3$.

The **Chinese Remainder Theorem** tells us that there exists a solution $x \bmod n_1n_2n_3$, such that:
$$x \equiv c_1 \pmod{n_1}, \quad x \equiv c_2 \pmod{n_2}, \quad x \equiv c_3 \pmod{n_3}$$

But if $m$ does not change for the three encryptions, we have that $x = m^3 \bmod n_1n_2n_3$ and, moreover: $m^3 < n_1n_2n_3$. We can, therefore, find $m$ by computing the **integer cube root** of $m^3$, knowing that for this calculation there exist efficient algorithms!

More generally, if $m < n^{1/e}$, we can apply fast algorithms (in $\mathbb{Z}$) to compute the $e$-th roots of $m^e$. It is therefore advisable to perform **"randomization" of $m$ before encrypting**!

**The multiplicative property of RSA**: $(m_1 m_2)^e \equiv m_1^e \cdot m_2^e \equiv c_1 \cdot c_2 \pmod{n}$

gives rise to **dangerous vulnerabilities** (see blind signatures).

Assuming parameters are correctly chosen and the implementation has no flaws, **the most effective method to "break" the generic RSA algorithm remains factoring $n$**.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Same message, small $e$**: CRT allows extracting $m$!
- **Message too small**: $m < n^{1/e}$ → direct root
- **Multiplicative property**: $E(m_1) \cdot E(m_2) = E(m_1 m_2)$
- **Protection**: always padding/randomization (OAEP)
:::

---

## The ElGamal Algorithm

Asymmetric system (1985) based on the **discrete logarithm problem (DLP)**.

**Keys:**

- Choose prime $p$, generator $\alpha \in \mathbb{Z}_p^*$, secret $a$
- Compute $y = \alpha^a \bmod p$
- **Public**: $(p, \alpha, y)$ | **Private**: $a$

**Encryption:** For message $m$, choose unique random $k$

- $\gamma = \alpha^k \bmod p$
- $\delta = m \cdot y^k \bmod p$
- Send $(\gamma, \delta)$

**Decryption:** $m = \delta \cdot \gamma^{-a} \bmod p$

::: {.callout-note collapse="true" title="Original Text"}
## ElGamal Encryption/Decryption Procedure

**Key generation**

Each entity (A) creates a key pair (public and private) as follows:

- A generates a prime number $p$ (len($p$) ≥ 1024 bits) and a **generator $\alpha$** of the multiplicative group $\mathbb{Z}_p^*$
- A generates a random number $a$, such that $1 \leq a \leq p-2$ and computes $y := \alpha^a \bmod p$
- The **public key** of A is $(p, \alpha, y)$, the **private key** of A is $a$

**Encryption**

- Entity B obtains $(p, \alpha, \alpha^a \bmod p)$, the authentic public key of A
- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in [0, p-1]$ $\forall i$
- For each message $m_i$:
  - B generates a **unique** random number $k$, such that $1 \leq k \leq p-2$
  - B computes $\gamma := \alpha^k \bmod p$ and $\delta := m_i \cdot (\alpha^a)^k \bmod p$ and sends the ciphertext $c := (\gamma, \delta)$

**Decryption**

- A uses its private key $a$ to compute $\gamma^{p-1-a} \bmod p$ (note that: $\gamma^{p-1-a} \equiv \gamma^{-a} \equiv \alpha^{-ak} \bmod p$)
- A retrieves the plaintext by computing: $\delta \cdot \gamma^{-ak} \bmod p$
:::

::: {.callout-tip collapse="true"}
## Quick Revision

**Base**: DLP in $\mathbb{Z}_p^*$

**Ciphertext**: $(\alpha^k, m \cdot y^k)$

**Security**: $k$ must be unique and large

**Disadvantage**: doubles message size
:::

### Essential Remarks

- **Proof**: $\delta \cdot \gamma^{-a} = m \cdot (\alpha^a)^k \cdot (\alpha^k)^{-a} = m \bmod p$
- **Security**: based on DLP (complexity sub-exponential close to factorization)
- **Exponents**: $k$ and $a$ must be large (otherwise vulnerable to baby-step giant-step)
- **Reuse prohibited**: if $k$ repeated, $\delta_1/\delta_2 = m_1/m_2$ reveals the messages
- **Major disadvantage**: ×2 expansion of ciphertext size
- **Generalization**: works on $GF(2^n)$ or elliptic curves

::: {.callout-note collapse="true"}
## Original Text - Remarks

**Proof** that the scheme works: If $s \equiv k^{-1}(m_h - ar) \bmod (p-1)$, we have that: $m_h \equiv (ar + ks) \bmod (p-1)$ and $v_2 = \alpha^{H(m)} \bmod p$. If, as we wish to show $m_h = H(m)$, by reducing exponents mod $(p-1)$, we can rewrite $v_2$: $v_2 \equiv \alpha^{ar+ks} \bmod p$. On the other hand: $v_1 = y^r\alpha^{rs} \equiv \alpha^{ar}\alpha^{ks} \equiv \alpha^{ar+ks} \bmod p$.

The ElGamal procedure is based on the difficulty of computing **discrete logarithms modulo a prime number** (DLP problem) even though it has not been proven to be strictly equivalent to this problem.

The **most efficient algorithms** known have a sub-exponential complexity very close to that of factorization (we often use the same algorithms).

The **chosen exponents** ($k$, $a$) must be large because there exist efficient algorithms to compute discrete logarithms modulo a prime number when the exponent is small (baby-step giant-step algorithm).

A **disadvantage of ElGamal** is that it multiplies the ciphertext length by 2.

It is **essential** for the security of the procedure that the random number $k$ is not repeated, otherwise: let $(\gamma_1, \delta_1)$ and $(\gamma_2, \delta_2)$ be the two generated ciphertexts, we have that $\delta_1/\delta_2 = m_1/m_2$ and consequently, it is trivial to recover one plaintext from the other.

The ElGamal procedure can be **generalized** to other groups like $GF(2^n)$ or elliptic curves.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Remarks

**Equivalence**: based on DLP (not proven equivalent)

**$k$ unique**: CRITICAL - otherwise $m_1/m_2$ revealed

**Key size**: large exponents necessary

**Extensions**: $GF(2^n)$, elliptic curves
:::

---

## Rabin Algorithm

Asymmetric system **equivalent to factorization** (provably secure).

**Keys:**

- Generate two primes $p$, $q$ (≥1024 bits total), compute $n = pq$
  - **Public**: $n$
  - **Private**: $(p, q)$

**Encryption:** $c = m^2 \bmod n$

**Decryption:** 

- Compute the 4 square roots of $c \bmod n$ (via roots mod $p$ and mod $q$)
- Identify the correct message by redundancy

::: {.callout-note collapse="true" title="Original Text"}
## Rabin Encryption/Decryption Procedure

**Key generation**

Each entity (A) creates a key pair (public and private) as follows:

- A generates two random prime numbers $p$ and $q$ of large size (len($pq$) ≥ 1024)
- A computes $n := pq$
- The **public key** of A is $n$, the **private key** of A is $(p, q)$

**Encryption**

- Entity B obtains $n$, the authentic public key of A
- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in [0, n-1]$ $\forall i$
- B computes $c_i = m_i^2 \bmod n$ for each message $m_i$
- B sends all the ciphertexts $c_i$ to A

**Decryption**

- A uses its private key $(p, q)$ to retrieve the **4 solutions** of the equation: $c_i = x^2 \bmod n$ using **efficient algorithms** to compute square roots $\bmod p$ and $\bmod q$
- A determines either by an **additional indication** from B, or by **redundancy analysis** which of the 4 messages $m_1, m_2, m_3, m_4$ is the original plaintext
:::

::: {.callout-tip collapse="true"}
## Quick Revision

**Base**: SQROOTP (square root mod composite)

**Advantage**: proven equivalent to factorization

**Problem**: 4 possible solutions, requires redundancy

**Vulnerability**: chosen-ciphertext attack reveals factors
:::

### Essential Remarks

- **Proven security**: SQROOTP ⟺ FACTP (only algorithm with proven equivalence)
- **Chosen-ciphertext attack**: if A decrypts $c = m^2 \bmod n$ chosen by adversary M
  - M receives a root $m_x$ among 4 possible
  - If $m \neq m_x \bmod n$ (prob. 0.5), then $\gcd(m - m_x, n)$ gives a factor of $n$
- **Solution**: require sufficient redundancy to identify unique solution without ambiguity

::: {.callout-note collapse="true"}
## Original Text - Remarks

The Rabin procedure is based on the **impossibility of finding square roots modulo a composite of unknown factorization** (SQROOTP problem).

The **main interest** of this algorithm lies in the fact that it has been **proven to be equivalent to factorization** (SQROOTP ⟺ FACTP). This algorithm therefore belongs to the **provably secure** category for any passive attack.

**Active attacks** can, in some cases, compromise the algorithm's security. More precisely, if we mount the following **chosen ciphertext** attack:

- The attacker M generates an $m$ and sends to A the ciphertext $c = m^2 \bmod n$.
- A responds with a root $m_x$ among the 4 possible $m_1, m_2, m_3, m_4$.
- If $m \neq m_x \bmod n$ (probability 0.5), M repeats with a new $m$.
- Otherwise, A computes $\gcd(m - m_x, n)$ and thus obtains one of the two factors of $n$.

This attack could be **avoided** if the procedure required **sufficient redundancy** in the plaintexts allowing A to identify without ambiguity which of the possible solutions is the original plaintext. In this case, A would always respond with $m$ and discard the other solutions that do not have the predefined level of redundancy.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Remarks

**Unique**: only algorithm proven equivalent to FACTP

**Attack**: chosen-ciphertext gives factors (prob. 0.5)

**Countermeasure**: mandatory redundancy in messages
:::

---

## Comparison RSA - ElGamal - Rabin

| Criterion | RSA | ElGamal | Rabin |
|---------|-----|---------|-------|
| **Problem** | RSAP | DLP | SQROOTP |
| **Security** | Equiv. factorization (generic case) | Based on DLP | **Proven** ⟺ factorization |
| **Expansion** | 1:1 | **1:2** | 1:1 |
| **Decryption** | Deterministic | Deterministic | **4 solutions** |
| **Signature** | Yes | Yes | Yes (with precautions) |

---

## Elliptic Curves (Basic Idea)

### Fundamental Concept

An **elliptic curve** $E$ is defined by: $y^2 = x^3 + ax + b$ (with discriminant $4a^3 + 27b^2 \neq 0$).

**Key operation: Point addition**

- Geometrically: draw a line between two points $P$ and $Q$, find the 3rd intersection point, then take its symmetric
- Forms a **commutative group** with point at infinity $\mathcal{O}$ as identity
- **Scalar multiplication**: $kP = P + P + ... + P$ ($k$ times)

**Cryptographic advantage:**

- The **ECDLP problem**: finding $k$ such that $Q = kP$ is very difficult (exponential effort)
- **Shorter keys** for same security as in $\mathbb{Z}_p^*$

::: {.callout-note collapse="true"}
## Original Text - Definition

An **elliptic curve** is a set of points $E$ defined by the equation: $y^2 = x^3 + ax + b$, with $x, y, a$ and $b$ rational numbers, integers or integers modulo $m$ ($m > 1$). The set $E$ also contains a "point at infinity" denoted $\mathcal{O}$. The point $\mathcal{O}$ is not on the curve but it is the identity element of $E$.

We will choose for our calculations elliptic curves that do not have multiple roots or, in other words, curves where the **discriminant** $4a^3 + 27b^2 \neq 0$.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Concept

**Equation**: $y^2 = x^3 + ax + b$

**Structure**: group with $\mathcal{O}$

**Operation**: geometric addition

**Hard problem**: ECDLP
:::

### Addition on Elliptic Curves

Let $P := (x, y) \in E$, we define $-P := (x, -y)$ (symmetric with respect to the x-axis). We have $P + (-P) = \mathcal{O}$.

For two points $P, Q \in E$ with $Q \neq -P$, we define $P + Q := R$ where $-R$ is the 3rd intersection point between the curve and the line passing through $P$ and $Q$.

For **doubling**: $2P = R$ where $-R$ is the intersection point of the curve with the tangent to the curve at point $P$.

::: {.callout-note collapse="true"}
## Original Text - Addition

Let $P := (x, y) \in E$, we define $-P$ as $-P := (x, -y)$. Graphically, $-P$ is the symmetric point of $P$ with respect to the x-axis. Note that $P + (-P) = \mathcal{O}$.

Let two points $P, Q \in E$, such that $Q \neq -P$, we define the addition $P + Q := R$ where $R \in E$ such that $-R$ is the 3rd intersection point between the curve and the line passing through $P$ and $Q$.

The set $E$ with $\oplus$ defines a **commutative group** for addition.

Let $P \in E$, the point $2P = R$, such that $-R$ is the intersection point of the curve with the line tangent to the curve at point $P$.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Addition

**Inverse**: $-P = (x, -y)$

**Addition**: 3rd intersection point + symmetry

**Doubling**: tangent + symmetry

**Property**: commutative group
:::

### ECDLP and Cryptographic Advantages

When the elliptic curve is defined over the field $\mathbb{Z}_p$ with $p$ a large prime ($y^2 \equiv x^3 + ax + b \bmod p$), the computation of $k \in \mathbb{Z}_p$ such that $Q = kP$ with $(P, Q)$ known is **very difficult** (exponential effort). This problem is the **Elliptic Curve Discrete Logarithm Problem (ECDLP)**.

**Main advantage**: key sizes much smaller for equivalent security.

::: {.callout-note collapse="true"}
## Original Text - ECDLP and Advantages

When the elliptic curve is defined over the field $\mathbb{Z}_p$ with $p$ a large prime number ($y^2 \equiv x^3 + ax + b \bmod p$), the computation of $k \in \mathbb{Z}_p$ such that $Q = kP$ with $(P, Q)$ known, is very difficult (requires exponential effort). This problem is known as: **Elliptic Curve Discrete Logarithm Problem (ECDLP)**.

The **main advantage** of public cryptography based on elliptic curves is that the size of the numbers used (and therefore, keys) is smaller.

This is due to the **increased complexity** of computations on $E_p$ (elliptic curve defined over field $\mathbb{Z}_p$) compared to usual fields such as $\mathbb{Z}_p$ or $GF(2^m)$.

The **representation of a plaintext as points** of the curve remains a complex operation.

In October 2003, the **US National Security Agency (NSA)** purchased a patent from Certicom for the use of elliptic curve cryptography.

In September 2013 Claus Diem showed that under certain conditions the ECDLP problem could be solved in **sub-exponential time**.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - ECDLP

**Problem**: finding $k$ in $Q = kP$ (exponential)

**Gain**: keys ~6-10× shorter

**Limit**: representing messages as points difficult

**NSA**: adopted in 2003
:::

### Key Size Comparison Table

| AES (symmetric) | RSA/DH | Elliptic Curves | Ratio |
|---------------------|---------|---------------------|---------|
| 56 bits | 512 bits | 112 bits | 1:4.6 |
| 80 bits | 1024 bits | 160 bits | 1:6.4 |
| 112 bits | 2048 bits | 224 bits | 1:9.1 |
| 128 bits | 3072 bits | 256 bits | 1:12 |
| 256 bits | 15360 bits | 512 bits | 1:30 |

::: {.callout-note collapse="true"}
## Original Text - Table

This table shows the key size ratios compared to RSA for equivalent security.

*(Table extracted from original document)*
:::

---

## ElGamal on Elliptic Curves

### Direct Adaptation

Replace operations in $\mathbb{Z}_p^*$ with operations on $E_p$

**Keys:**

- Choose curve $E_p$ and point $P_0 \in E_p$ of large order
- Secret $x$, compute $P_a = xP_0$
- **Public**: $(E_p, P_0, P_a)$ | **Private**: $x$

**Encryption:** For message $m_i \in E_p$

- Choose random $k$
- $\gamma = kP_0$, $\delta = kP_a + m_i$
- Send $(\gamma, \delta)$

**Decryption:** $m_i = \delta - x\gamma$

::: {.callout-note collapse="true"}
## Original Text - ElGamal EC

**Key generation**

Each entity (A) creates a key pair (public and private) as follows:

- A chooses an elliptic curve $E_p$ with $p$, a large prime number (len($p$) bits) and a point $P_0 \in E_p$.
- A generates a random number $x$, such that $1 \leq x \leq p$ and computes $P_a = xP_0$ (multiplication by a scalar on $E_p$, for which efficient algorithms exist).
- The public key of A is $(E_p, P_0, P_a)$, the private key of A is $x$.

**Encryption**

Entity B obtains $(E_p, P_0, P_a)$, the authentic public key of A.

- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in E_p$ for all $i$.
- For each message $m_i$:
  - B generates a **unique** random number $k$, such that $1 \leq k \leq p$.
  - B computes $\gamma := kP_0$ and $\delta := kP_a + m_i$ and sends the ciphertext $c := (\gamma, \delta)$.

**Decryption**

- A uses its private key $x$ to compute: $x\gamma = xkP_0 = kP_a$.
- A retrieves the plaintext by computing: $\delta - kP_a = kP_a + m_i - kP_a = m_i$.

The security of the scheme relies on **ECDLP**!

It is also necessary to **authenticate** the exchanged public parts to avoid the previously described man-in-the-middle attacks.

The properties of the protocol are identical to the $\mathbb{Z}_p^*$ case.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - ElGamal EC

**Principle**: same as ElGamal on $E_p$

**Operations**: + and scalar multiplication on points

**Security**: ECDLP

**Authentication**: necessary against MitM

**Advantage**: short keys
:::

# Cryptographic Hash Functions and MACs

## One-Way Functions (OWF)

A function $f$ is one-way if $f(x) = y$ is easy to compute, but finding $x$ from $y$ is computationally impossible for the majority of values.

**Examples:**

- Squares modulo composite: $f(x) = x^2 \bmod n$ with $n = pq$
- DES construction: $y = E_k(x) \oplus x$ with $k$ fixed and known

**Note:** OWF ≠ OWHF (hash functions impose compression and 2nd-preimage resistance).

::: {.callout-note collapse=true title="Original Text"}
A **function f is called one-way** (one-way function or **OWF**) if for $x \in X$ we can easily compute $f(x) = y$ but for the vast majority of $y \in Y$ it is **computationally impossible** to find an $x$ such that $f(x) = y$.

**Examples:**

- computing squares modulo a composite: $f(x) = x^2 \bmod n$ with $n = pq$ (p and q unknown) is a **one-way function** because the inverse is difficult (see the basic problem **SQROOTP**).
- we can construct a one-way function based on DES or any other block encryption system $E$ as follows: $y = f(x) = E_k(x) \oplus x$, $\forall x$, with $k$ a fixed and known key. We can consider that $E_k(x) \oplus x$ has (pseudo)random behavior by construction of $E$. Computing the inverse amounts to finding an $x$ such that: $x = E_k^{-1}(x \oplus y)$, which is considered difficult given the properties of $E$. Note that $f(x) = E_k(x)$ would not be sufficient to make an OWF because, with the key known, DES is reversible.

**OWF ≠ OWHF**: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.

**Example**: $f(x) = x^2 \bmod n$ with $n = pq$ (p and q unknown) is not an OWHF because given $x$, $-x$ is a trivial collision.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**OWF**: easy in one direction ($f(x) \to y$), impossible in the other ($y \to x$).

Examples: modular squares, $E_k(x) \oplus x$.

OWF ≠ OWHF (hash functions = more constraints).
:::

## Hash Functions: Definitions

A hash function $h$ has two essential properties:

- **Compression**: transforms data of arbitrary length into fixed-length output
- **Ease of computation**: $h(x)$ is fast to compute

**Classification:**

- **Unkeyed** (no key): MDC (Manipulation Detection Code)
- **Keyed** (with key): MAC (Message Authentication Code)

**Security properties:**

1. **Preimage resistance**: given $y$, impossible to find $x$ such that $h(x) = y$
2. **2nd-preimage resistance** (weak collision): given $x$, impossible to find $x' \neq x$ such that $h(x) = h(x')$
3. **Collision resistance** (strong collision): impossible to find any $x \neq x'$ with $h(x) = h(x')$

**Terminology:**

- **OWHF** (weak one-way): satisfies (1) and (2)
- **CRHF** (strong one-way): satisfies (2) and (3)

::: {.callout-note collapse=true title="Original Text"}
A **hash function** is a function $h$ having the following properties:

- **compression**: the function $h$ maps a set $X$ composed of bit strings of finite but arbitrary length to a set $Y$ composed of bit strings of finite and fixed length (and normally smaller than the size of $X$) with $h(x) = y$, and $x \in X$, $y \in Y$.
- **easy to compute**: given $h$ and $x \in X$, $h(x)$ is easy to compute.

A hash function is called **"keyed"** (keyed hash function) if a key is involved in the computation of the function ($h_k(x) = y$); otherwise it is called **"unkeyed"** (unkeyed hash function).

Hash functions have many computer applications including structured archiving facilitating search. On the security side we will study two main categories:

- **manipulation detection codes** (**MDC**) or message integrity codes (**MIC**): these are unkeyed functions allowing to provide an integrity service under certain conditions. The result of such a function is called **MDC-value** or simply **digest**.
- **message authentication codes** (**MAC**) which are keyed functions allowing to authenticate the source of the message and ensure its integrity without using additional (encryption) mechanisms.

**Some basic properties of hash functions:**

- **1) preimage resistance**: given a $y \in Y$, it is computationally impossible to find a preimage $x \in X$ satisfying $h(x) = y$.
- **2) 2nd-preimage resistance**: given an $x \in X$ and its image $y \in Y$, with $h(x) = y$, it is computationally impossible to find an $x' \neq x$ such that $h(x) = h(x')$. Also called **weak collision resistance**.
- **3) collision resistance**: it is computationally impossible to find two distinct preimages $x, x' \in X$ for which $h(x) = h(x')$ (no restriction on the choice of values). Also called **strong collision resistance**.

A **one-way hash function** (**OWHF**) is an MDC satisfying 1) and 2). Also called: **weak one-way hash function**.

A **collision resistant hash function** (**CRHF**) is an MDC satisfying properties 2) and 3). (Note that 3) ⇒ 2)). Also called: **strong one-way hash function**.

**OWF ≠ OWHF**: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.

**Example**: $f(x) = x^2 \bmod n$ with $n = pq$ (p and q unknown) is not an OWHF because given $x$, $-x$ is a trivial collision.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Hash function**: compression + easy computation

**MDC** (unkeyed) for integrity

**MAC** (keyed) for authentication

**Properties**

1. preimage resistance
2. 2nd-preimage resistance
3. collision resistance

**OWHF** = (1)+(2)

**CRHF** = (2)+(3).
:::

## Message Authentication Codes (MACs)

A MAC is a family of functions $h_k$ parameterized by a secret key $k$:

**Properties:**

1. **Compression**: arbitrary input → fixed output
2. **Easy to compute**: with known $k$, $h_k(x)$ is fast
3. **Computation-resistance**: without $k$, impossible to compute valid pairs $(x, h_k(x))$

**Implications:**

- Key non-recovery: impossible to recover $k$ from pairs $(x_i, h_k(x_i))$
- Preimage and collision resistance for anyone not possessing $k$

**Usage:** Source authentication + message integrity without directly revealing secrets.

::: {.callout-note collapse=true title="Original Text"}
A **Message Authentication Code** (**MAC**) is a family of functions $h_k$ parameterized by a secret key $k$ having the following properties:

- **1) compression**: as for generic hash functions but applied to $h_k$.
- **2) easy to compute**: from a function $h_k$, and a known key $k$, we can easily compute $h_k(x)$. The result is called a **MAC-value** or simply a **MAC**.
- **3) computational resistance** (computation-resistance): without knowledge of the symmetric key $k$, it is (computationally) impossible to compute pairs $(x, h_k(x))$ from 0 or several known pairs $(x_i, h_k(x_i))$ for any $x \neq x_i$.

Property 3) implies that the pairs $(x_i, h_k(x_i))$ cannot be used to compute the key $k$ (**key non-recovery**). However the key non-recovery property does not imply computation-resistance because chosen/known-plaintext attacks could lead to forged pairs $(x, h_k(x))$.

The impossibility of computing pairs $(x, h_k(x))$ also translates to preimage and collision resistance (cf. previous slide) for any entity not possessing the key $k$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**MAC** = hash with key $k$

Without $k$: impossible to forge $(x, h_k(x))$ or recover $k$

Guarantees source authentication + integrity.
:::

## Attacks on MDCs

### 2nd-Preimage Resistance Attack

**Problem:** Given $h(x) = y$, find $x'$ such that $h(x') = h(x)$.

**Probabilistic analysis:**

For an $m$-bit digest ($n = 2^m$ possible outputs), the probability of having at least one collision after $k$ attempts is:

$$P(\text{collision}) \approx 1 - (1-1/n)^k \approx k/n$$

For $P = 0.5$: $k = n/2 = 2^{m-1}$

**Conclusion:** For an $m$-bit digest, approximately $2^{m-1}$ attempts are needed to find a 2nd-preimage with probability 0.5.

::: {.callout-note collapse=true title="Original Text"}
**Problem**: given $h(x) = y$, find $x'$ such that $h(x')=h(x)$.

**Practical example**: we have a text with an associated digest bearing a digital signature; we want to create a fake text bearing the same signature (without control over the original text). What are our chances from a probabilistic point of view?

Let a hash function $h$ with $n$ possible outputs and a given value $h(x)$. If $h$ is applied to $k$ random values, what must be the value of $k$ so that the probability of having at least one $y$ such that $h(x) = h(y)$ is 0.5?

For the first value of $y$, the probability that $h(x) = h(y)$ is $1/n$. Conversely, the probability that $h(x) \neq h(y)$ is $1-1/n$. For $k$ values, the probability of having no collision is: $(1-1/n)^k$, i.e.:

$$\left(1 - \frac{1}{n}\right)^k = 1 - \frac{k}{n} + \frac{1}{2!}\left(\frac{k}{n}\right)^2 - \frac{1}{3!}\left(\frac{k}{n}\right)^3 + \ldots$$

which for very large $n$ can be approximated by $1 - k/n$. Therefore, the complementary probability of having at least one collision is about $k/n$; which gives us $k = n/2$ for a probability of 0.5.

**Conclusion**: for an $m$-bit digest, the number of attempts needed to find a $y$ such that $h(x) = h(y)$ with a probability of 0.5 is $2^{m-1}$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
To break 2nd-preimage resistance with $m$-bit digest: $2^{m-1}$ attempts (prob 0.5).
:::

### Collision Resistance Attack: Birthday Paradox

**Problem:** Find two distinct values $x, x'$ such that $h(x) = h(x')$.

**Birthday paradox:** In a group of 23 people, probability > 0.5 of having two people with the same birthday.

**Mathematical result:**

For $n$ possible outputs, the probability of collision after $k$ computations:

$$P(\text{at least 1 collision}) = 1 - e^{-k(k-1)/(2n)}$$

For $P \geq 0.5$: $k \approx 1.17\sqrt{n}$

**Cryptographic consequence:** For an $m$-bit digest ($n = 2^m$ outputs), approximately $2^{m/2}$ computations are needed to find a collision with probability > 0.5.

**Practical example:** Modification of a contract into 237 variations to find a fraudulent version having the same digest as the legitimate version.

::: {.callout-note collapse=true title="Original Text"}
**Problem**: find two values $x, x'$ distinct such that $h(x) = h(x')$.

**Practical example**: We have to have someone sign a text and we want to apply this signature to a falsified text (we control the original text). What are our chances of finding two original texts satisfying this criterion?

The **birthday paradox** is a classic probabilistic problem that shows that in a gathering of only 23 people, there is already a 50% chance of having two people with the same birthday.

Let $y_1, y_2,..., y_n$ all the possible outputs of a hash function. How many $h(x_i)$: $h(x_1), h(x_2),...,h(x_k)$ must we compute to have a probability of collision equal to or greater than 0.5?

The first choice for $h(x_1)$ is arbitrary (prob = 1), the second $h(x_2) \neq h(x_1)$ has a probability of $1 - 1/n$, the third of $1 - 2/n$, etc. This gives us a probability of having no collisions equal to:

$$P_{\text{no collision}} = \prod_{i=1}^{k-1}\left(1 - \frac{i}{n}\right)$$

We easily prove (series expansion of $e^{-x}$) that for $0 \leq x \leq 1$: $1-x \leq e^{-x}$ and therefore:

$$P_{\text{no coll}} \leq \prod_{i=1}^{k-1}\left(1 - \frac{i}{n}\right) \leq \prod_{i=1}^{k-1} e^{-i/n} = e^{-k(k-1)/(2n)}$$

The probability of having at least one collision is $P_{\text{at least1}} = 1 - P_{\text{no-coll}}$. To know the value of $k$ for which $P_{\text{at least1}}$ is greater than 0.5, it suffices to calculate:

$$\frac{1}{2} \leq 1 - e^{-k(k-1)/(2n)}$$

If $k$ is large, we replace $k(k-1)$ by $k^2$ and we obtain after simple calculations:

$$k \geq \sqrt{2\ln(2) \cdot n} \approx 1.17\sqrt{n}$$

Taking $n = 365$ for the birthday, we get $k = 22.3$, which confirms the statement of the problem.

**Consequence for hash functions**: Let a hash function with $2^m$ possible outputs. If $h$ is applied to $k = 2^{m/2}$ inputs we have a probability greater than 0.5 of obtaining $h(x_i) = h(x_j)$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Birthday paradox**: to break collision resistance with $m$-bit digest: $2^{m/2}$ attempts (prob > 0.5).

Example: 23 people suffice for identical birthdays.
:::

## Computational Resistance: Recap

For a hash function with $n$-bit digest and MAC key of $t$ bits:

| Type | Property | Difficulty | Recommended Size |
|------|-----------|------------|-------------------|
| **OWHF** | Preimage | $2^n$ | $n \geq 128$ bits |
| | 2nd-preimage | $2^{n-1}$ | |
| **CRHF** | Collision | $2^{n/2}$ | $n \geq 256$ bits |
| **MAC** | Key recovery | $2^t$ | $t \geq 256$ bits |
| | Computation | $\min(2^t, 2^n)$ | $n \geq 128$ bits |

**Practical implications:**

- For integrity only (OWHF): 128 bits sufficient
- For collision resistance (CRHF): minimum 256 bits
- MACs: 256-bit key, 128-bit digest minimum

::: {.callout-note collapse=true title="Original Text"}
$n$: size of the MDC-value or MAC-value resulting from the application of the hash function

$t$: size of the MAC key

| Hash Fct. Type | Characteristic | Computational Difficulty | Attack Goal | Recommended digest/key size |
|-------------------|-----------------|-------------------------|------------------|--------------------------------|
| **OWHF** | preimage resistance | $2^n$ | find a preimage | $n \geq 128$ bits |
| | 2nd-preimage resistance | $2^{n-1}$ | find $x'$ with $h(x') = h(x)$ | |
| **CRHF** | collision resistance | $2^{n/2}$ | find a collision | $n \geq 256$ bits |
| **MAC** | key non-recovery | $2^t$ | find the key | $n \geq 128$ |
| | computation resistance | $\min(2^t,2^n)$ | produce a $(x, h_k(x))$ | $t \geq 256$ |
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Efforts**: preimage $2^n$, 2nd-preimage $2^{n-1}$, collision $2^{n/2}$.

**Sizes**: OWHF ≥128 bits, CRHF ≥256 bits, MAC key ≥256 bits.
:::

## MDCs Based on Encryption Systems

**Principle:** Use a symmetric encryption algorithm (DES, AES) to construct an MDC.

**Challenges to solve:**

- Break the reversibility of symmetric algorithms
- Increase the nominal width (DES = 64 bits insufficient for CRHF)

**Operation:**

- Sequential processing of blocks
- Chaining operations with XOR
- Combination of $n$ boxes for digests of size $n \times$ nominal width

**Classical models:**

1. **Matyas-Meyer-Oseas**: $H_i = E_{m_i}(H_{i-1}) \oplus H_{i-1}$
2. **Davies-Meyer**: $H_i = E_{m_i}(H_{i-1}) \oplus m_i$
3. **Miyaguchi-Preneel**: $H_i = E_{m_i}(H_{i-1}) \oplus H_{i-1} \oplus m_i$

**Practical examples:**

- **MDC-2**: uses 2 DES boxes → 128-bit digest
- **MDC-4**: uses 4 DES boxes → 128-bit digest

**Limitation:** Security strongly dependent on the underlying algorithm.

::: {.callout-note collapse=true title="Original Text"}
**Idea**: use a known symmetric encryption system to construct an MDC.

**Problems to solve**:

- we must "break" the reversibility of symmetric algorithms to make them OWHF or CRHF.
- The "nominal width" of some encryption systems (eg. DES) is 64 bits, which is not sufficient to build CRHF.

**Operating principle**:

- the text blocks are sequentially processed by the encryption "box".
- compression is based on chaining operations with the blocks resulting from previous iterations and logical functions (fundamentally XOR). This also makes the process irreversible.
- If necessary, $n$ encryption boxes will be combined to obtain digest lengths $n$ times greater than the nominal width of the boxes used.

**Attention**: the security of these algorithms is strongly dependent on the properties of the underlying encryption boxes.

**Examples**:

- The models of **Matyas-Meyer-Oseas**, **Davies-Meyer** and **Miyaguchi-Preneel**.
- **MDC-2** and **MDC-4** using respectively 2 and 4 DES boxes. Digest = 128 bits.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
MDCs from symmetric crypto: break reversibility + chaining XOR.

Models: Matyas-Meyer-Oseas, Davies-Meyer, Miyaguchi-Preneel.

MDC-2/4 with DES → 128 bits.
:::

## Customized MDCs

Functions specifically designed for digest generation, optimized for speed and security.

**Construction elements:**

- Padding + adding the message length
- Predefined constants to increase dispersion
- Successive rounds with logical operations and rotations
- Chaining of outputs between rounds
- Every bit of the digest depends on every input bit

**Main algorithms:**

| Algorithm | Year | Digest | Status |
|------------|-------|--------|--------|
| **MD5** | 1992 | 128 bits | ❌ Broken |
| **SHA-0** | 1993 | 160 bits | ❌ Collisions in $2^{39}$ |
| **SHA-1** | 1995 | 160 bits | ⚠️ Collisions in $2^{63}$ |
| **SHA-2** | - | 224-512 bits | ✓ Currently secure |
| **SHA-3** (Keccak) | 2012 | 224-512 bits | ✓ Current standard |

**Attack evolution:**

- 2004: Full collisions on MD5 (X. Wang)
- 2005: SHA-1 theoretically broken ($2^{63}$ operations)
- 2008: Creation of fraudulent CA certificates via MD5
- 2012: SHA-3 adopted as new standard

::: {.callout-note collapse=true title="Original Text"}
These are functions designed exclusively to generate integrity codes (digests) with a main concern for speed and security.

Their operation is based on the following elements:

- initialization operations (**padding** + adding the length).
- a set of **predefined constants** chosen specifically to increase dispersion.
- a set of "steps" (**rounds**) that will sequentially apply to all the original data blocks. These rounds will perform a combination of logical operations and rotations on the data and constants.
- **chaining** operations involving the outputs of previous rounds.

In these functions, every bit of the digest is a function of every bit of the inputs.

The most famous are:

- **MD5**: R. Rivest, 1992; RFC 1321. Digest = 128 bits. **Broken!**
- **SHA-0**: NIST, 1993. Digest = 160 bits. Collisions in $2^{39}$ operations instead of $2^{80}$
- **SHA-1**: NIST, 1995. Digest = 160 bits. Revision of SHA-0 with additional bit rotation. Collisions in $2^{63}$ operations (instead of $2^{80}$).
- **SHA-2**: NIST (FIPS 190-3). Includes: SHA-224, SHA-256, SHA-384 and SHA-512. Digest sizes range from 224 to 512 bits.
- **SHA-3**: Keccak Algorithm (digest size variable from 224 to 512 bits)

**Latest Developments**:

- X.Wang et al. culminated in 2004 a long work aiming to find collisions in the MD5 algorithm. They publish two pairs of collisions for 1024-bit messages.
- In 2005, X.Wang et al. prove at the CRYPTO'05 conference that the number of operations needed to find collisions on SHA-1 (current standard for secure hash functions) is only $2^{63}$.
- These attacks target the search for arbitrary collisions but during CRYPTO'06 researchers from the University of Graz in Austria propose a method to partially control the content of collisions.
- In December 2008 it is shown that controlled collisions on MD5 can be generated and thus create an illicit Certification Authority allowing to forge certificates accepted by any browser.
- These results rely on **analytical** approaches (as opposed to brute force!)
- The selection process for SHA-1's successor is similar to the one that designated AES as a block encryption standard. NIST decided (October 2012) that **Keccak** would be the base algorithm for **SHA-3**.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Customized MDCs**

- MD5 (broken)
- SHA-0 (broken)
- SHA-1 (weak)
- SHA-2 (secure)
- SHA-3/Keccak (current standard).

Construction: padding + constants + rounds + chaining.
:::

## MACs Based on Encryption Systems

**CBC-MAC:** Uses a block cipher algorithm in CBC mode.

**Operation:**

- CBC mode with IV = 0
- Elimination of intermediate ciphertexts
- Only the last encrypted block is kept as MAC

**With DES:**

- Key length: 56 bits (112 in optional Triple-DES)
- MAC length: 64 bits

**Advantages:**

- Reuse of existing encryption infrastructure
- Acceptable performance

**Limitations:**

- Security limited by block size (64 bits for DES)
- Vulnerable if used incorrectly (ex: without variable IV)

::: {.callout-note collapse=true title="Original Text"}
**CBC-MAC algorithm based on DES-CBC with IV = 0 and elimination of intermediate ciphertexts**

- key length = 56 bits (112 in case of using the optional part)
- MAC-value length = 64 bits

The diagram shows the sequential processing of message blocks $M_1, M_2, M_3$ with the encryption algorithm $E$ and the key $k$. The intermediate ciphertexts $C_1, C_2$ are eliminated. Only the last block $C_3$ constitutes the MAC.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**CBC-MAC**: CBC mode + IV=0, only last block kept. DES: key 56/112 bits, MAC 64 bits.
:::

## Nested MACs and HMACs

**Nested MAC (NMAC):** Composition of two MAC families $G$ and $H$:

$$\text{NMAC}_{k,l}(x) = g_k(h_l(x))$$

**Security:** Depends on two criteria:

- $G$ resistant to collisions
- $H$ resistant to specific MAC attacks

**HMAC (FIPS 198 standard, 2002):** Nested MAC using unkeyed MDCs (SHA-1, SHA-256).

**Construction:**

- Constants: `ipad = 0x363636...36` and `opad = 0x5C5C5C...5C` (512 bits)
- Key $k$ of 512 bits

$$\text{HMAC-256}_k(x) = \text{SHA-256}((k \oplus \text{opad}) \parallel \text{SHA-256}((k \oplus \text{ipad}) \parallel x))$$

**Advantages:**

- Most widely used MACs in practice
- Attacks on SHA more difficult with secret key
- Excellent performance
- Standardized and widely supported

::: {.callout-note collapse=true title="Original Text"}
A **Nested MAC** or **NMAC** is a composition of 2 families of MAC functions $G$ and $H$ parameterized by keys $k$ and $l$ such that:

$$G \circ H = \{ g \circ h \text{ with } g \in G \text{ and } h \in H \} \text{ with } g \circ h_{(k,l)}(x) = g_k(h_l(x))$$

The security of an NMAC depends on two criteria:

- The family of functions $G$ is collision resistant.
- The family of functions $H$ is resistant to specific attacks for MACs, i.e.: It is impossible to find a pair $(x,y)$ and a fixed but unknown key $m$, such that: $\text{MAC}_m(x) = y$.

An **HMAC** (FIPS 198, 2002) is a Nested MAC using at its base dedicated unkeyed MDCs like SHA-1 or SHA-256.

An HMAC uses two 512-bit constants called `ipad` and `opad` such that:

- `opad := 363636 ... 36` 
- `ipad := 5C5C5C ... 5C`

and a key $k$ of 512 bits.

The operating scheme of HMAC-256 (based on SHA-256) is as follows:

$$\text{HMAC-256}_k(x) := \text{SHA-256}((k \oplus \text{opad}) \parallel \text{SHA-256}((k \oplus \text{ipad}) \parallel x))$$

**HMACs** are the most used MACs. The attacks mentioned on the functions of the SHA family are more difficult to carry out on an HMAC because of the key $k$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**HMAC**: double hash with derived keys (`ipad`/`opad`). $\text{HMAC}_k(x) = H((k \oplus \text{opad}) \parallel H((k \oplus \text{ipad}) \parallel x))$. Standard, secure, performant.
:::

## Hash Functions Applications

### Data Integrity

**Three main approaches:**

1. **MAC only:**
   - $A \to B: X, \text{MAC}_k(X)$
   - Authentication + integrity guaranteed
   - Requires shared key

2. **MDC + Encryption:**
   - $A \to B: E_k(X, \text{MDC}(X))$
   - Confidentiality + integrity
   - Shared symmetric key

3. **MDC + Authentic channel:**
   - $A \to B: X$ (normal channel)
   - $A \to B: \text{MDC}(X)$ (authentic channel)
   - Channel separation

**Limitations:** These simple protocols offer no protection against replay attacks.

**Solution:** add timestamps or sequence numbers.

::: {.callout-note collapse=true title="Original Text"}
**MAC Only**:
$$A \to B: X, \text{MAC}_k(X)$$
If $B$ computes on its side $\text{MAC}_k(X)$ and obtains the same value ⇒ the message comes from $A$.

**MDC + symmetric encryption** (key $k$ known to $A$ and $B$)
$$A \to B: X, E_k(\text{MDC}(X))$$
$B$ computes $\text{MDC}(X)$ and then $E_k(\text{MDC}(X))$. If equal ⇒ message comes from $A$.

**As 2) with confidentiality of $X$ added**:
$$A \to B: E_k(X,\text{MDC}(X))$$

**MDC + digital signature**:
$$A \to B: X, \text{Sig}_{\text{priv-A}}(\text{MDC}(X))$$
$B$ computes $\text{MDC}(X)$ and verifies $\text{Sig}_{\text{priv-A}}(\text{MDC}(X))$ with an authentic copy of `pub-A`. If equality ⇒ $A$ is the origin of the message. This solution additionally offers **origin non-repudiation**.

These simple protocols offer no support for uniqueness nor for the timeliness of received messages and are exposed to **replay attacks**! They require mechanisms taking into account time or the transaction context (cf. entity authentication).
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Integrity**: MAC only, MDC+crypto, MDC+signature.

⚠️ Vulnerable to replay without timestamps/nonces.
:::

### Blockchains and Proof of Work

**Bitcoin and blockchains:** Use of hash functions to chain transaction blocks.

**Characteristics:**

- Public and visible transactions
- Blocks chained via cryptographic hash functions
- Mining = solving a cryptographic puzzle (proof of work)

**Proof of Work:**

- Find a nonce such that $\text{hash}(\text{block} \parallel \text{nonce}) < \text{target}$
- Computationally expensive puzzle, rapid validation
- First miner to solve receives bitcoin reward

**Security:**

- Blockchain = public, decentralized, immutable ledger
- Falsification would require effort > all honest miners
- Protection based on CRHF properties

**Bitcoin statistics (October 2025):**

- Difficulty: 150.84 T
- Target: $\approx 2^{177}$ (pseudo-collision on 79 bits)
- Hashrate: ~1.1 ZH/sec ($1.1 \times 10^{21}$ hash/sec)
- Average block generation time: 10 minutes

::: {.callout-note collapse=true title="Original Text"}
Bitcoin transactions are published and visible by all participants. They are encapsulated in blocks chained using cryptographic hash functions.

**Mining** consists of iteratively adding new blocks containing current transactions.

Generating a valid block requires solving a **cryptographic puzzle** (proof of work) very costly in computation time (finding pseudo-collisions in cryptographic hash functions). Validation remains very efficient.

The first miner able to generate a valid block will receive a monetary reward (in bitcoins). The mining process is open to all miners but only the first is rewarded.

The resulting chain of blocks (**blockchain**) then becomes a public ledger, decentralized and **immutable** protecting all past transactions. Falsification/modification of data protected by the blockchain would require computational effort greater than that performed by all honest miners.

**Bitcoin Statistics 13/10/2025**:

- **Difficulty**: 150.84 T
- **Target**: $2^{224} / \text{Difficulty} = \approx 2^{177}$. The valid digest to generate a block must be less than $2^{177}$, which means a pseudo-collision on the 79 most significant bits. The variation on the inputs depends on the **nonce**.
- **Hashrate**: ~ 1.1 ZH/sec ($1.1 \times 10^{21}$ hashes /sec)
- **Hash functions executed to obtain a block**: ~ $660 \times 10^{21}$
- **Average block generation time**: 10 min
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Blockchain**: chaining of blocks via hash.

**Proof of Work**: find nonce for hash < target.

Security = effort > all miners.

Bitcoin: ~10 min/block, $10^{21}$ hash/sec.
:::

### Other Applications

**1. Authentication:**

- Data origin authentication (DOA)
- Transaction authentication (DOA + temporal parameters)

**2. Virus checking:**

- Creator publishes $\text{digest} = h(\text{software})$ via secure channel
- Users verify integrity by recalculating the digest

**3. Public key distribution:**

- Publish $h(\text{public key})$ instead of the complete key
- Simplified authenticity verification

**4. Document timestamping:**

- Timestamp applied to digest rather than complete document
- Reduction of data to sign

**5. One-time password (S-Key):**

- Hash chain: $x_1 = h(x_0), x_2 = h(x_1), \ldots, x_n = h(x_{n-1})$
- System stores $x_n$, user provides $x_{n-1}$
- Verification: $h(x_{n-1}) = x_n$
- After validation, system stores $x_{n-1}$ for next time

::: {.callout-note collapse=true title="Original Text"}
**Authentication**:

- data origin authentication (DOA)
- transaction authentication (= DOA + time-variant parameters)

**Virus checking**:

- The creator of software creates a digest = $h(x)$ with $x$ being the original and distributes it via a secure channel (eg. CD-ROM).

**Distribution of public keys**:

- Allows controlling the authenticity of a public key.

**Timestamp on a document**:

- The document on which we want to perform the timestamp is first submitted to a hash function. The timestamp (with the signature of the corresponding entity) then applies only to the digest.

**One-time password (S-Key)** (identification mechanism):

- From a secret seed $x_0$, we create a chain of hash-values: $x_1 = h(x_0)$, $x_2 = h(x_1)$, ... $x_n = h(x_{n-1})$.
- The system stores $x_n$ and the user enters $x_{n-1}$. If $h(x_{n-1}) == x_n$ ⇒ OK.
- The system then stores $x_{n-1}$ and so on.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Applications**

- authentication
- virus checking
- public key distribution
- timestamping
- one-time passwords (hash chain)
:::

## Randomized Hash Functions: UNIX Example

**Problem:** Deterministic hash functions always produce the same result for the same password.

**Risks:**

- Detection of identical passwords
- Offline dictionary attacks (pre-computed codebooks)
- Rainbow tables

**UNIX solution: Salt**

- Addition of a 12-bit pseudo-random element (salt) before hashing
- Different salt for each user
- 4096 possibilities ($2^{12}$) for each password

**Advantages:**

- Prevents detection of duplicates
- Pre-computed codebooks become ineffective
- Each password requires 4096 dictionary entries

**UNIX implementation:**

- File `/etc/passwd` globally accessible
- Format: `username:hash(salt+password):uid:gid:...`
- Hash based on modified DES (25 iterations)
- Salt stored in clear (first 2 characters of hash)

**Example:**
```
root:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh
pp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs
```

**Limitations:**

- Effective protection against pre-computed dictionaries
- Online attacks limited by the system (number of attempts)
- Offline attacks possible if file compromised

::: {.callout-note collapse=true title="Original Text"}
UNIX keeps its passwords in a globally accessible file (or possibly distributed by NIS). The stored information corresponds to the result produced by a hash function.

**Example (fictional)**:
```
root:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh
pp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs
```

**Problems**:

- the hash function being deterministic, it produces the same result for identical passwords.
- one could create "books" (codebooks) containing the result of applying the hash function to given inputs (eg. a dictionary) and easily compare them (off-line) with the strings stored by UNIX (**brute force dictionary attack**).

**Solution**:

- Add a (pseudo) random element of **12 bits** different for each password (called **salt**) before computing the hash function and during verification.
- This element allows adding a random factor of **4096 possibilities** for each password and prevents detection of duplicates.

The operating scheme uses DES with 25 iterations, the password as key, and the salt to modify the E-boxes. The final 64-bit result is converted to 11 ASCII characters.

User awareness (not visiting dubious sites) decreases the effectiveness of this technique in malware transmission.

Dictionary attacks are normally less effective **online** because operating systems limit the number of unsuccessful authentication attempts.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**UNIX salt**: 12 random bits added to password before hash.

4096 possible variations.

Prevents pre-computed codebooks and duplicate detection.
:::

# Digital Signatures

## Introduction and Definitions

A **digital signature** is a string of data associating a message with an originating entity, the digital equivalent of a handwritten signature.

**Classification:**

- **With appendix**: requires the original message for verification (ElGamal, DSS)
- **With message recovery**: allows reconstruction of the message (RSA, Rabin)

Signatures primarily use **asymmetric cryptography** to explicitly identify an entity.

**arbitrated digital signatures**: symmetric technology + Trusted Third Parties (TTP)

::: {.callout collapse=true}
## Original Text

**Digital signature**: string of data allowing to associate a message (in digital form) with an originating entity.

**Digital signature scheme**: generation algorithm + verification algorithm.

**Signature process**: message formatting + signature generation algorithm.

**Verification process**: verification algorithm + (message reconstruction).

**Classification of digital signatures**:

- **Digital signatures with appendix** which require the presence of the original message to verify the validity of the signature. These are the most commonly used. Examples: ElGamal, DSS.
- **Digital signatures with message recovery** which offer, in addition, the possibility to reconstruct the message from the signature. Examples: RSA, Rabin.

Digital signatures are mostly based on **asymmetric crypto** because the concept of a shared key is not suitable for the need to identify an entity explicitly.

Commitments similar to those obtained with a public key signature (such as origin non-repudiation) can however be obtained with symmetric technology and trusted third parties (TTP). These methods are called: **arbitrated digital signatures**.
:::

::: {.callout collapse=true}
## Quick Revision

**Digital signature** = string associating message + entity

**Two types**

- with appendix (requires original message)
- with recovery (reconstructs the message)

Based on asymmetric crypto
:::

---

## Formal Framework: Signatures with Appendix

**Working spaces:**

- $M$: message space
- $M_h$: hashed messages where $m_h = H(m)$ with $H$ a hash function
- $S$: space of possible signatures

**Operation:**

Each entity A defines:

- $S_A : M_h \rightarrow S$ (signature function, uses private key)
- $V_A : M_h \times S \rightarrow \{\text{true}, \text{false}\}$ (verification, uses public key)

With $V_A(m_h, s) = \text{true}$ if and only if $S_A(m_h) = s$

**Essential properties:**

- $S_A$ and $V_A$ easy to compute with the correct keys
- Impossible to find a valid $(m', s')$ without A's private key

::: {.callout collapse=true}
## Original Text

We assume that each entity has a private key to sign messages and an authentic copy of the public keys of correspondents.

**Notation:**
- M: Message space
- $M_h$: $m_h = H(m)$ with $m \in M$, $m_h \in M_h$ and $H$ a hash function
- S: Space of values that can be obtained by a signature process

**Description:**

Each entity defines an injective function $S_A : M_h \rightarrow S$ (i.e., the signature)

The function $S_A$ gives rise to a function $V_A$:
$V_A : M_h \times S \rightarrow \{\text{true}, \text{false}\}$ (i.e., the verification)

such that $\forall m_h \in M_h$, $s \in S$, we have:
$V_A(m_h, s) = \text{true}$ if $S_A(m_h) = s$ and
$V_A(m_h, s) = \text{false}$ otherwise

The operations $S_A$ require the private key of A while the operations $V_A$ use the public key of A.

**Some simple properties:**

- The operations $S_A$ and $V_A$ must be easy to compute (having the corresponding keys)
- It is impossible (computationally) for an entity not having the private key of A to find an $m'$ and an $s'$ with $m' \in M$ and $s' \in S$ such that $V_A(m'_h, s') = \text{true}$ with $m'_h = H(m')$.
:::

::: {.callout collapse=true}
## Quick Revision

Signature: $S_A(m_h) = s$ (private key).

Verification: $V_A(m_h, s)$ (public key).

Impossible to forge without private key.
:::

---

## Formal Framework: Signatures with Recovery

**Additional spaces:**

- $M_S$: space on which the signature is applied
- $R : M \rightarrow M_S$: redundancy function (injective, invertible, public)
- $M_R = \text{Im}(R)$: image of $R$

**Operation:**

- Signature: $S_A : M_S \rightarrow S$ (injective)
- Verification: $V_A : S \rightarrow M_S$ with $V_A \circ S_A = \text{Identity}$

**Generation:**

1. Compute $m_R = R(m)$ and $s = S_A(m_R)$
2. Publish $s$ as A's signature on $m$

**Verification:**

1. Compute $m_R = V_A(s)$ with public key
2. Verify $m_R \in M_R$ (reject otherwise)
3. Reconstruct $m = R^{-1}(m_R)$

**Redundancy function:**

Essential for security. If $M_R = M_S$, it becomes trivial to forge signatures.

**Example:** $R(m) = m \parallel m$ (concatenation). Forgery probability: $(1/2)^n$ for an $n$-bit message.

::: {.callout collapse=true}
## Original Text

**Notation:** in addition to the previous definitions, we have:

$M_S$: The space of elements on which a signature can be applied.

$R$: An injective function: $M \rightarrow M_S$, called the redundancy function. It must be invertible and public.

$M_R = \text{Im}(R)$

**Description:**

Each entity defines an injective function $S_A : M_S \rightarrow S$ (i.e., the signature)

The function $S_A$ gives rise to a function $V_A : S \rightarrow M_S$ (i.e., the verification) such that $V_A \circ S_A = \text{Identity}$ on $M_S$

Note that verification is performed without the private key of A

**Signature generation:**
1. Compute $m_R = R(m)$ and $s = S_A(m_R)$
2. Make $s$ public as A's signature on $m$. This allows other entities to verify the signature and reconstruct $m$.

**Verification:**
1. Compute $m_R = V_A(s)$ (with A's public key)
2. Verify that $m_R \in M_R$ (otherwise reject the signature)
3. Reconstruct $m$ by computing: $R^{-1}(m_R)$

**Properties:**

- The operations $S_A$ and $V_A$ must be easy to compute (having the corresponding keys)
- It is impossible (computationally) for an entity not having the private key of A to find an $s' \in S$ such that $V_A(s') \in M_R$

**Remarks on the redundancy function:**

- The choice of a redundancy function is **essential for the security** of the system.
- If $M_R = M_S$ and $R$ and $S_A$ are bijections respectively from $M$ to $M_R$ and from $M_S$ to $S$, then $M$ and $S$ have identical size and, consequently, it is trivial to forge messages bearing A's signature.

**Example of redundancy function:** let $M = \{m : m \in \{0,1\}^n\}$ (n message size) and $M_S = \{t : t \in \{0,1\}^{2n}\}$. Let $R : M \rightarrow M_S$ such that $R(m) = m \parallel m$ ($\parallel$ being the concatenation of 2 messages). The probability of falling on such a message when trying to forge a message from a signature is: $|M_R| / |M_S| = (1/2)^n$, which is negligible for large messages.

**Attention!**: A redundancy function suitable for one digital signature scheme may cause vulnerabilities in another different one!
:::

::: {.callout collapse=true}
## Quick Revision

**With recovery:** Redundancy function $R(m) = m_R$.

Signature $s = S_A(m_R)$.

Verification: $m_R = V_A(s)$, reconstruct $m = R^{-1}(m_R)$.

Redundancy crucial for security.
:::

---

## RSA Signature

**Key generation:**

- Choose two large prime numbers $p$ and $q$
- Compute $n = pq$ and $\phi(n) = (p-1)(q-1)$
- Choose $e$ with $\text{gcd}(e, \phi(n)) = 1$
- Compute $d$ such that $ed \equiv 1 \pmod{\phi(n)}$
- **Public key**: $(n, e)$; **Private key**: $d$

**Signature:**

1. Compute $m_R = R(m)$ (redundancy function)
2. Compute $s = m_R^d \bmod n$
3. Send $s$

**Verification:**

1. Compute $m'_R = s^e \bmod n$
2. Verify $m'_R \in M_R$ (reject otherwise)
3. Reconstruct $m = R^{-1}(m'_R)$

**Variant with appendix:**

- **Signature**: $m_h = H(m)$, then $s = m_h^d \bmod n$
- **Verification**: $m'_h = s^e \bmod n$, accept if $m'_h = H(m)$

**Characteristics:**

- Signature slower than verification ($d$ large, $e$ small)
- Differentiate signature/encryption keys
- Vulnerable to the same attacks as RSA encryption

::: {.callout collapse=true}
## Original Text

**Key generation:**

- Each entity (A) creates a key pair (public and private) as follows:
- A chooses the size of the modulus $n$ (e.g., size$(n) = 1024$ or size$(n) = 2048$).
- A generates two prime numbers $p$ and $q$ of large size $(n/2)$.
- A computes $n := pq$ and $\phi(n) = (p-1)(q-1)$.
- A generates the verification exponent $e$, with $1 < e < \phi(n)$ such that $\text{gcd}(e, \phi(n)) = 1$.
- A computes the signature exponent $d$, such that: $ed \equiv 1 \pmod{\phi(n)}$ using the extended Euclidean algorithm or fast exponentiation.
- The pair $(n,e)$ is A's public key; $d$ is A's private key.

**Signature:**

- A computes the redundancy function of the message $m$: $m_R := R(m)$.
- A computes the signature: $s := m_R^d \bmod n$ and sends $s$ to B.

**Verification:**

- Entity B obtains $(n,e)$, the authentic public key of A.
- B computes $m'_R = s^e \bmod n$, verifies $m'_R \in M_R$ and rejects the signature if $m'_R \notin M_R$
- B retrieves the correctly signed message by A by computing: $m = R^{-1}(m'_R)$.

**Remarks:**

The proof of operation is identical to that of the encryption process. The order of exponentiation has no influence since:
$$ed \equiv de \equiv 1 \pmod{\phi(n)}$$

The process can also be used to produce **signatures with appendix** with the following modifications:

**Signature:**
- A uses a hash function $H$ and computes $m_h := H(m)$.
- A computes the signature of $m_h$: $s := m_h^d \bmod n$ and sends the pair $(m,s)$ to B.

**Verification:**
- B computes $m'_h = s^e \bmod n$ and $H(m)$ and verifies the equality $m'_h = H(m)$.
- If the equality is verified, B accepts the signature $s$ of A on the message M.

The signature computation is **slower** than verification because of the difference in size between the exponent $d$ (size$(d) \approx$ size$(\phi(n))$) and $e$.

The risks and attacks mentioned in the encryption process also apply to the signature.

It is advisable to **differentiate the key pairs for encryption and signature** since they require distinct storage, backup and update policies.
:::

::: {.callout collapse=true}
## Quick Revision

**RSA signature:** $s = m_R^d \bmod n$ (private).

Verify: $m'_R = s^e \bmod n$ (public).

With appendix: $s = H(m)^d \bmod n$.

Signature slow, verification fast.
:::

---

## Blind Signatures

**Principle:** A sends information to B for signature. From the response, A can compute B's signature on a different message that B has never seen.

**Exploitation of the multiplicative property of RSA:**

$$(m_1 m_2)^e \equiv m_1^e m_2^e \equiv c_1 c_2 \pmod{n}$$

**Blinding functions:**

Let $k$ be an integer with $\text{gcd}(n,k) = 1$:

- **Blinding**: $f(m) = m \cdot k^e \bmod n$
- **Unblinding**: $g(m) = k^{-1} \cdot m \bmod n$

Result: $g(S_B(f(m))) = g(S_B(mk^e \bmod n)) = g(m^dk \bmod n) = m^d \bmod n = S_B(m)$

**Protocol:**

1. A → B: $m' = f(m)$ (blinded message)
2. A ← B: $s' = S_B(m')$ (signature of blinded message)
3. A computes $g(s')$ and obtains $S_B(m)$ (signature of original message)

**Applications:** Anonymous electronic cash, electronic voting systems.

::: {.callout collapse=true}
## Original Text

**Scheme invented by Chaum.**

**Idea:** A sends information to B for signature. B returns to A the signed information. From this signature, A can compute B's signature on another message chosen beforehand by A. This allows A to have a signature of B on a message that B has never seen (hence the name blind signature...).

In fact it is a vulnerability based on the **multiplicative property of RSA**: $(m_1m_2)^e \equiv m_1^e m_2^e \equiv c_1 c_2 \pmod{n}$ which was exploited to make a new signature scheme.

**Algorithm:** Let $S_B$ be the RSA signature of B with $(n,e)$ and $d$, respectively the public and private keys of B. Let $k$ be a fixed integer with $\text{gcd}(n,k) = 1$:

$f : \mathbb{Z}_n \rightarrow \mathbb{Z}_n$ with $f(m) = m \cdot k^e \bmod n$ (blinding function)

$g : \mathbb{Z}_n \rightarrow \mathbb{Z}_n$ with $g(m) = k^{-1} \cdot m \bmod n$ (unblinding function)

which gives:

$$g(S_B(f(m))) = g(S_B(mk^e \bmod n)) = g(m^dk \bmod n) = m^d \bmod n = S_B(m)$$

**Protocol:**

- A → B: $m' = f(m)$
- A ← B: $s' = S_B(m')$
- A computes $g(s')$ and obtains the desired signature using (*).
:::

::: {.callout collapse=true}
## Quick Revision

**Blind signature:** Exploits RSA multiplicativity.

Blinding $f(m) = m \cdot k^e$

Unblinding $g(m) = k^{-1} \cdot m$.

B signs $f(m)$, A obtains $S_B(m)$ without B seeing $m$.
:::

---

## Rabin Signature

**Key generation:**

- Generate two large prime numbers $p$ and $q$
- Compute $n = pq$
- **Public key**: $n$; **Private key**: $(p, q)$

**Signature:**

1. Compute $m_R = R(m)$ (redundancy function)
2. Compute $s = \sqrt{m_R} \bmod n$ (square root mod $n$)
3. Send $s$ (one of the 4 square roots)

**Verification:**

1. Compute $m'_R = s^2 \bmod n$
2. Verify $m'_R \in M_R$ (reject otherwise)
3. Reconstruct $m = R^{-1}(m'_R)$

**Characteristics:**

- Based on the SQROOTP problem (square roots mod composite)
- **Provably secure**: equivalent to factorization
- Vulnerable to active chosen-ciphertext attacks

::: {.callout collapse=true}
## Original Text

**Key generation:**

- Each entity (A) creates a key pair (public and private) as follows:
- A generates two random prime numbers $p$ and $q$ of large size (len$(pq) \geq 1024$).
- A computes $n := pq$.
- The public key of A is $n$, the private key of A is $(p,q)$.

**Signature:**

- A computes the redundancy function of the message $m$: $m_R := R(m)$.
- A uses its private key to compute the signature: $s := m_R^{1/2} \bmod n$ using efficient algorithms to compute square roots mod $p$ and mod $q$.
- A sends $s$ to B ($s$ is one of the 4 obtained square roots).

**Verification:**

- Entity B obtains $n$, the authentic public key of A.
- B computes $m'_R = s^2 \bmod n$, verifies $m'_R \in M_R$ and rejects the signature if $m'_R \notin M_R$
- B retrieves the correctly signed message by A by computing: $m = R^{-1}(m'_R)$.

**Remarks:**

The Rabin procedure is based on the **impossibility of finding square roots modulo a composite of unknown factorization** (SQROOTP problem).

The main interest of this algorithm lies in the fact that it has been **proven to be equivalent to factorization** (SQROOTP ⇔ FACTP). This algorithm therefore belongs to the **provably secure** category for any passive attack.

**Active attacks** can, in some cases, compromise the security of the algorithm. More precisely, if we mount the following chosen ciphertext attack (we ask A to decrypt a chosen ciphertext):

- The attacker M generates an $m$ and sends to A the ciphertext $c = m^2 \bmod n$.
- A responds with a root $m_x$ among the 4 possible $m_1, m_2, m_3, m_4$.
- If $m \not\equiv m_x \pmod{n}$ (probability 0.5), M repeats with a new $m$.
- Otherwise, A computes $\text{gcd}(m - m_x, n)$ and thus obtains one of the two factors of $n$...

This attack could be avoided if the procedure required sufficient redundancy in the plaintexts allowing A to identify without ambiguity which of the possible solutions is the original plaintext. In this case, A would always respond with $m$ and discard the other solutions that do not have the predefined level of redundancy.
:::

::: {.callout collapse=true}
## Quick Revision

**Rabin:** $s = \sqrt{m_R} \bmod n$.

Verify: $m'_R = s^2 \bmod n$.

**Provably secure** (equivalent to factorization).

Vulnerable to active chosen-ciphertext attacks.
:::

---

## ElGamal Signature

**Key generation:**

- Generate prime $p$ and generator $\alpha \in \mathbb{Z}_p^*$
- Generate random secret $a$, compute $y = \alpha^a \bmod p$
- **Public key**: $(p, \alpha, y)$; **Private key**: $a$

**Signature:**

1. Compute $m_h = H(m)$
2. Generate random $k$ with $\text{gcd}(k, p-1) = 1$
3. Compute $r = \alpha^k \bmod p$
4. Compute $s = k^{-1}(m_h - ar) \bmod (p-1)$
5. Signature: $(r, s)$

**Verification:**

1. Verify $1 \leq r \leq p-2$ (reject otherwise)
2. Compute $v_1 = y^r r^s \bmod p$
3. Compute $v_2 = \alpha^{H(m)} \bmod p$
4. Accept if $v_1 = v_2$

**Proof:** If $s \equiv k^{-1}(m_h - ar) \pmod{p-1}$, then $m_h \equiv ar + ks \pmod{p-1}$

So $v_2 = \alpha^{m_h} \equiv \alpha^{ar+ks} \equiv (\alpha^a)^r (\alpha^k)^s \equiv y^r r^s = v_1 \pmod{p}$

**Characteristics:**

- Works only with appendix (hash)
- Base of DSA (Digital Signature Algorithm)
- $k$ must be unique for each signature

::: {.callout collapse=true}
## Original Text

**Key generation:**

- Each entity (A) creates a key pair (public and private) as follows:
- A generates a prime number $p$ (len$(p) \geq 1024$ bits) and a generator $\alpha$ of $\mathbb{Z}_p^*$.
- A generates a random number $a$, such that $1 \leq a \leq p-2$ and computes $y := \alpha^a \bmod p$.
- The public key of A is $(p, \alpha, y)$, the private key of A is $a$.

**Signature:**

- A uses a hash function $H$ and computes $m_h := H(m)$.
- A generates a random number $k$ ($1 \leq k \leq p-2$ and $\text{gcd}(k,p-1) = 1$) and computes $k^{-1} \bmod (p-1)$
- A computes $r := \alpha^k \bmod p$ and then $s := k^{-1}(m_h - ar) \bmod (p-1)$
- The signature of A on the message $m$ is the pair $(r,s)$.

**Verification:**

- Entity B obtains $(p, \alpha, \alpha^a \bmod p)$, the authentic public key of A.
- B verifies that $1 \leq r \leq p-2$, otherwise rejects the signature.
- B computes $v_1 := y^r r^s \bmod p$.
- B computes $H(m)$ and $v_2 := \alpha^{H(m)} \bmod p$
- B accepts the signature iff $v_1 = v_2$.

**Remarks:**

**Proof that the scheme works:** If $s \equiv k^{-1}(m_h - ar) \pmod{p-1}$, we have:
$$m_h \equiv (ar + ks) \pmod{p-1}$$ 
and
$$v_2 = \alpha^{H(m)} \bmod p$$

if, as we wish to show $m_h = H(m)$, by reducing exponents mod $(p-1)$, we can rewrite $v_2$:
$$v_2 \equiv \alpha^{ar+ks} \pmod{p}$$

On the other hand:
$$v_1 = y^r r^s \equiv \alpha^{ar} \alpha^{ks} \equiv \alpha^{ar+ks} \pmod{p}$$ 
Q.E.D.

By construction, the ElGamal scheme works **only with appendix** (result of applying a hash function). The Nyberg-Rueppel scheme introduces a variation allowing message recovery.

The **Digital Signature Algorithm (DSA)**, approved by the US National Institute of Standards and Technology has become the most commonly used signature standard. It is built on the basis of a direct derivative of the ElGamal scheme with the SHA-1 hash function.
:::

::: {.callout collapse=true}
## Quick Revision

**ElGamal:** $(r,s)$ with $r = \alpha^k \bmod p$, $s = k^{-1}(m_h - ar) \bmod (p-1)$.

Verify: $y^r r^s \stackrel{?}{=} \alpha^{H(m)} \bmod p$.

Base of DSA.

$k$ unique crucial.
:::

---

## Signatures and Cryptocurrencies

Cryptocurrencies massively use digital signatures to authenticate transactions.

**Bitcoin and Ethereum:**

- Use **ECDSA** (Elliptic Curve Digital Signature Algorithm)
- Derivative of ElGamal on elliptic curves
- Security based on ECDLP

**Transaction process:**

Each spending/transmission requires:

- Signature with the **current holder's private key**
- The holder was the recipient of the previous transaction
- Each transaction forms an authentication chain

**ECDSA advantages:**

- Shorter keys for equivalent security
- More efficient computations
- Suitable for blockchain constraints

::: {.callout collapse=true}
## Original Text

Most cryptocurrencies are based on asymmetric cryptography. Bitcoin e.g. uses digital signatures to authenticate its transactions.

The spending or transmission of bitcoins requires the signature with the private key of the holder (who was in turn the recipient of the previous transaction).

Bitcoin and Ethereum use the **ECDSA (Elliptic Curve Digital Signature Algorithm)** algorithm derived from the ElGamal signature algorithm on elliptic curves whose security relies on ECDLP.

[Image: Diagram showing the Bitcoin transaction chain with signatures]

Source Image: Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto
:::

::: {.callout collapse=true}
## Quick Revision

**Cryptocurrencies:** Bitcoin/Ethereum use **ECDSA** (ElGamal on elliptic curves).

Each transaction signed with holder's private key.

Security based on ECDLP.
:::

---

## Summary Table of Schemes

| Class | Scheme | Message Recovery | Base Problem |
|--------|---------|------------------|------------------|
| **Classical Signatures** | RSA | Yes | RSAP |
| | Rabin | Yes | SQROOTP |
| | ElGamal | No | DLP |
| | DSS | No | DLP |
| **One-time Signatures** | Lamport | No | depends on OWF |
| | Bos-Chaum | No | depends on OWF |
| **Undeniable Signatures** | Chaum-van Antwerpen | No | DLP |
| **Fail-Stop Signatures** | van Heyst-Pedersen | No | DLP |
| **Blind Signatures** | Chaum | Yes | RSAP |

::: {.callout collapse=true}
## Original Text

[Complete table with all above information]

The operation of One-time, Undeniable and Fail-Stop signature schemes can be consulted in [Men97].
:::

::: {.callout collapse=true}
## Quick Revision

**Classical signatures:**

- RSA/Rabin (recovery)
- ElGamal/DSS (appendix)

**Specialized:**

- One-time
- Undeniable
- Fail-stop
- Blind

Base problems: RSAP, SQROOTP, DLP, depends on OWF.
:::

---

## Types of Attacks

**Criteria for "breaking" a scheme:**

- **Total Break**: Compute the private key or efficient generation algorithm
- **Selective forgery**: Generate signature for fixed message/class
- **Existential forgery**: Forge at least one signature (without message control)

**Basic attacks:**

- **Key-only**: Only the public key is known
- **Known-messages**: Access to signatures of known messages
- **Chosen-messages**: Attacker chooses messages to be signed
- **Adaptive chosen-messages**: Choice depends on previous responses

These attacks are equivalent to attacks on encryption systems (known/chosen-plaintext/ciphertext) but applied to messages.

::: {.callout collapse=true}
## Original Text

**Criteria for "breaking" a digital signature scheme:**

- **Total Break**: Compute the signer's private key or an efficient (polynomial) algorithm to generate signatures.
- **Selective forgery**: The adversary is able to generate a valid signature for a fixed message (or class of messages).
- **Existential forgery**: The adversary is able to forge a signature for (at least) one message (which they do not control).

**Basic attacks:**

- **Key-only attacks**: The adversary only has knowledge of the signer's public key.
- **Message-based attacks**: The adversary has access to signatures corresponding to:
  - known-messages
  - chosen-messages
  - adaptive chosen-messages

Equivalent to x-ciphertext attacks but with messages!
:::

::: {.callout collapse=true}
## Quick Revision

**Breaking signature:**

- Total break (private key)
- selective forgery (fixed message)
- existential (one message)

**Attacks:**

- key-only
- known/chosen/adaptive-chosen-messages.
:::