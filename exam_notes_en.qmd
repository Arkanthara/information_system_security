# Fundamental Security Services

Security services are the objectives aimed at protecting a system.

* **Confidentiality**: Protection against unauthorized disclosure.
* **Integrity**: Protection against unauthorized modification.
* **Availability**: Guarantee of access for legitimate users.
* **Authentication**:

  * *Entity authentication*: Certifying the identity of an actor.
  * *Data origin authentication*: Certifying the source of data.
* **Non-repudiation**: Inability to deny a transaction.
* **Non-duplication**: Protection against illicit copying.
* **Anonymity**: Preservation of identity or source.

::: {.callout collapse="true"}

#### Original version

* **Confidentiality**: Protection of information from unauthorized disclosure.
* **Integrity**: Protection against unauthorized modification of information.
* **Availability**: Ensuring that resources are accessible to legitimate users.
* **Authentication**:

  * **Entity authentication** *(entity authentication)*: Process allowing one entity to be certain of the identity of a second entity, supported by corroborating evidence (e.g., physical presence, cryptographic, biometric, etc.). The term identification is sometimes also used for this service.
  * **Data origin authentication** *(data origin authentication)*: Process allowing one entity to be certain that a second entity is the original source of a set of data. By definition, this service also ensures the integrity of the data.
* **Non-repudiation**: Guarantees that an entity cannot deny being involved in a transaction.
* **Non-duplication**: Protection against illicit copying.
* **Anonymity (entity or data origin)**: Preserves the identity of an entity, the source of information, or a transaction.

:::

---

# Summary: Services, Threats, and Protection Mechanisms

| Security Services         | Threats and Attacks (*Italic*)                             | Classic Mechanisms                          | Digital Mechanisms                                            |
| :------------------------ | :--------------------------------------------------------- | :------------------------------------------ | :------------------------------------------------------------ |
| **Confidentiality**       | Information leakage, *eavesdropping*, traffic analysis     | Seals, safes, padlocks                      | Encryption, logical authorization                             |
| **Integrity**             | Modification, *tampering*, illicit creation or destruction | Special ink, holograms                      | One-way functions + encryption                                |
| **Availability**          | *Denial of Service (DoS)*, viruses, illicit use            | Physical access control, video surveillance | Logical access control, audit, antivirus                      |
| **Entity Authentication** | Unauthorized access, password theft, protocol flaw         | Presence, voice, ID card, biometrics        | Secret + protocol, network address + userid, smart card + PIN |
| **Data Authentication**   | Falsification of information or signature                  | Seals, signature, fingerprint               | One-way functions + encryption                                |
| **Non-repudiation**       | Denying a transaction (*repudiation*), claiming key theft  | Seals, notary signature, registered mail    | One-way functions + encryption + digital signature            |
| **Non-duplication**       | Duplication, falsification, imitation                      | Special ink, holograms, tagging             | Digital watermarking, cryptographic locking                   |
| **Anonymity**             | Identification, transaction analysis, tracing              | Voice scramblers, disguise, cash            | *Mixers*, *remailers*, e-money, *deep web*                    |

::: {.callout collapse="true"}

#### Original version

## Threats and Attacks: Summary

| Services                  | Threats                              | Attacks                                                           |
| :------------------------ | :----------------------------------- | :---------------------------------------------------------------- |
| **Confidentiality**       | Information leakage                  | Unauthorized eavesdropping, traffic analysis                      |
| **Integrity**             | Information modification             | Illicit creation, alteration, or destruction                      |
| **Availability**          | Denial of service, illicit use       | Viruses, repeated access attempts to disable a system             |
| **Entity Authentication** | Unauthorized access                  | Password theft, authentication protocol flaw                      |
| **Data Authentication**   | Information falsification            | Signature forgery, protocol flaw                                  |
| **Non-repudiation**       | Denying involvement in a transaction | Claiming key theft or signature protocol flaw                     |
| **Non-duplication**       | Duplication                          | Falsification, imitation                                          |
| **Anonymity**             | Identification                       | Transaction analysis, unauthorized access enabling identification |

## Protection Mechanisms

| Services                  | Classic Mechanisms                                  | Digital Mechanisms                                                           |
| :------------------------ | :-------------------------------------------------- | :--------------------------------------------------------------------------- |
| **Confidentiality**       | Seals, safes, padlocks                              | Encryption, logical authorization                                            |
| **Integrity**             | Special ink, holograms                              | One-way functions + encryption                                               |
| **Availability**          | Physical access control, video surveillance         | Logical access control, audit, antivirus                                     |
| **Entity Authentication** | Presence, voice, ID card, biometric recognition     | Secret + authentication protocol, network address + userid, smart card + PIN |
| **Data Authentication**   | Seals, signature, fingerprint                       | One-way functions + encryption                                               |
| **Non-repudiation**       | Seals, signature, notary signature, registered mail | One-way functions + encryption + digital signature                           |
| **Non-duplication**       | Special ink, holograms, tagging                     | Digital watermarking, cryptographic locking                                  |
| **Anonymity**             | Voice scrambler, disguise, cash                     | Mixers, remailers, e-money, deep web                                         |

:::
---

# Internet-Related Risks

## Malware Delivered via E-Mail

* Also called **malware**.
* Emails designed to **trigger an action** (open attachment or click a link).
* Often **personalized** using **social engineering**.
* **Main consequences:**

  * Malware installation (*ransomware*, *keyloggers*, etc.).
  * **Loss or theft of personal data**.
  * **System hijacking** and **malware propagation**.

::: {.callout collapse="true"}

#### Ultra-summary

* Malware spread by email
* Prompting clicks or opens
* Social engineering
* Data theft, loss, hijacking
:::

::: {.callout collapse="true"}

#### Original version

## Malware Delivered via E-Mail

* Also called **malware**.
* Emails designed to **incite the recipient** to **open an attachment** or **follow a link** containing ads, offensive info, risky programs, etc.
* Often targeted based on victim interests (preliminary social engineering).
* **Consequences:**

  * Malware installation (*ransomware*, *keyloggers*, etc.) on victim systems (*computer*, *tablet*, *smartphone*, *smartwatch*, etc.).
  * Data destruction.
  * Theft of personal information or data.
  * System hijacking for malicious purposes (e.g., illegal bitcoin mining).
  * Malware propagation (potentially to other users).
:::

## Malware Delivered via Web

* Method called ***drive-by download***: **automatic infection when visiting a website**.
* Sources can be:

  * A **malicious website**
  * A **compromised legitimate site** (e.g., *cross-site scripting*).
* **User caution** greatly reduces this propagation method.
* **Impacts are similar** to email-borne infections.
* **Script restriction** (*Java/JavaScript*) reduces risk but can **affect browsing**.

::: {.callout collapse="true"}

#### Ultra-summary

* *Drive-by download* = infection without user action
* Malicious or compromised sites
* Awareness + restricted scripts = protection
:::

::: {.callout collapse="true"}

#### Original version

## Malware Delivered via Web

* Often called ***drive-by download***, allows **infecting the system** (*computer*, *tablet*, *smartphone*, *smartwatch*, etc.) **simply by visiting a website**.
* Sources may be:

  * Malicious site containing malware
  * Legitimate website previously infected (e.g., *cross-site scripting*). Infection may only affect certain pages.
* User awareness (avoiding suspicious sites) reduces the effectiveness.
* Consequences are similar to email infections.
* Restricted script execution (*Java/JavaScript*) in browsers can limit infection but may constrain navigation.
:::

## Phishing

* Technique to **collect private information** through **indiscriminate fishing**.
* ***Phishing*** can be:

  * **General** (broad targeting)
  * **Targeted** (*spear phishing*) for a specific person or organization.
* Main vector: **forged email address**, hard to detect.
* Goal: obtain **sensitive data** (credentials, passwords, personal or banking info).
* Attacks use **credible or threatening pretexts** to prompt victim cooperation.

::: {.callout collapse="true"}

#### Ultra-summary

* Information theft by deception
* Forged emails
* *Spear phishing* = targeted attack
* Urgent or threatening pretexts
:::

::: {.callout collapse="true"}

#### Original version

## Phishing

* The word ***phishing*** comes from English ***"password"***, ***"harvesting"***, and ***"fishing"***.
* Shows the technique’s main goal: **collect as much private info** via indiscriminate fishing.
* Targeted attacks are called ***spear phishing*** (from *spear fishing*).
* Transmission vector: email with **forged sender address** requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.
* Pretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored.
:::

## Spam

* **Unwanted emails**, often ads, or **unsolicited pop-ups** during web browsing.
* Represent about **60% of global emails**.
* Main consequences:

  * **Resource consumption** and time loss.
  * Some can **transmit malware**.
* Often target short addresses or come from **sold/exchanged address lists**.
* **Anti-spam filters** incur **significant costs** for organizations.

::: {.callout collapse="true"}

#### Ultra-summary

* Unwanted emails/ads
* Risks: time/resource loss, malware
* Targeting: short addresses or lists
* Filtering costly for organizations
:::

::: {.callout collapse="true"}

#### Original version

## Spam

* Includes all **unwanted emails** (often ads) received by people and organizations.
* Also applies to **pages/pop-up windows** **shown without user consent** during web browsing.
* Around **60%** of global emails belong to this category.
* Consequences: resource consumption and wasted time, but some spam can also **transmit malware**.
* Often target short email addresses or list-based addresses (sold/exchanged).
* **Anti-spam filtering** incurs high organizational costs.
:::

## Ransomware

* Trojan-type malware that **encrypts data** to make it inaccessible.
* Demands a **ransom** (often in bitcoins) to recover files.
* Can remain **dormant**, triggered by an event or date.
* Main vector: **malicious emails**.
* Other effects: **DoS attacks, extortion**.

::: {.callout collapse="true"}

#### Ultra-summary

* Data encrypted by Trojan
* Ransom to restore access
* Possible programmed dormancy
* Infection via malicious emails
:::

::: {.callout collapse="true"}

#### Original version

## Ransomware

* Trojan malware family.
* Typically **encrypts victim’s data** to make it completely inaccessible.
* Then displays a message requesting **ransom payment** (often in **bitcoins**).
* May stay in **dormant state** triggered by event or date.
* Infection vectors vary, but **malicious email attachments** often responsible.
* Variants exist and continue to evolve.
* Other behaviors: **DoS, targeted extortion, threats**, etc.
:::

## Attacks on ***Internet of Things (IoT)*** Devices

* Target **connected objects** (cameras, TVs, sensors, alarms, etc.).
* Devices are **easy to compromise** due to:

  * **Known vulnerabilities**
  * **Default passwords**
  * **User unawareness**
* **Remote control** enables:

  * **Entry point** to the network
  * **Device abuse** for illicit activities (DDoS, hacking, mining)
* A **precise inventory** of connected devices is essential.

::: {.callout collapse="true"}

#### Ultra-summary

* Targets connected objects
* Weak security (vulnerabilities, default passwords)
* Risk of network access and abuse
* IoT inventory needed
:::

::: {.callout collapse="true"}

#### Original version

## Attacks on IoT Devices

* Target connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).
* Often **easier to hack** than traditional systems due to:

  * Many vulnerabilities known to attackers
  * Default passwords
  * User negligence
* Remote takeover allows:

  * Entry point to home/corporate network
  * Device use for illicit activities (hacking, DDoS, bitcoin mining)
* Maintaining a detailed directory of all connected devices is necessary.
:::

## Information Spoofing and Website Defacement

* Attacks aiming to **alter information** on websites and social media.
* Impact: **compromised reputation** and **economic damage**.
* Websites: secure host system, restrictive configuration, **regular audits**.
* Social media: strong passwords, **multi-factor authentication**, session closure, cookie deletion.

::: {.callout collapse="true"}

#### Ultra-summary

* Altered info on websites and social media
* Risks: reputation, economic losses
* Websites: security + audits
* Social media: strong passwords, MFA, closed sessions, cookies cleared
:::

::: {.callout collapse="true"}

#### Original version

## Information Spoofing and Website Defacement

* Target **integrity** of published info on websites and social media.
* Affects **reputation** and can cause **economic damage**.
* **Websites**: secure host system, as restrictive configuration as possible, recurring security audits recommended.
* **Social media**: depends on authentication process:

  * Avoid simple passwords
  * Prefer strong, possibly multi-factor authentication
  * Close sessions properly
  * Clear cookies
:::

## Denial of Service (DoS / DDoS) Attacks

* Aim to **make IT systems inaccessible**, especially for organizations.
* **DDoS**: distributed attack using thousands of devices, generating massive traffic.
* Classic protections (*firewalls*, IDS/IPS sensors) often **insufficient**.
* Consequences:

  * **Affected reputation**
  * **Financial losses** (sometimes ransom)
  * **High risk for critical infrastructure** (hospitals, power plants, Internet backbone)

::: {.callout collapse="true"}

#### Ultra-summary

* DDoS = inaccessible systems via massive attacks
* Limited protections
* Risks: reputation, finances, critical infrastructures
:::

::: {.callout collapse="true"}

#### Original version

## Denial of Service (DoS / DDoS) Attacks

* Aim to **render IT systems inaccessible**, mainly targeting private or governmental organizations.
* **DDoS** (*Distributed Denial of Service*): multiple devices (**often tens of thousands**) simultaneously target victim system(s).
* Traffic can reach several hundred Gbps.
* Traditional protection (*firewalls*, *intrusion detection/prevention sensors*) has limited effectiveness.
* Service unavailability can cause:

  * **Reputational issues**
  * Significant **financial losses** (ransom demands)
  * **High security risks (even physical)** for **critical infrastructures** (hospitals, power plants, Internet backbone).
:::

# Digital Security Methods

**Problem:** Protecting digital information

* in a distributed environment
* globally accessible
* without physical boundaries

**Solution:**

* Cryptography
    * Symmetric
    * Asymmetric
    * $+$ One-way functions
    * $+$ (Pseudo) random generators

::: {.callout collapse="true"}
#### Ultra-summary
- **Problem:** Security in a distributed/global environment.
- **Solutions:**
  - Crypto (symmetric/asymmetric).
  - One-way functions (hashing).
  - Random generators (physical/pseudo).
:::

::: {.callout collapse="true"}
#### Original version

**Problem:** Protecting digital information

* in a distributed environment
* globally accessible
* without physical boundaries

**Solution:**

* Cryptography
    * Symmetric
    * Asymmetric
    * $+$ One-way functions
    * $+$ (Pseudo) random generators
:::

---

## Cryptographic Hash Functions

* **Functions easy to compute in one direction but virtually impossible to reverse**.
* Any modification of the source document radically changes the **digest** (avalanche effect).
* **Key properties**:
  - **One-way**: impossible to retrieve the input from the hash.
  - **Collision-free**: impossible to find two inputs with the same hash.
* Digest size: 160 to 512 bits.
* Algorithms (very **performant**): SHA-1, SHA-256, SHA-3.

::: {.callout collapse="true"}
#### Ultra-summary
- **One-way + collision-free**.
- Size: 160-512 bits.
- Algos: SHA-1/256/3.
- Usage: integrity, signatures.
:::

::: {.callout collapse="true"}
#### Original version

* **Functions easy to compute in one direction but virtually impossible to compute in the reverse direction**.
* Any modification (even insignificant) of the source document results in a fundamentally different **digest**.
* It is virtually impossible to retrieve the source document using only the digest (**one-way**).
* It is virtually impossible to find a second source document producing the same digest (**collision-free**).
* Usual digest length: 160 to 512 bits.
* One-way algorithms are very performant.
* Examples: SHA-1, SHA-256, SHA-3, etc.
:::

---

## (Pseudo) Random Generators

* **Characteristics**
    * **random**
    * **unpredictable**
    * **non-reproducible**
* **Critical** for security (keys, IV, secrets).
* **Types**:
  - **True random**: based on physical phenomena (radioactivity, quantum).
  - **Pseudo-random**: deterministic (based on a *seed*: initial random sequence).
* **Risk**: "Pseudo-security" if the *seed* is predictable (Pitkin quote).
* Applications: session keys, IV (DES-CBC), signatures (ElGamal).

::: {.callout collapse="true"}
#### Ultra-summary
- **True random**: physical (quantum).
- **Pseudo-random**: deterministic (*seed*).
- **Risk**: predictable *seed* = vulnerability.
- Uses: keys, IV, signatures.
:::

::: {.callout collapse="true"}
#### Original version

* Random number generation is a very important process that can compromise the security of many encryption systems.
* Applications: session key generation, initialization vectors (DES - CBC mode), secrets for signatures (ElGamal), etc.
* A **random generator** is a device capable of generating numbers in a **random**, **unpredictable** and **non-reproducible** way. (e.g. based on physical phenomena: radioactive or quantum source).
* **Pseudo-random generators** are deterministic processes developed from an initial random sequence (**seed**) (e.g. user keystrokes, disk access).
* *Quote:* R. Pitkin in [Kau95]: "The use of pseudo-random processes to generate secret quantities can result in pseudo-security"
:::

---

## Symmetric Cryptography

* **History**: Used since Julius Caesar (1st century BC).
* **Principle**: A single key for encryption/decryption.
* **Scheme**: Plaintext → Encryption (Key) → Ciphertext → Decryption (Key) → Plaintext.
* **Characteristics**:
  - Algorithms: AES, DES, IDEA, RC4.
  - Services: Confidentiality, Authentication, Integrity.
  - **Limit**: No signatures (shared key).
  - **Problem**: Secure key exchange required.

::: {.callout collapse="true"}
#### Ultra-summary
- **1 key** to encrypt/decrypt.
- **Fast** (AES, DES).
- **Problem**: key exchange.
- Uses: personal documents, closed groups.
:::

::: {.callout collapse="true"}
#### Original version

* Also called conventional cryptography or secret key cryptography (1st century BC, Julius Caesar).
* **Idea:** Based on a single secret key, perform a transformation capable of respectively making information unreadable and restoring it.
* **Scheme:** Plaintext $\to$ Encryption (Key) $\to$ Ciphertext $\to$ Decryption (Key) $\to$ Plaintext.
* **Characteristics:**
    * Algorithms: AES, DES, IDEA, RC4, RC5, etc. (some are free and openly available)
    * Services: Confidentiality, Authentication, Integrity.
    * No direct support for digital signatures (because key known by both).
    * Requires a confidential channel to exchange the key.
    * Ideal for protection of personal documents or closed groups.
:::

---

## Asymmetric Cryptography

* Also called **public cryptography** (1976, Diffie & Hellman).
* **Principle**
    - Key pair (public/private) for encryption and signatures.
* **Two main uses**:
  1. **Confidentiality**:
     - Encryption: recipient's public key
     - Decryption: recipient's private key
  2. **Digital signature**:
     - Signature: sender's private key
     - Verification: sender's public key
     - *Optimization*: Generally sign the **hash** of the document
     - **Fundamental properties**:
       - **Integrity**: Any modification invalidates the signature
       - **Non-collision**: Impossible to have 2 documents with the same signature
       - **Non-repudiation**: Only the holder of the private key can sign

* **Technical aspects**:
  - **Algorithms**: RSA, ElGamal
  - **Services**: Integrity, Authentication, Non-Repudiation
  - **Performance**: much slower than symmetric (100x slower)
  - **Advantage**: No need for a confidential channel for key exchange

::: {.callout collapse="true"}
#### Ultra-summary
- **2 keys**: public (encrypt/verify) + private (decrypt/sign)
- **2 uses**:
  - Confidentiality: encrypt for a recipient
  - Signature: prove authenticity
- **Signatures**:
  - Integrity + non-repudiation
- **Algorithms**: RSA/ElGamal
- **Advantage**: No need for secure channel to exchange keys
- **Disadvantage**: Slow
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography
* Also called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).
* **Idea:** Use two different keys - one **secret** and one **public** - respectively for encryption and decryption operations.
* Each user has a **keyring**.

**Confidentiality:**
* Sender encrypts with the **recipient's public key**.
* Recipient decrypts with their **private key**.
* Only the recipient's key is used!

**Digital Signature:**
* Sender signs with their **private key**.
* Recipient verifies with the **sender's public key**.
* Only the sender's key is used!
* *Note:* Generally sign the **digest** of the document (hash) for performance reasons.

**Signature characteristics:**
* The signature changes if the document changes, while the private key remains the same.
* If the document or signature is modified, verification fails (**integrity guaranteed**).
* It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function **without collisions**).
* Only the holder of the private key can generate a signature verifiable using the corresponding public key (**non-repudiation**).
* **Algorithms**: RSA, ElGamal.
* **Services**: Integrity, Authentication, Non-Repudiation.
* **Slowness**: Up to 50 times slower than symmetric cryptography.
* **Advantage**: No need for a confidential channel to exchange keys (unlike symmetric).
:::


---

## Asymmetric + Symmetric Cryptography (Hybrid)

* **Principle**: Use asymmetric to exchange a symmetric key (session key).
* **Steps**:
  1. A generates a random symmetric key $K_s$.
  2. A encrypts $K_s$ with B's public key.
  3. A and B then communicate using $K_s$ (symmetric).

::: {.callout collapse="true"}
#### Ultra-summary
- **Asymmetric**: exchange of symmetric key.
- **Symmetric**: data encryption.
- **Advantage**: combines security + performance.
:::

::: {.callout collapse="true"}
#### Original version

* **Idea:** Use public cryptography only to exchange symmetric keys (Session keys).
* A generates a random key $K_s$ and transmits it to B by encrypting it with B's public key.
* A & B then communicate using $K_s$ (symmetric).
:::

---

## Asymmetric Cryptography: Operation (RSA)

### Key Construction
1. **Choice of prime numbers**:
   - $p$ and $q$: two large prime numbers (> 1024 bits)
   - $n = pq$: RSA modulus (size = 2048+ bits)

2. **Calculation of Euler's totient function**:
   - $\phi(n) = (p-1)(q-1)$
   - *Property*: For any $a$ coprime with $n$, $a^{\phi(n)} \equiv 1 \pmod{n}$

3. **Selection of exponents**:
   - $e$: integer coprime with $\phi(n)$ (public exponent)
   - $d$: modular inverse of $e$ (private exponent), such that $ed \equiv 1 \pmod{\phi(n)}$

### Encryption/decryption process
* **Public key**: $(n,e)$
* **Private key**: $(d)$
* **Encryption**: $C = P^e \pmod{n}$
* **Decryption**: $P = C^d \pmod{n}$

### Mathematical proof
1. **Fundamental congruence**:
   - $ed = 1 + k\phi(n)$ (by definition of $d$)

2. **Application of Euler's theorem**:
   - $P^{\phi(n)} \equiv 1 \pmod{n}$ (if $P$ coprime with $n$)

3. **Demonstration**:

   \begin{align*}
   (P^e)^d &\equiv P^{ed} \pmod{n} \\
   &\equiv P^{1 + k\phi(n)} \pmod{n} \\
   &\equiv P \cdot (P^{\phi(n)})^k \pmod{n} \\
   &\equiv P \cdot 1^k \pmod{n} \\
   &\equiv P \pmod{n}
   \end{align*}

### System security
* **Hard problem**: Factorization of $n$ into $p$ and $q$
* **Recommended size**:
  - $n$: 2048 bits (minimum for current security)
  - $p$ and $q$: 1024+ bits each
* **Known vulnerabilities**:
  - Side-channel attacks (timing, power analysis)
  - Inappropriate parameter choices ($e$ too small, $p$ and $q$ too close)

::: {.callout collapse="true"}
#### Ultra-summary
- **Keys**:
  - Public: $(n,e)$ where $n = pq$
  - Private: $(d)$ with $ed \equiv 1 \pmod{\phi(n)}$
- **Operations**:
  - Encryption: $P^e \mod n$
  - Decryption: $C^d \mod n$
- **Security**: Factorization of $n$ difficult
- **Size**: 2048+ bits for $n$
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography: Operation (RSA)
* Let $n := pq$ with $p$ and $q$ two large prime numbers (> 1024 bits).
* Let $\phi(n) = (p-1)(q-1)$.
* Let $e$ and $d$ such that $ed \equiv 1 \pmod{\phi(n)}$.
* By definition of congruences: $ed = 1 + k\phi(n)$
* Euler's theorem: $a^{\phi(n)} \equiv 1 \pmod n$.
* **Encryption:** $C = P^e \pmod n$. **Public key:** $(n,e)$.
* **Decryption:** $P = C^d \pmod n$. **Private key:** $(d)$.
* *Proof:* $(P^e)^d \equiv P^{ed} \equiv P^{1 + k\phi(n)} \equiv (P \pmod n) (P^{\phi(n)} \pmod n)^k \equiv P \pmod n$.
:::


---

## Asymmetric Cryptography: Conclusions

* **Dominant algorithms**: RSA (most used), Rabin, ElGamal
* **Complete services**:
  - Confidentiality
  - Authentication
  - Integrity
  - Digital signature & Non-repudiation
  - Non-duplication

* **Performance**:
  - 50x slower than symmetric
  - **Optimal solution**: Combination of asymmetric (key exchange) + symmetric (encryption)

* **Key management**:
  - **Advantage**: Public key exchange without confidential channel
  - **Risk**: Need to verify authenticity of public keys
    - Authenticated acquisition channel **or**
    - Certification by trusted third party

::: {.callout collapse="true"}
#### Ultra-summary
- **Algos**: RSA (dominant), Rabin, ElGamal
- **Services**: Confidentiality + Authentication + Integrity + Signatures
- **Slowness**: 50x vs symmetric → **hybrid recommended**
- **Keys**: Simple public exchange but **authentication crucial**
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography: Conclusions

* There are a few asymmetric encryption systems (**Rabin**, **ElGamal**, etc.) but the most used is **RSA**.

* **Supported services**: **Confidentiality**, **Authentication**, **Integrity**, **Digital Signature & Non-Repudiation**, (**Non-Duplication**).

* Operations related to **asymmetric cryptography** are up to **50 times (!) slower** than those of **symmetric cryptography**.
  A **combination of the two methods** is often desirable.

* **Key distribution** is simplified by the fact that only **public keys** need to be exchanged between participants (no need for an alternative confidential channel) but…

* … it is necessary to **verify that the public key actually belongs to the recipient**:
  * Either the **acquisition channel** of the public key is protected against any modification (**authenticated**)
  * Or the key is **certified accurate by a third party**
:::

---

## Symmetric vs Asymmetric Comparison

### Comparative advantages

* **Symmetric**:
  - **Performance**: 100x faster
  - **Implementation**: Easy in hardware
  - **Keys**: Short (128 bits = 16 memorable characters)

* **Asymmetric**:
  - **Key exchange**: Authenticated channel sufficient (no need for confidentiality)
  - **Management**: 1 key pair for n correspondents (vs n keys in symmetric)

### Common issues

* **Weak link**: Key management by users
* **Security basis**: Empirical rather than theoretical
* **Legal constraints**: Usage and export restrictions

### Usage recommendations

| **Use case**                          | **Recommended solution**                          | **Justification**                                                                 |
|--------------------------------------|--------------------------------------------------|----------------------------------------------------------------------------------|
| Personal documents                    | Symmetric                                        | Speed + memorable keys                                                          |
| Groups of close users                 | Symmetric                                        | Speed + easy confidential exchange                                              |
| Distant/unknown users                 | Asymmetric                                       | No need for confidential channel                                                 |
| Remote transactions                  | Hybrid (Asymmetric + Symmetric)                 | Asymmetric for key exchange, symmetric for data                                 |
| Software protection (distribution)   | Hybrid                                           | Unique symmetric key per version, encrypted with asymmetric                    |
| Network segments                     | Symmetric                                        | Speed + controlled environment (easy key exchange between administrators)        |

::: {.callout collapse="true"}
#### Ultra-summary
**Symmetric**:

    ✅ Fast (100x)
    ✅ Short keys (128 bits)
    ❌ Confidential key exchange required

**Asymmetric**:

    ✅ Simplified key exchange
    ✅ 1 key pair for n correspondents
    ❌ Slow (50x)
    ❌ Long keys (1024+ bits)

**Hybrid**: Best of both worlds
**Common problems**: Key management, empirical basis, legal restrictions
:::

::: {.callout collapse="true"}
#### Original version
## Symmetric vs. Asymmetric Cryptography

* There are **hundreds of symmetric and asymmetric algorithms** capable of providing a sufficient level of **confidentiality**.

* **Symmetric solutions** offer the following advantages:
  * **Speed** (up to **100 times faster** than asymmetric solutions)
  * **Ease of hardware implementation**
  * **Reduced key length**: **128 bits** (= 16 characters ⇒ memorable!) instead of **1024 bits** for asymmetric equivalents.

* **Asymmetric solutions** have as main arguments:
  * **Simplified key exchange**: keys must be exchanged through an **authenticated but non-confidential channel**
  * **Simplified key management**: a single **public/private key pair** is sufficient for a user to receive confidential messages from **n users** (instead of **n different keys** in the symmetric case).

* **Problems common to both techniques**:
  * **Key management by the user** remains the **weakest link**
  * Security (normally) based on **empirical arguments** rather than **theoretical** ones
  * **Legal restrictions** on usage and export

## Symmetric vs. Asymmetric Cryptography (II)

| **Activity**                                                                                   | **Recommendation**                                                                                           | **Remarks**                                                                                                                              |
| --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| Protection of personal documents                                                             | **Symmetric crypto**                                                                                        | **Speed**, easily memorable keys                                                                                                  |
| Protection of documents in a group of close users                                            | **Symmetric crypto**                                                                                        | **Speed**, ease of exchanging confidential keys                                                                                   |
| Establishment of confidential channels between distant users (unknown)                       | **Asymmetric crypto**                                                                                       | No need to have a confidential channel: **authenticity suffices**                                                                         |
| Transactions between two distant users, Software protection (multicast distribution)         | **Asymmetric crypto for symmetric key protection** + **Symmetric crypto for data protection**              | **Speed**, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public |
| Protection of network segments                                                                | **Symmetric crypto**                                                                                        | **Speed**, Stable environment → easy confidential key exchange between sysadmins                                                   |
:::

# Dissection of an Attack: Ransomware

### Definition and Impact
* **Definition**: Malicious software that encrypts data and demands a ransom for its restoration.
* **Limitations of the classic definition**:
  - Does not cover the impact on **critical infrastructure** (e.g., Colonial Pipeline, May 2021)
  - Underestimates the **systemic scope** of attacks
* **Alarming statistics**:
  - Billions of annual attacks
  - Considered the **most dangerous cyber threat** in 2021 ("Ransomware Everywhere")

::: {.callout collapse="true"}
#### Ultra-summary
- **Malware**: Encrypts data → demands ransom
- **Impact**: Critical infrastructure (e.g., Colonial Pipeline)
- **Threat #1** in cybersecurity (2021)
- **Targets**: Individuals + businesses + states
:::

::: {.callout collapse="true"}
#### Original version
"Ransomware (from English **ransomware**), ransom software, extortion software, is malicious software that holds personal data hostage. To do this, ransomware **encrypts personal data** then asks their owner to send money in exchange for the **decryption key**" (Wikipedia September 21, 2021).

- **Incomplete definition** because **ransomware** affects a **vast spectrum of IT infrastructure**

- For example, in May 2021, a **ransomware attack** against the **Colonial Pipeline** company caused a **fuel supply disruption** for a large part of the US coast

- With a **total number of attacks** counted in **billions per year**, "**Ransomware Everywhere**" is globally considered the **most direct, visible and dangerous threat** for users and companies in 2021!
:::

---

## Ransomware Attack Lifecycle

### Prevention and Response
| Phase | Measures |
|-------|---------|
| **Prevention** | - Regular patching<br>- Detection solutions (Firewalls, WAFs, IDS/IPS)<br>- Anti-malware scans (emails, files) |
| **Protection** | - **Offline backups** (essential!)<br>- Strict security policies<br>- User training |
| **Response** | - **Do not pay** (official recommendation)<br>- Forensic analysis<br>- Restoration from backups |

### Technical Dissection
1. **Infection**:
   - Vectors: Phishing, exploits, vulnerable RDP
   - Propagation: Lateral (network) or vertical (system)

2. **Execution**:
   - Encryption of targeted files
   - Deletion of shadow copies
   - Persistence (registry, scheduled tasks)

3. **Extortion**:
   - Display of ransom demand
   - Payment in cryptocurrencies (Bitcoin, Monero)
   - Payment deadlines with penalties

4. **Obfuscation**:
   - Code obfuscation
   - Communication via TOR/Deep Web
   - Log erasure

::: {.callout collapse="true"}
#### Ultra-summary
**Attack cycle**:

1. Infection (phishing/exploits)
2. Execution (encryption + persistence)
3. Extortion (ransom in crypto)
4. Obfuscation (TOR + trace erasure)

**Countermeasures**:

    ✅ Offline backups
    ✅ Patching + detection
    ✅ Training
    ❌ Do not pay
:::

---

## Cryptolocker: Technical Analysis

### Attack Scheme

```{mermaid}
graph TD
    A[Initial infection] --> B[File encryption]
    B --> C[Private key storage on C2 servers]
    C --> D[Ransom demand]
    D --> E{Payment ?}
    E -->|Yes| F[Decryption key sent via TOR]
    E -->|No| G[Permanent data loss]
```

### Preferred Targets
* **Critical extensions** (extract):
  - Documents: `.docx`, `.xlsx`, `.pdf`, `.pptx`
  - Databases: `.mdb`, `.sql`, `.sqlite`
  - Media: `.jpg`, `.png`, `.mp4`, `.avi`
  - Development: `.java`, `.cpp`, `.py`, `.php`
  - Financial: `.qbw`, `.qbb`, `.wallet`

* **Behavior**:
  - **Selective** encryption (recent/modified files)
  - **Double extortion**: Encryption + threat of leakage
  - **RaaS** (Ransomware-as-a-Service): Economic model

::: {.callout collapse="true"}
#### Ultra-summary
**Mechanism**:
- Private key stored on C2 servers
- Payment → key via TOR
- Targets: 100+ extensions (docs, DB, media)

**Recent evolutions**:
- Double extortion (encryption + leakage)
- RaaS (ransomware rental)
:::

::: {.callout collapse="true"}
#### Original version
## Ransomware: Complete View

*(Source: 2017 State of Cybersecurity, F-Secure Inc.)*

## Ransomware: Complete View

#### Prevention, Remediation and Response
- **Patching**
- **Active and passive detection** (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)
- **Offline backups** !
- **Security Policy** - Rules for proper email usage
- **Training** !
- **To pay or not to pay**...

#### Technical Dissection of the Attack
- **Infection and propagation**
- **Execution**
- **Payment** (Crypto-currencies / Bitcoin)
- **Obfuscation** (Obfuscation, TOR Networks/Deep Web)

### Generic Scheme of a Cryptolocker Ransomware

- **Decryption private keys** are stored on the **attacker's** servers
- They are sent to the **victim** after **bitcoin payment**
- The **trace** is shredded using **TOR networks**

## Ransomware Cryptolocker: Targets

**Targeted file extensions**:
.jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb,
.asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg,
.jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads,
.agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl,
.bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw,
.cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml,
.php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw,
.dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf,
.dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray,
.grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key,
.kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3,
.mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg,
.nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf,
.ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd,
.pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps,
.psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat,
.raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql,
.sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg,
.swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2,
.wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw,
.ycbcra, .yuv

*Source: Intel Security Advanced Threat Research - http://www.intelsecurity.com*
:::

# Basic Cryptography Concepts

* Introduction to the **fundamental concepts** of cryptography.
* Presents **security principles**, **system types**, and **attack models**.
* Includes **historical systems** and complementary techniques.

## Kerckhoffs' Principle

* Fundamental principle: **security relies solely on the key**, not on the secrecy of the algorithm.
* The system must remain **secure even if the algorithm is public**.
* The key must be **easily modifiable** and the system **simple to use**.
* Explicit rejection of **security through obscurity**.

::: {.callout collapse="true"}
#### Ultra-summary
- Security based on the key
- Public algorithm
- No security through obscurity
:::

::: {.callout collapse="true"}
#### Original version
## Kerckhoffs' Principle

**Auguste Kerckhoffs** published in **1883** two articles defining **six principles** for military ciphers:

1. The system must be **practically, if not mathematically, undecipherable**.
2. It must **not require confidentiality** and remain secure even if it falls into enemy hands.
3. The **key** must be able to be **memorized, transmitted and modified easily**, without written notes.
4. The system must be **compatible with telegraphic communications**.
5. It must be **portable** and usable by **a single person**.
6. It must be **simple to use**, without complex procedures or excessive constraints.

Kerckhoffs stated as early as the **19th century** that security must be **mathematically demonstrable** and that **there is no security through obscurity**.
:::

## Classification of Encryption Systems

### Unconditional Security

(*unconditional security* / *perfect secrecy*)

* Security **independent of computing power**.
* **Ciphertext** provides no information about the **plaintext**.
* Conditions: **key ≥ message**, **never reused**.
* Mostly **theoretical** use.
* **Example**: *one-time pad*.

### As hard as / equivalent / provable security

* Cryptanalysis **as difficult** as a **hard mathematical problem**.
* **RSA** and **Rabin** proven equivalent to factorization.
  * Demonstrated by **reduction** (*reduction proof*).
* Central but **controversial** concept.

### Computational Security

(*computational security* / *practical security*)

* Security based on **unrealistic cost of attacks**.
* Most used category in practice.
* **Examples**: **AES**, **DES**, **IDEA**, **RC4**.

::: {.callout collapse="true"}

#### Ultra-summary

* **Unconditional**: perfect, theoretical (*one-time pad*).
* **Provable security**: equivalence to hard mathematical problem.
* **Computational**: secure in practice.
:::

::: {.callout collapse="true"}

#### Original version

* **Unconditional security** (*unconditional security also called **perfect secrecy***):

  * The security of the encryption system **is not compromised by the computing power** intended for cryptanalysis.
  * This category relies on **information theory** published by **Shannon in 1949**.
  * More precisely, an encryption system is **unconditionally secure** if the probability of encountering a **plaintext x** after observing the **corresponding ciphertext y** is identical to the a priori probability of encountering plaintext x.
  * In other words, having **plaintext/ciphertext pairs (x,y)** provides **no help for cryptanalysis**.
  * A necessary condition for a system to be unconditionally secure is that the **key be at least the same size as the message** and, above all, that it **not be reused** to encrypt different messages.
  * This condition makes these systems **poorly suited to usual cryptographic needs** and reduces their domain of interest to a **theoretical framework**.
  * The classic example is the **one-time pad** invented in **1917** by **J. Mauborgne** and **G. Vernam**.
  * Theoretical foundations of unconditionally secure systems + other examples in **[Sti06]**.

* **As hard as / equivalent / provable security**

  * When it can be proven that cryptanalyzing the algorithm is **as difficult as solving a reputedly hard mathematical problem**.
  * For example **factorization of large numbers**, calculation of **square roots modulo a composite**, calculation of **discrete logarithms in a finite group**, etc.
  * The **Rabin** and **RSA** algorithms (generic case^1) are "proven" **equivalent to factorization**.
  * Such a proof is called a "reduction" (**reduction proof**).
  * The notion of **provable security** is at the origin of an **important controversy** in the cryptographic world.

* **Computational security** (*computational security also called **practical security***)

  * An encryption system is in this category if the **computational effort needed to "break" it** using the best possible techniques is **beyond** (with a reasonable margin) the computing resources of a hypothetical adversary.
  * The vast majority of symmetric encryption systems (**AES, DES, IDEA, RC4**, etc.) are in this category.
:::

## Entropy

* **Entropy** (Shannon, 1948) measures the **effective amount of information** contained in a message.
* **Conditional entropy** measures the uncertainty that remains about the **plaintext** after observing the **ciphertext**.

### Properties

* $0 \le H(X) \le \log n$
* $H(X) = 0$ → no uncertainty
* $H(X) = \log n$ → all outcomes equally probable

### Interpretation

* Approximates the **number of bits needed** to encode $X$.
* **Redundancy** = difference between effective encoding and entropy.

### Conditional Entropy

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$
* Measures the remaining uncertainty about the **plaintext** after observing the **ciphertext**.

---

::: {.callout collapse="true"}

#### Ultra-summary

* **Entropy**: amount of information in a message.
* **Conditional entropy**: uncertainty about plaintext after ciphertext.
* **Redundancy**: difference between effective encoding and entropy.
:::

::: {.callout collapse="true"}

#### Original version

* An essential definition in cryptography is the **effective** amount of information contained in a message.
* For example, days of the week (*Monday*, ..., *Sunday*) can intuitively be encoded as character strings of length ($\le \text{len}(\text{``Wednesday''})$), i.e., $(8 \times 8 = 64)$ bits. However, the effective amount of information of the variable *day of the week* can be optimally encoded on **3 bits** (since $(2^3 = 8)$ is sufficient to represent the 7 possible variations).
* **Entropy** (Shannon, 1948) is the mathematical formalization of this definition.

### Formal Definition

Let $X$ be a random variable with a finite set of possible values ${x_1, x_2, \dots, x_n}$, such that $P(X=x_i) = p_i$, with $0 \le p_i \le 1$ and $\sum p_i = 1$.
The entropy of $X$, denoted $H(X)$, is defined by

$H(X) = - \sum_{i=1}^{n} p_i \log p_i = \sum_{i=1}^{n} p_i \log \left(\frac{1}{p_i}\right)$

By convention: $p_i \log p_i = 0$ if $p_i = 0$. All logarithms are in **base 2**.

### Interpretation

* Approximation of the number of bits needed to encode the elements of $X$.
* **Redundancy** is the difference between the effective encoding and entropy.

### Properties

1. $0 \le H(X) \le \log n$
2. $H(X) = 0 \iff \exists i : p_i = 1, p_j = 0 \ \forall j \ne i$
3. $H(X) = \log n \iff p_i = 1/n \ \forall i$

### Conditional Entropy

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$,
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$

*Measures the uncertainty about $X$ (plaintext) after having observed $Y$ (ciphertext).*
:::

## Attacks on Encryption Systems

* **Ciphertext-only**: Adversary has only the **ciphertext**.
* **Known-plaintext**: Adversary has **plaintext/ciphertext pairs**.
* **Chosen-plaintext**: Adversary **chooses** the **plaintext** and see the ciphertext (and tries to find the plaintext for other messages).
* **Adaptive chosen-plaintext**: **depends on** the **received** ciphertexts.
* **Chosen-ciphertext**: Adversary **chooses** the **ciphertext** and obtains the plaintext (aims to find the key).
* **Adaptive Chosen-ciphertext**: **Chosen-ciphertext** depends on the received plaintexts.

## Oracles and Security Models

### Random Oracles and Security Models

* **Random Oracle**: A theoretical "perfect" function that returns a uniform and random value for each new input, but remains deterministic for an input already seen.
* **ROM (Random Oracle Model)**: Mathematical proof framework using this ideal oracle as a substitute for hash functions.
* **Standard Model**: Framework where security relies solely on the adversary's computing power against real algorithms.
* **Limit**: A security proof in ROM does not guarantee absolute security in the real world (with SHA-256, etc.).

::: {.callout collapse="true"}
#### Original version
A **random oracle** is an abstract entity accessible to legitimate parties and adversaries.

* **Behavior**: It responds to input queries $x$ with perfectly random responses $Orc(x)$. 
* **Determinism**: The only exception lies in previously processed inputs ($x_1, x_2, \dots, x_n$). If $x_1' = x_1$, then $Orc(x_1') = Orc(x_1)$.
* **Modeling**: It is modeled by a function $Orc : X \to Y$ where $\forall x \in X, \Pr(Orc(x) = y) = \frac{1}{|Y|}$.
* **Utility**: It behaves like an **"ideal" cryptographic hash function**, a valuable tool for proving security in the **Random Oracle Model**. 
* **Comparison**: The **standard model** limits adversaries by computational factors. A protocol secure in the random oracle model can become vulnerable if used with a "real" hash function (SHA-1, SHA-256).
:::

---

### Encryption, Decryption and Signature Oracles

* **Function**: Entities that perform operations (encrypt/sign) for the adversary using secret keys without ever revealing them.
* **Symmetric cryptography**: The oracle provides $E_k(x)$ or $D_k(y)$.
* **Asymmetric cryptography**: The oracle is crucial for private operations (decryption/signature), as public operations are already freely accessible.

::: {.callout collapse="true"}
#### Original version: Operational Oracles
An **encryption/decryption/signature oracle** is an abstract entity offering an "on-demand" service.

* **Key access**: It uses the **same keys as the legitimate owners** (symmetric and asymmetric systems) without disclosing them.
* **Symmetric primitives**: For a primitive $E$ and a key $k$, it returns $y = E_k(x)$ or the corresponding plaintext $x$.
* **Public key systems**: The oracle is only needed for operations with the **private key** ($priv_k$).
    * **Decryption**: returns $x$ such that $E'_{pubk}(x) = y$.
    * **Signature**: For a system $S$, it returns $y = S_{privk}(x)$.
* **Attacks**: The attack models using **chosen plaintext** (CPA) and **chosen ciphertext** (CCA) rely on making these oracles available to the adversary.
:::

---

### Indistinguishability and Semantic Security (IND-CPA)

* **Property**: An adversary must not be able to distinguish the ciphertexts of two different plaintext messages.
* **IND-CPA (Indistinguishability under Chosen Plaintext Attack)**: If the adversary guesses the correct message only with a probability of $1/2 + \epsilon$, the system is considered secure.
* **Semantic Security**: Equivalent to IND-CPA, it ensures that no useful information leaks from the ciphertext.

::: {.callout collapse="true"}
#### Original version: Semantic Security
**Ciphertext indistinguishability** guarantees the inability to distinguish the ciphertexts of given plaintexts.

* **Experiment (IND-CPA Security Game)**:
    1. The adversary chooses two messages $M_0$ and $M_1$.
    2. The oracle chooses a random index $i \in \{0,1\}$ and returns $c_i = E_k(M_i)$.
    3. The adversary can perform other calculations or oracle calls.
* **IND-CPA Definition**: The system is secure if the adversary's advantage is **negligible** ($Prob = 1/2 + \epsilon$ with $\epsilon$ small).
* **Note**: In public key, the encryption oracle is useless because the adversary already possesses the public key. IND-CPA provides **semantic security**.
:::

---

### Probabilistic Encryption and OAEP

* **Problem**: Deterministic encryption allows **dictionary attacks** (comparison of known ciphertexts).
* **Solution**: Add randomness to the message before encryption so that $E(M)$ is different each time.
* **OAEP (Optimal Asymmetric Encryption Padding)**: Standard used with RSA. It combines the message $P$ with a random number $R$ via hash functions $h$ and XOR operations ($\oplus$).

::: {.callout collapse="true"}
#### Original version: Determinism vs. Probabilism
**Deterministic** behavior (same inputs = same outputs) creates vulnerabilities.

* **Example**: If Alice sends "Yes" or "No", the adversary can compute $C_{yes} = E_{pub}(``Yes")$ and compare. They can create a **codebook** (dictionary) to identify messages without breaking the key.
* **Probabilistic encryption**: Adds randomness. The goal is semantic security for the public key.
* **OAEP**: Used in **RSA-PKCS1**. The text $P$ is combined with randomness $R$:
    * $M_1 := P \oplus h(R)$
    * $M_2 := R \oplus h(M_1)$
    * Encryption applies to $M_1$ and $M_2$. During decryption, we recover $R = M_2 \oplus h(M_1)$, then $P = h(R) \oplus M_1$.
:::

::: {.callout collapse="true"}
#### Ultra-summary
- **Random Oracle**: "Ideal" hash function (theoretical model).
- **CPA/CCA Oracles**: Simulate access to the secret key to test resistance.
- **IND-CPA**: Inability to distinguish two ciphertexts (Semantic Security).
- **Probabilistic Encryption**: Essential to counter codebooks (dictionary attacks).
- **OAEP**: Padding method adding the necessary randomness to RSA.
:::

## History of Cryptography and Unconditional Security

### Historical Encryption Systems

Cryptography was for a long time limited to the sole pursuit of **confidentiality**. Historical systems are based on two fundamental principles: **substitution** and **transposition**.

* **Caesar Cipher** (mono-alphabetic substitution): Fixed letter shift. Very vulnerable to **frequency analysis**.
* **Vigenère Cipher** (polyalphabetic substitution): Uses a key to vary the shift. More complex, but breakable by identifying the key length.
* **Transposition Cipher**: Reorganization of the original text characters according to a permutation defined by a key.

::: {.callout collapse="true"}
#### Original version: Historical Cryptography
For centuries **confidentiality** was the only application of cryptography...

* **1st century BC, Caesar Cipher**: **Mono-alphabetic substitution encryption** $e_k(x) = (x + k) \pmod{26}$, $d_k(y) = (y - k) \pmod{26}$ where $x, y, k \in \mathbb{Z}_{26}$.
    * Example: $E_1(\text{'hello'}) = \text{'ifmmp'}$.
    * **Cryptanalysis**: easy, based on **character frequency**.
* **16th century, Vigenère**: **Polyalphabetic substitution encryption** $e_k(x_1, \dots, x_n) = (x_1 + k_1, \dots, x_m + k_m, x_{m+1} + k_1, \dots) \pmod{26}$.
    * **Cryptanalysis**: find the **key length $m$** by identifying repeated ciphertext portions and analyzing separate blocks as in the Caesar Cipher.
* **Transposition Ciphers** (Porta, 1563): The key defines a **permutation** on the plaintext.
* These techniques are still the basis of modern encryption systems (ex: **Enigma**, qualified by W. Churchill as the secret weapon that won the war).
:::

### The One-Time Pad (OTP)

The **One-Time Pad** (OTP), or **Vernam cipher**, is the only system proven to be **unconditionally secure** (perfect secrecy).

* **Principle**: The message is combined with a key of the same length via the XOR operation ($\oplus$).
* **Unconditional Security**: Observation of the encrypted message provides no information about the plaintext message. Even an adversary with infinite computing power cannot break it.
* **Shannon's Constraints**: The key must be **as long as the message**, purely **random**, and **used only once**.
* **Key Reuse**: If a key is reused for two messages, an attacker can eliminate the key by XOR ($y_a \oplus y_b = x_a \oplus x_b$) and recover the plaintext messages.

::: {.callout collapse="true"}
#### Original version: The One-Time Pad
Let $n \ge 1$ and the spaces $P, C, K$ such that $P, C, K = (\mathbb{Z}_2)^n$. The encryption and decryption operations of a **one-time pad** (Vernam Cipher) are:
$E_k(x_i) = x_i \oplus k_i$ and $D_k(y_i) = y_i \oplus k_i$ for $1 \le i \le n$.

* **Unconditional security**: If $k_i$ are random and independent, observation of ciphertexts does not help cryptanalysis. The **entropy** of $X$ does not decrease: $H(X|C) = H(X)$.
* **Shannon's Theorem**: Necessary condition: $H(K) \ge H(X)$. The length of the **random key** must be at least as large as that of the plaintext.
* **Key reuse**: $y_a \oplus y_b = x_a \oplus x_b$. With low-entropy messages, the plaintexts and the key ($k = y_a \oplus x_a$) can be recovered.
* Vulnerable to the **Known Plaintext** attack (if the key is reused).
* Major problem: The **distribution and management** of large keys. Revived by **quantum cryptography** proposing confidential channels for unlimited-length key distribution.
:::

### Steganography

In contrast to cryptography, which makes the message unreadable, **steganography** conceals the very existence of the message.

* **Method**: Use a "subliminal channel" (an innocent medium like an image or a banal text).
* **Modern technique**: Insertion of data into the **least significant bits** (LSB) of multimedia files, allowing the hiding of large volumes of data without visible alteration.

::: {.callout collapse="true"}
#### Original version: Steganography
**Steganography** hides a message inside another. Constituent elements:

1. A different **physical or logical channel** (subliminal channel).
2. A **secret mechanism** to identify this channel.

* **Classic examples**: First letters of words in a text, invisible ink.
* **Modern example**: Use the **least significant bits** of the frames of a Photo CD.
* For a 2048x3072 image (RGB 24 bits), hiding a message using 1 bit allows storing **2.3 Mb** without deteriorating quality.
:::

::: {.callout collapse="true"}
#### Ultra-summary
- **History**: Substitution (Caesar/Vigenère) and Transposition (permutation).
- **One-Time Pad**: Absolute security if the key is random, unique, and as long as the message ($H(K) \ge H(X)$).
- **Steganography**: Hiding the existence of the message (ex: LSB technique in images).
:::
# Symmetric Cryptography

## Stream Ciphers (Stream Encryption)

### Introduction to Stream Ciphers

#### Definition and Principle

**Stream ciphers** are a family of encryption systems characterized by:

- **Unit block size**: each encrypted block = 1 bit
- **Two-phase architecture**:
  1. **Keystream generation**: production of the key sequence
  2. **Substitution**: operation on plaintext bits based on the keystream

**Classic example**: the *one-time pad*

- Generation: (pseudo-)random generator
- Substitution: XOR operation ($\oplus$) with the keystream

#### General Characteristics

**Advantages:**

- **Speed**: encryption at register level, ideal for real-time *streaming* (video)
- **Lightweight**: work on systems with limited CPU resources
- **Low memory**: little or no buffering needed
- **Non-propagated errors**: retransmission of defective packets is sufficient (suitable for wireless transmissions - WiFi)

**Disadvantages:**

- **Dependency on keystream quality**: randomness determines robustness
- **Dangerous reuse**: keystream reuse allows easy cryptanalysis

::: {.callout-note collapse=true}
## 📄 Original text

### Stream Ciphers

- **Stream ciphers** constitute a **family of encryption systems** where the **size of the encrypted block is equal to 1 bit**.
- Stream ciphers are generally composed of **two phases**:
    - A **generation phase** of the sequence of elements forming the key (the **keystream**).
    - A **substitution phase** where the *plaintext* bits undergo a specific operation dependent on the keystream.
- An obvious example of a stream cipher is the **one-time pad** with:
    - A keystream generation phase performed by a **(pseudo-)random generator**.
    - A substitution phase consisting of performing a **xor** ($\oplus$) with the keystream.

### Stream Ciphers: Characteristics

- **Speed**: Encryption is done directly at the register level. Ideal for applications requiring *"on the fly"* encryption like **video streaming**.
- **Ease**: Operations can be performed by systems with **limited CPU resources**.
- **No (or little...) need for memory/buffering**.
- **Limited or absent error propagation**: retransmission of faulty packets is normally sufficient (suitable for applications where packet loss is frequent like **wireless transmissions (WiFi)**).
- **Disadvantages**:
    - The **quality in terms of randomness** of the generated keystream determines the **system's robustness**.
    - **Keystream reuse** allows **easy cryptanalysis** (cf. the one-time pad).
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Stream Ciphers** = encryption bit by bit in 2 phases (keystream generation + substitution).

**Advantages**: fast, lightweight, no error propagation.

**Disadvantages**: keystream quality critical, reuse = vulnerability.
:::

---

### Synchronous Stream Ciphers

#### Operating Principle

In a **synchronous stream cipher**, the keystream depends **only on the key**, independent of the plaintext and ciphertext.

**Process equations:**

$$\sigma_{i+1} = f(\sigma_i, k)$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Where:

- $\sigma_i$: state at time $i$ (initial state $\sigma_0$ may depend on $k$)
- $k$: secret key
- $f$: state transition function
- $g$: keystream production function producing $z_i$
- $h$: output function producing ciphertext $c_i$ from plaintext $m_i$

```{mermaid}
graph LR
    A[Key k] --> B[State σi]
    B --> C[Function f]
    C --> D[State σi+1]
    B --> E[Function g]
    E --> F[Keystream zi]
    F --> G[Function h]
    H[Plaintext mi] --> G
    G --> I[Ciphertext ci]
    D -.->|loop| B
```

#### Characteristics

**Synchronization requirement:**

- Transmitter and receiver must share the same key $k$ **AND** the same state $\sigma_i$
- Loss of synchronization = need for external mechanisms (markers, redundancy analysis)

**Properties:**

- **No error propagation**: modification of ciphertext does not affect subsequent sequences
- **Attention**: deletion of a ciphertext = receiver desynchronization

**Vulnerabilities to active attacks:**

- ✓ Detection: insertion, elimination, replay of fragments
- ✗ Bit modification: adversary can modify bits and analyze impact on plaintext
- **Solution**: additional authentication mechanisms necessary

#### Special case: Additive Stream Cipher

The most frequent case where:

- Functions $f$ and $g$ replaced by a random generator
- Function $h$ = modulo 2 addition (XOR: $\oplus$)

**Formula**: $c_i = z_i \oplus m_i$

::: {.callout-note collapse=true}
## 📄 Original text

### Synchronous Stream Ciphers

- The **generated keystream depends only on the key** and not on the plaintext nor the ciphertext.
- The encryption process of a **synchronous stream cipher** is described by the following equations:
  $$\sigma_{i+1} = f(\sigma_i, k)$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  with $\sigma_i$ the **initial state** which may depend on the key $k$, $f$ the **function determining the next state**, $g$ the **function producing the keystream** $z_i$ and $h$ the **output function** producing the ciphertext $c_i$ from the plaintext $m_i$.

### Synchronous Stream Ciphers: Characteristics

- **Require synchronization** of the transmitter and receiver: In addition to using the same key $k$, both must be in the **same state** for the process to work. If synchronization is lost, **external mechanisms** are needed to recover it (special markers, plaintext redundancy analysis, etc.)
- **No error propagation**. Modification of the ciphertext during transmission does not cause disturbances in subsequent ciphertext sequences (however, the **deletion** of a ciphertext would cause **desynchronization** of the receiver).
- **Active attacks**: Insertion, elimination or replay of parts of ciphertext are **detected** by the receiver. However, an adversary could **modify certain bits** of the ciphertext and analyze the impact on the corresponding plaintext. Additional **origin authentication mechanisms** are necessary to detect these attacks.
- **Most frequent case** of Synchronous Stream Ciphers: the **additive stream cipher** (cf. the one-time pad) where the functions $f$ and $g$ generating the keystream are replaced by a **random generator** and the function $h$ is a **modulo 2 addition (xor)**.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Synchronous**: keystream = $f$(key only). Equations: $\sigma_{i+1} = f(\sigma_i, k)$, $z_i = g(\sigma_i, k)$, $c_i = h(z_i, m_i)$.

**Requires synchronization** transmitter/receiver. No error propagation but vulnerable to bit modifications.

**Frequent case**: additive cipher with XOR.
:::

---

### Asynchronous Stream Ciphers

#### Operating Principle

Also called **self-synchronizing ciphers**.

The keystream depends on the key **AND** a fixed number of previous ciphertexts.

**Process equations:**

$$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Where $\sigma_i$ represents a buffer of the last $t$ ciphertexts.

```{mermaid}
graph LR
    A[Key k] --> B[Function g]
    C[Buffer: ci-t...ci-1] --> B
    B --> D[Keystream zi]
    D --> E[Function h]
    F[Plaintext mi] --> E
    E --> G[Ciphertext ci]
    G -.->|feedback| C
```

#### Characteristics

**Self-synchronization:**

- In case of insertion/elimination of ciphertexts, the receiver **automatically re-synchronizes**
- Mechanism: memorization (buffer) of the last ciphertexts

**Limited error propagation:**

- Error propagates only over the **buffer size** ($t$ bits)
- After buffer exhaustion, correct decryption resumes

**Security against active attacks:**

- **Better detection**: modifications detected thanks to error propagation
- **Attention**: self-synchronization allows receiver to continue even after insertions/deletions
- **Solution**: verification of integrity and authenticity of entire stream necessary

**Diffusion of plaintext statistics:**

- Each plaintext bit influences **all subsequent ciphertexts**
- **Result**: better dispersion of statistics vs. synchronous case
- **Application**: use for low entropy or highly redundant plaintexts

::: {.callout-note collapse=true}
## 📄 Original text

### Asynchronous Stream Ciphers

- Also called **self-synchronizing ciphers**.
- The **generated keystream depends on the key as well as a fixed number of previous ciphertexts**.
- The encryption process of an **asynchronous stream cipher** is described by the following equations:
  $$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  with $\sigma_i$, $g$ and $h$ as for the synchronous case.

### Asynchronous Stream Ciphers: Characteristics

- **Self-synchronization**: In case of elimination or insertion of ciphertexts along the way, the receiver is capable of **re-synchronizing with the transmitter** thanks to the **memorization (buffer)** of a number of previous ciphertexts.
- **Limited error propagation**: Error propagation extends only to the **number of ciphertext bits memorized** (buffer size). Afterwards, decryption proceeds correctly again.
- **Active attacks**: Modification of ciphertext fragments will be **more easily detected** than in the synchronous case because of error propagation. However, since the receiver is capable of self-synchronizing with the transmitter, even if ciphertexts are eliminated or inserted along the way, it is necessary to **verify the integrity and authenticity of the entire stream**.
- **Diffusion of plaintext statistics**: The fact that **each plaintext bit will influence all subsequent ciphertexts** results in a **greater dispersion of statistics** compared to the synchronous case...
- ... It is therefore advisable to use **asynchronous stream ciphers when the entropy of plaintexts is limited** and could allow targeted attacks on highly redundant plaintexts.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Asynchronous** (self-synchronizing): keystream = $f$(key + last ciphertexts). State $\sigma_i$ = buffer of $t$ previous ciphertexts.

**Automatic self-synchronization**. Limited error propagation to buffer.

**Better diffusion** of statistics → ideal for redundant/low entropy plaintexts.
:::

---

### Keystream Generators: LSFR

#### Context and Necessity

**Problem**: generate a keystream of length $m$ from a secret key of length $l$ with $l \ll m$.

**Solution**: Linear Feedback Shift Register (**LSFR** or **LFSR**)

#### LSFR Characteristics

**Advantages:**

- **Optimal hardware implementation**: very efficient circuits
- **Long periods**: sequences of great length
- **Good random quality**: notable randomness
- **Mathematical basis**: algebraic properties of linear combinations

**Generic structure**: LSFR of length $L$

```{mermaid}
graph LR
    A[bit L-1] --> B[bit L-2]
    B --> C[...]
    C --> D[bit 1]
    D --> E[bit 0]
    E --> F[Output]
    A -.->|feedback| G[⊕]
    D -.->|coeff| G
    C -.->|coeff| G
    G --> A
```

#### Important Remarks on LSFR

**History and Usage:**

- Very widespread construction in cryptography and coding theory
- Many military stream ciphers based on LSFR

**Security Limits:**

- **Insufficient security level** compared to modern block ciphers
- **Vulnerability**: the Berlekamp-Massey algorithm allows to:
  - Determine the **linear complexity** of an LSFR
  - Calculate an arbitrary number of generated sequences

**Metric**: Linear complexity (*linear complexity*)

**Improvement Solution:**

Replace the linear combination with a **non-linear function** $f$

→ **Non Linear Feedback Shift Registers** (NLFSR)

::: {.callout-note collapse=true}
## 📄 Original text

### Stream Ciphers: Keystream Generators

- When it is necessary to **generate a keystream of length $m$** from a **secret key of length $l$** with $l \ll m$, we call upon **keystream generators**.
- The most common of these generators is the **Linear Feedback Shift Register (LSFR)**.
- An LSFR has the following characteristics:
    - **Adapts very well to hardware implementations**.
    - Produces sequences of **long periods** and with **notable random quality** (quite strong randomness)
    - Based on the **algebraic properties of linear combinations**.

### LSFRs: Some Remarks

- LSFRs are **very widespread constructions** in cryptography and coding theory.
- A **large number of stream ciphers** based on LSFRs (especially in the **military sphere**) were developed in the past.
- Unfortunately, the **security level offered by these systems is deemed insufficient** nowadays (compared to that of block ciphers...)
- The **metric** allowing analysis of an LFSR is its **linear complexity**. The **Berlekamp-Massey algorithm** allows determining the linear complexity of an LSFR and thus calculating an arbitrarily large number of sequences generated by an LSFR.
- A solution to **increase complexity** is to substitute the linear combination of ciphertext bits with a **non-linear function** $f$. These are the **Non Linear Feedback Shift Registers**.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**LSFR**: long keystream generator ($m$) from short key ($l$). Base = linear combinations.

**Advantages**: efficient hardware, long periods.

**Problem**: insufficient security, vulnerable to Berlekamp-Massey (linear complexity calculation).

**Solution**: NLFSR (non-linear function).
:::

---

### RC4: Software Stream Cipher

#### General Presentation

**RC4™** (*Rivest Cipher 4*) developed in 1987 by Ron Rivest for RSA Security.

**Main characteristics:**

- **Variable key**: flexible length
- **Extremely fast**: 10× faster than DES
- **Synchronous mode**: keystream independent of plaintext/ciphertext

**History:**

- 1987-1994: patented, details confidential (NDA contract required)
- 1994: unofficial publication in a newsgroup
- Since then: intensive analysis by cryptographic community

#### Architecture

**Key components:**

- **S-box**: 8×8 substitution box (256 entries)
  - Content: permutation of numbers 0 to 255
  - Depends on the main key of variable length: $0 < len(k) \leq 255$
- **Combinations**: linear and non-linear
- **Final encryption**: XOR between keystream and plaintext

#### Applications and Security

**Commercial uses (numerous):**

- Lotus Notes
- Oracle SQL
- Microsoft Windows
- SSL/TLS
- And many more...

**Analyses and Vulnerabilities:**

- Exhaustive work on key scheduling and PRGA
- **Major flaw**: implementation in WEP (WiFi Wired Equivalent Privacy)
  - WEP protocol completely compromised
  - Problem: faulty usage mode, not the RC4 algorithm itself

#### Operation

RC4 decomposes into **two steps**:

1. **Key Scheduling Algorithm (KSA)**
   - Responsible for initial permutation of the S-box
   - Function of the variable length key $len(k) = l$

2. **Pseudo Random Generator Algorithm (PRGA)**
   - Generates keystream of arbitrary size
   - Relies on S-box permuted by KSA

```{mermaid}
graph TB
    A[Variable length key k] --> B[KSA: Key Scheduling]
    B --> C[Permuted S-box]
    C --> D[PRGA: Generation]
    D --> E[Keystream zi]
    E --> F[XOR]
    G[Plaintext mi] --> F
    F --> H[Ciphertext ci]
```

::: {.callout-note collapse=true}
## 📄 Original text

### Software Cipher Streams: RC4

- The major **disadvantage of stream ciphers based on registers** is that they are **very slow in programmed version** on a generic machine. **RC4™** is a **variable key stream cipher** developed in **1987 by Ron Rivest** for RSA security. It is **very fast** (**10 times faster than DES** !)
- For 7 years, this algorithm was **patented** and its internal operational details were disclosed only after **signing a confidentiality contract**. Since its **(unofficial) publication in a newsgroup in 1994**, it has been widely discussed and analyzed by the entire cryptographic community.
- The algorithm works in **synchronous mode** (the keystream is independent of the ciphertext and plaintext).
- It is composed of **linear and non-linear combinations**. The key element is an **8×8 substitution box (S-box)** whose entries are a **permutation of the numbers 0 to 255**. The permutation is a **function of the main key** of variable size with $0 < len(k) \leq 255$. The **final encryption is obtained by a xor** between the keystream and the plaintext.
- RC4 is used in a **large number of commercial applications**: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. It is the subject of a **large number of analytical and exhaustive works** that have managed to **compromise the security** of the key scheduling and the PRGA.
- In particular the application of RC4 to the **Wired Equivalent Privacy (WiFi WEP) protocol has been "broken"** due to a **flaw in the protocol's usage mode**.

### RC4: Operation

- The algorithm consists of **two steps**:
    - The **Key Scheduling Algorithm (KSA)**: Responsible for the **initial permutation** that will fill the S-box depending on the variable length key $len(k) = l$.
    - The **Pseudo Random Generator Algorithm (PRGA)**: Generates the **keystream of arbitrary size** relying on the S-box.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**RC4**: software stream cipher, variable key, 10× faster than DES.

**Architecture**: 8×8 S-box (permutation 0-255) + XOR.

**2 steps**: KSA (S-box permutation) + PRGA (keystream generation). Synchronous mode.

**Vulnerability**: WEP broken (usage flaw). Used in SSL, Windows, Oracle...
:::

## Block Ciphers (Block Encryption)

### 1. Introduction to Block Ciphers

#### Definition and Principle

A **block cipher** is a cryptographic function that:

- **Transforms fixed-size blocks**: maps a block of $n$ bits to another block of the same size
- **Is parameterized by a key**: the key $K$ of $k$ bits defines the transformation
- **Must be bijective**: to allow unique decryption
- **Each key = different bijection**: guarantees variability

**Nominal size**: input block size on which encryption is applied

#### Quality Criteria

**1. Key size/Entropy**

- Keys ideally **equiprobable** with entropy = $k$ bits
- Strong entropy protects against **brute-force attacks**
- **Minimum required**: 128 bits for modern block ciphers

**2. Performance**

- Execution speed
- Software/hardware efficiency

**3. Block size**

- Too small block = vulnerability to **plaintext/ciphertext dictionaries**
- **Modern standard**: blocks ≥ 128 bits

**4. Cryptographic resistance**

- Resistance to known techniques:
  - Linear cryptanalysis
  - Differential cryptanalysis
  - Meet in the middle
- **Cryptanalysis effort** equivalent to brute force

```{mermaid}
graph LR
    A[Plaintext n bits] --> B[Block Cipher]
    C[Key K k bits] --> B
    B --> D[Ciphertext n bits]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
```

::: {.callout-note collapse=true}
### 📄 Original text

#### Block Ciphers

- **Symmetric block ciphers** constitute the **cornerstone of cryptography**. Their main functionality is **confidentiality** but they are also the basis for **authentication**, **hashing functions**, **random generation**, etc.

- **Definition**: A block cipher is a **function** that maps a **block of $n$ bits** to another block of **the same size**. The function is **parameterized by a key $K$ of $k$ bits**. To allow **unique decryption**, the function must be **bijective**. **Each key defines a different bijection**. The **input block size** on which encryption is applied is also called **nominal algorithm size**.

- **Criteria to evaluate the quality** of a block cipher:
  - **Key size/Entropy**: Ideally, keys are **equiprobable** and the key space has an **entropy equal to $k$**. A **strong key entropy** protects against **brute-force attacks** from chosen/known plaintexts. Modern block ciphers must have **keys of at least 128 bits**.
  - **Performance**
  - **Block size**: A **too small block** would allow attacks where **plaintext/ciphertext "dictionaries"** could be built. Nowadays, **blocks of size ≥ 128 bits** are becoming common.
  - **Cryptographic resistance**: The block cipher must show **resistance** to known cryptanalysis techniques: **linear or differential cryptanalysis**, **meet in the middle**, etc. The **inherent effort** of these attacks (complexity, storage, parallelization, etc.) must be **equivalent to that of a brute force attack**.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision

**Block cipher**: bijective function transforming blocks of $n$ bits with key $K$ of $k$ bits. **Criteria**: key entropy ≥ 128 bits, block size ≥ 128 bits, cryptanalysis resistance = brute force effort. **Usage**: confidentiality, authentication, hashing, random generation.
:::

---

### 2. Block Cipher Modes of Operation

#### 2.1 Electronic Codebook (ECB)

**Principle**: each plaintext block is encrypted **independently** with the same key.

$$c_i = E_K(m_i)$$
$$m_i = D_K(c_i)$$

```{mermaid}
graph TB
    subgraph Encryption
        P1[Plaintext Block 1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext Block 1]
        
        P2[Plaintext Block 2] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext Block 2]
    end
    
    style E1 fill:#ffcccc
    style E2 fill:#ffcccc
    style K1 fill:#fff4e1
    style K2 fill:#fff4e1
```

**Characteristics:**

- ✗ **Identical plaintexts** → identical ciphertexts (predictable)
- ✓ **No error propagation**: error on $c_j$ affects only $m_j$
- ✗ **Visible patterns**: plaintext structure transparent in ciphertext
- ✓ **Parallelizable**: each block processed independently

**⚠️ Major vulnerability**: Should NOT be used for redundant data

---

#### 2.2 Cipher Block Chaining (CBC)

**Principle**: each plaintext block is **XORed with the previous ciphertext** before encryption.

$$c_i = E_K(m_i \oplus c_{i-1})$$
$$m_i = D_K(c_i) \oplus c_{i-1}$$

With $c_0 = IV$ (Initialization Vector)

```{mermaid}
graph TB
    subgraph Encryption
        IV[IV] --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext c1]
        
        C1 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ccffcc
    style E2 fill:#ccffcc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **Patterns erased**: chaining masks the structure
- ✓ **Limited error propagation**: error on $c_j$ affects $m_j$ and $m_{j+1}$ only
- ✗ **Not parallelizable** in encryption (sequential)
- ✓ **Parallelizable** in decryption

**IV (Initialization Vector):**

- Must be **random** or **pseudo-random**
- Can be transmitted **in clear**
- Must be **different** for each message with the same key

---

#### 2.3 Cipher Feedback Mode (CFB)

**Principle**: works like a **stream cipher** where the keystream is generated by the block cipher. The keystream depends on **previous ciphertexts** (**asynchronous** mode).

$$c_i = m_i \oplus E_K(c_{i-1})$$
$$m_i = c_i \oplus E_K(c_{i-1})$$

With $c_0 = IV$

```{mermaid}
graph TB
    subgraph CFB_Encryption
        IV[IV / ci-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        C1 -.feedback.-> IV
    end
    
    style E1 fill:#ffccff
    style X1 fill:#ffffcc
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **Chaining**: dependencies between ciphertexts
- ⚠️ **Error propagation**: error on $c_j$ affects $\frac{n}{r}$ following blocks
  - $n$ = nominal size of block cipher
  - $r$ = size of plaintexts
- ✗ **Not parallelizable**
- ⚠️ **IV non-confidential** but must be transmitted

**Usage**: suitable for transmissions with frequent packet loss

---

#### 2.4 Output Feedback Mode (OFB)

**Principle**: works like a **synchronous stream cipher**. The keystream is **entirely determined** by the key and IV, **independent** of plaintext and ciphertext.

$$z_i = E_K(z_{i-1})$$
$$c_i = m_i \oplus z_i$$
$$m_i = c_i \oplus z_i$$

With $z_0 = IV$

```{mermaid}
graph TB
    subgraph OFB_Mode
        IV[IV / zi-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> Z[zi keystream]
        Z --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        Z -.feedback.-> IV
    end
    
    style E1 fill:#cce5ff
    style X1 fill:#ffffcc
    style Z fill:#e1ffe1
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **No error propagation**: error on $c_j$ affects only $m_j$
- ✓ **Pre-computable keystream**: efficient
- ⚠️ **CRITICAL**: NEVER reuse the same IV with the same key (otherwise identical keystream)
- ✓ **Parallelizable** if keystream pre-computed

**⚠️ Reuse warning**: Change IV for each new message!

::: {.callout-note collapse=true}
### 📄 Original text (CFB and OFB Modes)

#### CFB and OFB Modes: Characteristics

The **CFB and OFB modes** work as a **stream cipher** with a **keystream generated by the encryption block**. In **CFB**, the keystream depends on **previous ciphertexts** (**asynchronous**) whereas in **OFB**, the keystream is **entirely determined by the key and the IV** (**synchronous**).

**Particularities of CFB:**

- As in CBC mode, **identical plaintexts** are translated into **different ciphertexts** if the **IV changes**. The **IV is not necessarily confidential** and can be exchanged in clear between parties.
- **Chaining** also introduces **dependencies** between current ciphertexts and previous ciphertexts. In particular, if $n$ is the **nominal algorithm size** and $r$ is the **plaintext size**, the current ciphertext will depend on the $\frac{n}{r}$ **previous ciphertexts** (each iteration will shift the faulty input by $r$ positions, after $\frac{n}{r}$ iterations the faulty ciphertext will be completely "expelled").
- **Error propagation** follows the same principle: an error in a ciphertext will result in incorrect decryption of the $\frac{n}{r}$ following ciphertexts.

**Particularities of OFB:**

- OFB has **identical behavior** to CBC and CFB modes for **encryption of identical plaintexts**.
- **No error propagation** on adjacent ciphertexts.
- **Modify the IV** if the key does not change to **avoid keystream reuse** !!!
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (CFB/OFB)

**CFB** (asynchronous): keystream = $f$(previous ciphertexts). Limited error propagation ($\frac{n}{r}$ blocks).

**OFB** (synchronous): keystream = $f$(key + IV only). No error propagation.

**CRITICAL**: NEVER reuse same IV with same key. IV transmissible in clear.
:::

---

#### 2.5 Counter Mode (CTR)

**Principle**: the keystream is generated by **encryption of a counter** incremented at each block.

$$c_i = m_i \oplus E_K(counter + i)$$
$$m_i = c_i \oplus E_K(counter + i)$$

```{mermaid}
graph TB
    subgraph CTR_Mode
        CTR1[Counter + 0] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> C1[Ciphertext c1]
        
        CTR2[Counter + 1] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ffe6cc
    style E2 fill:#ffe6cc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Characteristics:**

- ✓ **Synchronous mode**: keystream = $f$(counter)
- ✓ **Parallelizable**: keystream pre-computable for encryption AND decryption
- ✓ **Random access**: each block decryptable independently
- ✓ **No error propagation**
- ✓ **Benefits from SIMD architectures**: no dependencies between blocks
- ⚠️ **Counter**: must be of size $2^b$ ($b$ = block size)
- ⚠️ **CRITICAL**: NEVER reuse the same counter with the same key

**Counter management:**

- **Increment modulo** $2^b$ after each iteration
- **Solution**: always increment for each encrypted stream
- First block of stream $i+1$ > last block of stream $i$

**Applications:**

- **ATM** (Asynchronous Transfer Mode)
- **IPsec** (IP security)
- **High-speed lines**: selective transmission of blocks
- **Large volume transfers**: video

::: {.callout-note collapse=true}
### 📄 Original text (Counter Mode)

#### Counter Mode (CTR Mode)

Frequently used as encryption support in data transfer protocols like **ATM** (Asynchronous Transfer Mode) and **IPsec** (IP security).

#### Counter Mode (II)

- The **keystream** is generated by the **encryption of a random counter** of size $2^b$ (with $b$ the block size) and necessary for decryption. This counter is **incremented modulo** $2^b$ after each iteration.
- Works in **synchronous mode**. **Reuse of the same counter** results in an **identical keystream** !
- **Solution**: Always **increment the counter** for each encrypted stream such that the counter of the first block of a stream is **larger than the last block** of the previous stream.
- **Easily parallelizable**: The keystream can be **pre-calculated** both for encryption and decryption. Fully benefits from **SIMD architectures** because unlike other chaining modes there are no **dependencies between operations** of different blocks.
- **Random access** to encryption/decryption of each block: Unlike other chaining modes where the $i$-th operation depends on the $(i-1)$-th operation.
- If we add **absence of error propagation**, the counter mode facilitates **selective (re)transmission** of ciphertext blocks, making it very attractive for **securing high-speed lines** as well as for **encrypted transfers of large volumes** of information (e.g. video).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (Counter Mode)

**CTR**: keystream = $E_K$(counter + $i$).

**Advantages**: parallelizable (encryption + decryption), random access, no error propagation, SIMD-friendly.

**CRITICAL**: never reuse counter.

**Usage**: ATM, IPsec, high speed, video.
:::

---

### 3. Product Ciphers and Feistel Ciphers

#### Product Ciphers

**Definition**: encryption scheme combining a **series of successive transformations** to strengthen resistance to cryptanalysis.

**Common transformations:**

- Transpositions (permutations)
- Substitutions (S-boxes)
- XORs
- Linear combinations
- Modular multiplications

#### Feistel Ciphers

**Definition**: iterative product cipher with specific structure.

**Operating principle:**

- **Input**: plaintext of $2t$ bits = $(L_0, R_0)$ (two sub-blocks of $t$ bits)
- **Output**: ciphertext of $2t$ bits = $(R_r, L_r)$ after $r$ steps (rounds)
- **Each step**: invertible bijection (for unique decryption)

**Equations of step** $i$ ($1 \leq i \leq r$):

$$(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$$

With:

- $L_i = R_{i-1}$
- $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$

```{mermaid}
graph TB
    subgraph Feistel_Round
        L0[Li-1] --> R1[Ri = Li-1 ⊕ f]
        R0[Ri-1] --> L1[Li = Ri-1]
        R0 --> F[Function f]
        K[Key Ki] --> F
        F --> XOR[⊕]
        L0 --> XOR
        XOR --> R1
    end
    
    style F fill:#ffcccc
    style XOR fill:#ffffcc
    style K fill:#fff4e1
```

**Characteristics:**

- $K_i$: subkeys generated from the main key $K$
- Number of steps $r$: generally **even** and $\geq 3$
  - Example: DES has 16 steps
- **Final permutation**: $(L_r, R_r) \rightarrow (R_r, L_r)$
- **Decryption**: identical to encryption but subkeys applied in **reverse order** (from $K_r$ to $K_1$)

**Frequent operations:**

- Permutations
- Substitutions (S-boxes)

::: {.callout-note collapse=true}
### 📄 Original text

#### Product Ciphers and Feistel Ciphers

- A **product cipher** is an **encryption scheme** combining a **series of successive transformations** to **strengthen resistance to cryptanalysis**. Common transformations for a product cipher are: **transpositions**, **substitutions**, **XORs**, **linear combinations**, **modular multiplications**, etc.

- A **Feistel cipher** is an **iterative product cipher** capable of transforming a **plaintext of $2t$ bits** of the form $(L_0, R_0)$ composed of two **sub-blocks** $L_0$ and $R_0$ of $t$ bits into a **ciphertext of size $2t$** of the form $(R_r, L_r)$ after $r$ **successive steps (rounds)** with $r \geq 1$. **Each step** defines a **bijection (inversible !)** to allow unique decryption.

- **Permutations** and **substitutions** are the most frequent operations.

- The steps $1 \leq i \leq r$ are written: $(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$ with $L_i = R_{i-1}$ and $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$. The $K_i$ are **sub-keys**, **different for each step**, generated from the **main key $K$** of the encryption scheme.

- The **number of steps** proper to a Feistel cipher is normally **even** and $\geq 3$ (e.g. **DES has 16 steps**)

- After execution of all steps, a Feistel cipher performs a **permutation** of the two parts $(L_r, R_r)$ into $(R_r, L_r)$.

- The **decryption** of a Feistel Cipher is **identical to encryption** except that the sub-keys $K_i$ are applied in **reverse order** (From $K_r$ to $K_1$).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision

**Product cipher**: combination of successive transformations (transpositions, substitutions, XOR).

**Feistel cipher**:

  - iterative product cipher
  - plaintext $2t$ bits = $(L_0, R_0)$
  - $r$ rounds with $L_i = R_{i-1}$ and $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$.
  - Decryption = encryption with reversed sub-keys.
  - Example: DES (16 rounds).
:::

---

### 4. Data Encryption Standard (DES)

#### General Presentation

**DES** (Data Encryption Standard): most important cryptographic algorithm until the advent of AES in 2001.

**Main characteristics:**

- **Type**: Feistel Cipher
- **Block size**: 64 bits (nominal size)
- **Key size**: 56 effective bits (64 total bits with 8 parity bits)
- **Number of steps**: 16 rounds
- **Subkeys**: 16 subkeys of 48 bits (one per step)
- **Usage modes**: ECB, CBC, CFB, OFB

```{mermaid}
graph TB
    subgraph DES_Overview
        P[Plaintext 64 bits] --> DES[DES Encryption]
        K[Key 56 bits] --> DES
        DES --> C[Ciphertext 64 bits]
        
        C --> DES_INV[DES Decryption]
        K2[Key 56 bits] --> DES_INV
        DES_INV --> P2[Plaintext 64 bits]
    end
    
    style DES fill:#ffcccc
    style DES_INV fill:#ccffcc
    style K fill:#fff4e1
    style K2 fill:#fff4e1
```

#### DES Structure

**Main components:**

1. **Initial permutation (IP)**: permutation of the 64 input bits
2. **16 Feistel rounds**: iterative transformation
3. **Final permutation (IP⁻¹)**: inverse of IP

**Each round applies:**

- Division into two halves: $L_{i-1}$ and $R_{i-1}$ (32 bits each)
- Function $f$ on $R_{i-1}$ with subkey $K_i$
- XOR with $L_{i-1}$
- Exchange of halves

```{mermaid}
graph TB
    Plain[Plaintext 64 bits] --> IP[Initial Permutation IP]
    IP --> Split[Split L0, R0]
    
    Split --> Round1[Round 1]
    K1[K1] --> Round1
    Round1 --> Round2[Round 2]
    K2[K2] --> Round2
    Round2 --> Dots[...]
    Dots --> Round16[Round 16]
    K16[K16] --> Round16
    
    Round16 --> Swap[Swap R16, L16]
    Swap --> IP_inv[Final Permutation IP⁻¹]
    IP_inv --> Cipher[Ciphertext 64 bits]
    
    style IP fill:#e1f5ff
    style IP_inv fill:#e1f5ff
    style Round1 fill:#ffcccc
    style Round2 fill:#ffcccc
    style Round16 fill:#ffcccc
```

#### DES Cipher Function

The **function $f$** for each round:

1. **Expansion E**: 32 bits → 48 bits (table E)
2. **Key Addition**: XOR with subkey $K_i$ (48 bits)
3. **S-boxes**: 8 S-boxes transform 48 bits → 32 bits
   - Each S-box: 6 bits input → 4 bits output
4. **Permutation P**: permutation of the resulting 32 bits

```{mermaid}
graph TB
    R[Ri-1 32 bits] --> E[Expansion E]
    E --> E_out[48 bits]
    E_out --> XOR1[⊕]
    K[Ki 48 bits] --> XOR1
    XOR1 --> S[8 S-boxes]
    S --> S_out[32 bits]
    S_out --> P[Permutation P]
    P --> F_out[f output 32 bits]
    
    style E fill:#cce5ff
    style S fill:#ffcccc
    style P fill:#e1ffe1
    style XOR1 fill:#ffffcc
```

**S-box operation:**

Input: $a_1a_2a_3a_4a_5a_6$ (6 bits)

- **Row**: $a_1 + 2a_6$ (external bits)
- **Column**: $a_2 + 2a_3 + 4a_4 + 8a_5$ (internal bits)
- **Output**: value of the corresponding cell (4 bits)

#### Subkey Generation

**Process:**

1. Main key: 64 bits (56 effective + 8 parity)
2. **Permuted Choice 1 (PC-1)**: selection of 56 bits
3. Division into two halves: $C_0$ and $D_0$ (28 bits each)
4. For each round $i$:
   - Left circular rotation of $C_{i-1}$ and $D_{i-1}$
   - **Permuted Choice 2 (PC-2)**: selection of 48 bits for $K_i$

**Rotations:**

- Rounds 1, 2, 9, 16: 1 position
- Other rounds: 2 positions

::: {.callout-note collapse=true}
### 📄 Original text (DES Operation)

#### DES: Operation

**Cipher Function**

- **Expansion E**: The **32 bits of the input** are transformed into a vector of **48 bits** using the **table E**. The first line of this table indicates how the first sub-block of 6 bits will be generated: first take the 32nd bit then bits 1,2,3,4,5. The second sub-block starts with the 4th bit then bits 5,6,7,8,9 and so on...

- **Key addition**: **XOR of the 48-bit vector** with the key.

- **S-boxes**: Apply **8 S-boxes** on the resulting 48-bit vector. Each of these S-boxes takes a **6-bit sub-block** and transforms it into a **4-bit sub-block**. The operation is performed as follows: If we denote the 6 input bits of the S-box as: $a_1a_2a_3a_4a_5a_6$. The output is given by the content of the cell located in the **row** $a_1 + 2a_6$ and the **column** $a_2 + 2a_3 + 4a_4 + 8a_5$.

- **Permutation P**: Permutation P works as follows: The first bit is sent to the 16th position, the second to the 7th position and so on.

**Permutations IP and IP⁻¹**

- Act respectively at the **beginning** and at the **end** of the block processing and on the **entirety of the 64 bits**.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (DES)

**DES**: Feistel cipher, 64-bit blocks, 56-bit effective key, 16 rounds.

**Function $f$**: Expansion E (32→48 bits) → XOR $K_i$ → 8 S-boxes (48→32 bits) → Permutation P.

**S-box**: 6 bits input → 4 bits output via table (row = external bits, column = internal bits).

**Permutations**: IP (initial) and IP⁻¹ (final) on 64 bits.
:::

---

### 5. Triple-DES and DES Security

#### DES Vulnerabilities

**Main problem**: key space size $\{0,1\}^{56}$ insufficient.

**Brute force attack:**

- **1999**: key found in **24 hours**
- Technique: massively parallel brute force (100,000 PCs on Internet)
- Known plaintext attack

#### Triple-DES (3DES)

**Solution**: increase key space to $\{0,1\}^{112}$.

**Scheme:**

$$C = E_{K_1}(D_{K_2}(E_{K_1}(P)))$$

With:

- $E$: DES encryption
- $D$: DES decryption
- $K_1, K_2$: two 56-bit keys

```{mermaid}
graph LR
    P[Plaintext 64 bits] --> E1[DES Encrypt K1]
    E1 --> D[DES Decrypt K2]
    D --> E2[DES Encrypt K1]
    E2 --> C[Ciphertext 64 bits]
    
    K1a[Key K1 56 bits] --> E1
    K2[Key K2 56 bits] --> D
    K1b[Key K1 56 bits] --> E2
    
    style E1 fill:#ffcccc
    style D fill:#ccffcc
    style E2 fill:#ffcccc
```

**Advantages:**

- ✓ **Satisfactory security**: key space $2^{112}$
- ✓ **Compatibility**: reuse of existing DES hardware/software
- ✓ **Gradual migration**: while waiting for AES

**Disadvantage:**

- ✗ **Performance**: 3× slower (3 successive DES executions)

#### DES Properties

**1. DES is not a group**

DES is NOT a group under composition:

$$\nexists K_3 \text{ such that } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)$$

**Consequence**: composite encryption (Triple-DES) considerably increases security.

**If DES were a group**: exhaustive search on $\{0,1\}^{56}$ would break the algorithm regardless of the number of consecutive executions.

**2. Weak and semi-weak keys**

- **Weak key**: $E_K(E_K(x)) = x$

- **Pair of semi-weak keys**: $E_{K_1}(E_{K_2}(x)) = x$

**Characteristic**: weak keys generate identical subkeys in pairs:

- $k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$
- Facilitates cryptanalysis

**DES has 4 weak keys:**

| Weak key (hexadecimal) |
|---------------------------|
| 0101 0101 0101 0101 |
| 0101 0101 FEFE FEFE |
| FEFE FEFE FEFE FEFE |
| FEFE FEFE 0101 0101 |

**And 6 pairs of semi-weak keys**

::: {.callout-note collapse=true}
### 📄 Original text (DES and 3DES)

#### DES and Triple-DES

- The **size of the key set** ($\{0,1\}^{56}$) constitutes the **greatest threat** weighing on DES with current computing resources. In **1999** it took only **24 hours** to find the key from a **known plaintext** using a **massively parallel brute force technique** (100,000 PCs connected to the Internet).

- **Triple DES** protects us from these **brute force attacks** by increasing the **possible key space** to $\{0,1\}^{112}$.

- This alternative allows continuing to use **DES "boxes"** (hardware and software) while waiting for migration to AES.

- The **security level** obtained by this solution is **very satisfactory**.

- The **performance impact** of three successive DES executions remains a **disadvantage** for some applications.

#### DES: properties

- **DES is not a group** (in the algebraic sense) under composition: In other words, DES being a permutation: $\{0,1\}^{64} \rightarrow \{0,1\}^{64}$, if DES were a group under composition, this would mean that: $\exists K_3$ such that $E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)$

  This property ensures that **composite encryption** (like Triple-DES) **considerably increases the security** of DES. If DES were a group, exhaustive search on the possible key set ($\{0,1\}^{56}$) would allow "breaking" the algorithm **regardless of the number of consecutive executions** of DES.

- **Weak and semi-weak keys** (weak and semi-weak keys):
  - A key $K$ is said to be **weak** if $E_K(E_K(x)) = x$.
  - A pair of keys $(K_1, K_2)$ is said to be **semi-weak** if $E_{K_1}(E_{K_2}(x)) = x$.

- Weak keys have the particularity of generating **identical subkeys in pairs** ($k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$), which **facilitates cryptanalysis**.

- **DES has 4 weak keys** (and 6 pairs of semi-weak keys).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (3DES and security)

**DES vulnerability**: key space $2^{56}$ breakable in 24h (1999). **Triple-DES**: $E_{K_1}(D_{K_2}(E_{K_1}(P)))$, space $2^{112}$, reuses DES hardware, 3× slower. **DES ≠ group** → composite encryption strengthens security. **4 weak keys** generating identical subkeys in pairs → facilitates cryptanalysis.
:::

---

### 6. Advanced Encryption Standard (AES)

#### General Presentation

**AES** (Advanced Encryption Standard): standard adopted in November 2001.

**Design**: Johan Daemen and Vincent Rijmen (original name: **Rijndael**)

**Main characteristics:**

- **Type**: iterative block cipher (but **NOT a Feistel Cipher**)
- **Block size**: 128 bits
- **Variable key size**: 128, 192 or 256 bits
- **Number of rounds**: depends on key size
  - 10 rounds for 128-bit key
  - 12 rounds for 192-bit key
  - 14 rounds for 256-bit key
- **Usage modes**: ECB, CBC, CFB, OFB, CTR

**Advantages over DES:**

- ✓ **Open process**: consultation and analysis by worldwide experts
- ✓ **~2× more performant** in software
- ✓ **~10²² times more secure** (theoretically)
- ✓ **Scalable**: key size can be increased if necessary

#### AES Structure

**Basic unit**: **State** matrix of 4 rows × 4 columns (for 128-bit key)

- Each element = 1 byte
- **Total**: 16 bytes = 128 bits

**Operations on field** $GF(2^8)$:

- Byte = element of $GF(2^8)$
- Finite field of polynomials of degree ≤ 7 with coefficients in $GF(2)$
- Additions, multiplications defined in $GF(2^8)$

```{mermaid}
graph TB
    subgraph State_Matrix
        S00[s0,0] --- S01[s0,1]
        S01 --- S02[s0,2]
        S02 --- S03[s0,3]
        
        S10[s1,0] --- S11[s1,1]
        S11 --- S12[s1,2]
        S12 --- S13[s1,3]
        
        S20[s2,0] --- S21[s2,1]
        S21 --- S22[s2,2]
        S22 --- S23[s2,3]
        
        S30[s3,0] --- S31[s3,1]
        S31 --- S32[s3,2]
        S32 --- S33[s3,3]
    end
    
    style S00 fill:#ffe6cc
    style S11 fill:#ffe6cc
    style S22 fill:#ffe6cc
    style S33 fill:#ffe6cc
```

#### AES Round Detail

**Four operations per round:**

**1. SubBytes (ByteSub)**

- Non-linear substitution via **S-box**
- Each byte transformed independently
- Resistance to linear and differential cryptanalysis

**2. ShiftRows**

- **Permutation of bytes** with variable shifts per row
- Row 0: no shift
- Row 1: left shift 1 position
- Row 2: left shift 2 positions
- Row 3: left shift 3 positions

**3. MixColumns**

- Each column = linear combination of other columns
- **Matrix multiplication** in $GF(2^8)$
- Maximum diffusion

**4. AddRoundKey**

- **XOR** of the State matrix with the round subkey
- Subkey = result of Key Schedule

```{mermaid}
graph TB
    Input[State Input] --> SB[SubBytes]
    SB --> SR[ShiftRows]
    SR --> MC[MixColumns]
    MC --> ARK[AddRoundKey]
    K[Round Key] --> ARK
    ARK --> Output[State Output]
    
    style SB fill:#ffcccc
    style SR fill:#ccffcc
    style MC fill:#cce5ff
    style ARK fill:#ffffcc
```

**Final round**: identical EXCEPT **no MixColumns**

#### Key Schedule (Subkey Generation)

**Process:**

1. **Key Expansion**: generation of an extended matrix
   - Key 128 bits → matrix 4 × 4 × ($N_e$ + 1) bytes
   - $N_e$ = number of rounds
2. **Key Selection**: extraction of subkeys
   - First subkey: first 4 columns
   - Second subkey: next 4 columns
   - Etc.

**Operations:**

- Byte rotations
- Substitutions via S-box
- XOR with constants (Rcon)

#### AES Pseudo-code

```
Rijndael(State, CipherKey) {
    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule
    
    AddRoundKey(State, ExpandedKey[0..3]); // Initial XOR
    
    for(i = 1; i < Ne; i++) {
        Round(State, ExpandedKey[4*i...(4*i)+3]);
    }
    
    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Without MixColumns
}
```

#### AES Decryption

**Principle**: apply the **inverse operations** in each round.

**Inverse operations:**

- **InvSubBytes**: inverse substitution via S-box⁻¹
- **InvShiftRows**: right shifts (instead of left)
- **InvMixColumns**: inverse matrix multiplication
- **AddRoundKey**: self-inverse (XOR)

**Order**: inverse of encryption with subkeys in reverse order

::: {.callout-note collapse=true}
### 📄 Original text (AES)

#### Advanced Encryption Standard (AES)

- Adopted as **standard in November 2001**, designed by **Johan Daemen and Vincent Rijmen** (hence its original name **Rijndael**).

- It is also an **iterative block cipher** (like DES) but **not a Feistel Cipher**.

- **Plaintext/Ciphertext Blocks**: **128 bits**.

- **Variable key length**: **128, 192, or 256 bits**.

- Unlike DES, AES comes from an **open consultation and analysis process** involving worldwide experts.

- Techniques similar to DES (substitutions, permutations, XOR…) complemented by **simple and very performant algebraic operations**.

- All operations are performed in the **field** $GF(2^8)$: the finite field of **polynomials of degree ≤ 7** with **coefficients in** $GF(2)$.

- In particular, a **byte for AES is an element in** $GF(2^8)$ and the **operations on bytes** (additions, multiplications,...) are **defined as in** $GF(2^8)$.

- **~2 times more performant** (in software) and **~10²² times (in theory...) more secure** than DES...

- **Scalable**: The key size can be increased if necessary.

##### Detail of an AES Step (round)

The **basic unit** on which calculations are applied is a **matrix of 4 rows and 4 columns** (in the case of a 128-bit key) whose elements are **bytes**:

- **ByteSub**: **Non-linear operation (S-box)** designed to **resist linear and differential cryptanalysis**.

- **ShiftRow**: **Permutation of bytes** introducing **variable shifts** on the rows.

- **MixColumn**: Each column is replaced by **linear combinations** of the other columns (**matrix multiplication** !)

- **AddRoundKey**: **XOR** of the current matrix with the **subkey** corresponding to the current step.

##### AES: Global Operation

- The **number of steps** of AES varies depending on the **key size**. For a **128-bit key**, **10 steps** must be performed. Each increase of 32 bits in the key size entails an **additional step** (14 steps for 256-bit keys).

- **Decryption** consists of applying the **inverse operations** in each of the steps (**InvSubBytes**, **InvShiftRows**, **InvMixColumns**). **AddRoundKey** (because of XOR) is **its own inverse**.

- The **Key Schedule** consists of:
  - An operation of **key expansion** of the main key. If $N_e$ is the number of steps (depending on the key), a **matrix of 4 rows and 4 × ($N_e$ + 1) columns** is generated.
  - An operation of **step key selection**: The **first subkey** will be constituted by the **first 4 columns** of the matrix generated during expansion and so on.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (AES)

**AES** (Rijndael 2001): iterative block cipher (NOT Feistel), 128-bit blocks, keys 128/192/256 bits → 10/12/14 rounds.

**State**: 4×4 byte matrix in $GF(2^8)$.

**4 operations/round**:

  - SubBytes (non-linear S-box)
  - ShiftRows (row shifts)
  - MixColumns (linear combinations)
  - AddRoundKey (XOR subkey).

2× faster than DES, 10²² times more secure.
:::

---

### 7. Attacks and AES Security

#### AES Strengths

**Simplicity and performance:**

- ✓ Simple and efficient algorithm
- ✓ Works on limited platforms (8-bit smart cards)
- ✓ Hardware and software optimizations

#### Published Attacks

**1. Algebraic attacks (2002)**

**XSL technique** (N. Courtois and P. Pieprzyk):

- Represents AES as **system of 8000 quadratic equations** with 1600 binary unknowns
- **Estimated effort**: $2^{100}$ operations (still a conjecture)
- **Characteristic**: requires few known plaintexts
- **Distinction**: different from linear/differential attacks

**Critique**: based on the "highly algebraic" character of AES (largely contested)

**2. Related Key Attacks (2009-2011)**

**Principle**: attacks based on **similar keys**

- Interesting results on **reduced versions** of AES
- Do not compromise full AES

**3. Side Channel Attacks**

**Principle**: attacks on **implementation** (not the algorithm)

**Techniques:**

- **Cache timing attacks**: cache access analysis
- **Power analysis**: power consumption
- **Electromagnetic analysis**: electromagnetic emissions

**Example** (2005): Osvik, Shamir, Tromer

- Extraction of 128-bit key with **6-7 plaintext/ciphertext pairs**
- Based on **cache access** analysis

**4. Meet in the Middle on biclique structures (2011-2015)**

**Result:**

- Reduces effort for AES-128 to **$2^{126}$** (factor 4 vs brute force)
- **Remains well above** current capabilities

#### Practical Security

**Fundamental assumption**: key of **maximum entropy**

**Recent attacks** (WPA2, etc.):

- Exploit **weakness of passwords/passphrases**
- No flaw in AES itself
- Problem: key generation from weak passwords

**⚠️ Critical reminder**: key quality = system security

::: {.callout-note collapse=true}
### 📄 Original text (AES Attacks)

#### AES: Final Remarks and Attacks (I)

- The greatest **strength of AES** lies in its **simplicity** and its **performance**, including on **reduced computing capacity platforms** (e.g. **smart cards** with 8-bit processors).

- Since its official publication, **many cryptanalysis works** have been published with very interesting results. In particular, **N. Courtois and P.Pieprzyk** presented a technique called **XSL** allowing to represent AES as a **system of 8000 quadratic equations** with **1600 binary unknowns**. The **effort needed** to break this system is estimated (it is still a **conjecture**...) to be **$2^{100}$**.

- These attacks are based on the **highly algebraic character** (and largely contested...) of AES. Moreover, only **a few known plaintexts** are needed to set them up, which distinguishes them from linear and differential attacks.

- In recent years (2009-2011) **attacks based on similar keys** (related key attacks) have obtained interesting results on **reduced versions** of AES.

- Another family of attacks called **side channel attacks** acting directly on the **algorithm implementation** allows extracting cryptographically relevant information during encryption execution.

#### AES: Final remarks and Attacks (II)

- In **2015** a **Meet in the Middle** type attack based on **biclique structures** showed that it was possible to reduce the **effort needed** to find an AES-128 key to **$2^{126}$**, i.e., a **factor of 4** compared to brute force. This nevertheless remains **well above** current computing capabilities.

- Another family of attacks called **side channel attacks** acting directly on the **algorithm implementation** allows extracting cryptographically relevant information during encryption execution. In particular, the authors manage to **extract the 128-bit key** with only **6-7 plaintext/ciphertext pairs** based on **cache accesses**.

- The **security of AES** (as for any other encryption algorithm) is always based on the assumption of a **key of maximum entropy**. The **attacks published recently** on protocols based on AES (like WPA2) exploit the **weakness of passwords/passphrases** that are the origin of the keys used.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (AES Security)

**Strengths**: simplicity, performance (even 8-bit cards). **Attacks**: XSL ($2^{100}$, algebraic), related keys (reduced versions), side channel (implementation, cache), Meet-in-Middle biclique ($2^{126}$). **Security**: assumption of max entropy key. Practical attacks = weak passwords, not AES flaw.
:::

---

### 8. Block Cipher Cryptanalysis Techniques

#### 8.1 Differential Cryptanalysis

**Principle**: **chosen plaintext** attack analyzing the **propagation of differences** between two plaintexts through the rounds.

**Method:**

1. Choose two plaintexts with known difference: $x_a$ and $x_b$
2. Observe propagation: $\Delta x = x_a \oplus x_b$
3. Analyze ciphertexts: $\Delta y = y_a \oplus y_b$
4. **Assign probabilities to keys** according to observed changes
5. **Most probable key** = correct key (after many trials)

**Characteristics:**

- Requires **$2^{47}$ chosen plaintext pairs** for DES
- **Probabilities**: depend on S-boxes and structure
- The more pairs increase, the more success probability increases

**Sensitivity**: very sensitive to **number of rounds**

- Chances of success increase **exponentially** when rounds decrease

#### 8.2 Linear Cryptanalysis

**Principle**: **known plaintext** attack creating a **linear simulator** of the block cipher.

**Method:**

1. Create **linear approximations** of the algorithm
2. Analyze a large number of plaintext/ciphertext pairs
3. The bits of the simulator key **tend to coincide** with those of the real key (probabilistic calculation)

**Complexity for DES:**

- **$2^{38}$ known plaintexts** → 10% probability of guessing correctly
- **$2^{43}$ known plaintexts** → 85% success probability

**Characteristics:**

- **Most powerful analytical attack** to date on block ciphers
- Also **sensitive to number of rounds**

#### 8.3 Differential vs Linear Comparison

**Common difficulties:**

- ✗ **Parallelization**: less efficient than parallel brute force
- ⚠️ **Sensitivity to rounds**: efficiency decreases exponentially with number of rounds

**DES and these attacks:**

- Widespread conjecture: DES designers **knew these attacks** (1970s, unpublished at the time)
- **S-box design**: very high resistance to both techniques

#### 8.4 Meet-in-the-Middle Attack

**Principle**: exploits **composite constructions** of type $y = E_{K_2}(E_{K_1}(x))$.

**Method:**

1. Build list $L_1$: $L_1 = \{E_{K_1}(x) \mid K_1 \in \text{KeySpace}\}$
2. Build list $L_2$: $L_2 = \{D_{K_2}(y) \mid K_2 \in \text{KeySpace}\}$
3. Identify **repeated elements** in $L_1$ and $L_2$
4. Verify hypothesis with **second known plaintext**
5. The associated keys $K_1$ and $K_2$ are probably the sought keys

**Example for DES:**

Intuitive key space for $E_{K_2}(E_{K_1}(x))$: $\{0,1\}^{112}$

**Actual effort:**

- **$2^{57}$ operations** to establish the two lists
- **$2^{56}$ blocks** of 64 bits storage
- **Significantly lower** than the intuitive $2^{112}$

**Applications:**

- Attacks on **composite constructions**
- **Internal** cryptanalysis of block ciphers

```{mermaid}
graph TB
    subgraph Meet_in_Middle
        X[Known Plaintext x] --> E1[Encrypt K1]
        E1 --> M[Middle Value m]
        M --> E2[Encrypt K2]
        E2 --> Y[Known Ciphertext y]
        
        X2[x] --> L1[List L1: EK1 for all K1]
        Y2[y] --> L2[List L2: DK2 for all K2]
        
        L1 -.match.-> Match[Find common m]
        L2 -.match.-> Match
    end
    
    style M fill:#ffffcc
    style Match fill:#ccffcc
```

::: {.callout-note collapse=true}
### 📄 Original text (Cryptanalysis)

#### Block Cipher Cryptanalysis Techniques

**Differential Cryptanalysis**

- This is a **chosen plaintext attack** that focuses on the **propagation of differences** in two plaintexts as they evolve through the different steps of the algorithm.

- It **assigns probabilities to keys** it "guesses" based on the **changes** they induce on the ciphertexts. The **most probable key** has a good chance of being the correct key after a **large number** of plaintext/ciphertext pairs.

- Requires **$2^{47}$ chosen plaintext pairs** (for DES) to obtain correct results.

**Linear Cryptanalysis**

- This is a **known plaintext attack** that creates a **block simulator** from **linear approximations**. By analyzing a **large number** of plaintext/ciphertext pairs, the **bits of the simulator key** tend to **coincide** with those of the analyzed block cipher (**probabilistic calculation**)

- For DES an attack based on this technique requires **$2^{38}$ known plaintexts** to obtain a probability of **10%** of guessing correctly and **$2^{43}$ for 85%** !

- It is the **most powerful analytical attack** to date on block ciphers.

#### Block Cipher Cryptanalysis Techniques (II)

- The practical implementation of **differential and linear attacks** presents **difficulties in parallelizing** calculations compared to an exhaustive key search.

- These two attacks are **very sensitive to the number of steps** of the block cipher: chances of success increase **exponentially** as the number of algorithm steps decreases.

- A widespread conjecture among cryptographers is that these attacks, at the time **unpublished**, were **known to the designers of DES**. In particular, the **design of the S-boxes** offers a **very high resistance** to both techniques.

**Meet-in-the-Middle Attack**

- Applies to constructions of the type $y := E_{K_2}(E_{K_1}(x))$. For DES, the key space for this solution would be $\{0,1\}^{112}$. First build **two lists** $L_1$ and $L_2$ of $2^{56}$ messages of the form: $L_1 = E_{K_1}(x)$ and $L_2 = D_{K_2}(y)$ with $E$ and $D$ the encryption and decryption operations respectively. Then **identify elements that repeat** in both lists and **verify our hypothesis** with a second known plaintext. The $K_1$ and $K_2$ associated with this pair of known plaintexts will (in all likelihood) be **the sought keys** !

- **Effort required** to carry out the attacks (for DES): **$2^{57}$ operations** to establish the two lists + **$2^{56}$ blocks** of 64 bits of storage to memorize intermediate results... **significantly lower** than the intuitive $2^{112}$...

- These meet-in-the-middle techniques are also applied to the **internal cryptanalysis** of block ciphers.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (Cryptanalysis)

**Differential**: chosen plaintext, difference propagation, probabilities on keys, $2^{47}$ pairs (DES).

**Linear**: known plaintext, linear approximations, $2^{38}$-$2^{43}$ plaintexts (DES), most powerful attack.

**Meet-in-Middle**: composite constructions, 2 lists $2^{56}$, effort $2^{57}$ << $2^{112}$.

**Sensitivity**: very dependent on number of rounds.
:::