# Fundamental Security Services

Security services are the objectives aimed at protecting a system.

* **Confidentiality**: Protection against unauthorized disclosure.
* **Integrity**: Protection against unauthorized modification.
* **Availability**: Guarantee of access for legitimate users.
* **Authentication**:

  * *Entity authentication*: Certifying the identity of an actor.
  * *Data origin authentication*: Certifying the source of data.
* **Non-repudiation**: Inability to deny a transaction.
* **Non-duplication**: Protection against illicit copying.
* **Anonymity**: Preservation of identity or source.

::: {.callout collapse="true"}

#### Original version

* **Confidentiality**: Protection of information from unauthorized disclosure.
* **Integrity**: Protection against unauthorized modification of information.
* **Availability**: Ensuring that resources are accessible to legitimate users.
* **Authentication**:

  * **Entity authentication** *(entity authentication)*: Process allowing one entity to be certain of the identity of a second entity, supported by corroborating evidence (e.g., physical presence, cryptographic, biometric, etc.). The term identification is sometimes also used for this service.
  * **Data origin authentication** *(data origin authentication)*: Process allowing one entity to be certain that a second entity is the original source of a set of data. By definition, this service also ensures the integrity of the data.
* **Non-repudiation**: Guarantees that an entity cannot deny being involved in a transaction.
* **Non-duplication**: Protection against illicit copying.
* **Anonymity (entity or data origin)**: Preserves the identity of an entity, the source of information, or a transaction.

:::

---

# Summary: Services, Threats, and Protection Mechanisms

| Security Services         | Threats and Attacks (*Italic*)                             | Classic Mechanisms                          | Digital Mechanisms                                            |
| :------------------------ | :--------------------------------------------------------- | :------------------------------------------ | :------------------------------------------------------------ |
| **Confidentiality**       | Information leakage, *eavesdropping*, traffic analysis     | Seals, safes, padlocks                      | Encryption, logical authorization                             |
| **Integrity**             | Modification, *tampering*, illicit creation or destruction | Special ink, holograms                      | One-way functions + encryption                                |
| **Availability**          | *Denial of Service (DoS)*, viruses, illicit use            | Physical access control, video surveillance | Logical access control, audit, antivirus                      |
| **Entity Authentication** | Unauthorized access, password theft, protocol flaw         | Presence, voice, ID card, biometrics        | Secret + protocol, network address + userid, smart card + PIN |
| **Data Authentication**   | Falsification of information or signature                  | Seals, signature, fingerprint               | One-way functions + encryption                                |
| **Non-repudiation**       | Denying a transaction (*repudiation*), claiming key theft  | Seals, notary signature, registered mail    | One-way functions + encryption + digital signature            |
| **Non-duplication**       | Duplication, falsification, imitation                      | Special ink, holograms, tagging             | Digital watermarking, cryptographic locking                   |
| **Anonymity**             | Identification, transaction analysis, tracing              | Voice scramblers, disguise, cash            | *Mixers*, *remailers*, e-money, *deep web*                    |

::: {.callout collapse="true"}

#### Original version

## Threats and Attacks: Summary

| Services                  | Threats                              | Attacks                                                           |
| :------------------------ | :----------------------------------- | :---------------------------------------------------------------- |
| **Confidentiality**       | Information leakage                  | Unauthorized eavesdropping, traffic analysis                      |
| **Integrity**             | Information modification             | Illicit creation, alteration, or destruction                      |
| **Availability**          | Denial of service, illicit use       | Viruses, repeated access attempts to disable a system             |
| **Entity Authentication** | Unauthorized access                  | Password theft, authentication protocol flaw                      |
| **Data Authentication**   | Information falsification            | Signature forgery, protocol flaw                                  |
| **Non-repudiation**       | Denying involvement in a transaction | Claiming key theft or signature protocol flaw                     |
| **Non-duplication**       | Duplication                          | Falsification, imitation                                          |
| **Anonymity**             | Identification                       | Transaction analysis, unauthorized access enabling identification |

## Protection Mechanisms

| Services                  | Classic Mechanisms                                  | Digital Mechanisms                                                           |
| :------------------------ | :-------------------------------------------------- | :--------------------------------------------------------------------------- |
| **Confidentiality**       | Seals, safes, padlocks                              | Encryption, logical authorization                                            |
| **Integrity**             | Special ink, holograms                              | One-way functions + encryption                                               |
| **Availability**          | Physical access control, video surveillance         | Logical access control, audit, antivirus                                     |
| **Entity Authentication** | Presence, voice, ID card, biometric recognition     | Secret + authentication protocol, network address + userid, smart card + PIN |
| **Data Authentication**   | Seals, signature, fingerprint                       | One-way functions + encryption                                               |
| **Non-repudiation**       | Seals, signature, notary signature, registered mail | One-way functions + encryption + digital signature                           |
| **Non-duplication**       | Special ink, holograms, tagging                     | Digital watermarking, cryptographic locking                                  |
| **Anonymity**             | Voice scrambler, disguise, cash                     | Mixers, remailers, e-money, deep web                                         |

:::
---

# Internet-Related Risks

## Malware Delivered via E-Mail

* Also called **malware**.
* Emails designed to **trigger an action** (open attachment or click a link).
* Often **personalized** using **social engineering**.
* **Main consequences:**

  * Malware installation (*ransomware*, *keyloggers*, etc.).
  * **Loss or theft of personal data**.
  * **System hijacking** and **malware propagation**.

::: {.callout collapse="true"}

#### Ultra-summary

* Malware spread by email
* Prompting clicks or opens
* Social engineering
* Data theft, loss, hijacking
:::

::: {.callout collapse="true"}

#### Original version

## Malware Delivered via E-Mail

* Also called **malware**.
* Emails designed to **incite the recipient** to **open an attachment** or **follow a link** containing ads, offensive info, risky programs, etc.
* Often targeted based on victim interests (preliminary social engineering).
* **Consequences:**

  * Malware installation (*ransomware*, *keyloggers*, etc.) on victim systems (*computer*, *tablet*, *smartphone*, *smartwatch*, etc.).
  * Data destruction.
  * Theft of personal information or data.
  * System hijacking for malicious purposes (e.g., illegal bitcoin mining).
  * Malware propagation (potentially to other users).
:::

## Malware Delivered via Web

* Method called ***drive-by download***: **automatic infection when visiting a website**.
* Sources can be:

  * A **malicious website**
  * A **compromised legitimate site** (e.g., *cross-site scripting*).
* **User caution** greatly reduces this propagation method.
* **Impacts are similar** to email-borne infections.
* **Script restriction** (*Java/JavaScript*) reduces risk but can **affect browsing**.

::: {.callout collapse="true"}

#### Ultra-summary

* *Drive-by download* = infection without user action
* Malicious or compromised sites
* Awareness + restricted scripts = protection
:::

::: {.callout collapse="true"}

#### Original version

## Malware Delivered via Web

* Often called ***drive-by download***, allows **infecting the system** (*computer*, *tablet*, *smartphone*, *smartwatch*, etc.) **simply by visiting a website**.
* Sources may be:

  * Malicious site containing malware
  * Legitimate website previously infected (e.g., *cross-site scripting*). Infection may only affect certain pages.
* User awareness (avoiding suspicious sites) reduces the effectiveness.
* Consequences are similar to email infections.
* Restricted script execution (*Java/JavaScript*) in browsers can limit infection but may constrain navigation.
:::

## Phishing

* Technique to **collect private information** through **indiscriminate fishing**.
* ***Phishing*** can be:

  * **General** (broad targeting)
  * **Targeted** (*spear phishing*) for a specific person or organization.
* Main vector: **forged email address**, hard to detect.
* Goal: obtain **sensitive data** (credentials, passwords, personal or banking info).
* Attacks use **credible or threatening pretexts** to prompt victim cooperation.

::: {.callout collapse="true"}

#### Ultra-summary

* Information theft by deception
* Forged emails
* *Spear phishing* = targeted attack
* Urgent or threatening pretexts
:::

::: {.callout collapse="true"}

#### Original version

## Phishing

* The word ***phishing*** comes from English ***"password"***, ***"harvesting"***, and ***"fishing"***.
* Shows the technique’s main goal: **collect as much private info** via indiscriminate fishing.
* Targeted attacks are called ***spear phishing*** (from *spear fishing*).
* Transmission vector: email with **forged sender address** requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.
* Pretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored.
:::

## Spam

* **Unwanted emails**, often ads, or **unsolicited pop-ups** during web browsing.
* Represent about **60% of global emails**.
* Main consequences:

  * **Resource consumption** and time loss.
  * Some can **transmit malware**.
* Often target short addresses or come from **sold/exchanged address lists**.
* **Anti-spam filters** incur **significant costs** for organizations.

::: {.callout collapse="true"}

#### Ultra-summary

* Unwanted emails/ads
* Risks: time/resource loss, malware
* Targeting: short addresses or lists
* Filtering costly for organizations
:::

::: {.callout collapse="true"}

#### Original version

## Spam

* Includes all **unwanted emails** (often ads) received by people and organizations.
* Also applies to **pages/pop-up windows** **shown without user consent** during web browsing.
* Around **60%** of global emails belong to this category.
* Consequences: resource consumption and wasted time, but some spam can also **transmit malware**.
* Often target short email addresses or list-based addresses (sold/exchanged).
* **Anti-spam filtering** incurs high organizational costs.
:::

## Ransomware

* Trojan-type malware that **encrypts data** to make it inaccessible.
* Demands a **ransom** (often in bitcoins) to recover files.
* Can remain **dormant**, triggered by an event or date.
* Main vector: **malicious emails**.
* Other effects: **DoS attacks, extortion**.

::: {.callout collapse="true"}

#### Ultra-summary

* Data encrypted by Trojan
* Ransom to restore access
* Possible programmed dormancy
* Infection via malicious emails
:::

::: {.callout collapse="true"}

#### Original version

## Ransomware

* Trojan malware family.
* Typically **encrypts victim’s data** to make it completely inaccessible.
* Then displays a message requesting **ransom payment** (often in **bitcoins**).
* May stay in **dormant state** triggered by event or date.
* Infection vectors vary, but **malicious email attachments** often responsible.
* Variants exist and continue to evolve.
* Other behaviors: **DoS, targeted extortion, threats**, etc.
:::

## Attacks on ***Internet of Things (IoT)*** Devices

* Target **connected objects** (cameras, TVs, sensors, alarms, etc.).
* Devices are **easy to compromise** due to:

  * **Known vulnerabilities**
  * **Default passwords**
  * **User unawareness**
* **Remote control** enables:

  * **Entry point** to the network
  * **Device abuse** for illicit activities (DDoS, hacking, mining)
* A **precise inventory** of connected devices is essential.

::: {.callout collapse="true"}

#### Ultra-summary

* Targets connected objects
* Weak security (vulnerabilities, default passwords)
* Risk of network access and abuse
* IoT inventory needed
:::

::: {.callout collapse="true"}

#### Original version

## Attacks on IoT Devices

* Target connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).
* Often **easier to hack** than traditional systems due to:

  * Many vulnerabilities known to attackers
  * Default passwords
  * User negligence
* Remote takeover allows:

  * Entry point to home/corporate network
  * Device use for illicit activities (hacking, DDoS, bitcoin mining)
* Maintaining a detailed directory of all connected devices is necessary.
:::

## Information Spoofing and Website Defacement

* Attacks aiming to **alter information** on websites and social media.
* Impact: **compromised reputation** and **economic damage**.
* Websites: secure host system, restrictive configuration, **regular audits**.
* Social media: strong passwords, **multi-factor authentication**, session closure, cookie deletion.

::: {.callout collapse="true"}

#### Ultra-summary

* Altered info on websites and social media
* Risks: reputation, economic losses
* Websites: security + audits
* Social media: strong passwords, MFA, closed sessions, cookies cleared
:::

::: {.callout collapse="true"}

#### Original version

## Information Spoofing and Website Defacement

* Target **integrity** of published info on websites and social media.
* Affects **reputation** and can cause **economic damage**.
* **Websites**: secure host system, as restrictive configuration as possible, recurring security audits recommended.
* **Social media**: depends on authentication process:

  * Avoid simple passwords
  * Prefer strong, possibly multi-factor authentication
  * Close sessions properly
  * Clear cookies
:::

## Denial of Service (DoS / DDoS) Attacks

* Aim to **make IT systems inaccessible**, especially for organizations.
* **DDoS**: distributed attack using thousands of devices, generating massive traffic.
* Classic protections (*firewalls*, IDS/IPS sensors) often **insufficient**.
* Consequences:

  * **Affected reputation**
  * **Financial losses** (sometimes ransom)
  * **High risk for critical infrastructure** (hospitals, power plants, Internet backbone)

::: {.callout collapse="true"}

#### Ultra-summary

* DDoS = inaccessible systems via massive attacks
* Limited protections
* Risks: reputation, finances, critical infrastructures
:::

::: {.callout collapse="true"}

#### Original version

## Denial of Service (DoS / DDoS) Attacks

* Aim to **render IT systems inaccessible**, mainly targeting private or governmental organizations.
* **DDoS** (*Distributed Denial of Service*): multiple devices (**often tens of thousands**) simultaneously target victim system(s).
* Traffic can reach several hundred Gbps.
* Traditional protection (*firewalls*, *intrusion detection/prevention sensors*) has limited effectiveness.
* Service unavailability can cause:

  * **Reputational issues**
  * Significant **financial losses** (ransom demands)
  * **High security risks (even physical)** for **critical infrastructures** (hospitals, power plants, Internet backbone).
:::

# Digital Security Methods

**Problem:** Protecting digital information

* in a distributed environment
* globally accessible
* without physical boundaries

**Solution:**

* Cryptography
    * Symmetric
    * Asymmetric
    * $+$ One-way functions
    * $+$ (Pseudo) random generators

::: {.callout collapse="true"}
#### Ultra-summary
- **Problem:** Security in a distributed/global environment.
- **Solutions:**
  - Crypto (symmetric/asymmetric).
  - One-way functions (hashing).
  - Random generators (physical/pseudo).
:::

::: {.callout collapse="true"}
#### Original version

**Problem:** Protecting digital information

* in a distributed environment
* globally accessible
* without physical boundaries

**Solution:**

* Cryptography
    * Symmetric
    * Asymmetric
    * $+$ One-way functions
    * $+$ (Pseudo) random generators
:::

---

## Cryptographic Hash Functions

* **Functions easy to compute in one direction but virtually impossible to reverse**.
* Any modification of the source document radically changes the **digest** (avalanche effect).
* **Key properties**:
  - **One-way**: impossible to retrieve the input from the hash.
  - **Collision-free**: impossible to find two inputs with the same hash.
* Digest size: 160 to 512 bits.
* Algorithms (very **performant**): SHA-1, SHA-256, SHA-3.

::: {.callout collapse="true"}
#### Ultra-summary
- **One-way + collision-free**.
- Size: 160-512 bits.
- Algos: SHA-1/256/3.
- Usage: integrity, signatures.
:::

::: {.callout collapse="true"}
#### Original version

* **Functions easy to compute in one direction but virtually impossible to compute in the reverse direction**.
* Any modification (even insignificant) of the source document results in a fundamentally different **digest**.
* It is virtually impossible to retrieve the source document using only the digest (**one-way**).
* It is virtually impossible to find a second source document producing the same digest (**collision-free**).
* Usual digest length: 160 to 512 bits.
* One-way algorithms are very performant.
* Examples: SHA-1, SHA-256, SHA-3, etc.
:::

---

## (Pseudo) Random Generators

* **Characteristics**
    * **random**
    * **unpredictable**
    * **non-reproducible**
* **Critical** for security (keys, IV, secrets).
* **Types**:
  - **True random**: based on physical phenomena (radioactivity, quantum).
  - **Pseudo-random**: deterministic (based on a *seed*: initial random sequence).
* **Risk**: "Pseudo-security" if the *seed* is predictable (Pitkin quote).
* Applications: session keys, IV (DES-CBC), signatures (ElGamal).

::: {.callout collapse="true"}
#### Ultra-summary
- **True random**: physical (quantum).
- **Pseudo-random**: deterministic (*seed*).
- **Risk**: predictable *seed* = vulnerability.
- Uses: keys, IV, signatures.
:::

::: {.callout collapse="true"}
#### Original version

* Random number generation is a very important process that can compromise the security of many encryption systems.
* Applications: session key generation, initialization vectors (DES - CBC mode), secrets for signatures (ElGamal), etc.
* A **random generator** is a device capable of generating numbers in a **random**, **unpredictable** and **non-reproducible** way. (e.g. based on physical phenomena: radioactive or quantum source).
* **Pseudo-random generators** are deterministic processes developed from an initial random sequence (**seed**) (e.g. user keystrokes, disk access).
* *Quote:* R. Pitkin in [Kau95]: "The use of pseudo-random processes to generate secret quantities can result in pseudo-security"
:::

---

## Symmetric Cryptography

* **History**: Used since Julius Caesar (1st century BC).
* **Principle**: A single key for encryption/decryption.
* **Scheme**: Plaintext → Encryption (Key) → Ciphertext → Decryption (Key) → Plaintext.
* **Characteristics**:
  - Algorithms: AES, DES, IDEA, RC4.
  - Services: Confidentiality, Authentication, Integrity.
  - **Limit**: No signatures (shared key).
  - **Problem**: Secure key exchange required.

::: {.callout collapse="true"}
#### Ultra-summary
- **1 key** to encrypt/decrypt.
- **Fast** (AES, DES).
- **Problem**: key exchange.
- Uses: personal documents, closed groups.
:::

::: {.callout collapse="true"}
#### Original version

* Also called conventional cryptography or secret key cryptography (1st century BC, Julius Caesar).
* **Idea:** Based on a single secret key, perform a transformation capable of respectively making information unreadable and restoring it.
* **Scheme:** Plaintext $\to$ Encryption (Key) $\to$ Ciphertext $\to$ Decryption (Key) $\to$ Plaintext.
* **Characteristics:**
    * Algorithms: AES, DES, IDEA, RC4, RC5, etc. (some are free and openly available)
    * Services: Confidentiality, Authentication, Integrity.
    * No direct support for digital signatures (because key known by both).
    * Requires a confidential channel to exchange the key.
    * Ideal for protection of personal documents or closed groups.
:::

---

## Asymmetric Cryptography

* Also called **public cryptography** (1976, Diffie & Hellman).
* **Principle**
    - Key pair (public/private) for encryption and signatures.
* **Two main uses**:
  1. **Confidentiality**:
     - Encryption: recipient's public key
     - Decryption: recipient's private key
  2. **Digital signature**:
     - Signature: sender's private key
     - Verification: sender's public key
     - *Optimization*: Generally sign the **hash** of the document
     - **Fundamental properties**:
       - **Integrity**: Any modification invalidates the signature
       - **Non-collision**: Impossible to have 2 documents with the same signature
       - **Non-repudiation**: Only the holder of the private key can sign

* **Technical aspects**:
  - **Algorithms**: RSA, ElGamal
  - **Services**: Integrity, Authentication, Non-Repudiation
  - **Performance**: much slower than symmetric (100x slower)
  - **Advantage**: No need for a confidential channel for key exchange

::: {.callout collapse="true"}
#### Ultra-summary
- **2 keys**: public (encrypt/verify) + private (decrypt/sign)
- **2 uses**:
  - Confidentiality: encrypt for a recipient
  - Signature: prove authenticity
- **Signatures**:
  - Integrity + non-repudiation
- **Algorithms**: RSA/ElGamal
- **Advantage**: No need for secure channel to exchange keys
- **Disadvantage**: Slow
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography
* Also called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).
* **Idea:** Use two different keys - one **secret** and one **public** - respectively for encryption and decryption operations.
* Each user has a **keyring**.

**Confidentiality:**
* Sender encrypts with the **recipient's public key**.
* Recipient decrypts with their **private key**.
* Only the recipient's key is used!

**Digital Signature:**
* Sender signs with their **private key**.
* Recipient verifies with the **sender's public key**.
* Only the sender's key is used!
* *Note:* Generally sign the **digest** of the document (hash) for performance reasons.

**Signature characteristics:**
* The signature changes if the document changes, while the private key remains the same.
* If the document or signature is modified, verification fails (**integrity guaranteed**).
* It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function **without collisions**).
* Only the holder of the private key can generate a signature verifiable using the corresponding public key (**non-repudiation**).
* **Algorithms**: RSA, ElGamal.
* **Services**: Integrity, Authentication, Non-Repudiation.
* **Slowness**: Up to 50 times slower than symmetric cryptography.
* **Advantage**: No need for a confidential channel to exchange keys (unlike symmetric).
:::


---

## Asymmetric + Symmetric Cryptography (Hybrid)

* **Principle**: Use asymmetric to exchange a symmetric key (session key).
* **Steps**:
  1. A generates a random symmetric key $K_s$.
  2. A encrypts $K_s$ with B's public key.
  3. A and B then communicate using $K_s$ (symmetric).

::: {.callout collapse="true"}
#### Ultra-summary
- **Asymmetric**: exchange of symmetric key.
- **Symmetric**: data encryption.
- **Advantage**: combines security + performance.
:::

::: {.callout collapse="true"}
#### Original version

* **Idea:** Use public cryptography only to exchange symmetric keys (Session keys).
* A generates a random key $K_s$ and transmits it to B by encrypting it with B's public key.
* A & B then communicate using $K_s$ (symmetric).
:::

---

## Asymmetric Cryptography: Operation (RSA)

### Key Construction
1. **Choice of prime numbers**:
   - $p$ and $q$: two large prime numbers (> 1024 bits)
   - $n = pq$: RSA modulus (size = 2048+ bits)

2. **Calculation of Euler's totient function**:
   - $\phi(n) = (p-1)(q-1)$
   - *Property*: For any $a$ coprime with $n$, $a^{\phi(n)} \equiv 1 \pmod{n}$

3. **Selection of exponents**:
   - $e$: integer coprime with $\phi(n)$ (public exponent)
   - $d$: modular inverse of $e$ (private exponent), such that $ed \equiv 1 \pmod{\phi(n)}$

### Encryption/decryption process
* **Public key**: $(n,e)$
* **Private key**: $(d)$
* **Encryption**: $C = P^e \pmod{n}$
* **Decryption**: $P = C^d \pmod{n}$

### Mathematical proof
1. **Fundamental congruence**:
   - $ed = 1 + k\phi(n)$ (by definition of $d$)

2. **Application of Euler's theorem**:
   - $P^{\phi(n)} \equiv 1 \pmod{n}$ (if $P$ coprime with $n$)

3. **Demonstration**:

   \begin{align*}
   (P^e)^d &\equiv P^{ed} \pmod{n} \\
   &\equiv P^{1 + k\phi(n)} \pmod{n} \\
   &\equiv P \cdot (P^{\phi(n)})^k \pmod{n} \\
   &\equiv P \cdot 1^k \pmod{n} \\
   &\equiv P \pmod{n}
   \end{align*}

### System security
* **Hard problem**: Factorization of $n$ into $p$ and $q$
* **Recommended size**:
  - $n$: 2048 bits (minimum for current security)
  - $p$ and $q$: 1024+ bits each
* **Known vulnerabilities**:
  - Side-channel attacks (timing, power analysis)
  - Inappropriate parameter choices ($e$ too small, $p$ and $q$ too close)

::: {.callout collapse="true"}
#### Ultra-summary
- **Keys**:
  - Public: $(n,e)$ where $n = pq$
  - Private: $(d)$ with $ed \equiv 1 \pmod{\phi(n)}$
- **Operations**:
  - Encryption: $P^e \mod n$
  - Decryption: $C^d \mod n$
- **Security**: Factorization of $n$ difficult
- **Size**: 2048+ bits for $n$
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography: Operation (RSA)
* Let $n := pq$ with $p$ and $q$ two large prime numbers (> 1024 bits).
* Let $\phi(n) = (p-1)(q-1)$.
* Let $e$ and $d$ such that $ed \equiv 1 \pmod{\phi(n)}$.
* By definition of congruences: $ed = 1 + k\phi(n)$
* Euler's theorem: $a^{\phi(n)} \equiv 1 \pmod n$.
* **Encryption:** $C = P^e \pmod n$. **Public key:** $(n,e)$.
* **Decryption:** $P = C^d \pmod n$. **Private key:** $(d)$.
* *Proof:* $(P^e)^d \equiv P^{ed} \equiv P^{1 + k\phi(n)} \equiv (P \pmod n) (P^{\phi(n)} \pmod n)^k \equiv P \pmod n$.
:::


---

## Asymmetric Cryptography: Conclusions

* **Dominant algorithms**: RSA (most used), Rabin, ElGamal
* **Complete services**:
  - Confidentiality
  - Authentication
  - Integrity
  - Digital signature & Non-repudiation
  - Non-duplication

* **Performance**:
  - 50x slower than symmetric
  - **Optimal solution**: Combination of asymmetric (key exchange) + symmetric (encryption)

* **Key management**:
  - **Advantage**: Public key exchange without confidential channel
  - **Risk**: Need to verify authenticity of public keys
    - Authenticated acquisition channel **or**
    - Certification by trusted third party

::: {.callout collapse="true"}
#### Ultra-summary
- **Algos**: RSA (dominant), Rabin, ElGamal
- **Services**: Confidentiality + Authentication + Integrity + Signatures
- **Slowness**: 50x vs symmetric → **hybrid recommended**
- **Keys**: Simple public exchange but **authentication crucial**
:::

::: {.callout collapse="true"}
#### Original version
## Asymmetric Cryptography: Conclusions

* There are a few asymmetric encryption systems (**Rabin**, **ElGamal**, etc.) but the most used is **RSA**.

* **Supported services**: **Confidentiality**, **Authentication**, **Integrity**, **Digital Signature & Non-Repudiation**, (**Non-Duplication**).

* Operations related to **asymmetric cryptography** are up to **50 times (!) slower** than those of **symmetric cryptography**.
  A **combination of the two methods** is often desirable.

* **Key distribution** is simplified by the fact that only **public keys** need to be exchanged between participants (no need for an alternative confidential channel) but…

* … it is necessary to **verify that the public key actually belongs to the recipient**:
  * Either the **acquisition channel** of the public key is protected against any modification (**authenticated**)
  * Or the key is **certified accurate by a third party**
:::

---

## Symmetric vs Asymmetric Comparison

### Comparative advantages

* **Symmetric**:
  - **Performance**: 100x faster
  - **Implementation**: Easy in hardware
  - **Keys**: Short (128 bits = 16 memorable characters)

* **Asymmetric**:
  - **Key exchange**: Authenticated channel sufficient (no need for confidentiality)
  - **Management**: 1 key pair for n correspondents (vs n keys in symmetric)

### Common issues

* **Weak link**: Key management by users
* **Security basis**: Empirical rather than theoretical
* **Legal constraints**: Usage and export restrictions

### Usage recommendations

| **Use case**                          | **Recommended solution**                          | **Justification**                                                                 |
|--------------------------------------|--------------------------------------------------|----------------------------------------------------------------------------------|
| Personal documents                    | Symmetric                                        | Speed + memorable keys                                                          |
| Groups of close users                 | Symmetric                                        | Speed + easy confidential exchange                                              |
| Distant/unknown users                 | Asymmetric                                       | No need for confidential channel                                                 |
| Remote transactions                  | Hybrid (Asymmetric + Symmetric)                 | Asymmetric for key exchange, symmetric for data                                 |
| Software protection (distribution)   | Hybrid                                           | Unique symmetric key per version, encrypted with asymmetric                    |
| Network segments                     | Symmetric                                        | Speed + controlled environment (easy key exchange between administrators)        |

::: {.callout collapse="true"}
#### Ultra-summary
**Symmetric**:

    ✅ Fast (100x)
    ✅ Short keys (128 bits)
    ❌ Confidential key exchange required

**Asymmetric**:

    ✅ Simplified key exchange
    ✅ 1 key pair for n correspondents
    ❌ Slow (50x)
    ❌ Long keys (1024+ bits)

**Hybrid**: Best of both worlds
**Common problems**: Key management, empirical basis, legal restrictions
:::

::: {.callout collapse="true"}
#### Original version
## Symmetric vs. Asymmetric Cryptography

* There are **hundreds of symmetric and asymmetric algorithms** capable of providing a sufficient level of **confidentiality**.

* **Symmetric solutions** offer the following advantages:
  * **Speed** (up to **100 times faster** than asymmetric solutions)
  * **Ease of hardware implementation**
  * **Reduced key length**: **128 bits** (= 16 characters ⇒ memorable!) instead of **1024 bits** for asymmetric equivalents.

* **Asymmetric solutions** have as main arguments:
  * **Simplified key exchange**: keys must be exchanged through an **authenticated but non-confidential channel**
  * **Simplified key management**: a single **public/private key pair** is sufficient for a user to receive confidential messages from **n users** (instead of **n different keys** in the symmetric case).

* **Problems common to both techniques**:
  * **Key management by the user** remains the **weakest link**
  * Security (normally) based on **empirical arguments** rather than **theoretical** ones
  * **Legal restrictions** on usage and export

## Symmetric vs. Asymmetric Cryptography (II)

| **Activity**                                                                                   | **Recommendation**                                                                                           | **Remarks**                                                                                                                              |
| --------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| Protection of personal documents                                                             | **Symmetric crypto**                                                                                        | **Speed**, easily memorable keys                                                                                                  |
| Protection of documents in a group of close users                                            | **Symmetric crypto**                                                                                        | **Speed**, ease of exchanging confidential keys                                                                                   |
| Establishment of confidential channels between distant users (unknown)                       | **Asymmetric crypto**                                                                                       | No need to have a confidential channel: **authenticity suffices**                                                                         |
| Transactions between two distant users, Software protection (multicast distribution)         | **Asymmetric crypto for symmetric key protection** + **Symmetric crypto for data protection**              | **Speed**, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public |
| Protection of network segments                                                                | **Symmetric crypto**                                                                                        | **Speed**, Stable environment → easy confidential key exchange between sysadmins                                                   |
:::

# Dissection of an Attack: Ransomware

### Definition and Impact
* **Definition**: Malicious software that encrypts data and demands a ransom for its restoration.
* **Limitations of the classic definition**:
  - Does not cover the impact on **critical infrastructure** (e.g., Colonial Pipeline, May 2021)
  - Underestimates the **systemic scope** of attacks
* **Alarming statistics**:
  - Billions of annual attacks
  - Considered the **most dangerous cyber threat** in 2021 ("Ransomware Everywhere")

::: {.callout collapse="true"}
#### Ultra-summary
- **Malware**: Encrypts data → demands ransom
- **Impact**: Critical infrastructure (e.g., Colonial Pipeline)
- **Threat #1** in cybersecurity (2021)
- **Targets**: Individuals + businesses + states
:::

::: {.callout collapse="true"}
#### Original version
"Ransomware (from English **ransomware**), ransom software, extortion software, is malicious software that holds personal data hostage. To do this, ransomware **encrypts personal data** then asks their owner to send money in exchange for the **decryption key**" (Wikipedia September 21, 2021).

- **Incomplete definition** because **ransomware** affects a **vast spectrum of IT infrastructure**

- For example, in May 2021, a **ransomware attack** against the **Colonial Pipeline** company caused a **fuel supply disruption** for a large part of the US coast

- With a **total number of attacks** counted in **billions per year**, "**Ransomware Everywhere**" is globally considered the **most direct, visible and dangerous threat** for users and companies in 2021!
:::

---

## Ransomware Attack Lifecycle

### Prevention and Response
| Phase | Measures |
|-------|---------|
| **Prevention** | - Regular patching<br>- Detection solutions (Firewalls, WAFs, IDS/IPS)<br>- Anti-malware scans (emails, files) |
| **Protection** | - **Offline backups** (essential!)<br>- Strict security policies<br>- User training |
| **Response** | - **Do not pay** (official recommendation)<br>- Forensic analysis<br>- Restoration from backups |

### Technical Dissection
1. **Infection**:
   - Vectors: Phishing, exploits, vulnerable RDP
   - Propagation: Lateral (network) or vertical (system)

2. **Execution**:
   - Encryption of targeted files
   - Deletion of shadow copies
   - Persistence (registry, scheduled tasks)

3. **Extortion**:
   - Display of ransom demand
   - Payment in cryptocurrencies (Bitcoin, Monero)
   - Payment deadlines with penalties

4. **Obfuscation**:
   - Code obfuscation
   - Communication via TOR/Deep Web
   - Log erasure

::: {.callout collapse="true"}
#### Ultra-summary
**Attack cycle**:

1. Infection (phishing/exploits)
2. Execution (encryption + persistence)
3. Extortion (ransom in crypto)
4. Obfuscation (TOR + trace erasure)

**Countermeasures**:

    ✅ Offline backups
    ✅ Patching + detection
    ✅ Training
    ❌ Do not pay
:::

---

## Cryptolocker: Technical Analysis

### Attack Scheme

```{mermaid}
graph TD
    A[Initial infection] --> B[File encryption]
    B --> C[Private key storage on C2 servers]
    C --> D[Ransom demand]
    D --> E{Payment ?}
    E -->|Yes| F[Decryption key sent via TOR]
    E -->|No| G[Permanent data loss]
```

### Preferred Targets
* **Critical extensions** (extract):
  - Documents: `.docx`, `.xlsx`, `.pdf`, `.pptx`
  - Databases: `.mdb`, `.sql`, `.sqlite`
  - Media: `.jpg`, `.png`, `.mp4`, `.avi`
  - Development: `.java`, `.cpp`, `.py`, `.php`
  - Financial: `.qbw`, `.qbb`, `.wallet`

* **Behavior**:
  - **Selective** encryption (recent/modified files)
  - **Double extortion**: Encryption + threat of leakage
  - **RaaS** (Ransomware-as-a-Service): Economic model

::: {.callout collapse="true"}
#### Ultra-summary
**Mechanism**:
- Private key stored on C2 servers
- Payment → key via TOR
- Targets: 100+ extensions (docs, DB, media)

**Recent evolutions**:
- Double extortion (encryption + leakage)
- RaaS (ransomware rental)
:::

::: {.callout collapse="true"}
#### Original version
## Ransomware: Complete View

*(Source: 2017 State of Cybersecurity, F-Secure Inc.)*

## Ransomware: Complete View

#### Prevention, Remediation and Response
- **Patching**
- **Active and passive detection** (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)
- **Offline backups** !
- **Security Policy** - Rules for proper email usage
- **Training** !
- **To pay or not to pay**...

#### Technical Dissection of the Attack
- **Infection and propagation**
- **Execution**
- **Payment** (Crypto-currencies / Bitcoin)
- **Obfuscation** (Obfuscation, TOR Networks/Deep Web)

### Generic Scheme of a Cryptolocker Ransomware

- **Decryption private keys** are stored on the **attacker's** servers
- They are sent to the **victim** after **bitcoin payment**
- The **trace** is shredded using **TOR networks**

## Ransomware Cryptolocker: Targets

**Targeted file extensions**:
.jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb,
.asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg,
.jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads,
.agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl,
.bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw,
.cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml,
.php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw,
.dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf,
.dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray,
.grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key,
.kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3,
.mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg,
.nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf,
.ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd,
.pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps,
.psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat,
.raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql,
.sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg,
.swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2,
.wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw,
.ycbcra, .yuv

*Source: Intel Security Advanced Threat Research - http://www.intelsecurity.com*
:::

# Basic Cryptography Concepts

* Introduction to the **fundamental concepts** of cryptography.
* Presents **security principles**, **system types**, and **attack models**.
* Includes **historical systems** and complementary techniques.

## Kerckhoffs' Principle

* Fundamental principle: **security relies solely on the key**, not on the secrecy of the algorithm.
* The system must remain **secure even if the algorithm is public**.
* The key must be **easily modifiable** and the system **simple to use**.
* Explicit rejection of **security through obscurity**.

::: {.callout collapse="true"}
#### Ultra-summary
- Security based on the key
- Public algorithm
- No security through obscurity
:::

::: {.callout collapse="true"}
#### Original version
## Kerckhoffs' Principle

**Auguste Kerckhoffs** published in **1883** two articles defining **six principles** for military ciphers:

1. The system must be **practically, if not mathematically, undecipherable**.
2. It must **not require confidentiality** and remain secure even if it falls into enemy hands.
3. The **key** must be able to be **memorized, transmitted and modified easily**, without written notes.
4. The system must be **compatible with telegraphic communications**.
5. It must be **portable** and usable by **a single person**.
6. It must be **simple to use**, without complex procedures or excessive constraints.

Kerckhoffs stated as early as the **19th century** that security must be **mathematically demonstrable** and that **there is no security through obscurity**.
:::

## Classification of Encryption Systems

### Unconditional Security

(*unconditional security* / *perfect secrecy*)

* Security **independent of computing power**.
* **Ciphertext** provides no information about the **plaintext**.
* Conditions: **key ≥ message**, **never reused**.
* Mostly **theoretical** use.
* **Example**: *one-time pad*.

### As hard as / equivalent / provable security

* Cryptanalysis **as difficult** as a **hard mathematical problem**.
* **RSA** and **Rabin** proven equivalent to factorization.
  * Demonstrated by **reduction** (*reduction proof*).
* Central but **controversial** concept.

### Computational Security

(*computational security* / *practical security*)

* Security based on **unrealistic cost of attacks**.
* Most used category in practice.
* **Examples**: **AES**, **DES**, **IDEA**, **RC4**.

::: {.callout collapse="true"}

#### Ultra-summary

* **Unconditional**: perfect, theoretical (*one-time pad*).
* **Provable security**: equivalence to hard mathematical problem.
* **Computational**: secure in practice.
:::

::: {.callout collapse="true"}

#### Original version

* **Unconditional security** (*unconditional security also called **perfect secrecy***):

  * The security of the encryption system **is not compromised by the computing power** intended for cryptanalysis.
  * This category relies on **information theory** published by **Shannon in 1949**.
  * More precisely, an encryption system is **unconditionally secure** if the probability of encountering a **plaintext x** after observing the **corresponding ciphertext y** is identical to the a priori probability of encountering plaintext x.
  * In other words, having **plaintext/ciphertext pairs (x,y)** provides **no help for cryptanalysis**.
  * A necessary condition for a system to be unconditionally secure is that the **key be at least the same size as the message** and, above all, that it **not be reused** to encrypt different messages.
  * This condition makes these systems **poorly suited to usual cryptographic needs** and reduces their domain of interest to a **theoretical framework**.
  * The classic example is the **one-time pad** invented in **1917** by **J. Mauborgne** and **G. Vernam**.
  * Theoretical foundations of unconditionally secure systems + other examples in **[Sti06]**.

* **As hard as / equivalent / provable security**

  * When it can be proven that cryptanalyzing the algorithm is **as difficult as solving a reputedly hard mathematical problem**.
  * For example **factorization of large numbers**, calculation of **square roots modulo a composite**, calculation of **discrete logarithms in a finite group**, etc.
  * The **Rabin** and **RSA** algorithms (generic case^1) are "proven" **equivalent to factorization**.
  * Such a proof is called a "reduction" (**reduction proof**).
  * The notion of **provable security** is at the origin of an **important controversy** in the cryptographic world.

* **Computational security** (*computational security also called **practical security***)

  * An encryption system is in this category if the **computational effort needed to "break" it** using the best possible techniques is **beyond** (with a reasonable margin) the computing resources of a hypothetical adversary.
  * The vast majority of symmetric encryption systems (**AES, DES, IDEA, RC4**, etc.) are in this category.
:::

## Entropy

* **Entropy** (Shannon, 1948) measures the **effective amount of information** contained in a message.
* **Conditional entropy** measures the uncertainty that remains about the **plaintext** after observing the **ciphertext**.

### Properties

* $0 \le H(X) \le \log n$
* $H(X) = 0$ → no uncertainty
* $H(X) = \log n$ → all outcomes equally probable

### Interpretation

* Approximates the **number of bits needed** to encode $X$.
* **Redundancy** = difference between effective encoding and entropy.

### Conditional Entropy

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$
* Measures the remaining uncertainty about the **plaintext** after observing the **ciphertext**.

---

::: {.callout collapse="true"}

#### Ultra-summary

* **Entropy**: amount of information in a message.
* **Conditional entropy**: uncertainty about plaintext after ciphertext.
* **Redundancy**: difference between effective encoding and entropy.
:::

::: {.callout collapse="true"}

#### Original version

* An essential definition in cryptography is the **effective** amount of information contained in a message.
* For example, days of the week (*Monday*, ..., *Sunday*) can intuitively be encoded as character strings of length ($\le \text{len}(\text{``Wednesday''})$), i.e., $(8 \times 8 = 64)$ bits. However, the effective amount of information of the variable *day of the week* can be optimally encoded on **3 bits** (since $(2^3 = 8)$ is sufficient to represent the 7 possible variations).
* **Entropy** (Shannon, 1948) is the mathematical formalization of this definition.

### Formal Definition

Let $X$ be a random variable with a finite set of possible values ${x_1, x_2, \dots, x_n}$, such that $P(X=x_i) = p_i$, with $0 \le p_i \le 1$ and $\sum p_i = 1$.
The entropy of $X$, denoted $H(X)$, is defined by

$H(X) = - \sum_{i=1}^{n} p_i \log p_i = \sum_{i=1}^{n} p_i \log \left(\frac{1}{p_i}\right)$

By convention: $p_i \log p_i = 0$ if $p_i = 0$. All logarithms are in **base 2**.

### Interpretation

* Approximation of the number of bits needed to encode the elements of $X$.
* **Redundancy** is the difference between the effective encoding and entropy.

### Properties

1. $0 \le H(X) \le \log n$
2. $H(X) = 0 \iff \exists i : p_i = 1, p_j = 0 \ \forall j \ne i$
3. $H(X) = \log n \iff p_i = 1/n \ \forall i$

### Conditional Entropy

* $H(X \mid Y = y) = - \sum_{x} P(X=x \mid Y=y) \log P(X=x \mid Y=y)$,
* $H(X \mid Y) = \sum_y P(Y=y) H(X \mid Y=y)$

*Measures the uncertainty about $X$ (plaintext) after having observed $Y$ (ciphertext).*
:::

## Attacks on Encryption Systems

* **Ciphertext-only**: Adversary has only the **ciphertext**.
* **Known-plaintext**: Adversary has **plaintext/ciphertext pairs**.
* **Chosen-plaintext**: Adversary **chooses** the **plaintext** and see the ciphertext (and tries to find the plaintext for other messages).
* **Adaptive chosen-plaintext**: **depends on** the **received** ciphertexts.
* **Chosen-ciphertext**: Adversary **chooses** the **ciphertext** and obtains the plaintext (aims to find the key).
* **Adaptive Chosen-ciphertext**: **Chosen-ciphertext** depends on the received plaintexts.

## Oracles and Security Models

### Random Oracles and Security Models

* **Random Oracle**: A theoretical "perfect" function that returns a uniform and random value for each new input, but remains deterministic for an input already seen.
* **ROM (Random Oracle Model)**: Mathematical proof framework using this ideal oracle as a substitute for hash functions.
* **Standard Model**: Framework where security relies solely on the adversary's computing power against real algorithms.
* **Limit**: A security proof in ROM does not guarantee absolute security in the real world (with SHA-256, etc.).

::: {.callout collapse="true"}
#### Original version
A **random oracle** is an abstract entity accessible to legitimate parties and adversaries.

* **Behavior**: It responds to input queries $x$ with perfectly random responses $Orc(x)$. 
* **Determinism**: The only exception lies in previously processed inputs ($x_1, x_2, \dots, x_n$). If $x_1' = x_1$, then $Orc(x_1') = Orc(x_1)$.
* **Modeling**: It is modeled by a function $Orc : X \to Y$ where $\forall x \in X, \Pr(Orc(x) = y) = \frac{1}{|Y|}$.
* **Utility**: It behaves like an **"ideal" cryptographic hash function**, a valuable tool for proving security in the **Random Oracle Model**. 
* **Comparison**: The **standard model** limits adversaries by computational factors. A protocol secure in the random oracle model can become vulnerable if used with a "real" hash function (SHA-1, SHA-256).
:::

---

### Encryption, Decryption and Signature Oracles

* **Function**: Entities that perform operations (encrypt/sign) for the adversary using secret keys without ever revealing them.
* **Symmetric cryptography**: The oracle provides $E_k(x)$ or $D_k(y)$.
* **Asymmetric cryptography**: The oracle is crucial for private operations (decryption/signature), as public operations are already freely accessible.

::: {.callout collapse="true"}
#### Original version: Operational Oracles
An **encryption/decryption/signature oracle** is an abstract entity offering an "on-demand" service.

* **Key access**: It uses the **same keys as the legitimate owners** (symmetric and asymmetric systems) without disclosing them.
* **Symmetric primitives**: For a primitive $E$ and a key $k$, it returns $y = E_k(x)$ or the corresponding plaintext $x$.
* **Public key systems**: The oracle is only needed for operations with the **private key** ($priv_k$).
    * **Decryption**: returns $x$ such that $E'_{pubk}(x) = y$.
    * **Signature**: For a system $S$, it returns $y = S_{privk}(x)$.
* **Attacks**: The attack models using **chosen plaintext** (CPA) and **chosen ciphertext** (CCA) rely on making these oracles available to the adversary.
:::

---

### Indistinguishability and Semantic Security (IND-CPA)

* **Property**: An adversary must not be able to distinguish the ciphertexts of two different plaintext messages.
* **IND-CPA (Indistinguishability under Chosen Plaintext Attack)**: If the adversary guesses the correct message only with a probability of $1/2 + \epsilon$, the system is considered secure.
* **Semantic Security**: Equivalent to IND-CPA, it ensures that no useful information leaks from the ciphertext.

::: {.callout collapse="true"}
#### Original version: Semantic Security
**Ciphertext indistinguishability** guarantees the inability to distinguish the ciphertexts of given plaintexts.

* **Experiment (IND-CPA Security Game)**:
    1. The adversary chooses two messages $M_0$ and $M_1$.
    2. The oracle chooses a random index $i \in \{0,1\}$ and returns $c_i = E_k(M_i)$.
    3. The adversary can perform other calculations or oracle calls.
* **IND-CPA Definition**: The system is secure if the adversary's advantage is **negligible** ($Prob = 1/2 + \epsilon$ with $\epsilon$ small).
* **Note**: In public key, the encryption oracle is useless because the adversary already possesses the public key. IND-CPA provides **semantic security**.
:::

---

### Probabilistic Encryption and OAEP

* **Problem**: Deterministic encryption allows **dictionary attacks** (comparison of known ciphertexts).
* **Solution**: Add randomness to the message before encryption so that $E(M)$ is different each time.
* **OAEP (Optimal Asymmetric Encryption Padding)**: Standard used with RSA. It combines the message $P$ with a random number $R$ via hash functions $h$ and XOR operations ($\oplus$).

::: {.callout collapse="true"}
#### Original version: Determinism vs. Probabilism
**Deterministic** behavior (same inputs = same outputs) creates vulnerabilities.

* **Example**: If Alice sends "Yes" or "No", the adversary can compute $C_{yes} = E_{pub}(``Yes")$ and compare. They can create a **codebook** (dictionary) to identify messages without breaking the key.
* **Probabilistic encryption**: Adds randomness. The goal is semantic security for the public key.
* **OAEP**: Used in **RSA-PKCS1**. The text $P$ is combined with randomness $R$:
    * $M_1 := P \oplus h(R)$
    * $M_2 := R \oplus h(M_1)$
    * Encryption applies to $M_1$ and $M_2$. During decryption, we recover $R = M_2 \oplus h(M_1)$, then $P = h(R) \oplus M_1$.
:::

::: {.callout collapse="true"}
#### Ultra-summary
- **Random Oracle**: "Ideal" hash function (theoretical model).
- **CPA/CCA Oracles**: Simulate access to the secret key to test resistance.
- **IND-CPA**: Inability to distinguish two ciphertexts (Semantic Security).
- **Probabilistic Encryption**: Essential to counter codebooks (dictionary attacks).
- **OAEP**: Padding method adding the necessary randomness to RSA.
:::

## History of Cryptography and Unconditional Security

### Historical Encryption Systems

Cryptography was for a long time limited to the sole pursuit of **confidentiality**. Historical systems are based on two fundamental principles: **substitution** and **transposition**.

* **Caesar Cipher** (mono-alphabetic substitution): Fixed letter shift. Very vulnerable to **frequency analysis**.
* **Vigenère Cipher** (polyalphabetic substitution): Uses a key to vary the shift. More complex, but breakable by identifying the key length.
* **Transposition Cipher**: Reorganization of the original text characters according to a permutation defined by a key.

::: {.callout collapse="true"}
#### Original version: Historical Cryptography
For centuries **confidentiality** was the only application of cryptography...

* **1st century BC, Caesar Cipher**: **Mono-alphabetic substitution encryption** $e_k(x) = (x + k) \pmod{26}$, $d_k(y) = (y - k) \pmod{26}$ where $x, y, k \in \mathbb{Z}_{26}$.
    * Example: $E_1(\text{'hello'}) = \text{'ifmmp'}$.
    * **Cryptanalysis**: easy, based on **character frequency**.
* **16th century, Vigenère**: **Polyalphabetic substitution encryption** $e_k(x_1, \dots, x_n) = (x_1 + k_1, \dots, x_m + k_m, x_{m+1} + k_1, \dots) \pmod{26}$.
    * **Cryptanalysis**: find the **key length $m$** by identifying repeated ciphertext portions and analyzing separate blocks as in the Caesar Cipher.
* **Transposition Ciphers** (Porta, 1563): The key defines a **permutation** on the plaintext.
* These techniques are still the basis of modern encryption systems (ex: **Enigma**, qualified by W. Churchill as the secret weapon that won the war).
:::

### The One-Time Pad (OTP)

The **One-Time Pad** (OTP), or **Vernam cipher**, is the only system proven to be **unconditionally secure** (perfect secrecy).

* **Principle**: The message is combined with a key of the same length via the XOR operation ($\oplus$).
* **Unconditional Security**: Observation of the encrypted message provides no information about the plaintext message. Even an adversary with infinite computing power cannot break it.
* **Shannon's Constraints**: The key must be **as long as the message**, purely **random**, and **used only once**.
* **Key Reuse**: If a key is reused for two messages, an attacker can eliminate the key by XOR ($y_a \oplus y_b = x_a \oplus x_b$) and recover the plaintext messages.

::: {.callout collapse="true"}
#### Original version: The One-Time Pad
Let $n \ge 1$ and the spaces $P, C, K$ such that $P, C, K = (\mathbb{Z}_2)^n$. The encryption and decryption operations of a **one-time pad** (Vernam Cipher) are:
$E_k(x_i) = x_i \oplus k_i$ and $D_k(y_i) = y_i \oplus k_i$ for $1 \le i \le n$.

* **Unconditional security**: If $k_i$ are random and independent, observation of ciphertexts does not help cryptanalysis. The **entropy** of $X$ does not decrease: $H(X|C) = H(X)$.
* **Shannon's Theorem**: Necessary condition: $H(K) \ge H(X)$. The length of the **random key** must be at least as large as that of the plaintext.
* **Key reuse**: $y_a \oplus y_b = x_a \oplus x_b$. With low-entropy messages, the plaintexts and the key ($k = y_a \oplus x_a$) can be recovered.
* Vulnerable to the **Known Plaintext** attack (if the key is reused).
* Major problem: The **distribution and management** of large keys. Revived by **quantum cryptography** proposing confidential channels for unlimited-length key distribution.
:::

### Steganography

In contrast to cryptography, which makes the message unreadable, **steganography** conceals the very existence of the message.

* **Method**: Use a "subliminal channel" (an innocent medium like an image or a banal text).
* **Modern technique**: Insertion of data into the **least significant bits** (LSB) of multimedia files, allowing the hiding of large volumes of data without visible alteration.

::: {.callout collapse="true"}
#### Original version: Steganography
**Steganography** hides a message inside another. Constituent elements:

1. A different **physical or logical channel** (subliminal channel).
2. A **secret mechanism** to identify this channel.

* **Classic examples**: First letters of words in a text, invisible ink.
* **Modern example**: Use the **least significant bits** of the frames of a Photo CD.
* For a 2048x3072 image (RGB 24 bits), hiding a message using 1 bit allows storing **2.3 Mb** without deteriorating quality.
:::

::: {.callout collapse="true"}
#### Ultra-summary
- **History**: Substitution (Caesar/Vigenère) and Transposition (permutation).
- **One-Time Pad**: Absolute security if the key is random, unique, and as long as the message ($H(K) \ge H(X)$).
- **Steganography**: Hiding the existence of the message (ex: LSB technique in images).
:::
# Symmetric Cryptography

## Stream Ciphers (Stream Encryption)

### Introduction to Stream Ciphers

#### Definition and Principle

**Stream ciphers** are a family of encryption systems characterized by:

- **Unit block size**: each encrypted block = 1 bit
- **Two-phase architecture**:
  1. **Keystream generation**: production of the key sequence
  2. **Substitution**: operation on plaintext bits based on the keystream

**Classic example**: the *one-time pad*

- Generation: (pseudo-)random generator
- Substitution: XOR operation ($\oplus$) with the keystream

#### General Characteristics

**Advantages:**

- **Speed**: encryption at register level, ideal for real-time *streaming* (video)
- **Lightweight**: work on systems with limited CPU resources
- **Low memory**: little or no buffering needed
- **Non-propagated errors**: retransmission of defective packets is sufficient (suitable for wireless transmissions - WiFi)

**Disadvantages:**

- **Dependency on keystream quality**: randomness determines robustness
- **Dangerous reuse**: keystream reuse allows easy cryptanalysis

::: {.callout-note collapse=true}
## 📄 Original text

### Stream Ciphers

- **Stream ciphers** constitute a **family of encryption systems** where the **size of the encrypted block is equal to 1 bit**.
- Stream ciphers are generally composed of **two phases**:
    - A **generation phase** of the sequence of elements forming the key (the **keystream**).
    - A **substitution phase** where the *plaintext* bits undergo a specific operation dependent on the keystream.
- An obvious example of a stream cipher is the **one-time pad** with:
    - A keystream generation phase performed by a **(pseudo-)random generator**.
    - A substitution phase consisting of performing a **xor** ($\oplus$) with the keystream.

### Stream Ciphers: Characteristics

- **Speed**: Encryption is done directly at the register level. Ideal for applications requiring *"on the fly"* encryption like **video streaming**.
- **Ease**: Operations can be performed by systems with **limited CPU resources**.
- **No (or little...) need for memory/buffering**.
- **Limited or absent error propagation**: retransmission of faulty packets is normally sufficient (suitable for applications where packet loss is frequent like **wireless transmissions (WiFi)**).
- **Disadvantages**:
    - The **quality in terms of randomness** of the generated keystream determines the **system's robustness**.
    - **Keystream reuse** allows **easy cryptanalysis** (cf. the one-time pad).
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Stream Ciphers** = encryption bit by bit in 2 phases (keystream generation + substitution).

**Advantages**: fast, lightweight, no error propagation.

**Disadvantages**: keystream quality critical, reuse = vulnerability.
:::

---

### Synchronous Stream Ciphers

#### Operating Principle

In a **synchronous stream cipher**, the keystream depends **only on the key**, independent of the plaintext and ciphertext.

**Process equations:**

$$\sigma_{i+1} = f(\sigma_i, k)$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Where:

- $\sigma_i$: state at time $i$ (initial state $\sigma_0$ may depend on $k$)
- $k$: secret key
- $f$: state transition function
- $g$: keystream production function producing $z_i$
- $h$: output function producing ciphertext $c_i$ from plaintext $m_i$

```{mermaid}
graph LR
    A[Key k] --> B[State σi]
    B --> C[Function f]
    C --> D[State σi+1]
    B --> E[Function g]
    E --> F[Keystream zi]
    F --> G[Function h]
    H[Plaintext mi] --> G
    G --> I[Ciphertext ci]
    D -.->|loop| B
```

#### Characteristics

**Synchronization requirement:**

- Transmitter and receiver must share the same key $k$ **AND** the same state $\sigma_i$
- Loss of synchronization = need for external mechanisms (markers, redundancy analysis)

**Properties:**

- **No error propagation**: modification of ciphertext does not affect subsequent sequences
- **Attention**: deletion of a ciphertext = receiver desynchronization

**Vulnerabilities to active attacks:**

- ✓ Detection: insertion, elimination, replay of fragments
- ✗ Bit modification: adversary can modify bits and analyze impact on plaintext
- **Solution**: additional authentication mechanisms necessary

#### Special case: Additive Stream Cipher

The most frequent case where:

- Functions $f$ and $g$ replaced by a random generator
- Function $h$ = modulo 2 addition (XOR: $\oplus$)

**Formula**: $c_i = z_i \oplus m_i$

::: {.callout-note collapse=true}
## 📄 Original text

### Synchronous Stream Ciphers

- The **generated keystream depends only on the key** and not on the plaintext nor the ciphertext.
- The encryption process of a **synchronous stream cipher** is described by the following equations:
  $$\sigma_{i+1} = f(\sigma_i, k)$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  with $\sigma_i$ the **initial state** which may depend on the key $k$, $f$ the **function determining the next state**, $g$ the **function producing the keystream** $z_i$ and $h$ the **output function** producing the ciphertext $c_i$ from the plaintext $m_i$.

### Synchronous Stream Ciphers: Characteristics

- **Require synchronization** of the transmitter and receiver: In addition to using the same key $k$, both must be in the **same state** for the process to work. If synchronization is lost, **external mechanisms** are needed to recover it (special markers, plaintext redundancy analysis, etc.)
- **No error propagation**. Modification of the ciphertext during transmission does not cause disturbances in subsequent ciphertext sequences (however, the **deletion** of a ciphertext would cause **desynchronization** of the receiver).
- **Active attacks**: Insertion, elimination or replay of parts of ciphertext are **detected** by the receiver. However, an adversary could **modify certain bits** of the ciphertext and analyze the impact on the corresponding plaintext. Additional **origin authentication mechanisms** are necessary to detect these attacks.
- **Most frequent case** of Synchronous Stream Ciphers: the **additive stream cipher** (cf. the one-time pad) where the functions $f$ and $g$ generating the keystream are replaced by a **random generator** and the function $h$ is a **modulo 2 addition (xor)**.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Synchronous**: keystream = $f$(key only). Equations: $\sigma_{i+1} = f(\sigma_i, k)$, $z_i = g(\sigma_i, k)$, $c_i = h(z_i, m_i)$.

**Requires synchronization** transmitter/receiver. No error propagation but vulnerable to bit modifications.

**Frequent case**: additive cipher with XOR.
:::

---

### Asynchronous Stream Ciphers

#### Operating Principle

Also called **self-synchronizing ciphers**.

The keystream depends on the key **AND** a fixed number of previous ciphertexts.

**Process equations:**

$$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
$$z_i = g(\sigma_i, k)$$
$$c_i = h(z_i, m_i)$$

Where $\sigma_i$ represents a buffer of the last $t$ ciphertexts.

```{mermaid}
graph LR
    A[Key k] --> B[Function g]
    C[Buffer: ci-t...ci-1] --> B
    B --> D[Keystream zi]
    D --> E[Function h]
    F[Plaintext mi] --> E
    E --> G[Ciphertext ci]
    G -.->|feedback| C
```

#### Characteristics

**Self-synchronization:**

- In case of insertion/elimination of ciphertexts, the receiver **automatically re-synchronizes**
- Mechanism: memorization (buffer) of the last ciphertexts

**Limited error propagation:**

- Error propagates only over the **buffer size** ($t$ bits)
- After buffer exhaustion, correct decryption resumes

**Security against active attacks:**

- **Better detection**: modifications detected thanks to error propagation
- **Attention**: self-synchronization allows receiver to continue even after insertions/deletions
- **Solution**: verification of integrity and authenticity of entire stream necessary

**Diffusion of plaintext statistics:**

- Each plaintext bit influences **all subsequent ciphertexts**
- **Result**: better dispersion of statistics vs. synchronous case
- **Application**: use for low entropy or highly redundant plaintexts

::: {.callout-note collapse=true}
## 📄 Original text

### Asynchronous Stream Ciphers

- Also called **self-synchronizing ciphers**.
- The **generated keystream depends on the key as well as a fixed number of previous ciphertexts**.
- The encryption process of an **asynchronous stream cipher** is described by the following equations:
  $$\sigma_i = (c_{i-t}, c_{i-t+1}, \ldots, c_{i-1})$$
  $$z_i = g(\sigma_i, k)$$
  $$c_i = h(z_i, m_i)$$
  with $\sigma_i$, $g$ and $h$ as for the synchronous case.

### Asynchronous Stream Ciphers: Characteristics

- **Self-synchronization**: In case of elimination or insertion of ciphertexts along the way, the receiver is capable of **re-synchronizing with the transmitter** thanks to the **memorization (buffer)** of a number of previous ciphertexts.
- **Limited error propagation**: Error propagation extends only to the **number of ciphertext bits memorized** (buffer size). Afterwards, decryption proceeds correctly again.
- **Active attacks**: Modification of ciphertext fragments will be **more easily detected** than in the synchronous case because of error propagation. However, since the receiver is capable of self-synchronizing with the transmitter, even if ciphertexts are eliminated or inserted along the way, it is necessary to **verify the integrity and authenticity of the entire stream**.
- **Diffusion of plaintext statistics**: The fact that **each plaintext bit will influence all subsequent ciphertexts** results in a **greater dispersion of statistics** compared to the synchronous case...
- ... It is therefore advisable to use **asynchronous stream ciphers when the entropy of plaintexts is limited** and could allow targeted attacks on highly redundant plaintexts.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**Asynchronous** (self-synchronizing): keystream = $f$(key + last ciphertexts). State $\sigma_i$ = buffer of $t$ previous ciphertexts.

**Automatic self-synchronization**. Limited error propagation to buffer.

**Better diffusion** of statistics → ideal for redundant/low entropy plaintexts.
:::

---

### Keystream Generators: LSFR

#### Context and Necessity

**Problem**: generate a keystream of length $m$ from a secret key of length $l$ with $l \ll m$.

**Solution**: Linear Feedback Shift Register (**LSFR** or **LFSR**)

#### LSFR Characteristics

**Advantages:**

- **Optimal hardware implementation**: very efficient circuits
- **Long periods**: sequences of great length
- **Good random quality**: notable randomness
- **Mathematical basis**: algebraic properties of linear combinations

**Generic structure**: LSFR of length $L$

```{mermaid}
graph LR
    A[bit L-1] --> B[bit L-2]
    B --> C[...]
    C --> D[bit 1]
    D --> E[bit 0]
    E --> F[Output]
    A -.->|feedback| G[⊕]
    D -.->|coeff| G
    C -.->|coeff| G
    G --> A
```

#### Important Remarks on LSFR

**History and Usage:**

- Very widespread construction in cryptography and coding theory
- Many military stream ciphers based on LSFR

**Security Limits:**

- **Insufficient security level** compared to modern block ciphers
- **Vulnerability**: the Berlekamp-Massey algorithm allows to:
  - Determine the **linear complexity** of an LSFR
  - Calculate an arbitrary number of generated sequences

**Metric**: Linear complexity (*linear complexity*)

**Improvement Solution:**

Replace the linear combination with a **non-linear function** $f$

→ **Non Linear Feedback Shift Registers** (NLFSR)

::: {.callout-note collapse=true}
## 📄 Original text

### Stream Ciphers: Keystream Generators

- When it is necessary to **generate a keystream of length $m$** from a **secret key of length $l$** with $l \ll m$, we call upon **keystream generators**.
- The most common of these generators is the **Linear Feedback Shift Register (LSFR)**.
- An LSFR has the following characteristics:
    - **Adapts very well to hardware implementations**.
    - Produces sequences of **long periods** and with **notable random quality** (quite strong randomness)
    - Based on the **algebraic properties of linear combinations**.

### LSFRs: Some Remarks

- LSFRs are **very widespread constructions** in cryptography and coding theory.
- A **large number of stream ciphers** based on LSFRs (especially in the **military sphere**) were developed in the past.
- Unfortunately, the **security level offered by these systems is deemed insufficient** nowadays (compared to that of block ciphers...)
- The **metric** allowing analysis of an LFSR is its **linear complexity**. The **Berlekamp-Massey algorithm** allows determining the linear complexity of an LSFR and thus calculating an arbitrarily large number of sequences generated by an LSFR.
- A solution to **increase complexity** is to substitute the linear combination of ciphertext bits with a **non-linear function** $f$. These are the **Non Linear Feedback Shift Registers**.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**LSFR**: long keystream generator ($m$) from short key ($l$). Base = linear combinations.

**Advantages**: efficient hardware, long periods.

**Problem**: insufficient security, vulnerable to Berlekamp-Massey (linear complexity calculation).

**Solution**: NLFSR (non-linear function).
:::

---

### RC4: Software Stream Cipher

#### General Presentation

**RC4™** (*Rivest Cipher 4*) developed in 1987 by Ron Rivest for RSA Security.

**Main characteristics:**

- **Variable key**: flexible length
- **Extremely fast**: 10× faster than DES
- **Synchronous mode**: keystream independent of plaintext/ciphertext

**History:**

- 1987-1994: patented, details confidential (NDA contract required)
- 1994: unofficial publication in a newsgroup
- Since then: intensive analysis by cryptographic community

#### Architecture

**Key components:**

- **S-box**: 8×8 substitution box (256 entries)
  - Content: permutation of numbers 0 to 255
  - Depends on the main key of variable length: $0 < len(k) \leq 255$
- **Combinations**: linear and non-linear
- **Final encryption**: XOR between keystream and plaintext

#### Applications and Security

**Commercial uses (numerous):**

- Lotus Notes
- Oracle SQL
- Microsoft Windows
- SSL/TLS
- And many more...

**Analyses and Vulnerabilities:**

- Exhaustive work on key scheduling and PRGA
- **Major flaw**: implementation in WEP (WiFi Wired Equivalent Privacy)
  - WEP protocol completely compromised
  - Problem: faulty usage mode, not the RC4 algorithm itself

#### Operation

RC4 decomposes into **two steps**:

1. **Key Scheduling Algorithm (KSA)**
   - Responsible for initial permutation of the S-box
   - Function of the variable length key $len(k) = l$

2. **Pseudo Random Generator Algorithm (PRGA)**
   - Generates keystream of arbitrary size
   - Relies on S-box permuted by KSA

```{mermaid}
graph TB
    A[Variable length key k] --> B[KSA: Key Scheduling]
    B --> C[Permuted S-box]
    C --> D[PRGA: Generation]
    D --> E[Keystream zi]
    E --> F[XOR]
    G[Plaintext mi] --> F
    F --> H[Ciphertext ci]
```

::: {.callout-note collapse=true}
## 📄 Original text

### Software Cipher Streams: RC4

- The major **disadvantage of stream ciphers based on registers** is that they are **very slow in programmed version** on a generic machine. **RC4™** is a **variable key stream cipher** developed in **1987 by Ron Rivest** for RSA security. It is **very fast** (**10 times faster than DES** !)
- For 7 years, this algorithm was **patented** and its internal operational details were disclosed only after **signing a confidentiality contract**. Since its **(unofficial) publication in a newsgroup in 1994**, it has been widely discussed and analyzed by the entire cryptographic community.
- The algorithm works in **synchronous mode** (the keystream is independent of the ciphertext and plaintext).
- It is composed of **linear and non-linear combinations**. The key element is an **8×8 substitution box (S-box)** whose entries are a **permutation of the numbers 0 to 255**. The permutation is a **function of the main key** of variable size with $0 < len(k) \leq 255$. The **final encryption is obtained by a xor** between the keystream and the plaintext.
- RC4 is used in a **large number of commercial applications**: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. It is the subject of a **large number of analytical and exhaustive works** that have managed to **compromise the security** of the key scheduling and the PRGA.
- In particular the application of RC4 to the **Wired Equivalent Privacy (WiFi WEP) protocol has been "broken"** due to a **flaw in the protocol's usage mode**.

### RC4: Operation

- The algorithm consists of **two steps**:
    - The **Key Scheduling Algorithm (KSA)**: Responsible for the **initial permutation** that will fill the S-box depending on the variable length key $len(k) = l$.
    - The **Pseudo Random Generator Algorithm (PRGA)**: Generates the **keystream of arbitrary size** relying on the S-box.
:::

::: {.callout-tip collapse=true}
## 📌 Quick revision

**RC4**: software stream cipher, variable key, 10× faster than DES.

**Architecture**: 8×8 S-box (permutation 0-255) + XOR.

**2 steps**: KSA (S-box permutation) + PRGA (keystream generation). Synchronous mode.

**Vulnerability**: WEP broken (usage flaw). Used in SSL, Windows, Oracle...
:::

## Block Ciphers (Block Encryption)

### 1. Introduction to Block Ciphers

#### Definition and Principle

A **block cipher** is a cryptographic function that:

- **Transforms fixed-size blocks**: maps a block of $n$ bits to another block of the same size
- **Is parameterized by a key**: the key $K$ of $k$ bits defines the transformation
- **Must be bijective**: to allow unique decryption
- **Each key = different bijection**: guarantees variability

**Nominal size**: input block size on which encryption is applied

#### Quality Criteria

**1. Key size/Entropy**

- Keys ideally **equiprobable** with entropy = $k$ bits
- Strong entropy protects against **brute-force attacks**
- **Minimum required**: 128 bits for modern block ciphers

**2. Performance**

- Execution speed
- Software/hardware efficiency

**3. Block size**

- Too small block = vulnerability to **plaintext/ciphertext dictionaries**
- **Modern standard**: blocks ≥ 128 bits

**4. Cryptographic resistance**

- Resistance to known techniques:
  - Linear cryptanalysis
  - Differential cryptanalysis
  - Meet in the middle
- **Cryptanalysis effort** equivalent to brute force

```{mermaid}
graph LR
    A[Plaintext n bits] --> B[Block Cipher]
    C[Key K k bits] --> B
    B --> D[Ciphertext n bits]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
```

::: {.callout-note collapse=true}
### 📄 Original text

#### Block Ciphers

- **Symmetric block ciphers** constitute the **cornerstone of cryptography**. Their main functionality is **confidentiality** but they are also the basis for **authentication**, **hashing functions**, **random generation**, etc.

- **Definition**: A block cipher is a **function** that maps a **block of $n$ bits** to another block of **the same size**. The function is **parameterized by a key $K$ of $k$ bits**. To allow **unique decryption**, the function must be **bijective**. **Each key defines a different bijection**. The **input block size** on which encryption is applied is also called **nominal algorithm size**.

- **Criteria to evaluate the quality** of a block cipher:
  - **Key size/Entropy**: Ideally, keys are **equiprobable** and the key space has an **entropy equal to $k$**. A **strong key entropy** protects against **brute-force attacks** from chosen/known plaintexts. Modern block ciphers must have **keys of at least 128 bits**.
  - **Performance**
  - **Block size**: A **too small block** would allow attacks where **plaintext/ciphertext "dictionaries"** could be built. Nowadays, **blocks of size ≥ 128 bits** are becoming common.
  - **Cryptographic resistance**: The block cipher must show **resistance** to known cryptanalysis techniques: **linear or differential cryptanalysis**, **meet in the middle**, etc. The **inherent effort** of these attacks (complexity, storage, parallelization, etc.) must be **equivalent to that of a brute force attack**.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision

**Block cipher**: bijective function transforming blocks of $n$ bits with key $K$ of $k$ bits. **Criteria**: key entropy ≥ 128 bits, block size ≥ 128 bits, cryptanalysis resistance = brute force effort. **Usage**: confidentiality, authentication, hashing, random generation.
:::

---

### 2. Block Cipher Modes of Operation

#### 2.1 Electronic Codebook (ECB)

**Principle**: each plaintext block is encrypted **independently** with the same key.

$$c_i = E_K(m_i)$$
$$m_i = D_K(c_i)$$

```{mermaid}
graph TB
    subgraph Encryption
        P1[Plaintext Block 1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext Block 1]
        
        P2[Plaintext Block 2] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext Block 2]
    end
    
    style E1 fill:#ffcccc
    style E2 fill:#ffcccc
    style K1 fill:#fff4e1
    style K2 fill:#fff4e1
```

**Characteristics:**

- ✗ **Identical plaintexts** → identical ciphertexts (predictable)
- ✓ **No error propagation**: error on $c_j$ affects only $m_j$
- ✗ **Visible patterns**: plaintext structure transparent in ciphertext
- ✓ **Parallelizable**: each block processed independently

**⚠️ Major vulnerability**: Should NOT be used for redundant data

---

#### 2.2 Cipher Block Chaining (CBC)

**Principle**: each plaintext block is **XORed with the previous ciphertext** before encryption.

$$c_i = E_K(m_i \oplus c_{i-1})$$
$$m_i = D_K(c_i) \oplus c_{i-1}$$

With $c_0 = IV$ (Initialization Vector)

```{mermaid}
graph TB
    subgraph Encryption
        IV[IV] --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> C1[Ciphertext c1]
        
        C1 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ccffcc
    style E2 fill:#ccffcc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **Patterns erased**: chaining masks the structure
- ✓ **Limited error propagation**: error on $c_j$ affects $m_j$ and $m_{j+1}$ only
- ✗ **Not parallelizable** in encryption (sequential)
- ✓ **Parallelizable** in decryption

**IV (Initialization Vector):**

- Must be **random** or **pseudo-random**
- Can be transmitted **in clear**
- Must be **different** for each message with the same key

---

#### 2.3 Cipher Feedback Mode (CFB)

**Principle**: works like a **stream cipher** where the keystream is generated by the block cipher. The keystream depends on **previous ciphertexts** (**asynchronous** mode).

$$c_i = m_i \oplus E_K(c_{i-1})$$
$$m_i = c_i \oplus E_K(c_{i-1})$$

With $c_0 = IV$

```{mermaid}
graph TB
    subgraph CFB_Encryption
        IV[IV / ci-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        C1 -.feedback.-> IV
    end
    
    style E1 fill:#ffccff
    style X1 fill:#ffffcc
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **Chaining**: dependencies between ciphertexts
- ⚠️ **Error propagation**: error on $c_j$ affects $\frac{n}{r}$ following blocks
  - $n$ = nominal size of block cipher
  - $r$ = size of plaintexts
- ✗ **Not parallelizable**
- ⚠️ **IV non-confidential** but must be transmitted

**Usage**: suitable for transmissions with frequent packet loss

---

#### 2.4 Output Feedback Mode (OFB)

**Principle**: works like a **synchronous stream cipher**. The keystream is **entirely determined** by the key and IV, **independent** of plaintext and ciphertext.

$$z_i = E_K(z_{i-1})$$
$$c_i = m_i \oplus z_i$$
$$m_i = c_i \oplus z_i$$

With $z_0 = IV$

```{mermaid}
graph TB
    subgraph OFB_Mode
        IV[IV / zi-1] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> Z[zi keystream]
        Z --> X1[⊕]
        P1[Plaintext mi] --> X1
        X1 --> C1[Ciphertext ci]
        Z -.feedback.-> IV
    end
    
    style E1 fill:#cce5ff
    style X1 fill:#ffffcc
    style Z fill:#e1ffe1
```

**Characteristics:**

- ✓ **Identical plaintexts** → different ciphertexts (if IV changes)
- ✓ **No error propagation**: error on $c_j$ affects only $m_j$
- ✓ **Pre-computable keystream**: efficient
- ⚠️ **CRITICAL**: NEVER reuse the same IV with the same key (otherwise identical keystream)
- ✓ **Parallelizable** if keystream pre-computed

**⚠️ Reuse warning**: Change IV for each new message!

::: {.callout-note collapse=true}
### 📄 Original text (CFB and OFB Modes)

#### CFB and OFB Modes: Characteristics

The **CFB and OFB modes** work as a **stream cipher** with a **keystream generated by the encryption block**. In **CFB**, the keystream depends on **previous ciphertexts** (**asynchronous**) whereas in **OFB**, the keystream is **entirely determined by the key and the IV** (**synchronous**).

**Particularities of CFB:**

- As in CBC mode, **identical plaintexts** are translated into **different ciphertexts** if the **IV changes**. The **IV is not necessarily confidential** and can be exchanged in clear between parties.
- **Chaining** also introduces **dependencies** between current ciphertexts and previous ciphertexts. In particular, if $n$ is the **nominal algorithm size** and $r$ is the **plaintext size**, the current ciphertext will depend on the $\frac{n}{r}$ **previous ciphertexts** (each iteration will shift the faulty input by $r$ positions, after $\frac{n}{r}$ iterations the faulty ciphertext will be completely "expelled").
- **Error propagation** follows the same principle: an error in a ciphertext will result in incorrect decryption of the $\frac{n}{r}$ following ciphertexts.

**Particularities of OFB:**

- OFB has **identical behavior** to CBC and CFB modes for **encryption of identical plaintexts**.
- **No error propagation** on adjacent ciphertexts.
- **Modify the IV** if the key does not change to **avoid keystream reuse** !!!
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (CFB/OFB)

**CFB** (asynchronous): keystream = $f$(previous ciphertexts). Limited error propagation ($\frac{n}{r}$ blocks).

**OFB** (synchronous): keystream = $f$(key + IV only). No error propagation.

**CRITICAL**: NEVER reuse same IV with same key. IV transmissible in clear.
:::

---

#### 2.5 Counter Mode (CTR)

**Principle**: the keystream is generated by **encryption of a counter** incremented at each block.

$$c_i = m_i \oplus E_K(counter + i)$$
$$m_i = c_i \oplus E_K(counter + i)$$

```{mermaid}
graph TB
    subgraph CTR_Mode
        CTR1[Counter + 0] --> E1[Block Cipher E]
        K1[Key K] --> E1
        E1 --> X1[⊕]
        P1[Plaintext m1] --> X1
        X1 --> C1[Ciphertext c1]
        
        CTR2[Counter + 1] --> E2[Block Cipher E]
        K2[Key K] --> E2
        E2 --> X2[⊕]
        P2[Plaintext m2] --> X2
        X2 --> C2[Ciphertext c2]
    end
    
    style E1 fill:#ffe6cc
    style E2 fill:#ffe6cc
    style X1 fill:#ffffcc
    style X2 fill:#ffffcc
```

**Characteristics:**

- ✓ **Synchronous mode**: keystream = $f$(counter)
- ✓ **Parallelizable**: keystream pre-computable for encryption AND decryption
- ✓ **Random access**: each block decryptable independently
- ✓ **No error propagation**
- ✓ **Benefits from SIMD architectures**: no dependencies between blocks
- ⚠️ **Counter**: must be of size $2^b$ ($b$ = block size)
- ⚠️ **CRITICAL**: NEVER reuse the same counter with the same key

**Counter management:**

- **Increment modulo** $2^b$ after each iteration
- **Solution**: always increment for each encrypted stream
- First block of stream $i+1$ > last block of stream $i$

**Applications:**

- **ATM** (Asynchronous Transfer Mode)
- **IPsec** (IP security)
- **High-speed lines**: selective transmission of blocks
- **Large volume transfers**: video

::: {.callout-note collapse=true}
### 📄 Original text (Counter Mode)

#### Counter Mode (CTR Mode)

Frequently used as encryption support in data transfer protocols like **ATM** (Asynchronous Transfer Mode) and **IPsec** (IP security).

#### Counter Mode (II)

- The **keystream** is generated by the **encryption of a random counter** of size $2^b$ (with $b$ the block size) and necessary for decryption. This counter is **incremented modulo** $2^b$ after each iteration.
- Works in **synchronous mode**. **Reuse of the same counter** results in an **identical keystream** !
- **Solution**: Always **increment the counter** for each encrypted stream such that the counter of the first block of a stream is **larger than the last block** of the previous stream.
- **Easily parallelizable**: The keystream can be **pre-calculated** both for encryption and decryption. Fully benefits from **SIMD architectures** because unlike other chaining modes there are no **dependencies between operations** of different blocks.
- **Random access** to encryption/decryption of each block: Unlike other chaining modes where the $i$-th operation depends on the $(i-1)$-th operation.
- If we add **absence of error propagation**, the counter mode facilitates **selective (re)transmission** of ciphertext blocks, making it very attractive for **securing high-speed lines** as well as for **encrypted transfers of large volumes** of information (e.g. video).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (Counter Mode)

**CTR**: keystream = $E_K$(counter + $i$).

**Advantages**: parallelizable (encryption + decryption), random access, no error propagation, SIMD-friendly.

**CRITICAL**: never reuse counter.

**Usage**: ATM, IPsec, high speed, video.
:::

---

### 3. Product Ciphers and Feistel Ciphers

#### Product Ciphers

**Definition**: encryption scheme combining a **series of successive transformations** to strengthen resistance to cryptanalysis.

**Common transformations:**

- Transpositions (permutations)
- Substitutions (S-boxes)
- XORs
- Linear combinations
- Modular multiplications

#### Feistel Ciphers

**Definition**: iterative product cipher with specific structure.

**Operating principle:**

- **Input**: plaintext of $2t$ bits = $(L_0, R_0)$ (two sub-blocks of $t$ bits)
- **Output**: ciphertext of $2t$ bits = $(R_r, L_r)$ after $r$ steps (rounds)
- **Each step**: invertible bijection (for unique decryption)

**Equations of step** $i$ ($1 \leq i \leq r$):

$$(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$$

With:

- $L_i = R_{i-1}$
- $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$

```{mermaid}
graph TB
    subgraph Feistel_Round
        L0[Li-1] --> R1[Ri = Li-1 ⊕ f]
        R0[Ri-1] --> L1[Li = Ri-1]
        R0 --> F[Function f]
        K[Key Ki] --> F
        F --> XOR[⊕]
        L0 --> XOR
        XOR --> R1
    end
    
    style F fill:#ffcccc
    style XOR fill:#ffffcc
    style K fill:#fff4e1
```

**Characteristics:**

- $K_i$: subkeys generated from the main key $K$
- Number of steps $r$: generally **even** and $\geq 3$
  - Example: DES has 16 steps
- **Final permutation**: $(L_r, R_r) \rightarrow (R_r, L_r)$
- **Decryption**: identical to encryption but subkeys applied in **reverse order** (from $K_r$ to $K_1$)

**Frequent operations:**

- Permutations
- Substitutions (S-boxes)

::: {.callout-note collapse=true}
### 📄 Original text

#### Product Ciphers and Feistel Ciphers

- A **product cipher** is an **encryption scheme** combining a **series of successive transformations** to **strengthen resistance to cryptanalysis**. Common transformations for a product cipher are: **transpositions**, **substitutions**, **XORs**, **linear combinations**, **modular multiplications**, etc.

- A **Feistel cipher** is an **iterative product cipher** capable of transforming a **plaintext of $2t$ bits** of the form $(L_0, R_0)$ composed of two **sub-blocks** $L_0$ and $R_0$ of $t$ bits into a **ciphertext of size $2t$** of the form $(R_r, L_r)$ after $r$ **successive steps (rounds)** with $r \geq 1$. **Each step** defines a **bijection (inversible !)** to allow unique decryption.

- **Permutations** and **substitutions** are the most frequent operations.

- The steps $1 \leq i \leq r$ are written: $(L_{i-1}, R_{i-1}) \xrightarrow{K_i} (L_i, R_i)$ with $L_i = R_{i-1}$ and $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$. The $K_i$ are **sub-keys**, **different for each step**, generated from the **main key $K$** of the encryption scheme.

- The **number of steps** proper to a Feistel cipher is normally **even** and $\geq 3$ (e.g. **DES has 16 steps**)

- After execution of all steps, a Feistel cipher performs a **permutation** of the two parts $(L_r, R_r)$ into $(R_r, L_r)$.

- The **decryption** of a Feistel Cipher is **identical to encryption** except that the sub-keys $K_i$ are applied in **reverse order** (From $K_r$ to $K_1$).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision

**Product cipher**: combination of successive transformations (transpositions, substitutions, XOR).

**Feistel cipher**:

  - iterative product cipher
  - plaintext $2t$ bits = $(L_0, R_0)$
  - $r$ rounds with $L_i = R_{i-1}$ and $R_i = L_{i-1} \oplus f(R_{i-1}, K_i)$.
  - Decryption = encryption with reversed sub-keys.
  - Example: DES (16 rounds).
:::

---

### 4. Data Encryption Standard (DES)

#### General Presentation

**DES** (Data Encryption Standard): most important cryptographic algorithm until the advent of AES in 2001.

**Main characteristics:**

- **Type**: Feistel Cipher
- **Block size**: 64 bits (nominal size)
- **Key size**: 56 effective bits (64 total bits with 8 parity bits)
- **Number of steps**: 16 rounds
- **Subkeys**: 16 subkeys of 48 bits (one per step)
- **Usage modes**: ECB, CBC, CFB, OFB

```{mermaid}
graph TB
    subgraph DES_Overview
        P[Plaintext 64 bits] --> DES[DES Encryption]
        K[Key 56 bits] --> DES
        DES --> C[Ciphertext 64 bits]
        
        C --> DES_INV[DES Decryption]
        K2[Key 56 bits] --> DES_INV
        DES_INV --> P2[Plaintext 64 bits]
    end
    
    style DES fill:#ffcccc
    style DES_INV fill:#ccffcc
    style K fill:#fff4e1
    style K2 fill:#fff4e1
```

#### DES Structure

**Main components:**

1. **Initial permutation (IP)**: permutation of the 64 input bits
2. **16 Feistel rounds**: iterative transformation
3. **Final permutation (IP⁻¹)**: inverse of IP

**Each round applies:**

- Division into two halves: $L_{i-1}$ and $R_{i-1}$ (32 bits each)
- Function $f$ on $R_{i-1}$ with subkey $K_i$
- XOR with $L_{i-1}$
- Exchange of halves

```{mermaid}
graph TB
    Plain[Plaintext 64 bits] --> IP[Initial Permutation IP]
    IP --> Split[Split L0, R0]
    
    Split --> Round1[Round 1]
    K1[K1] --> Round1
    Round1 --> Round2[Round 2]
    K2[K2] --> Round2
    Round2 --> Dots[...]
    Dots --> Round16[Round 16]
    K16[K16] --> Round16
    
    Round16 --> Swap[Swap R16, L16]
    Swap --> IP_inv[Final Permutation IP⁻¹]
    IP_inv --> Cipher[Ciphertext 64 bits]
    
    style IP fill:#e1f5ff
    style IP_inv fill:#e1f5ff
    style Round1 fill:#ffcccc
    style Round2 fill:#ffcccc
    style Round16 fill:#ffcccc
```

#### DES Cipher Function

The **function $f$** for each round:

1. **Expansion E**: 32 bits → 48 bits (table E)
2. **Key Addition**: XOR with subkey $K_i$ (48 bits)
3. **S-boxes**: 8 S-boxes transform 48 bits → 32 bits
   - Each S-box: 6 bits input → 4 bits output
4. **Permutation P**: permutation of the resulting 32 bits

```{mermaid}
graph TB
    R[Ri-1 32 bits] --> E[Expansion E]
    E --> E_out[48 bits]
    E_out --> XOR1[⊕]
    K[Ki 48 bits] --> XOR1
    XOR1 --> S[8 S-boxes]
    S --> S_out[32 bits]
    S_out --> P[Permutation P]
    P --> F_out[f output 32 bits]
    
    style E fill:#cce5ff
    style S fill:#ffcccc
    style P fill:#e1ffe1
    style XOR1 fill:#ffffcc
```

**S-box operation:**

Input: $a_1a_2a_3a_4a_5a_6$ (6 bits)

- **Row**: $a_1 + 2a_6$ (external bits)
- **Column**: $a_2 + 2a_3 + 4a_4 + 8a_5$ (internal bits)
- **Output**: value of the corresponding cell (4 bits)

#### Subkey Generation

**Process:**

1. Main key: 64 bits (56 effective + 8 parity)
2. **Permuted Choice 1 (PC-1)**: selection of 56 bits
3. Division into two halves: $C_0$ and $D_0$ (28 bits each)
4. For each round $i$:
   - Left circular rotation of $C_{i-1}$ and $D_{i-1}$
   - **Permuted Choice 2 (PC-2)**: selection of 48 bits for $K_i$

**Rotations:**

- Rounds 1, 2, 9, 16: 1 position
- Other rounds: 2 positions

::: {.callout-note collapse=true}
### 📄 Original text (DES Operation)

#### DES: Operation

**Cipher Function**

- **Expansion E**: The **32 bits of the input** are transformed into a vector of **48 bits** using the **table E**. The first line of this table indicates how the first sub-block of 6 bits will be generated: first take the 32nd bit then bits 1,2,3,4,5. The second sub-block starts with the 4th bit then bits 5,6,7,8,9 and so on...

- **Key addition**: **XOR of the 48-bit vector** with the key.

- **S-boxes**: Apply **8 S-boxes** on the resulting 48-bit vector. Each of these S-boxes takes a **6-bit sub-block** and transforms it into a **4-bit sub-block**. The operation is performed as follows: If we denote the 6 input bits of the S-box as: $a_1a_2a_3a_4a_5a_6$. The output is given by the content of the cell located in the **row** $a_1 + 2a_6$ and the **column** $a_2 + 2a_3 + 4a_4 + 8a_5$.

- **Permutation P**: Permutation P works as follows: The first bit is sent to the 16th position, the second to the 7th position and so on.

**Permutations IP and IP⁻¹**

- Act respectively at the **beginning** and at the **end** of the block processing and on the **entirety of the 64 bits**.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (DES)

**DES**: Feistel cipher, 64-bit blocks, 56-bit effective key, 16 rounds.

**Function $f$**: Expansion E (32→48 bits) → XOR $K_i$ → 8 S-boxes (48→32 bits) → Permutation P.

**S-box**: 6 bits input → 4 bits output via table (row = external bits, column = internal bits).

**Permutations**: IP (initial) and IP⁻¹ (final) on 64 bits.
:::

---

### 5. Triple-DES and DES Security

#### DES Vulnerabilities

**Main problem**: key space size $\{0,1\}^{56}$ insufficient.

**Brute force attack:**

- **1999**: key found in **24 hours**
- Technique: massively parallel brute force (100,000 PCs on Internet)
- Known plaintext attack

#### Triple-DES (3DES)

**Solution**: increase key space to $\{0,1\}^{112}$.

**Scheme:**

$$C = E_{K_1}(D_{K_2}(E_{K_1}(P)))$$

With:

- $E$: DES encryption
- $D$: DES decryption
- $K_1, K_2$: two 56-bit keys

```{mermaid}
graph LR
    P[Plaintext 64 bits] --> E1[DES Encrypt K1]
    E1 --> D[DES Decrypt K2]
    D --> E2[DES Encrypt K1]
    E2 --> C[Ciphertext 64 bits]
    
    K1a[Key K1 56 bits] --> E1
    K2[Key K2 56 bits] --> D
    K1b[Key K1 56 bits] --> E2
    
    style E1 fill:#ffcccc
    style D fill:#ccffcc
    style E2 fill:#ffcccc
```

**Advantages:**

- ✓ **Satisfactory security**: key space $2^{112}$
- ✓ **Compatibility**: reuse of existing DES hardware/software
- ✓ **Gradual migration**: while waiting for AES

**Disadvantage:**

- ✗ **Performance**: 3× slower (3 successive DES executions)

#### DES Properties

**1. DES is not a group**

DES is NOT a group under composition:

$$\nexists K_3 \text{ such that } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)$$

**Consequence**: composite encryption (Triple-DES) considerably increases security.

**If DES were a group**: exhaustive search on $\{0,1\}^{56}$ would break the algorithm regardless of the number of consecutive executions.

**2. Weak and semi-weak keys**

- **Weak key**: $E_K(E_K(x)) = x$

- **Pair of semi-weak keys**: $E_{K_1}(E_{K_2}(x)) = x$

**Characteristic**: weak keys generate identical subkeys in pairs:

- $k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$
- Facilitates cryptanalysis

**DES has 4 weak keys:**

| Weak key (hexadecimal) |
|---------------------------|
| 0101 0101 0101 0101 |
| 0101 0101 FEFE FEFE |
| FEFE FEFE FEFE FEFE |
| FEFE FEFE 0101 0101 |

**And 6 pairs of semi-weak keys**

::: {.callout-note collapse=true}
### 📄 Original text (DES and 3DES)

#### DES and Triple-DES

- The **size of the key set** ($\{0,1\}^{56}$) constitutes the **greatest threat** weighing on DES with current computing resources. In **1999** it took only **24 hours** to find the key from a **known plaintext** using a **massively parallel brute force technique** (100,000 PCs connected to the Internet).

- **Triple DES** protects us from these **brute force attacks** by increasing the **possible key space** to $\{0,1\}^{112}$.

- This alternative allows continuing to use **DES "boxes"** (hardware and software) while waiting for migration to AES.

- The **security level** obtained by this solution is **very satisfactory**.

- The **performance impact** of three successive DES executions remains a **disadvantage** for some applications.

#### DES: properties

- **DES is not a group** (in the algebraic sense) under composition: In other words, DES being a permutation: $\{0,1\}^{64} \rightarrow \{0,1\}^{64}$, if DES were a group under composition, this would mean that: $\exists K_3$ such that $E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)$

  This property ensures that **composite encryption** (like Triple-DES) **considerably increases the security** of DES. If DES were a group, exhaustive search on the possible key set ($\{0,1\}^{56}$) would allow "breaking" the algorithm **regardless of the number of consecutive executions** of DES.

- **Weak and semi-weak keys** (weak and semi-weak keys):
  - A key $K$ is said to be **weak** if $E_K(E_K(x)) = x$.
  - A pair of keys $(K_1, K_2)$ is said to be **semi-weak** if $E_{K_1}(E_{K_2}(x)) = x$.

- Weak keys have the particularity of generating **identical subkeys in pairs** ($k_1 = k_{16}$, $k_2 = k_{15}$, ..., $k_8 = k_9$), which **facilitates cryptanalysis**.

- **DES has 4 weak keys** (and 6 pairs of semi-weak keys).
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (3DES and security)

**DES vulnerability**: key space $2^{56}$ breakable in 24h (1999). **Triple-DES**: $E_{K_1}(D_{K_2}(E_{K_1}(P)))$, space $2^{112}$, reuses DES hardware, 3× slower. **DES ≠ group** → composite encryption strengthens security. **4 weak keys** generating identical subkeys in pairs → facilitates cryptanalysis.
:::

---

### 6. Advanced Encryption Standard (AES)

#### General Presentation

**AES** (Advanced Encryption Standard): standard adopted in November 2001.

**Design**: Johan Daemen and Vincent Rijmen (original name: **Rijndael**)

**Main characteristics:**

- **Type**: iterative block cipher (but **NOT a Feistel Cipher**)
- **Block size**: 128 bits
- **Variable key size**: 128, 192 or 256 bits
- **Number of rounds**: depends on key size
  - 10 rounds for 128-bit key
  - 12 rounds for 192-bit key
  - 14 rounds for 256-bit key
- **Usage modes**: ECB, CBC, CFB, OFB, CTR

**Advantages over DES:**

- ✓ **Open process**: consultation and analysis by worldwide experts
- ✓ **~2× more performant** in software
- ✓ **~10²² times more secure** (theoretically)
- ✓ **Scalable**: key size can be increased if necessary

#### AES Structure

**Basic unit**: **State** matrix of 4 rows × 4 columns (for 128-bit key)

- Each element = 1 byte
- **Total**: 16 bytes = 128 bits

**Operations on field** $GF(2^8)$:

- Byte = element of $GF(2^8)$
- Finite field of polynomials of degree ≤ 7 with coefficients in $GF(2)$
- Additions, multiplications defined in $GF(2^8)$

```{mermaid}
graph TB
    subgraph State_Matrix
        S00[s0,0] --- S01[s0,1]
        S01 --- S02[s0,2]
        S02 --- S03[s0,3]
        
        S10[s1,0] --- S11[s1,1]
        S11 --- S12[s1,2]
        S12 --- S13[s1,3]
        
        S20[s2,0] --- S21[s2,1]
        S21 --- S22[s2,2]
        S22 --- S23[s2,3]
        
        S30[s3,0] --- S31[s3,1]
        S31 --- S32[s3,2]
        S32 --- S33[s3,3]
    end
    
    style S00 fill:#ffe6cc
    style S11 fill:#ffe6cc
    style S22 fill:#ffe6cc
    style S33 fill:#ffe6cc
```

#### AES Round Detail

**Four operations per round:**

**1. SubBytes (ByteSub)**

- Non-linear substitution via **S-box**
- Each byte transformed independently
- Resistance to linear and differential cryptanalysis

**2. ShiftRows**

- **Permutation of bytes** with variable shifts per row
- Row 0: no shift
- Row 1: left shift 1 position
- Row 2: left shift 2 positions
- Row 3: left shift 3 positions

**3. MixColumns**

- Each column = linear combination of other columns
- **Matrix multiplication** in $GF(2^8)$
- Maximum diffusion

**4. AddRoundKey**

- **XOR** of the State matrix with the round subkey
- Subkey = result of Key Schedule

```{mermaid}
graph TB
    Input[State Input] --> SB[SubBytes]
    SB --> SR[ShiftRows]
    SR --> MC[MixColumns]
    MC --> ARK[AddRoundKey]
    K[Round Key] --> ARK
    ARK --> Output[State Output]
    
    style SB fill:#ffcccc
    style SR fill:#ccffcc
    style MC fill:#cce5ff
    style ARK fill:#ffffcc
```

**Final round**: identical EXCEPT **no MixColumns**

#### Key Schedule (Subkey Generation)

**Process:**

1. **Key Expansion**: generation of an extended matrix
   - Key 128 bits → matrix 4 × 4 × ($N_e$ + 1) bytes
   - $N_e$ = number of rounds
2. **Key Selection**: extraction of subkeys
   - First subkey: first 4 columns
   - Second subkey: next 4 columns
   - Etc.

**Operations:**

- Byte rotations
- Substitutions via S-box
- XOR with constants (Rcon)

#### AES Pseudo-code

```
Rijndael(State, CipherKey) {
    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule
    
    AddRoundKey(State, ExpandedKey[0..3]); // Initial XOR
    
    for(i = 1; i < Ne; i++) {
        Round(State, ExpandedKey[4*i...(4*i)+3]);
    }
    
    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Without MixColumns
}
```

#### AES Decryption

**Principle**: apply the **inverse operations** in each round.

**Inverse operations:**

- **InvSubBytes**: inverse substitution via S-box⁻¹
- **InvShiftRows**: right shifts (instead of left)
- **InvMixColumns**: inverse matrix multiplication
- **AddRoundKey**: self-inverse (XOR)

**Order**: inverse of encryption with subkeys in reverse order

::: {.callout-note collapse=true}
### 📄 Original text (AES)

#### Advanced Encryption Standard (AES)

- Adopted as **standard in November 2001**, designed by **Johan Daemen and Vincent Rijmen** (hence its original name **Rijndael**).

- It is also an **iterative block cipher** (like DES) but **not a Feistel Cipher**.

- **Plaintext/Ciphertext Blocks**: **128 bits**.

- **Variable key length**: **128, 192, or 256 bits**.

- Unlike DES, AES comes from an **open consultation and analysis process** involving worldwide experts.

- Techniques similar to DES (substitutions, permutations, XOR…) complemented by **simple and very performant algebraic operations**.

- All operations are performed in the **field** $GF(2^8)$: the finite field of **polynomials of degree ≤ 7** with **coefficients in** $GF(2)$.

- In particular, a **byte for AES is an element in** $GF(2^8)$ and the **operations on bytes** (additions, multiplications,...) are **defined as in** $GF(2^8)$.

- **~2 times more performant** (in software) and **~10²² times (in theory...) more secure** than DES...

- **Scalable**: The key size can be increased if necessary.

##### Detail of an AES Step (round)

The **basic unit** on which calculations are applied is a **matrix of 4 rows and 4 columns** (in the case of a 128-bit key) whose elements are **bytes**:

- **ByteSub**: **Non-linear operation (S-box)** designed to **resist linear and differential cryptanalysis**.

- **ShiftRow**: **Permutation of bytes** introducing **variable shifts** on the rows.

- **MixColumn**: Each column is replaced by **linear combinations** of the other columns (**matrix multiplication** !)

- **AddRoundKey**: **XOR** of the current matrix with the **subkey** corresponding to the current step.

##### AES: Global Operation

- The **number of steps** of AES varies depending on the **key size**. For a **128-bit key**, **10 steps** must be performed. Each increase of 32 bits in the key size entails an **additional step** (14 steps for 256-bit keys).

- **Decryption** consists of applying the **inverse operations** in each of the steps (**InvSubBytes**, **InvShiftRows**, **InvMixColumns**). **AddRoundKey** (because of XOR) is **its own inverse**.

- The **Key Schedule** consists of:
  - An operation of **key expansion** of the main key. If $N_e$ is the number of steps (depending on the key), a **matrix of 4 rows and 4 × ($N_e$ + 1) columns** is generated.
  - An operation of **step key selection**: The **first subkey** will be constituted by the **first 4 columns** of the matrix generated during expansion and so on.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (AES)

**AES** (Rijndael 2001): iterative block cipher (NOT Feistel), 128-bit blocks, keys 128/192/256 bits → 10/12/14 rounds.

**State**: 4×4 byte matrix in $GF(2^8)$.

**4 operations/round**:

  - SubBytes (non-linear S-box)
  - ShiftRows (row shifts)
  - MixColumns (linear combinations)
  - AddRoundKey (XOR subkey).

2× faster than DES, 10²² times more secure.
:::

---

### 7. Attacks and AES Security

#### AES Strengths

**Simplicity and performance:**

- ✓ Simple and efficient algorithm
- ✓ Works on limited platforms (8-bit smart cards)
- ✓ Hardware and software optimizations

#### Published Attacks

**1. Algebraic attacks (2002)**

**XSL technique** (N. Courtois and P. Pieprzyk):

- Represents AES as **system of 8000 quadratic equations** with 1600 binary unknowns
- **Estimated effort**: $2^{100}$ operations (still a conjecture)
- **Characteristic**: requires few known plaintexts
- **Distinction**: different from linear/differential attacks

**Critique**: based on the "highly algebraic" character of AES (largely contested)

**2. Related Key Attacks (2009-2011)**

**Principle**: attacks based on **similar keys**

- Interesting results on **reduced versions** of AES
- Do not compromise full AES

**3. Side Channel Attacks**

**Principle**: attacks on **implementation** (not the algorithm)

**Techniques:**

- **Cache timing attacks**: cache access analysis
- **Power analysis**: power consumption
- **Electromagnetic analysis**: electromagnetic emissions

**Example** (2005): Osvik, Shamir, Tromer

- Extraction of 128-bit key with **6-7 plaintext/ciphertext pairs**
- Based on **cache access** analysis

**4. Meet in the Middle on biclique structures (2011-2015)**

**Result:**

- Reduces effort for AES-128 to **$2^{126}$** (factor 4 vs brute force)
- **Remains well above** current capabilities

#### Practical Security

**Fundamental assumption**: key of **maximum entropy**

**Recent attacks** (WPA2, etc.):

- Exploit **weakness of passwords/passphrases**
- No flaw in AES itself
- Problem: key generation from weak passwords

**⚠️ Critical reminder**: key quality = system security

::: {.callout-note collapse=true}
### 📄 Original text (AES Attacks)

#### AES: Final Remarks and Attacks (I)

- The greatest **strength of AES** lies in its **simplicity** and its **performance**, including on **reduced computing capacity platforms** (e.g. **smart cards** with 8-bit processors).

- Since its official publication, **many cryptanalysis works** have been published with very interesting results. In particular, **N. Courtois and P.Pieprzyk** presented a technique called **XSL** allowing to represent AES as a **system of 8000 quadratic equations** with **1600 binary unknowns**. The **effort needed** to break this system is estimated (it is still a **conjecture**...) to be **$2^{100}$**.

- These attacks are based on the **highly algebraic character** (and largely contested...) of AES. Moreover, only **a few known plaintexts** are needed to set them up, which distinguishes them from linear and differential attacks.

- In recent years (2009-2011) **attacks based on similar keys** (related key attacks) have obtained interesting results on **reduced versions** of AES.

- Another family of attacks called **side channel attacks** acting directly on the **algorithm implementation** allows extracting cryptographically relevant information during encryption execution.

#### AES: Final remarks and Attacks (II)

- In **2015** a **Meet in the Middle** type attack based on **biclique structures** showed that it was possible to reduce the **effort needed** to find an AES-128 key to **$2^{126}$**, i.e., a **factor of 4** compared to brute force. This nevertheless remains **well above** current computing capabilities.

- Another family of attacks called **side channel attacks** acting directly on the **algorithm implementation** allows extracting cryptographically relevant information during encryption execution. In particular, the authors manage to **extract the 128-bit key** with only **6-7 plaintext/ciphertext pairs** based on **cache accesses**.

- The **security of AES** (as for any other encryption algorithm) is always based on the assumption of a **key of maximum entropy**. The **attacks published recently** on protocols based on AES (like WPA2) exploit the **weakness of passwords/passphrases** that are the origin of the keys used.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (AES Security)

**Strengths**: simplicity, performance (even 8-bit cards). **Attacks**: XSL ($2^{100}$, algebraic), related keys (reduced versions), side channel (implementation, cache), Meet-in-Middle biclique ($2^{126}$). **Security**: assumption of max entropy key. Practical attacks = weak passwords, not AES flaw.
:::

---

### 8. Block Cipher Cryptanalysis Techniques

#### 8.1 Differential Cryptanalysis

**Principle**: **chosen plaintext** attack analyzing the **propagation of differences** between two plaintexts through the rounds.

**Method:**

1. Choose two plaintexts with known difference: $x_a$ and $x_b$
2. Observe propagation: $\Delta x = x_a \oplus x_b$
3. Analyze ciphertexts: $\Delta y = y_a \oplus y_b$
4. **Assign probabilities to keys** according to observed changes
5. **Most probable key** = correct key (after many trials)

**Characteristics:**

- Requires **$2^{47}$ chosen plaintext pairs** for DES
- **Probabilities**: depend on S-boxes and structure
- The more pairs increase, the more success probability increases

**Sensitivity**: very sensitive to **number of rounds**

- Chances of success increase **exponentially** when rounds decrease

#### 8.2 Linear Cryptanalysis

**Principle**: **known plaintext** attack creating a **linear simulator** of the block cipher.

**Method:**

1. Create **linear approximations** of the algorithm
2. Analyze a large number of plaintext/ciphertext pairs
3. The bits of the simulator key **tend to coincide** with those of the real key (probabilistic calculation)

**Complexity for DES:**

- **$2^{38}$ known plaintexts** → 10% probability of guessing correctly
- **$2^{43}$ known plaintexts** → 85% success probability

**Characteristics:**

- **Most powerful analytical attack** to date on block ciphers
- Also **sensitive to number of rounds**

#### 8.3 Differential vs Linear Comparison

**Common difficulties:**

- ✗ **Parallelization**: less efficient than parallel brute force
- ⚠️ **Sensitivity to rounds**: efficiency decreases exponentially with number of rounds

**DES and these attacks:**

- Widespread conjecture: DES designers **knew these attacks** (1970s, unpublished at the time)
- **S-box design**: very high resistance to both techniques

#### 8.4 Meet-in-the-Middle Attack

**Principle**: exploits **composite constructions** of type $y = E_{K_2}(E_{K_1}(x))$.

**Method:**

1. Build list $L_1$: $L_1 = \{E_{K_1}(x) \mid K_1 \in \text{KeySpace}\}$
2. Build list $L_2$: $L_2 = \{D_{K_2}(y) \mid K_2 \in \text{KeySpace}\}$
3. Identify **repeated elements** in $L_1$ and $L_2$
4. Verify hypothesis with **second known plaintext**
5. The associated keys $K_1$ and $K_2$ are probably the sought keys

**Example for DES:**

Intuitive key space for $E_{K_2}(E_{K_1}(x))$: $\{0,1\}^{112}$

**Actual effort:**

- **$2^{57}$ operations** to establish the two lists
- **$2^{56}$ blocks** of 64 bits storage
- **Significantly lower** than the intuitive $2^{112}$

**Applications:**

- Attacks on **composite constructions**
- **Internal** cryptanalysis of block ciphers

```{mermaid}
graph TB
    subgraph Meet_in_Middle
        X[Known Plaintext x] --> E1[Encrypt K1]
        E1 --> M[Middle Value m]
        M --> E2[Encrypt K2]
        E2 --> Y[Known Ciphertext y]
        
        X2[x] --> L1[List L1: EK1 for all K1]
        Y2[y] --> L2[List L2: DK2 for all K2]
        
        L1 -.match.-> Match[Find common m]
        L2 -.match.-> Match
    end
    
    style M fill:#ffffcc
    style Match fill:#ccffcc
```

::: {.callout-note collapse=true}
### 📄 Original text (Cryptanalysis)

#### Block Cipher Cryptanalysis Techniques

**Differential Cryptanalysis**

- This is a **chosen plaintext attack** that focuses on the **propagation of differences** in two plaintexts as they evolve through the different steps of the algorithm.

- It **assigns probabilities to keys** it "guesses" based on the **changes** they induce on the ciphertexts. The **most probable key** has a good chance of being the correct key after a **large number** of plaintext/ciphertext pairs.

- Requires **$2^{47}$ chosen plaintext pairs** (for DES) to obtain correct results.

**Linear Cryptanalysis**

- This is a **known plaintext attack** that creates a **block simulator** from **linear approximations**. By analyzing a **large number** of plaintext/ciphertext pairs, the **bits of the simulator key** tend to **coincide** with those of the analyzed block cipher (**probabilistic calculation**)

- For DES an attack based on this technique requires **$2^{38}$ known plaintexts** to obtain a probability of **10%** of guessing correctly and **$2^{43}$ for 85%** !

- It is the **most powerful analytical attack** to date on block ciphers.

#### Block Cipher Cryptanalysis Techniques (II)

- The practical implementation of **differential and linear attacks** presents **difficulties in parallelizing** calculations compared to an exhaustive key search.

- These two attacks are **very sensitive to the number of steps** of the block cipher: chances of success increase **exponentially** as the number of algorithm steps decreases.

- A widespread conjecture among cryptographers is that these attacks, at the time **unpublished**, were **known to the designers of DES**. In particular, the **design of the S-boxes** offers a **very high resistance** to both techniques.

**Meet-in-the-Middle Attack**

- Applies to constructions of the type $y := E_{K_2}(E_{K_1}(x))$. For DES, the key space for this solution would be $\{0,1\}^{112}$. First build **two lists** $L_1$ and $L_2$ of $2^{56}$ messages of the form: $L_1 = E_{K_1}(x)$ and $L_2 = D_{K_2}(y)$ with $E$ and $D$ the encryption and decryption operations respectively. Then **identify elements that repeat** in both lists and **verify our hypothesis** with a second known plaintext. The $K_1$ and $K_2$ associated with this pair of known plaintexts will (in all likelihood) be **the sought keys** !

- **Effort required** to carry out the attacks (for DES): **$2^{57}$ operations** to establish the two lists + **$2^{56}$ blocks** of 64 bits of storage to memorize intermediate results... **significantly lower** than the intuitive $2^{112}$...

- These meet-in-the-middle techniques are also applied to the **internal cryptanalysis** of block ciphers.
:::

::: {.callout-tip collapse=true}
### 📌 Quick revision (Cryptanalysis)

**Differential**: chosen plaintext, difference propagation, probabilities on keys, $2^{47}$ pairs (DES).

**Linear**: known plaintext, linear approximations, $2^{38}$-$2^{43}$ plaintexts (DES), most powerful attack.

**Meet-in-Middle**: composite constructions, 2 lists $2^{56}$, effort $2^{57}$ << $2^{112}$.

**Sensitivity**: very dependent on number of rounds.
:::
# Asymmetric Cryptography (Public Key Cryptography)

## Mathematical Foundations

### Fundamental Theorem of Arithmetic and Euler's Totient Function

Asymmetric cryptography relies on solid mathematical foundations from number theory. Two concepts are essential:

**Fundamental Theorem of Arithmetic**: Every positive integer greater than 1 can be written uniquely (up to order) as a product of prime powers:

$$n = p_1^{e_1} \cdot p_2^{e_2} \cdot p_3^{e_3} \cdots p_m^{e_m}$$

**Euler's Totient Function $\phi(n)$**: Number of positive integers smaller than $n$ that are coprime with $n$.

To compute $\phi(n)$:

$$\phi(n) = \prod_{i=1}^{m} p_i^{e_i} \cdot \left(1 - \frac{1}{p_i}\right)$$

**Important special case**: If $n = p \cdot q$ with $p$ and $q$ prime, then:

$$\phi(n) = (p-1)(q-1)$$

::: {.callout-note collapse=true title="Original Text"}
### Mathematical Foundations

**Fundamental Theorem of Arithmetic**: Every positive integer $n$ can be written uniquely (up to order) as a product of powers of distinct prime numbers $p_i$:

$$n = p_1^{e_1} \cdot p_2^{e_2} \cdot p_3^{e_3} \cdots p_m^{e_m}$$

**Euler's Totient Function**: Let $n \in \mathbb{Z}^+$, the **Euler's totient function** $\phi(n)$ is equal to the number of positive integers smaller than $n$ that are **relatively prime** to $n$.

**Calculation of Euler's totient function**: According to the fundamental theorem of arithmetic, every integer $n > 1$ can be written as:

$$n = \prod_{i=1}^{m} p_i^{e_i}$$

then $\phi(n)$ is calculated as:

$$\phi(n) = \prod_{i=1}^{m} \left(p_i^{e_i} - p_i^{e_i-1}\right)$$

In particular, if $n = p \cdot q$ with $p$ and $q$ prime, then:

$$\phi(n) = (p-1)(q-1)$$
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Unique decomposition**: every integer = product of prime numbers
- **$\phi(n)$**: counts integers $< n$ coprime with $n$
- **Key for RSA**: if $n = pq$ (primes) then $\phi(n) = (p-1)(q-1)$
:::

---

### Euler's Theorem and Fermat's Little Theorem

These theorems are at the heart of RSA and other asymmetric algorithms.

**Euler's Theorem**: If $n \in \mathbb{Z}^+$ and $a \in \mathbb{Z}$ with $\text{gcd}(a,n) = 1$, then:

$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**Fermat's Little Theorem** (special case if $n = p$ prime): If $a \in \mathbb{Z}$ and $p$ prime does not divide $a$:

$$a^{p-1} \equiv 1 \pmod{p}$$

**Important applications**:

1. **Exponent reduction**: If $n$ is a product of distinct primes and $r \equiv s \pmod{\phi(n)}$, then:
   $$a^r \equiv a^s \pmod{n}$$

2. **Calculation of inverses**: $a^{\phi(n)-1}$ is the inverse of $a$ modulo $n$. In particular, if $p$ is prime, $a^{p-2}$ is the inverse of $a$ modulo $p$.

::: {.callout-note collapse=true title="Original Text"}
### Mathematical Foundations (II)

**Euler's Theorem**: Let $n \in \mathbb{Z}^+$ and $a \in \mathbb{Z}$ with $\text{gcd}(a,n) = 1$, then we have:

$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**Fermat's Little Theorem** (special case of Euler's theorem if $n$ is prime): Let $a \in \mathbb{Z}$ and $p$ a prime number such that $p$ does not divide $a$, then we have:

$$a^{p-1} \equiv 1 \pmod{p}$$

Note that since $p$ is prime, we have $\phi(p) = p-1$.

**Exponent reduction** $\bmod \phi(n)$: If $n$ is the product of distinct primes and $r, s \in \mathbb{Z}$ such that $r \equiv s \pmod{\phi(n)}$ then $\forall a \in \mathbb{Z}$:

$$a^r \equiv a^s \pmod{n}$$

**Application of Euler's Theorem to inverse calculation**: From Euler's theorem, we have that:

$$a \cdot a^{\phi(n)-1} \equiv 1 \pmod{n}$$

which means that $a^{\phi(n)-1}$ is the **inverse of $a$ modulo $n$**. In particular, $a^{p-2}$ is the inverse of $a$ modulo $n$ if $p$ is prime.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Euler's Theorem**: $a^{\phi(n)} \equiv 1 \pmod{n}$
- **Fermat**: special case if $p$ prime: $a^{p-1} \equiv 1 \pmod{p}$
- **Modular inverse**: $a^{-1} \equiv a^{\phi(n)-1} \pmod{n}$
- **Base of RSA**: enables encryption/decryption with exponents
:::

---

### Multiplicative Groups and Generators

**Multiplicative group $\mathbb{Z}_n^*$**: Set of elements of $\mathbb{Z}_n$ coprime with $n$:

$$\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n \mid \text{gcd}(a,n) = 1\}$$

If $n$ is prime: $\mathbb{Z}_n^* = \{1, 2, \ldots, n-1\}$

**Order of an element**: Smallest positive integer $t$ such that $a^t \equiv 1 \pmod{n}$

**Generator**: An element $\alpha$ is a generator of $\mathbb{Z}_n^*$ if its order is $\phi(n)$. Then $\mathbb{Z}_n^*$ is said to be **cyclic**.

**Properties of generators**:

1. $\mathbb{Z}_n^*$ has a generator iff $n = 2, 4, p^k$ or $2p^k$ (with $p$ prime, $p \neq 2$ and $k \geq 1$)
2. If $p$ is prime, $\mathbb{Z}_p^*$ always has a generator
3. If $\alpha$ is a generator, all elements can be written as: $\mathbb{Z}_n^* = \{\alpha^i \bmod n \mid 0 \leq i < \phi(n)\}$
4. The number of generators is $\phi(\phi(n))$

**Generator test**

- $\alpha$ is a generator of $\mathbb{Z}_n^*$ iff for every prime $p$ dividing $\phi(n)$, $\alpha^{\phi(n)/p} \not\equiv 1 \pmod{n}$
- if $n = 2p+1$ is a "safe prime" with $p$ prime: $\alpha$ is a generator iff $\alpha^2 \not\equiv 1 \pmod{n}$ and $\alpha^p \not\equiv 1 \pmod{n}$

::: {.callout-note collapse=true title="Original Text"}
### Mathematical Foundations (III)

**Definition**: The **multiplicative group of $\mathbb{Z}_n$**, denoted $\mathbb{Z}_n^*$ is:

$$\mathbb{Z}_n^* = \{a \in \mathbb{Z}_n \mid \text{gcd}(a,n) = 1\}$$

In particular, if $n$ is prime: $\mathbb{Z}_n^* = \{a \mid 1 \leq a \leq n-1\}$

The **number of elements or order** of the multiplicative group $\mathbb{Z}_n^*$ is $\phi(n)$ (by definition of $\phi$).

**Definition**: Let $a \in \mathbb{Z}_n$, the **order of $a$** is the smallest positive integer $t$ for which:

$$a^t \equiv 1 \pmod{n}$$

**Definition**: Let $\alpha \in \mathbb{Z}_n^*$, if the order of $\alpha$ is $\phi(n)$, then $\alpha$ is a **generator of $\mathbb{Z}_n^*$**. When a group $\mathbb{Z}_n^*$ has a generator, it is said to be **cyclic**.

**Properties of generators**:

- $\mathbb{Z}_n^*$ has a generator iff $n = 2, 4, p^k$ or $2p^k$, with $p$ prime, $p \neq 2$ and $k \geq 1$. In particular, if $p$ is prime, $\mathbb{Z}_p^*$ has a generator.

- If $\alpha$ is a generator of $\mathbb{Z}_n^*$, then all elements of $\mathbb{Z}_n^*$ can be written as:
  $$\mathbb{Z}_n^* = \{\alpha^i \bmod n \mid 0 \leq i \leq \phi(n)-1\}$$

- The number of generators of $\mathbb{Z}_n^*$ is $\phi(\phi(n))$.

- $\alpha$ is a generator of $\mathbb{Z}_n^*$ iff for every prime $p$ dividing $\phi(n)$, we have:
  $$\alpha^{\phi(n)/p} \not\equiv 1 \pmod{n}$$

In particular if $n$ is a prime of the form $n = 2p+1$ with $p$ prime (such $n$ is called a **safe prime**), $\alpha$ is a generator of $\mathbb{Z}_n^*$ iff $\alpha^2 \not\equiv 1 \pmod{n}$ and $\alpha^p \not\equiv 1 \pmod{n}$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **$\mathbb{Z}_n^*$**: elements coprime with $n$, cardinality = $\phi(n)$
- **Generator**: element of order $\phi(n)$ (generates the entire group)
- **Crucial for DH and ElGamal**: security based on discrete logarithm in cyclic group
- **Safe prime**: $n = 2p+1$ with $p$ and $n$ prime
:::

---

### Fast Exponentiation

Efficient computation of $a^k \bmod n$ in polynomial time, essential for all asymmetric algorithms.

**Principle**: Use the binary representation of the exponent $k$.

**Example**: Computation of $2^{644} \bmod 645$

1. Binary representation: $(644)_{10} = (1010000100)_2$

2. Compute successive powers of 2 modulo 645:
   - $2^1 \bmod 645$
   - $2^2 \bmod 645$
   - $2^4 \bmod 645$
   - $2^8 \bmod 645$
   - ...
   - $2^{512} \bmod 645$

3. Combine according to bits set to 1: $2^{644} = 2^{512} \cdot 2^{128} \cdot 2^4$

**Complexity**: $O(\log^3 n)$ - very efficient!

**Application**: Computation of the inverse using Euler's theorem in polynomial time.

Alternative: **Extended Euclidean algorithm** to find $x$ such that $ax \equiv 1 \pmod{n}$ by solving $ax - kn = 1 = \text{gcd}(a,n)$. Complexity also $O(\log^3 n)$.

::: {.callout-note collapse=true title="Original Text"}
### Fast Exponentiation

**Fast exponentiation**: Using the binary representation of a number, we can compute powers very efficiently.

**Example**: computation of $2^{644} \bmod 645$

$(644)_{10} = (1010000100)_2$

Now, we compute the exponents corresponding to the powers of 2, namely:

$$2^1 \bmod 645, \quad 2^2 \bmod 645, \quad 2^4 \bmod 645, \quad \ldots, \quad 2^{512} \bmod 645$$

From the binary representation, we compute:

$$2^{644} = 2^{512+128+4} = 2^{512} \cdot 2^{128} \cdot 2^4 = 160 \cdot 153 \cdot 6 \bmod 645$$

**The complexity of this algorithm** fast exponentiation is $O(\log^3 n)$.

By relying on **Euler's theorem**, the computation of the **inverse of a number** in such a group is therefore performed in polynomial time.

**The extended Euclidean algorithm** can also be used to find an $x$ such that:

$$ax \equiv 1 \pmod{n}$$

since this congruence can be written as: $ax - 1 = kn$ and therefore:

$$ax - kn = 1 = \text{gcd}(a,n)$$

The complexity of this algorithm is also $O(\log^3 n)$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Idea**: binary representation of the exponent
- **Complexity**: $O(\log^3 n)$ - polynomial!
- **Essential**: makes RSA, ElGamal, DH practical
- **Alternative**: extended Euclidean algorithm for inverses
:::

---

### Chinese Remainder Theorem (CRT)

The CRT allows solving systems of simultaneous congruences, with important applications in cryptography.

**Theorem**: Let $n_1, n_2, \ldots, n_t \in \mathbb{Z}^+$ pairwise coprime (gcd$(n_i, n_j) = 1$ if $i \neq j$) and $a_1, a_2, \ldots, a_t \in \mathbb{Z}$. Then the system:

$$\begin{cases}
x \equiv a_1 \pmod{n_1} \\
x \equiv a_2 \pmod{n_2} \\
\vdots \\
x \equiv a_t \pmod{n_t}
\end{cases}$$

has a unique solution $x \bmod N$ with $N := n_1 \cdot n_2 \cdots n_t$.

**Gauss's algorithm** (1801) to compute $x$:

$$x = \sum_{i=1}^{t} a_i N_i M_i \bmod N$$

with:

- $N_i = N/n_i$
- $M_i = N_i^{-1} \bmod n_i$ (modular inverse)

**Complexity**: $O(\log^3 n)$ - polynomial!

**Cryptographic applications**:

1. Acceleration of RSA computations (use $p$ and $q$ separately)
2. Secret sharing (secret sharing schemes)
3. Certain attacks on RSA (if small exponent and multiple messages)

::: {.callout-note collapse=true title="Original Text"}
### Chinese Remainder Theorem

The **Chinese Remainder Theorem** (3rd century!) allows solving linear systems of simultaneous congruences. It solves problems raised in ancient Chinese puzzles. It was, for example, about finding a number that produces a remainder of 1 when divided by 3, of 2 when divided by 5 and of 3 when divided by 7... It was also used to calculate the exact moment of alignment of several celestial bodies having different orbits (and therefore periods).

**Chinese Remainder Theorem**: Let $n_1, n_2, \ldots, n_t \in \mathbb{Z}^+$ be pairwise coprime (i.e., gcd$(n_i, n_j) = 1$, $\forall i \neq j$) and $a_1, a_2, \ldots, a_t \in \mathbb{Z}$. Then, the system of congruences:

$$\begin{cases}
x \equiv a_1 \pmod{n_1} \\
x \equiv a_2 \pmod{n_2} \\
\vdots \\
x \equiv a_t \pmod{n_t}
\end{cases}$$

has a unique solution $x \bmod N := n_1 n_2 \cdots n_t$

**Gauss's algorithm** (1801) for the computation of $x$:

$$x = \sum_{i=1}^{t} a_i N_i M_i \bmod N$$

with $N_i = N/n_i$ and $M_i = N_i^{-1} \bmod n_i$.

The **complexity** of this algorithm is $O(\log^3 n)$.

It is therefore possible in **polynomial time** to go from congruences mod $n_i$ to congruences mod $N$!
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Solves**: systems of congruences with pairwise coprime moduli
- **Unique solution**: modulo product of moduli
- **Complexity**: $O(\log^3 n)$ (polynomial)
- **Crypto usage**: RSA optimization, attacks if small exponent
:::

---

## Basic Problems and Complexity

### Classification of Hard Problems

The security of asymmetric cryptography relies on mathematical problems reputed to be hard:

**Generic problems**:

1. **Factorization (FACTP)**: Given $n$, find its factorization into prime numbers
   - Base of **RSA** and **Rabin**

2. **Discrete Logarithms (DLP)**: Given prime $p$, a generator $\alpha \in \mathbb{Z}_p^*$ and $\beta \in \mathbb{Z}_p^*$, find $x$ such that:
   $$\alpha^x \equiv \beta \pmod{p}$$
   - Base of **ElGamal** and **Diffie-Hellman**

3. **Square Root modulo composite (SQROOTP)**: Given composite $n$ and a quadratic residue $a$, find $\sqrt{a} \bmod n$
   - Base of **Rabin**

**Specific problems**:

1. **RSA Problem (RSAP)**: Given $n = pq$, $e$ with gcd$(e, \phi(n)) = 1$ and $c$, find $m$ such that $m^e \equiv c \pmod{n}$

2. **Diffie-Hellman Problem (DHP)**: Given prime $p$, generator $\alpha$, $\alpha^a \bmod p$ and $\alpha^b \bmod p$, find $\alpha^{ab} \bmod p$

**Proven equivalences**:

- **DHP ⟺ DLP** (equivalent under certain conditions)
- **RSAP ⟺ FACTP** (proven equivalent for the generic case)
- **SQROOTP ⟺ FACTP**

::: {.callout-note collapse=true title="Original Text"}
### Basic Problems

**Main generic problems**:

- **Factorization (FACTP)**: Given a positive integer $n$, find its factorization into prime numbers.

- **Discrete Logarithms (DLP)**: Given a prime number $p$, a generator $\alpha \in \mathbb{Z}_p^*$ and an element $\beta \in \mathbb{Z}_p^*$, find the integer $x$, $0 \leq x \leq p-2$, such that: $\alpha^x \equiv \beta \pmod{p}$.

- **Square Root in $\mathbb{Z}_n$ if $n$ is composite (SQROOTP)**: Given a composite integer $n$ and a quadratic residue $a$, find the square root of $a$ mod $n$.

**Specific problems** (proper to an encryption system):

- **RSA (RSAP)**: Given a positive integer $n = pq$, a positive integer $e$ with gcd$(e, (p-1)(q-1)) = 1$ and an integer $c$, find an integer $m$ with $m^e \equiv c \pmod{n}$.

- **Diffie-Hellman (DHP)**: Given a prime number $p$, a generator $\alpha \in \mathbb{Z}_p^*$ and the elements $\alpha^a \bmod p$ and $\alpha^b \bmod p$, find $\alpha^{ab} \bmod p$.

**Proven results**:

- **DHP ⟺ DLP** (Equivalent under certain conditions)
- **RSAP ⟺ FACTP** (Proven equivalent for the generic problem)
- **SQROOTP ⟺ FACTP**
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **FACTP**: factor $n$ → base of RSA/Rabin
- **DLP**: find discrete logarithm → base ElGamal/DH
- **SQROOTP**: square root mod composite → Rabin
- **Equivalences**: breaking = solving the base problem
:::

---

### Factorization Techniques

The security of RSA depends on the difficulty of factoring large numbers.

**Exponential time methods**: $O(\exp(c \cdot \ln(n)))$

- Trial Division (successive division)
- Sieve of Eratosthenes (2nd century BC)
- Fermat's Method (~1650)
- Pollard's $\rho$ Method (1975)
- Pollard's $p-1$ Method (1974)

**Sub-exponential time methods**: $O(\exp(c \cdot (\ln(n))^{1/3}))$

- Continued Fractions (1975)
- **Quadratic Sieve (1981)** - very effective in practice
- **Number Field Sieve - NFS (1990)** - currently the fastest
- General Number Field Sieve - GNFS (2006)

**Polynomial time methods**:

- **Shor's Algorithm** (1994): $O(\log^c n)$ on **quantum computer**

**Current records (2020)**:

- Largest number factored: **RSA-829** (250 digits, 829 bits)
- Computation time: 2700 core-years (Intel Xeon Gold 6130 CPUs)
- Method: General Number Field Sieve

**Implications**:

- RSA keys < 1024 bits: **vulnerable**
- RSA keys 1024 bits: **limits** (states with significant resources)
- Recommendation: **2048 bits minimum** (3072-4096 for long term)

::: {.callout-note collapse=true title="Original Text"}
### Classical Factoring Techniques and New Developments

**Exponential time**: $O(\exp(c \cdot \ln(n)))$

- Trial Division
- Eratosthenes' Sieve (II B.C.)
- Fermat's Difference of Squares Method (~1650)
- Square Form Factorization (1971)
- Pollard's p-1 method (1974)
- Pollard's Rho Method (1975)

**Sub-exponential time**: $O(\exp(c \cdot (\ln(n))^{1/3}))$

- Continued Fractions (1975)
- **Quadratic Sieve (1981)**
- **Number Field Sieve - NFS (1990)**
- **General Number Field Sieve - GNFS (2006)**

**Polynomial time**:

- **Shor's Algorithm in a Quantum Computer (1994)**: $O(\log^c n)$

**Recent developments**:

- Bernstein's specific NFS computer to factor a 1536-bit number would take the same time as a 512-bit computation on a conventional machine
- **Largest factorization to date (2020)**: RSA-829 (250-digit number) using NFS
- Total computation time: **2700 core-years** (Intel Xeon Gold 6130 CPUs at 2.1GHz)

**Factorization on quantum computer**:

- Significant problems (errors, dispersion, etc.)
- 2001: 7-qubit computer (IBM Almaden)
- Feasibility of a computer with millions of qubits... ?
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Sub-exponential**: NFS currently the fastest
- **Record 2020**: RSA-829 (829 bits) in 2700 core-years
- **Recommendation**: keys ≥ 2048 bits for RSA
- **Future threat**: quantum computers (Shor)
:::

---

## The RSA Algorithm

### RSA Operation (Encryption/Decryption)

RSA (Rivest-Shamir-Adleman, 1978) is the most used asymmetric algorithm.

**Key generation**:

1. Choose two **large** prime numbers $p$ and $q$ (≥ 1024 bits each)
2. Compute $n := p \cdot q$ and $\phi(n) = (p-1)(q-1)$
3. Choose encryption exponent $e$ with:
   - $1 < e < \phi(n)$
   - gcd$(e, \phi(n)) = 1$
4. Compute decryption exponent $d$ such that:
   $$e \cdot d \equiv 1 \pmod{\phi(n)}$$
   (using extended Euclidean algorithm or fast exponentiation)

**Resulting keys**:

- **Public** key: $(n, e)$
- **Private** key: $d$ (keep $p$ and $q$ secret too!)

**Encryption** (by Bob, to Alice):

1. Obtain authentic public key $(n, e)$ of Alice
2. Transform plaintext into integers $m_i \in [0, n-1]$
3. Compute ciphertexts: $c_i := m_i^e \bmod n$
4. Send the $c_i$ to Alice

**Decryption** (by Alice):

- Use private key $d$ to compute:
   $$m_i = c_i^d \bmod n$$

**Proof of operation**:

$$c^d \equiv (m^e)^d \equiv m^{ed} \pmod{n}$$

Since $ed \equiv 1 \pmod{\phi(n)}$, there exists $k$ such that $ed = 1 + k\phi(n)$, therefore:

$$c^d \equiv m^{1+k\phi(n)} \equiv m \cdot (m^{\phi(n)})^k \equiv m \cdot 1^k \equiv m \pmod{n}$$

(by Euler's theorem)

::: {.callout-note collapse=true title="Original Text"}
### RSA Encryption/Decryption Procedure and Proof

**Key generation**:

- Each entity (A) creates a key pair (public and private) as follows:
  - A chooses the size of the modulus $n$ (e.g., size$(n) = 1024$ or size$(n) = 2048$).
  - A generates two prime numbers $p$ and $q$ of large size $(n/2)$.
  - A computes $n := pq$ and $\phi(n) = (p-1)(q-1)$.
  - A generates the encryption exponent $e$, with $1 < e < \phi(n)$ such that gcd$(e, \phi(n)) = 1$.
  - A computes the decryption exponent $d$, such that: $ed \equiv 1 \pmod{\phi(n)}$ using the extended Euclidean algorithm or fast exponentiation.
- The pair $(n,e)$ is A's **public** key; $d$ is A's **private** key.

**Encryption**:

- Entity B obtains $(n,e)$, the **authentic** public key of A.
- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in [0, n-1]$ $\forall i$.
- B computes the ciphertext $c_i := m_i^e \bmod n$, $\forall i$ using fast exponentiation.
- B sends to A all the ciphertexts $c_i$.

**Decryption**:

- A uses its private key to compute the plaintexts $m_i = c_i^d \bmod n$.

**Proof**: Let $m$ be the plaintext and $c$ the ciphertext with $c := m^e \bmod n$, we need to prove: $m \stackrel{!}{=} c^d \bmod n$

Substituting $c$ by its value we obtain:
$$c^d \bmod n = m^{ed} \bmod n \quad (*)$$

but, we know that:
$$ed \equiv 1 \pmod{\phi(n)}$$

and therefore by definition of congruences, there exists an integer $k$ with:
$$ed - 1 = k\phi(n)$$

substituting in (*):
$$c^d \equiv m^{k\phi(n)+1} \equiv m^{k\phi(n)} \cdot m \pmod{n}$$

If gcd$(m,n) = 1$, we have by **Euler's theorem**:
$$m^{\phi(n)} \equiv 1 \pmod{n}$$

therefore:
$$c^d \equiv (m^{\phi(n)})^k \cdot m \equiv m \pmod{n}$$ Q.E.D. !

If gcd$(m,n) \neq 1$, $m$ is necessarily a multiple of $p$ or $q$ (very unlikely case...), we can show by doing the calculations mod $p$ and mod $q$ that the congruence remains true.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Public key**: $(n, e)$ with $n = pq$
- **Private key**: $d$ such that $ed \equiv 1 \pmod{\phi(n)}$
- **Encryption**: $c = m^e \bmod n$
- **Decryption**: $m = c^d \bmod n$
- **Security**: based on difficulty of factoring $n$
:::

```{mermaid}
graph LR
    A[Plaintext m] -->|Encryption: m^e mod n| B[Ciphertext c]
    B -->|Decryption: c^d mod n| C[Plaintext m]
    D[Public key: n, e] -.->|used for| A
    E[Private key: d] -.->|used for| B
    F[p, q secret primes] -->|n = pq| D
    F -->|φn = p-1q-1| E
```

---

### RSA Security

**Equivalence RSA problem ⟺ Factorization**:

- Finding $d$ ⟺ factoring $n$ (proven equivalent)
- Decrypting without $d$ is **not proven** as hard as factoring, but...
- No method faster than factoring is known

**Factorization complexity**:

- Fastest methods: $O(\exp(c \cdot (\ln(n))^{1/3}))$ (sub-exponential)
- Computationally impossible for $n \geq 1024$ bits
- **Current recommendation**: 2048 bits minimum (3072-4096 for long-term security)

**Choice of exponents**:

- **Encryption exponent $e$**:

  - Often **small** for speed: $e = 3, 17, 65537$ (common)
  - Caution: if $e$ too small AND $m < n^{1/e}$, attack possible ($e$-th root in $\mathbb{Z}$)
  - Solution: **randomization** (padding) of the message

- **Decryption exponent $d$**:

  - Must be **large**: at least half the size of $n$
  - If $d$ small: vulnerable to Wiener's attack

**Performance consequence**:

- **Fast encryption** ($e$ small)
- **Slow decryption** ($d$ large)

::: {.callout-note collapse=true title="Original Text"}
### RSA: Security

The **RSAP** problem of finding $m$ from $c$ is not proven to be as hard as factorization but...:

- We can prove that if we find $d$ we can easily compute $p$ and $q$. This is equivalent to saying that **factoring $n$ and finding $d$ require equivalent computational effort**.

- We know that the fastest methods for factoring have a **sub-exponential complexity** $O(\exp(c \cdot (\ln(n))^{1/3}))$. The problem therefore remains **computationally impossible** for modulus $\geq 1048$ bits (2048 bits is a frequent choice for long-term security...).

- To improve encryption speed, we tend to choose **relatively small exponents $e$** (typically: $e := 3$, $e := 17$ and $e := 19$). However, it has been proven that computing an $i$-th root (with small $i$) modulo a composite $n$ can be significantly easier than factoring $n$. On the other hand, in 2008 it was proven that the generic RSA problem is equivalent to factorization.

- The **decryption exponent $d$ must imperatively be large** (at least half the size of $n$) to guarantee the system's security.

- Consequently, **encryption is normally significantly faster than decryption** since the exponents used are much smaller!
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Security**: based on difficulty of FACTP (factorization)
- **Recommended size**: $n \geq 2048$ bits
- **Small $e$**: fast encryption (3, 17, 65537)
- **Large $d$**: at least $\text{size}(n)/2$
- **Separate keys**: encryption ≠ signature
:::

---

### Attacks on RSA

#### Attack on small exponent with same message

If the same message $m$ is sent to 3 recipients with $e = 3$:

- $c_1 \equiv m^3 \pmod{n_1}$
- $c_2 \equiv m^3 \pmod{n_2}$
- $c_3 \equiv m^3 \pmod{n_3}$

The **Chinese Remainder Theorem** gives a unique solution $x \bmod n_1n_2n_3$ such that:
$$x \equiv c_1 \pmod{n_1}, \quad x \equiv c_2 \pmod{n_2}, \quad x \equiv c_3 \pmod{n_3}$$

If $m^3 < n_1n_2n_3$ (often true), then $x = m^3$ in $\mathbb{Z}$ and we can compute $m$ by simply taking the integer cube root!

**Protection**: always randomize the message before encryption (OAEP padding)

#### Attack if message small

If $m < n^{1/e}$, then $m^e < n$, so $c = m^e$ (in $\mathbb{Z}$, not modulo). We can directly compute the $e$-th root!

**Protection**: padding mandatory

#### Multiplicative property

$$E(m_1) \cdot E(m_2) \equiv (m_1 \cdot m_2)^e \equiv E(m_1 \cdot m_2) \pmod{n}$$

Allows chosen-ciphertext attacks and blind signatures.

#### General attack

The most effective method remains **factoring $n$** (if parameters well chosen and implementation correct).

::: {.callout-note collapse=true title="Original Text"}
### RSA: Attacks

When we want to encrypt the **same message for a group of correspondents**, it is advisable to introduce variations (**randomization**) before encryption to avoid the following attack:

Assume we compute ciphertexts $c_1, c_2, c_3$ from the same plaintext $m$ and the same exponent $e := 3$ addressed to three entities with modulus: $n_1, n_2, n_3$.

The **Chinese Remainder Theorem** tells us that there exists a solution $x \bmod n_1n_2n_3$, such that:
$$x \equiv c_1 \pmod{n_1}, \quad x \equiv c_2 \pmod{n_2}, \quad x \equiv c_3 \pmod{n_3}$$

But if $m$ does not change for the three encryptions, we have that $x = m^3 \bmod n_1n_2n_3$ and, moreover: $m^3 < n_1n_2n_3$. We can, therefore, find $m$ by computing the **integer cube root** of $m^3$, knowing that for this calculation there exist efficient algorithms!

More generally, if $m < n^{1/e}$, we can apply fast algorithms (in $\mathbb{Z}$) to compute the $e$-th roots of $m^e$. It is therefore advisable to perform **"randomization" of $m$ before encrypting**!

**The multiplicative property of RSA**: $(m_1 m_2)^e \equiv m_1^e \cdot m_2^e \equiv c_1 \cdot c_2 \pmod{n}$

gives rise to **dangerous vulnerabilities** (see blind signatures).

Assuming parameters are correctly chosen and the implementation has no flaws, **the most effective method to "break" the generic RSA algorithm remains factoring $n$**.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
- **Same message, small $e$**: CRT allows extracting $m$!
- **Message too small**: $m < n^{1/e}$ → direct root
- **Multiplicative property**: $E(m_1) \cdot E(m_2) = E(m_1 m_2)$
- **Protection**: always padding/randomization (OAEP)
:::

---

## The ElGamal Algorithm

Asymmetric system (1985) based on the **discrete logarithm problem (DLP)**.

**Keys:**

- Choose prime $p$, generator $\alpha \in \mathbb{Z}_p^*$, secret $a$
- Compute $y = \alpha^a \bmod p$
- **Public**: $(p, \alpha, y)$ | **Private**: $a$

**Encryption:** For message $m$, choose unique random $k$

- $\gamma = \alpha^k \bmod p$
- $\delta = m \cdot y^k \bmod p$
- Send $(\gamma, \delta)$

**Decryption:** $m = \delta \cdot \gamma^{-a} \bmod p$

::: {.callout-note collapse="true" title="Original Text"}
## ElGamal Encryption/Decryption Procedure

**Key generation**

Each entity (A) creates a key pair (public and private) as follows:

- A generates a prime number $p$ (len($p$) ≥ 1024 bits) and a **generator $\alpha$** of the multiplicative group $\mathbb{Z}_p^*$
- A generates a random number $a$, such that $1 \leq a \leq p-2$ and computes $y := \alpha^a \bmod p$
- The **public key** of A is $(p, \alpha, y)$, the **private key** of A is $a$

**Encryption**

- Entity B obtains $(p, \alpha, \alpha^a \bmod p)$, the authentic public key of A
- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in [0, p-1]$ $\forall i$
- For each message $m_i$:
  - B generates a **unique** random number $k$, such that $1 \leq k \leq p-2$
  - B computes $\gamma := \alpha^k \bmod p$ and $\delta := m_i \cdot (\alpha^a)^k \bmod p$ and sends the ciphertext $c := (\gamma, \delta)$

**Decryption**

- A uses its private key $a$ to compute $\gamma^{p-1-a} \bmod p$ (note that: $\gamma^{p-1-a} \equiv \gamma^{-a} \equiv \alpha^{-ak} \bmod p$)
- A retrieves the plaintext by computing: $\delta \cdot \gamma^{-ak} \bmod p$
:::

::: {.callout-tip collapse="true"}
## Quick Revision

**Base**: DLP in $\mathbb{Z}_p^*$

**Ciphertext**: $(\alpha^k, m \cdot y^k)$

**Security**: $k$ must be unique and large

**Disadvantage**: doubles message size
:::

### Essential Remarks

- **Proof**: $\delta \cdot \gamma^{-a} = m \cdot (\alpha^a)^k \cdot (\alpha^k)^{-a} = m \bmod p$
- **Security**: based on DLP (complexity sub-exponential close to factorization)
- **Exponents**: $k$ and $a$ must be large (otherwise vulnerable to baby-step giant-step)
- **Reuse prohibited**: if $k$ repeated, $\delta_1/\delta_2 = m_1/m_2$ reveals the messages
- **Major disadvantage**: ×2 expansion of ciphertext size
- **Generalization**: works on $GF(2^n)$ or elliptic curves

::: {.callout-note collapse="true"}
## Original Text - Remarks

**Proof** that the scheme works: If $s \equiv k^{-1}(m_h - ar) \bmod (p-1)$, we have that: $m_h \equiv (ar + ks) \bmod (p-1)$ and $v_2 = \alpha^{H(m)} \bmod p$. If, as we wish to show $m_h = H(m)$, by reducing exponents mod $(p-1)$, we can rewrite $v_2$: $v_2 \equiv \alpha^{ar+ks} \bmod p$. On the other hand: $v_1 = y^r\alpha^{rs} \equiv \alpha^{ar}\alpha^{ks} \equiv \alpha^{ar+ks} \bmod p$.

The ElGamal procedure is based on the difficulty of computing **discrete logarithms modulo a prime number** (DLP problem) even though it has not been proven to be strictly equivalent to this problem.

The **most efficient algorithms** known have a sub-exponential complexity very close to that of factorization (we often use the same algorithms).

The **chosen exponents** ($k$, $a$) must be large because there exist efficient algorithms to compute discrete logarithms modulo a prime number when the exponent is small (baby-step giant-step algorithm).

A **disadvantage of ElGamal** is that it multiplies the ciphertext length by 2.

It is **essential** for the security of the procedure that the random number $k$ is not repeated, otherwise: let $(\gamma_1, \delta_1)$ and $(\gamma_2, \delta_2)$ be the two generated ciphertexts, we have that $\delta_1/\delta_2 = m_1/m_2$ and consequently, it is trivial to recover one plaintext from the other.

The ElGamal procedure can be **generalized** to other groups like $GF(2^n)$ or elliptic curves.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Remarks

**Equivalence**: based on DLP (not proven equivalent)

**$k$ unique**: CRITICAL - otherwise $m_1/m_2$ revealed

**Key size**: large exponents necessary

**Extensions**: $GF(2^n)$, elliptic curves
:::

---

## Rabin Algorithm

Asymmetric system **equivalent to factorization** (provably secure).

**Keys:**

- Generate two primes $p$, $q$ (≥1024 bits total), compute $n = pq$
  - **Public**: $n$
  - **Private**: $(p, q)$

**Encryption:** $c = m^2 \bmod n$

**Decryption:** 

- Compute the 4 square roots of $c \bmod n$ (via roots mod $p$ and mod $q$)
- Identify the correct message by redundancy

::: {.callout-note collapse="true" title="Original Text"}
## Rabin Encryption/Decryption Procedure

**Key generation**

Each entity (A) creates a key pair (public and private) as follows:

- A generates two random prime numbers $p$ and $q$ of large size (len($pq$) ≥ 1024)
- A computes $n := pq$
- The **public key** of A is $n$, the **private key** of A is $(p, q)$

**Encryption**

- Entity B obtains $n$, the authentic public key of A
- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in [0, n-1]$ $\forall i$
- B computes $c_i = m_i^2 \bmod n$ for each message $m_i$
- B sends all the ciphertexts $c_i$ to A

**Decryption**

- A uses its private key $(p, q)$ to retrieve the **4 solutions** of the equation: $c_i = x^2 \bmod n$ using **efficient algorithms** to compute square roots $\bmod p$ and $\bmod q$
- A determines either by an **additional indication** from B, or by **redundancy analysis** which of the 4 messages $m_1, m_2, m_3, m_4$ is the original plaintext
:::

::: {.callout-tip collapse="true"}
## Quick Revision

**Base**: SQROOTP (square root mod composite)

**Advantage**: proven equivalent to factorization

**Problem**: 4 possible solutions, requires redundancy

**Vulnerability**: chosen-ciphertext attack reveals factors
:::

### Essential Remarks

- **Proven security**: SQROOTP ⟺ FACTP (only algorithm with proven equivalence)
- **Chosen-ciphertext attack**: if A decrypts $c = m^2 \bmod n$ chosen by adversary M
  - M receives a root $m_x$ among 4 possible
  - If $m \neq m_x \bmod n$ (prob. 0.5), then $\gcd(m - m_x, n)$ gives a factor of $n$
- **Solution**: require sufficient redundancy to identify unique solution without ambiguity

::: {.callout-note collapse="true"}
## Original Text - Remarks

The Rabin procedure is based on the **impossibility of finding square roots modulo a composite of unknown factorization** (SQROOTP problem).

The **main interest** of this algorithm lies in the fact that it has been **proven to be equivalent to factorization** (SQROOTP ⟺ FACTP). This algorithm therefore belongs to the **provably secure** category for any passive attack.

**Active attacks** can, in some cases, compromise the algorithm's security. More precisely, if we mount the following **chosen ciphertext** attack:

- The attacker M generates an $m$ and sends to A the ciphertext $c = m^2 \bmod n$.
- A responds with a root $m_x$ among the 4 possible $m_1, m_2, m_3, m_4$.
- If $m \neq m_x \bmod n$ (probability 0.5), M repeats with a new $m$.
- Otherwise, A computes $\gcd(m - m_x, n)$ and thus obtains one of the two factors of $n$.

This attack could be **avoided** if the procedure required **sufficient redundancy** in the plaintexts allowing A to identify without ambiguity which of the possible solutions is the original plaintext. In this case, A would always respond with $m$ and discard the other solutions that do not have the predefined level of redundancy.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Remarks

**Unique**: only algorithm proven equivalent to FACTP

**Attack**: chosen-ciphertext gives factors (prob. 0.5)

**Countermeasure**: mandatory redundancy in messages
:::

---

## Comparison RSA - ElGamal - Rabin

| Criterion | RSA | ElGamal | Rabin |
|---------|-----|---------|-------|
| **Problem** | RSAP | DLP | SQROOTP |
| **Security** | Equiv. factorization (generic case) | Based on DLP | **Proven** ⟺ factorization |
| **Expansion** | 1:1 | **1:2** | 1:1 |
| **Decryption** | Deterministic | Deterministic | **4 solutions** |
| **Signature** | Yes | Yes | Yes (with precautions) |

---

## Elliptic Curves (Basic Idea)

### Fundamental Concept

An **elliptic curve** $E$ is defined by: $y^2 = x^3 + ax + b$ (with discriminant $4a^3 + 27b^2 \neq 0$).

**Key operation: Point addition**

- Geometrically: draw a line between two points $P$ and $Q$, find the 3rd intersection point, then take its symmetric
- Forms a **commutative group** with point at infinity $\mathcal{O}$ as identity
- **Scalar multiplication**: $kP = P + P + ... + P$ ($k$ times)

**Cryptographic advantage:**

- The **ECDLP problem**: finding $k$ such that $Q = kP$ is very difficult (exponential effort)
- **Shorter keys** for same security as in $\mathbb{Z}_p^*$

::: {.callout-note collapse="true"}
## Original Text - Definition

An **elliptic curve** is a set of points $E$ defined by the equation: $y^2 = x^3 + ax + b$, with $x, y, a$ and $b$ rational numbers, integers or integers modulo $m$ ($m > 1$). The set $E$ also contains a "point at infinity" denoted $\mathcal{O}$. The point $\mathcal{O}$ is not on the curve but it is the identity element of $E$.

We will choose for our calculations elliptic curves that do not have multiple roots or, in other words, curves where the **discriminant** $4a^3 + 27b^2 \neq 0$.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Concept

**Equation**: $y^2 = x^3 + ax + b$

**Structure**: group with $\mathcal{O}$

**Operation**: geometric addition

**Hard problem**: ECDLP
:::

### Addition on Elliptic Curves

Let $P := (x, y) \in E$, we define $-P := (x, -y)$ (symmetric with respect to the x-axis). We have $P + (-P) = \mathcal{O}$.

For two points $P, Q \in E$ with $Q \neq -P$, we define $P + Q := R$ where $-R$ is the 3rd intersection point between the curve and the line passing through $P$ and $Q$.

For **doubling**: $2P = R$ where $-R$ is the intersection point of the curve with the tangent to the curve at point $P$.

::: {.callout-note collapse="true"}
## Original Text - Addition

Let $P := (x, y) \in E$, we define $-P$ as $-P := (x, -y)$. Graphically, $-P$ is the symmetric point of $P$ with respect to the x-axis. Note that $P + (-P) = \mathcal{O}$.

Let two points $P, Q \in E$, such that $Q \neq -P$, we define the addition $P + Q := R$ where $R \in E$ such that $-R$ is the 3rd intersection point between the curve and the line passing through $P$ and $Q$.

The set $E$ with $\oplus$ defines a **commutative group** for addition.

Let $P \in E$, the point $2P = R$, such that $-R$ is the intersection point of the curve with the line tangent to the curve at point $P$.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - Addition

**Inverse**: $-P = (x, -y)$

**Addition**: 3rd intersection point + symmetry

**Doubling**: tangent + symmetry

**Property**: commutative group
:::

### ECDLP and Cryptographic Advantages

When the elliptic curve is defined over the field $\mathbb{Z}_p$ with $p$ a large prime ($y^2 \equiv x^3 + ax + b \bmod p$), the computation of $k \in \mathbb{Z}_p$ such that $Q = kP$ with $(P, Q)$ known is **very difficult** (exponential effort). This problem is the **Elliptic Curve Discrete Logarithm Problem (ECDLP)**.

**Main advantage**: key sizes much smaller for equivalent security.

::: {.callout-note collapse="true"}
## Original Text - ECDLP and Advantages

When the elliptic curve is defined over the field $\mathbb{Z}_p$ with $p$ a large prime number ($y^2 \equiv x^3 + ax + b \bmod p$), the computation of $k \in \mathbb{Z}_p$ such that $Q = kP$ with $(P, Q)$ known, is very difficult (requires exponential effort). This problem is known as: **Elliptic Curve Discrete Logarithm Problem (ECDLP)**.

The **main advantage** of public cryptography based on elliptic curves is that the size of the numbers used (and therefore, keys) is smaller.

This is due to the **increased complexity** of computations on $E_p$ (elliptic curve defined over field $\mathbb{Z}_p$) compared to usual fields such as $\mathbb{Z}_p$ or $GF(2^m)$.

The **representation of a plaintext as points** of the curve remains a complex operation.

In October 2003, the **US National Security Agency (NSA)** purchased a patent from Certicom for the use of elliptic curve cryptography.

In September 2013 Claus Diem showed that under certain conditions the ECDLP problem could be solved in **sub-exponential time**.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - ECDLP

**Problem**: finding $k$ in $Q = kP$ (exponential)

**Gain**: keys ~6-10× shorter

**Limit**: representing messages as points difficult

**NSA**: adopted in 2003
:::

### Key Size Comparison Table

| AES (symmetric) | RSA/DH | Elliptic Curves | Ratio |
|---------------------|---------|---------------------|---------|
| 56 bits | 512 bits | 112 bits | 1:4.6 |
| 80 bits | 1024 bits | 160 bits | 1:6.4 |
| 112 bits | 2048 bits | 224 bits | 1:9.1 |
| 128 bits | 3072 bits | 256 bits | 1:12 |
| 256 bits | 15360 bits | 512 bits | 1:30 |

::: {.callout-note collapse="true"}
## Original Text - Table

This table shows the key size ratios compared to RSA for equivalent security.

*(Table extracted from original document)*
:::

---

## ElGamal on Elliptic Curves

### Direct Adaptation

Replace operations in $\mathbb{Z}_p^*$ with operations on $E_p$

**Keys:**

- Choose curve $E_p$ and point $P_0 \in E_p$ of large order
- Secret $x$, compute $P_a = xP_0$
- **Public**: $(E_p, P_0, P_a)$ | **Private**: $x$

**Encryption:** For message $m_i \in E_p$

- Choose random $k$
- $\gamma = kP_0$, $\delta = kP_a + m_i$
- Send $(\gamma, \delta)$

**Decryption:** $m_i = \delta - x\gamma$

::: {.callout-note collapse="true"}
## Original Text - ElGamal EC

**Key generation**

Each entity (A) creates a key pair (public and private) as follows:

- A chooses an elliptic curve $E_p$ with $p$, a large prime number (len($p$) bits) and a point $P_0 \in E_p$.
- A generates a random number $x$, such that $1 \leq x \leq p$ and computes $P_a = xP_0$ (multiplication by a scalar on $E_p$, for which efficient algorithms exist).
- The public key of A is $(E_p, P_0, P_a)$, the private key of A is $x$.

**Encryption**

Entity B obtains $(E_p, P_0, P_a)$, the authentic public key of A.

- B transforms its plaintext into a series of integers $m_i$, such that $m_i \in E_p$ for all $i$.
- For each message $m_i$:
  - B generates a **unique** random number $k$, such that $1 \leq k \leq p$.
  - B computes $\gamma := kP_0$ and $\delta := kP_a + m_i$ and sends the ciphertext $c := (\gamma, \delta)$.

**Decryption**

- A uses its private key $x$ to compute: $x\gamma = xkP_0 = kP_a$.
- A retrieves the plaintext by computing: $\delta - kP_a = kP_a + m_i - kP_a = m_i$.

The security of the scheme relies on **ECDLP**!

It is also necessary to **authenticate** the exchanged public parts to avoid the previously described man-in-the-middle attacks.

The properties of the protocol are identical to the $\mathbb{Z}_p^*$ case.
:::

::: {.callout-tip collapse="true"}
## Quick Revision - ElGamal EC

**Principle**: same as ElGamal on $E_p$

**Operations**: + and scalar multiplication on points

**Security**: ECDLP

**Authentication**: necessary against MitM

**Advantage**: short keys
:::

# Cryptographic Hash Functions and MACs

## One-Way Functions (OWF)

A function $f$ is one-way if $f(x) = y$ is easy to compute, but finding $x$ from $y$ is computationally impossible for the majority of values.

**Examples:**

- Squares modulo composite: $f(x) = x^2 \bmod n$ with $n = pq$
- DES construction: $y = E_k(x) \oplus x$ with $k$ fixed and known

**Note:** OWF ≠ OWHF (hash functions impose compression and 2nd-preimage resistance).

::: {.callout-note collapse=true title="Original Text"}
A **function f is called one-way** (one-way function or **OWF**) if for $x \in X$ we can easily compute $f(x) = y$ but for the vast majority of $y \in Y$ it is **computationally impossible** to find an $x$ such that $f(x) = y$.

**Examples:**

- computing squares modulo a composite: $f(x) = x^2 \bmod n$ with $n = pq$ (p and q unknown) is a **one-way function** because the inverse is difficult (see the basic problem **SQROOTP**).
- we can construct a one-way function based on DES or any other block encryption system $E$ as follows: $y = f(x) = E_k(x) \oplus x$, $\forall x$, with $k$ a fixed and known key. We can consider that $E_k(x) \oplus x$ has (pseudo)random behavior by construction of $E$. Computing the inverse amounts to finding an $x$ such that: $x = E_k^{-1}(x \oplus y)$, which is considered difficult given the properties of $E$. Note that $f(x) = E_k(x)$ would not be sufficient to make an OWF because, with the key known, DES is reversible.

**OWF ≠ OWHF**: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.

**Example**: $f(x) = x^2 \bmod n$ with $n = pq$ (p and q unknown) is not an OWHF because given $x$, $-x$ is a trivial collision.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**OWF**: easy in one direction ($f(x) \to y$), impossible in the other ($y \to x$).

Examples: modular squares, $E_k(x) \oplus x$.

OWF ≠ OWHF (hash functions = more constraints).
:::

## Hash Functions: Definitions

A hash function $h$ has two essential properties:

- **Compression**: transforms data of arbitrary length into fixed-length output
- **Ease of computation**: $h(x)$ is fast to compute

**Classification:**

- **Unkeyed** (no key): MDC (Manipulation Detection Code)
- **Keyed** (with key): MAC (Message Authentication Code)

**Security properties:**

1. **Preimage resistance**: given $y$, impossible to find $x$ such that $h(x) = y$
2. **2nd-preimage resistance** (weak collision): given $x$, impossible to find $x' \neq x$ such that $h(x) = h(x')$
3. **Collision resistance** (strong collision): impossible to find any $x \neq x'$ with $h(x) = h(x')$

**Terminology:**

- **OWHF** (weak one-way): satisfies (1) and (2)
- **CRHF** (strong one-way): satisfies (2) and (3)

::: {.callout-note collapse=true title="Original Text"}
A **hash function** is a function $h$ having the following properties:

- **compression**: the function $h$ maps a set $X$ composed of bit strings of finite but arbitrary length to a set $Y$ composed of bit strings of finite and fixed length (and normally smaller than the size of $X$) with $h(x) = y$, and $x \in X$, $y \in Y$.
- **easy to compute**: given $h$ and $x \in X$, $h(x)$ is easy to compute.

A hash function is called **"keyed"** (keyed hash function) if a key is involved in the computation of the function ($h_k(x) = y$); otherwise it is called **"unkeyed"** (unkeyed hash function).

Hash functions have many computer applications including structured archiving facilitating search. On the security side we will study two main categories:

- **manipulation detection codes** (**MDC**) or message integrity codes (**MIC**): these are unkeyed functions allowing to provide an integrity service under certain conditions. The result of such a function is called **MDC-value** or simply **digest**.
- **message authentication codes** (**MAC**) which are keyed functions allowing to authenticate the source of the message and ensure its integrity without using additional (encryption) mechanisms.

**Some basic properties of hash functions:**

- **1) preimage resistance**: given a $y \in Y$, it is computationally impossible to find a preimage $x \in X$ satisfying $h(x) = y$.
- **2) 2nd-preimage resistance**: given an $x \in X$ and its image $y \in Y$, with $h(x) = y$, it is computationally impossible to find an $x' \neq x$ such that $h(x) = h(x')$. Also called **weak collision resistance**.
- **3) collision resistance**: it is computationally impossible to find two distinct preimages $x, x' \in X$ for which $h(x) = h(x')$ (no restriction on the choice of values). Also called **strong collision resistance**.

A **one-way hash function** (**OWHF**) is an MDC satisfying 1) and 2). Also called: **weak one-way hash function**.

A **collision resistant hash function** (**CRHF**) is an MDC satisfying properties 2) and 3). (Note that 3) ⇒ 2)). Also called: **strong one-way hash function**.

**OWF ≠ OWHF**: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.

**Example**: $f(x) = x^2 \bmod n$ with $n = pq$ (p and q unknown) is not an OWHF because given $x$, $-x$ is a trivial collision.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Hash function**: compression + easy computation

**MDC** (unkeyed) for integrity

**MAC** (keyed) for authentication

**Properties**

1. preimage resistance
2. 2nd-preimage resistance
3. collision resistance

**OWHF** = (1)+(2)

**CRHF** = (2)+(3).
:::

## Message Authentication Codes (MACs)

A MAC is a family of functions $h_k$ parameterized by a secret key $k$:

**Properties:**

1. **Compression**: arbitrary input → fixed output
2. **Easy to compute**: with known $k$, $h_k(x)$ is fast
3. **Computation-resistance**: without $k$, impossible to compute valid pairs $(x, h_k(x))$

**Implications:**

- Key non-recovery: impossible to recover $k$ from pairs $(x_i, h_k(x_i))$
- Preimage and collision resistance for anyone not possessing $k$

**Usage:** Source authentication + message integrity without directly revealing secrets.

::: {.callout-note collapse=true title="Original Text"}
A **Message Authentication Code** (**MAC**) is a family of functions $h_k$ parameterized by a secret key $k$ having the following properties:

- **1) compression**: as for generic hash functions but applied to $h_k$.
- **2) easy to compute**: from a function $h_k$, and a known key $k$, we can easily compute $h_k(x)$. The result is called a **MAC-value** or simply a **MAC**.
- **3) computational resistance** (computation-resistance): without knowledge of the symmetric key $k$, it is (computationally) impossible to compute pairs $(x, h_k(x))$ from 0 or several known pairs $(x_i, h_k(x_i))$ for any $x \neq x_i$.

Property 3) implies that the pairs $(x_i, h_k(x_i))$ cannot be used to compute the key $k$ (**key non-recovery**). However the key non-recovery property does not imply computation-resistance because chosen/known-plaintext attacks could lead to forged pairs $(x, h_k(x))$.

The impossibility of computing pairs $(x, h_k(x))$ also translates to preimage and collision resistance (cf. previous slide) for any entity not possessing the key $k$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**MAC** = hash with key $k$

Without $k$: impossible to forge $(x, h_k(x))$ or recover $k$

Guarantees source authentication + integrity.
:::

## Attacks on MDCs

### 2nd-Preimage Resistance Attack

**Problem:** Given $h(x) = y$, find $x'$ such that $h(x') = h(x)$.

**Probabilistic analysis:**

For an $m$-bit digest ($n = 2^m$ possible outputs), the probability of having at least one collision after $k$ attempts is:

$$P(\text{collision}) \approx 1 - (1-1/n)^k \approx k/n$$

For $P = 0.5$: $k = n/2 = 2^{m-1}$

**Conclusion:** For an $m$-bit digest, approximately $2^{m-1}$ attempts are needed to find a 2nd-preimage with probability 0.5.

::: {.callout-note collapse=true title="Original Text"}
**Problem**: given $h(x) = y$, find $x'$ such that $h(x')=h(x)$.

**Practical example**: we have a text with an associated digest bearing a digital signature; we want to create a fake text bearing the same signature (without control over the original text). What are our chances from a probabilistic point of view?

Let a hash function $h$ with $n$ possible outputs and a given value $h(x)$. If $h$ is applied to $k$ random values, what must be the value of $k$ so that the probability of having at least one $y$ such that $h(x) = h(y)$ is 0.5?

For the first value of $y$, the probability that $h(x) = h(y)$ is $1/n$. Conversely, the probability that $h(x) \neq h(y)$ is $1-1/n$. For $k$ values, the probability of having no collision is: $(1-1/n)^k$, i.e.:

$$\left(1 - \frac{1}{n}\right)^k = 1 - \frac{k}{n} + \frac{1}{2!}\left(\frac{k}{n}\right)^2 - \frac{1}{3!}\left(\frac{k}{n}\right)^3 + \ldots$$

which for very large $n$ can be approximated by $1 - k/n$. Therefore, the complementary probability of having at least one collision is about $k/n$; which gives us $k = n/2$ for a probability of 0.5.

**Conclusion**: for an $m$-bit digest, the number of attempts needed to find a $y$ such that $h(x) = h(y)$ with a probability of 0.5 is $2^{m-1}$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
To break 2nd-preimage resistance with $m$-bit digest: $2^{m-1}$ attempts (prob 0.5).
:::

### Collision Resistance Attack: Birthday Paradox

**Problem:** Find two distinct values $x, x'$ such that $h(x) = h(x')$.

**Birthday paradox:** In a group of 23 people, probability > 0.5 of having two people with the same birthday.

**Mathematical result:**

For $n$ possible outputs, the probability of collision after $k$ computations:

$$P(\text{at least 1 collision}) = 1 - e^{-k(k-1)/(2n)}$$

For $P \geq 0.5$: $k \approx 1.17\sqrt{n}$

**Cryptographic consequence:** For an $m$-bit digest ($n = 2^m$ outputs), approximately $2^{m/2}$ computations are needed to find a collision with probability > 0.5.

**Practical example:** Modification of a contract into 237 variations to find a fraudulent version having the same digest as the legitimate version.

::: {.callout-note collapse=true title="Original Text"}
**Problem**: find two values $x, x'$ distinct such that $h(x) = h(x')$.

**Practical example**: We have to have someone sign a text and we want to apply this signature to a falsified text (we control the original text). What are our chances of finding two original texts satisfying this criterion?

The **birthday paradox** is a classic probabilistic problem that shows that in a gathering of only 23 people, there is already a 50% chance of having two people with the same birthday.

Let $y_1, y_2,..., y_n$ all the possible outputs of a hash function. How many $h(x_i)$: $h(x_1), h(x_2),...,h(x_k)$ must we compute to have a probability of collision equal to or greater than 0.5?

The first choice for $h(x_1)$ is arbitrary (prob = 1), the second $h(x_2) \neq h(x_1)$ has a probability of $1 - 1/n$, the third of $1 - 2/n$, etc. This gives us a probability of having no collisions equal to:

$$P_{\text{no collision}} = \prod_{i=1}^{k-1}\left(1 - \frac{i}{n}\right)$$

We easily prove (series expansion of $e^{-x}$) that for $0 \leq x \leq 1$: $1-x \leq e^{-x}$ and therefore:

$$P_{\text{no coll}} \leq \prod_{i=1}^{k-1}\left(1 - \frac{i}{n}\right) \leq \prod_{i=1}^{k-1} e^{-i/n} = e^{-k(k-1)/(2n)}$$

The probability of having at least one collision is $P_{\text{at least1}} = 1 - P_{\text{no-coll}}$. To know the value of $k$ for which $P_{\text{at least1}}$ is greater than 0.5, it suffices to calculate:

$$\frac{1}{2} \leq 1 - e^{-k(k-1)/(2n)}$$

If $k$ is large, we replace $k(k-1)$ by $k^2$ and we obtain after simple calculations:

$$k \geq \sqrt{2\ln(2) \cdot n} \approx 1.17\sqrt{n}$$

Taking $n = 365$ for the birthday, we get $k = 22.3$, which confirms the statement of the problem.

**Consequence for hash functions**: Let a hash function with $2^m$ possible outputs. If $h$ is applied to $k = 2^{m/2}$ inputs we have a probability greater than 0.5 of obtaining $h(x_i) = h(x_j)$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Birthday paradox**: to break collision resistance with $m$-bit digest: $2^{m/2}$ attempts (prob > 0.5).

Example: 23 people suffice for identical birthdays.
:::

## Computational Resistance: Recap

For a hash function with $n$-bit digest and MAC key of $t$ bits:

| Type | Property | Difficulty | Recommended Size |
|------|-----------|------------|-------------------|
| **OWHF** | Preimage | $2^n$ | $n \geq 128$ bits |
| | 2nd-preimage | $2^{n-1}$ | |
| **CRHF** | Collision | $2^{n/2}$ | $n \geq 256$ bits |
| **MAC** | Key recovery | $2^t$ | $t \geq 256$ bits |
| | Computation | $\min(2^t, 2^n)$ | $n \geq 128$ bits |

**Practical implications:**

- For integrity only (OWHF): 128 bits sufficient
- For collision resistance (CRHF): minimum 256 bits
- MACs: 256-bit key, 128-bit digest minimum

::: {.callout-note collapse=true title="Original Text"}
$n$: size of the MDC-value or MAC-value resulting from the application of the hash function

$t$: size of the MAC key

| Hash Fct. Type | Characteristic | Computational Difficulty | Attack Goal | Recommended digest/key size |
|-------------------|-----------------|-------------------------|------------------|--------------------------------|
| **OWHF** | preimage resistance | $2^n$ | find a preimage | $n \geq 128$ bits |
| | 2nd-preimage resistance | $2^{n-1}$ | find $x'$ with $h(x') = h(x)$ | |
| **CRHF** | collision resistance | $2^{n/2}$ | find a collision | $n \geq 256$ bits |
| **MAC** | key non-recovery | $2^t$ | find the key | $n \geq 128$ |
| | computation resistance | $\min(2^t,2^n)$ | produce a $(x, h_k(x))$ | $t \geq 256$ |
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Efforts**: preimage $2^n$, 2nd-preimage $2^{n-1}$, collision $2^{n/2}$.

**Sizes**: OWHF ≥128 bits, CRHF ≥256 bits, MAC key ≥256 bits.
:::

## MDCs Based on Encryption Systems

**Principle:** Use a symmetric encryption algorithm (DES, AES) to construct an MDC.

**Challenges to solve:**

- Break the reversibility of symmetric algorithms
- Increase the nominal width (DES = 64 bits insufficient for CRHF)

**Operation:**

- Sequential processing of blocks
- Chaining operations with XOR
- Combination of $n$ boxes for digests of size $n \times$ nominal width

**Classical models:**

1. **Matyas-Meyer-Oseas**: $H_i = E_{m_i}(H_{i-1}) \oplus H_{i-1}$
2. **Davies-Meyer**: $H_i = E_{m_i}(H_{i-1}) \oplus m_i$
3. **Miyaguchi-Preneel**: $H_i = E_{m_i}(H_{i-1}) \oplus H_{i-1} \oplus m_i$

**Practical examples:**

- **MDC-2**: uses 2 DES boxes → 128-bit digest
- **MDC-4**: uses 4 DES boxes → 128-bit digest

**Limitation:** Security strongly dependent on the underlying algorithm.

::: {.callout-note collapse=true title="Original Text"}
**Idea**: use a known symmetric encryption system to construct an MDC.

**Problems to solve**:

- we must "break" the reversibility of symmetric algorithms to make them OWHF or CRHF.
- The "nominal width" of some encryption systems (eg. DES) is 64 bits, which is not sufficient to build CRHF.

**Operating principle**:

- the text blocks are sequentially processed by the encryption "box".
- compression is based on chaining operations with the blocks resulting from previous iterations and logical functions (fundamentally XOR). This also makes the process irreversible.
- If necessary, $n$ encryption boxes will be combined to obtain digest lengths $n$ times greater than the nominal width of the boxes used.

**Attention**: the security of these algorithms is strongly dependent on the properties of the underlying encryption boxes.

**Examples**:

- The models of **Matyas-Meyer-Oseas**, **Davies-Meyer** and **Miyaguchi-Preneel**.
- **MDC-2** and **MDC-4** using respectively 2 and 4 DES boxes. Digest = 128 bits.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
MDCs from symmetric crypto: break reversibility + chaining XOR.

Models: Matyas-Meyer-Oseas, Davies-Meyer, Miyaguchi-Preneel.

MDC-2/4 with DES → 128 bits.
:::

## Customized MDCs

Functions specifically designed for digest generation, optimized for speed and security.

**Construction elements:**

- Padding + adding the message length
- Predefined constants to increase dispersion
- Successive rounds with logical operations and rotations
- Chaining of outputs between rounds
- Every bit of the digest depends on every input bit

**Main algorithms:**

| Algorithm | Year | Digest | Status |
|------------|-------|--------|--------|
| **MD5** | 1992 | 128 bits | ❌ Broken |
| **SHA-0** | 1993 | 160 bits | ❌ Collisions in $2^{39}$ |
| **SHA-1** | 1995 | 160 bits | ⚠️ Collisions in $2^{63}$ |
| **SHA-2** | - | 224-512 bits | ✓ Currently secure |
| **SHA-3** (Keccak) | 2012 | 224-512 bits | ✓ Current standard |

**Attack evolution:**

- 2004: Full collisions on MD5 (X. Wang)
- 2005: SHA-1 theoretically broken ($2^{63}$ operations)
- 2008: Creation of fraudulent CA certificates via MD5
- 2012: SHA-3 adopted as new standard

::: {.callout-note collapse=true title="Original Text"}
These are functions designed exclusively to generate integrity codes (digests) with a main concern for speed and security.

Their operation is based on the following elements:

- initialization operations (**padding** + adding the length).
- a set of **predefined constants** chosen specifically to increase dispersion.
- a set of "steps" (**rounds**) that will sequentially apply to all the original data blocks. These rounds will perform a combination of logical operations and rotations on the data and constants.
- **chaining** operations involving the outputs of previous rounds.

In these functions, every bit of the digest is a function of every bit of the inputs.

The most famous are:

- **MD5**: R. Rivest, 1992; RFC 1321. Digest = 128 bits. **Broken!**
- **SHA-0**: NIST, 1993. Digest = 160 bits. Collisions in $2^{39}$ operations instead of $2^{80}$
- **SHA-1**: NIST, 1995. Digest = 160 bits. Revision of SHA-0 with additional bit rotation. Collisions in $2^{63}$ operations (instead of $2^{80}$).
- **SHA-2**: NIST (FIPS 190-3). Includes: SHA-224, SHA-256, SHA-384 and SHA-512. Digest sizes range from 224 to 512 bits.
- **SHA-3**: Keccak Algorithm (digest size variable from 224 to 512 bits)

**Latest Developments**:

- X.Wang et al. culminated in 2004 a long work aiming to find collisions in the MD5 algorithm. They publish two pairs of collisions for 1024-bit messages.
- In 2005, X.Wang et al. prove at the CRYPTO'05 conference that the number of operations needed to find collisions on SHA-1 (current standard for secure hash functions) is only $2^{63}$.
- These attacks target the search for arbitrary collisions but during CRYPTO'06 researchers from the University of Graz in Austria propose a method to partially control the content of collisions.
- In December 2008 it is shown that controlled collisions on MD5 can be generated and thus create an illicit Certification Authority allowing to forge certificates accepted by any browser.
- These results rely on **analytical** approaches (as opposed to brute force!)
- The selection process for SHA-1's successor is similar to the one that designated AES as a block encryption standard. NIST decided (October 2012) that **Keccak** would be the base algorithm for **SHA-3**.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Customized MDCs**

- MD5 (broken)
- SHA-0 (broken)
- SHA-1 (weak)
- SHA-2 (secure)
- SHA-3/Keccak (current standard).

Construction: padding + constants + rounds + chaining.
:::

## MACs Based on Encryption Systems

**CBC-MAC:** Uses a block cipher algorithm in CBC mode.

**Operation:**

- CBC mode with IV = 0
- Elimination of intermediate ciphertexts
- Only the last encrypted block is kept as MAC

**With DES:**

- Key length: 56 bits (112 in optional Triple-DES)
- MAC length: 64 bits

**Advantages:**

- Reuse of existing encryption infrastructure
- Acceptable performance

**Limitations:**

- Security limited by block size (64 bits for DES)
- Vulnerable if used incorrectly (ex: without variable IV)

::: {.callout-note collapse=true title="Original Text"}
**CBC-MAC algorithm based on DES-CBC with IV = 0 and elimination of intermediate ciphertexts**

- key length = 56 bits (112 in case of using the optional part)
- MAC-value length = 64 bits

The diagram shows the sequential processing of message blocks $M_1, M_2, M_3$ with the encryption algorithm $E$ and the key $k$. The intermediate ciphertexts $C_1, C_2$ are eliminated. Only the last block $C_3$ constitutes the MAC.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**CBC-MAC**: CBC mode + IV=0, only last block kept. DES: key 56/112 bits, MAC 64 bits.
:::

## Nested MACs and HMACs

**Nested MAC (NMAC):** Composition of two MAC families $G$ and $H$:

$$\text{NMAC}_{k,l}(x) = g_k(h_l(x))$$

**Security:** Depends on two criteria:

- $G$ resistant to collisions
- $H$ resistant to specific MAC attacks

**HMAC (FIPS 198 standard, 2002):** Nested MAC using unkeyed MDCs (SHA-1, SHA-256).

**Construction:**

- Constants: `ipad = 0x363636...36` and `opad = 0x5C5C5C...5C` (512 bits)
- Key $k$ of 512 bits

$$\text{HMAC-256}_k(x) = \text{SHA-256}((k \oplus \text{opad}) \parallel \text{SHA-256}((k \oplus \text{ipad}) \parallel x))$$

**Advantages:**

- Most widely used MACs in practice
- Attacks on SHA more difficult with secret key
- Excellent performance
- Standardized and widely supported

::: {.callout-note collapse=true title="Original Text"}
A **Nested MAC** or **NMAC** is a composition of 2 families of MAC functions $G$ and $H$ parameterized by keys $k$ and $l$ such that:

$$G \circ H = \{ g \circ h \text{ with } g \in G \text{ and } h \in H \} \text{ with } g \circ h_{(k,l)}(x) = g_k(h_l(x))$$

The security of an NMAC depends on two criteria:

- The family of functions $G$ is collision resistant.
- The family of functions $H$ is resistant to specific attacks for MACs, i.e.: It is impossible to find a pair $(x,y)$ and a fixed but unknown key $m$, such that: $\text{MAC}_m(x) = y$.

An **HMAC** (FIPS 198, 2002) is a Nested MAC using at its base dedicated unkeyed MDCs like SHA-1 or SHA-256.

An HMAC uses two 512-bit constants called `ipad` and `opad` such that:

- `opad := 363636 ... 36` 
- `ipad := 5C5C5C ... 5C`

and a key $k$ of 512 bits.

The operating scheme of HMAC-256 (based on SHA-256) is as follows:

$$\text{HMAC-256}_k(x) := \text{SHA-256}((k \oplus \text{opad}) \parallel \text{SHA-256}((k \oplus \text{ipad}) \parallel x))$$

**HMACs** are the most used MACs. The attacks mentioned on the functions of the SHA family are more difficult to carry out on an HMAC because of the key $k$.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**HMAC**: double hash with derived keys (`ipad`/`opad`). $\text{HMAC}_k(x) = H((k \oplus \text{opad}) \parallel H((k \oplus \text{ipad}) \parallel x))$. Standard, secure, performant.
:::

## Hash Functions Applications

### Data Integrity

**Three main approaches:**

1. **MAC only:**
   - $A \to B: X, \text{MAC}_k(X)$
   - Authentication + integrity guaranteed
   - Requires shared key

2. **MDC + Encryption:**
   - $A \to B: E_k(X, \text{MDC}(X))$
   - Confidentiality + integrity
   - Shared symmetric key

3. **MDC + Authentic channel:**
   - $A \to B: X$ (normal channel)
   - $A \to B: \text{MDC}(X)$ (authentic channel)
   - Channel separation

**Limitations:** These simple protocols offer no protection against replay attacks.

**Solution:** add timestamps or sequence numbers.

::: {.callout-note collapse=true title="Original Text"}
**MAC Only**:
$$A \to B: X, \text{MAC}_k(X)$$
If $B$ computes on its side $\text{MAC}_k(X)$ and obtains the same value ⇒ the message comes from $A$.

**MDC + symmetric encryption** (key $k$ known to $A$ and $B$)
$$A \to B: X, E_k(\text{MDC}(X))$$
$B$ computes $\text{MDC}(X)$ and then $E_k(\text{MDC}(X))$. If equal ⇒ message comes from $A$.

**As 2) with confidentiality of $X$ added**:
$$A \to B: E_k(X,\text{MDC}(X))$$

**MDC + digital signature**:
$$A \to B: X, \text{Sig}_{\text{priv-A}}(\text{MDC}(X))$$
$B$ computes $\text{MDC}(X)$ and verifies $\text{Sig}_{\text{priv-A}}(\text{MDC}(X))$ with an authentic copy of `pub-A`. If equality ⇒ $A$ is the origin of the message. This solution additionally offers **origin non-repudiation**.

These simple protocols offer no support for uniqueness nor for the timeliness of received messages and are exposed to **replay attacks**! They require mechanisms taking into account time or the transaction context (cf. entity authentication).
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Integrity**: MAC only, MDC+crypto, MDC+signature.

⚠️ Vulnerable to replay without timestamps/nonces.
:::

### Blockchains and Proof of Work

**Bitcoin and blockchains:** Use of hash functions to chain transaction blocks.

**Characteristics:**

- Public and visible transactions
- Blocks chained via cryptographic hash functions
- Mining = solving a cryptographic puzzle (proof of work)

**Proof of Work:**

- Find a nonce such that $\text{hash}(\text{block} \parallel \text{nonce}) < \text{target}$
- Computationally expensive puzzle, rapid validation
- First miner to solve receives bitcoin reward

**Security:**

- Blockchain = public, decentralized, immutable ledger
- Falsification would require effort > all honest miners
- Protection based on CRHF properties

**Bitcoin statistics (October 2025):**

- Difficulty: 150.84 T
- Target: $\approx 2^{177}$ (pseudo-collision on 79 bits)
- Hashrate: ~1.1 ZH/sec ($1.1 \times 10^{21}$ hash/sec)
- Average block generation time: 10 minutes

::: {.callout-note collapse=true title="Original Text"}
Bitcoin transactions are published and visible by all participants. They are encapsulated in blocks chained using cryptographic hash functions.

**Mining** consists of iteratively adding new blocks containing current transactions.

Generating a valid block requires solving a **cryptographic puzzle** (proof of work) very costly in computation time (finding pseudo-collisions in cryptographic hash functions). Validation remains very efficient.

The first miner able to generate a valid block will receive a monetary reward (in bitcoins). The mining process is open to all miners but only the first is rewarded.

The resulting chain of blocks (**blockchain**) then becomes a public ledger, decentralized and **immutable** protecting all past transactions. Falsification/modification of data protected by the blockchain would require computational effort greater than that performed by all honest miners.

**Bitcoin Statistics 13/10/2025**:

- **Difficulty**: 150.84 T
- **Target**: $2^{224} / \text{Difficulty} = \approx 2^{177}$. The valid digest to generate a block must be less than $2^{177}$, which means a pseudo-collision on the 79 most significant bits. The variation on the inputs depends on the **nonce**.
- **Hashrate**: ~ 1.1 ZH/sec ($1.1 \times 10^{21}$ hashes /sec)
- **Hash functions executed to obtain a block**: ~ $660 \times 10^{21}$
- **Average block generation time**: 10 min
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Blockchain**: chaining of blocks via hash.

**Proof of Work**: find nonce for hash < target.

Security = effort > all miners.

Bitcoin: ~10 min/block, $10^{21}$ hash/sec.
:::

### Other Applications

**1. Authentication:**

- Data origin authentication (DOA)
- Transaction authentication (DOA + temporal parameters)

**2. Virus checking:**

- Creator publishes $\text{digest} = h(\text{software})$ via secure channel
- Users verify integrity by recalculating the digest

**3. Public key distribution:**

- Publish $h(\text{public key})$ instead of the complete key
- Simplified authenticity verification

**4. Document timestamping:**

- Timestamp applied to digest rather than complete document
- Reduction of data to sign

**5. One-time password (S-Key):**

- Hash chain: $x_1 = h(x_0), x_2 = h(x_1), \ldots, x_n = h(x_{n-1})$
- System stores $x_n$, user provides $x_{n-1}$
- Verification: $h(x_{n-1}) = x_n$
- After validation, system stores $x_{n-1}$ for next time

::: {.callout-note collapse=true title="Original Text"}
**Authentication**:

- data origin authentication (DOA)
- transaction authentication (= DOA + time-variant parameters)

**Virus checking**:

- The creator of software creates a digest = $h(x)$ with $x$ being the original and distributes it via a secure channel (eg. CD-ROM).

**Distribution of public keys**:

- Allows controlling the authenticity of a public key.

**Timestamp on a document**:

- The document on which we want to perform the timestamp is first submitted to a hash function. The timestamp (with the signature of the corresponding entity) then applies only to the digest.

**One-time password (S-Key)** (identification mechanism):

- From a secret seed $x_0$, we create a chain of hash-values: $x_1 = h(x_0)$, $x_2 = h(x_1)$, ... $x_n = h(x_{n-1})$.
- The system stores $x_n$ and the user enters $x_{n-1}$. If $h(x_{n-1}) == x_n$ ⇒ OK.
- The system then stores $x_{n-1}$ and so on.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**Applications**

- authentication
- virus checking
- public key distribution
- timestamping
- one-time passwords (hash chain)
:::

## Randomized Hash Functions: UNIX Example

**Problem:** Deterministic hash functions always produce the same result for the same password.

**Risks:**

- Detection of identical passwords
- Offline dictionary attacks (pre-computed codebooks)
- Rainbow tables

**UNIX solution: Salt**

- Addition of a 12-bit pseudo-random element (salt) before hashing
- Different salt for each user
- 4096 possibilities ($2^{12}$) for each password

**Advantages:**

- Prevents detection of duplicates
- Pre-computed codebooks become ineffective
- Each password requires 4096 dictionary entries

**UNIX implementation:**

- File `/etc/passwd` globally accessible
- Format: `username:hash(salt+password):uid:gid:...`
- Hash based on modified DES (25 iterations)
- Salt stored in clear (first 2 characters of hash)

**Example:**
```
root:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh
pp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs
```

**Limitations:**

- Effective protection against pre-computed dictionaries
- Online attacks limited by the system (number of attempts)
- Offline attacks possible if file compromised

::: {.callout-note collapse=true title="Original Text"}
UNIX keeps its passwords in a globally accessible file (or possibly distributed by NIS). The stored information corresponds to the result produced by a hash function.

**Example (fictional)**:
```
root:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh
pp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs
```

**Problems**:

- the hash function being deterministic, it produces the same result for identical passwords.
- one could create "books" (codebooks) containing the result of applying the hash function to given inputs (eg. a dictionary) and easily compare them (off-line) with the strings stored by UNIX (**brute force dictionary attack**).

**Solution**:

- Add a (pseudo) random element of **12 bits** different for each password (called **salt**) before computing the hash function and during verification.
- This element allows adding a random factor of **4096 possibilities** for each password and prevents detection of duplicates.

The operating scheme uses DES with 25 iterations, the password as key, and the salt to modify the E-boxes. The final 64-bit result is converted to 11 ASCII characters.

User awareness (not visiting dubious sites) decreases the effectiveness of this technique in malware transmission.

Dictionary attacks are normally less effective **online** because operating systems limit the number of unsuccessful authentication attempts.
:::

::: {.callout-tip collapse=true title="Quick Revision"}
**UNIX salt**: 12 random bits added to password before hash.

4096 possible variations.

Prevents pre-computed codebooks and duplicate detection.
:::

# Digital Signatures

## Introduction and Definitions

A **digital signature** is a string of data associating a message with an originating entity, the digital equivalent of a handwritten signature.

**Classification:**

- **With appendix**: requires the original message for verification (ElGamal, DSS)
- **With message recovery**: allows reconstruction of the message (RSA, Rabin)

Signatures primarily use **asymmetric cryptography** to explicitly identify an entity.

**arbitrated digital signatures**: symmetric technology + Trusted Third Parties (TTP)

::: {.callout collapse=true}
## Original Text

**Digital signature**: string of data allowing to associate a message (in digital form) with an originating entity.

**Digital signature scheme**: generation algorithm + verification algorithm.

**Signature process**: message formatting + signature generation algorithm.

**Verification process**: verification algorithm + (message reconstruction).

**Classification of digital signatures**:

- **Digital signatures with appendix** which require the presence of the original message to verify the validity of the signature. These are the most commonly used. Examples: ElGamal, DSS.
- **Digital signatures with message recovery** which offer, in addition, the possibility to reconstruct the message from the signature. Examples: RSA, Rabin.

Digital signatures are mostly based on **asymmetric crypto** because the concept of a shared key is not suitable for the need to identify an entity explicitly.

Commitments similar to those obtained with a public key signature (such as origin non-repudiation) can however be obtained with symmetric technology and trusted third parties (TTP). These methods are called: **arbitrated digital signatures**.
:::

::: {.callout collapse=true}
## Quick Revision

**Digital signature** = string associating message + entity

**Two types**

- with appendix (requires original message)
- with recovery (reconstructs the message)

Based on asymmetric crypto
:::

---

## Formal Framework: Signatures with Appendix

**Working spaces:**

- $M$: message space
- $M_h$: hashed messages where $m_h = H(m)$ with $H$ a hash function
- $S$: space of possible signatures

**Operation:**

Each entity A defines:

- $S_A : M_h \rightarrow S$ (signature function, uses private key)
- $V_A : M_h \times S \rightarrow \{\text{true}, \text{false}\}$ (verification, uses public key)

With $V_A(m_h, s) = \text{true}$ if and only if $S_A(m_h) = s$

**Essential properties:**

- $S_A$ and $V_A$ easy to compute with the correct keys
- Impossible to find a valid $(m', s')$ without A's private key

::: {.callout collapse=true}
## Original Text

We assume that each entity has a private key to sign messages and an authentic copy of the public keys of correspondents.

**Notation:**
- M: Message space
- $M_h$: $m_h = H(m)$ with $m \in M$, $m_h \in M_h$ and $H$ a hash function
- S: Space of values that can be obtained by a signature process

**Description:**

Each entity defines an injective function $S_A : M_h \rightarrow S$ (i.e., the signature)

The function $S_A$ gives rise to a function $V_A$:
$V_A : M_h \times S \rightarrow \{\text{true}, \text{false}\}$ (i.e., the verification)

such that $\forall m_h \in M_h$, $s \in S$, we have:
$V_A(m_h, s) = \text{true}$ if $S_A(m_h) = s$ and
$V_A(m_h, s) = \text{false}$ otherwise

The operations $S_A$ require the private key of A while the operations $V_A$ use the public key of A.

**Some simple properties:**

- The operations $S_A$ and $V_A$ must be easy to compute (having the corresponding keys)
- It is impossible (computationally) for an entity not having the private key of A to find an $m'$ and an $s'$ with $m' \in M$ and $s' \in S$ such that $V_A(m'_h, s') = \text{true}$ with $m'_h = H(m')$.
:::

::: {.callout collapse=true}
## Quick Revision

Signature: $S_A(m_h) = s$ (private key).

Verification: $V_A(m_h, s)$ (public key).

Impossible to forge without private key.
:::

---

## Formal Framework: Signatures with Recovery

**Additional spaces:**

- $M_S$: space on which the signature is applied
- $R : M \rightarrow M_S$: redundancy function (injective, invertible, public)
- $M_R = \text{Im}(R)$: image of $R$

**Operation:**

- Signature: $S_A : M_S \rightarrow S$ (injective)
- Verification: $V_A : S \rightarrow M_S$ with $V_A \circ S_A = \text{Identity}$

**Generation:**

1. Compute $m_R = R(m)$ and $s = S_A(m_R)$
2. Publish $s$ as A's signature on $m$

**Verification:**

1. Compute $m_R = V_A(s)$ with public key
2. Verify $m_R \in M_R$ (reject otherwise)
3. Reconstruct $m = R^{-1}(m_R)$

**Redundancy function:**

Essential for security. If $M_R = M_S$, it becomes trivial to forge signatures.

**Example:** $R(m) = m \parallel m$ (concatenation). Forgery probability: $(1/2)^n$ for an $n$-bit message.

::: {.callout collapse=true}
## Original Text

**Notation:** in addition to the previous definitions, we have:

$M_S$: The space of elements on which a signature can be applied.

$R$: An injective function: $M \rightarrow M_S$, called the redundancy function. It must be invertible and public.

$M_R = \text{Im}(R)$

**Description:**

Each entity defines an injective function $S_A : M_S \rightarrow S$ (i.e., the signature)

The function $S_A$ gives rise to a function $V_A : S \rightarrow M_S$ (i.e., the verification) such that $V_A \circ S_A = \text{Identity}$ on $M_S$

Note that verification is performed without the private key of A

**Signature generation:**
1. Compute $m_R = R(m)$ and $s = S_A(m_R)$
2. Make $s$ public as A's signature on $m$. This allows other entities to verify the signature and reconstruct $m$.

**Verification:**
1. Compute $m_R = V_A(s)$ (with A's public key)
2. Verify that $m_R \in M_R$ (otherwise reject the signature)
3. Reconstruct $m$ by computing: $R^{-1}(m_R)$

**Properties:**

- The operations $S_A$ and $V_A$ must be easy to compute (having the corresponding keys)
- It is impossible (computationally) for an entity not having the private key of A to find an $s' \in S$ such that $V_A(s') \in M_R$

**Remarks on the redundancy function:**

- The choice of a redundancy function is **essential for the security** of the system.
- If $M_R = M_S$ and $R$ and $S_A$ are bijections respectively from $M$ to $M_R$ and from $M_S$ to $S$, then $M$ and $S$ have identical size and, consequently, it is trivial to forge messages bearing A's signature.

**Example of redundancy function:** let $M = \{m : m \in \{0,1\}^n\}$ (n message size) and $M_S = \{t : t \in \{0,1\}^{2n}\}$. Let $R : M \rightarrow M_S$ such that $R(m) = m \parallel m$ ($\parallel$ being the concatenation of 2 messages). The probability of falling on such a message when trying to forge a message from a signature is: $|M_R| / |M_S| = (1/2)^n$, which is negligible for large messages.

**Attention!**: A redundancy function suitable for one digital signature scheme may cause vulnerabilities in another different one!
:::

::: {.callout collapse=true}
## Quick Revision

**With recovery:** Redundancy function $R(m) = m_R$.

Signature $s = S_A(m_R)$.

Verification: $m_R = V_A(s)$, reconstruct $m = R^{-1}(m_R)$.

Redundancy crucial for security.
:::

---

## RSA Signature

**Key generation:**

- Choose two large prime numbers $p$ and $q$
- Compute $n = pq$ and $\phi(n) = (p-1)(q-1)$
- Choose $e$ with $\text{gcd}(e, \phi(n)) = 1$
- Compute $d$ such that $ed \equiv 1 \pmod{\phi(n)}$
- **Public key**: $(n, e)$; **Private key**: $d$

**Signature:**

1. Compute $m_R = R(m)$ (redundancy function)
2. Compute $s = m_R^d \bmod n$
3. Send $s$

**Verification:**

1. Compute $m'_R = s^e \bmod n$
2. Verify $m'_R \in M_R$ (reject otherwise)
3. Reconstruct $m = R^{-1}(m'_R)$

**Variant with appendix:**

- **Signature**: $m_h = H(m)$, then $s = m_h^d \bmod n$
- **Verification**: $m'_h = s^e \bmod n$, accept if $m'_h = H(m)$

**Characteristics:**

- Signature slower than verification ($d$ large, $e$ small)
- Differentiate signature/encryption keys
- Vulnerable to the same attacks as RSA encryption

::: {.callout collapse=true}
## Original Text

**Key generation:**

- Each entity (A) creates a key pair (public and private) as follows:
- A chooses the size of the modulus $n$ (e.g., size$(n) = 1024$ or size$(n) = 2048$).
- A generates two prime numbers $p$ and $q$ of large size $(n/2)$.
- A computes $n := pq$ and $\phi(n) = (p-1)(q-1)$.
- A generates the verification exponent $e$, with $1 < e < \phi(n)$ such that $\text{gcd}(e, \phi(n)) = 1$.
- A computes the signature exponent $d$, such that: $ed \equiv 1 \pmod{\phi(n)}$ using the extended Euclidean algorithm or fast exponentiation.
- The pair $(n,e)$ is A's public key; $d$ is A's private key.

**Signature:**

- A computes the redundancy function of the message $m$: $m_R := R(m)$.
- A computes the signature: $s := m_R^d \bmod n$ and sends $s$ to B.

**Verification:**

- Entity B obtains $(n,e)$, the authentic public key of A.
- B computes $m'_R = s^e \bmod n$, verifies $m'_R \in M_R$ and rejects the signature if $m'_R \notin M_R$
- B retrieves the correctly signed message by A by computing: $m = R^{-1}(m'_R)$.

**Remarks:**

The proof of operation is identical to that of the encryption process. The order of exponentiation has no influence since:
$$ed \equiv de \equiv 1 \pmod{\phi(n)}$$

The process can also be used to produce **signatures with appendix** with the following modifications:

**Signature:**
- A uses a hash function $H$ and computes $m_h := H(m)$.
- A computes the signature of $m_h$: $s := m_h^d \bmod n$ and sends the pair $(m,s)$ to B.

**Verification:**
- B computes $m'_h = s^e \bmod n$ and $H(m)$ and verifies the equality $m'_h = H(m)$.
- If the equality is verified, B accepts the signature $s$ of A on the message M.

The signature computation is **slower** than verification because of the difference in size between the exponent $d$ (size$(d) \approx$ size$(\phi(n))$) and $e$.

The risks and attacks mentioned in the encryption process also apply to the signature.

It is advisable to **differentiate the key pairs for encryption and signature** since they require distinct storage, backup and update policies.
:::

::: {.callout collapse=true}
## Quick Revision

**RSA signature:** $s = m_R^d \bmod n$ (private).

Verify: $m'_R = s^e \bmod n$ (public).

With appendix: $s = H(m)^d \bmod n$.

Signature slow, verification fast.
:::

---

## Blind Signatures

**Principle:** A sends information to B for signature. From the response, A can compute B's signature on a different message that B has never seen.

**Exploitation of the multiplicative property of RSA:**

$$(m_1 m_2)^e \equiv m_1^e m_2^e \equiv c_1 c_2 \pmod{n}$$

**Blinding functions:**

Let $k$ be an integer with $\text{gcd}(n,k) = 1$:

- **Blinding**: $f(m) = m \cdot k^e \bmod n$
- **Unblinding**: $g(m) = k^{-1} \cdot m \bmod n$

Result: $g(S_B(f(m))) = g(S_B(mk^e \bmod n)) = g(m^dk \bmod n) = m^d \bmod n = S_B(m)$

**Protocol:**

1. A → B: $m' = f(m)$ (blinded message)
2. A ← B: $s' = S_B(m')$ (signature of blinded message)
3. A computes $g(s')$ and obtains $S_B(m)$ (signature of original message)

**Applications:** Anonymous electronic cash, electronic voting systems.

::: {.callout collapse=true}
## Original Text

**Scheme invented by Chaum.**

**Idea:** A sends information to B for signature. B returns to A the signed information. From this signature, A can compute B's signature on another message chosen beforehand by A. This allows A to have a signature of B on a message that B has never seen (hence the name blind signature...).

In fact it is a vulnerability based on the **multiplicative property of RSA**: $(m_1m_2)^e \equiv m_1^e m_2^e \equiv c_1 c_2 \pmod{n}$ which was exploited to make a new signature scheme.

**Algorithm:** Let $S_B$ be the RSA signature of B with $(n,e)$ and $d$, respectively the public and private keys of B. Let $k$ be a fixed integer with $\text{gcd}(n,k) = 1$:

$f : \mathbb{Z}_n \rightarrow \mathbb{Z}_n$ with $f(m) = m \cdot k^e \bmod n$ (blinding function)

$g : \mathbb{Z}_n \rightarrow \mathbb{Z}_n$ with $g(m) = k^{-1} \cdot m \bmod n$ (unblinding function)

which gives:

$$g(S_B(f(m))) = g(S_B(mk^e \bmod n)) = g(m^dk \bmod n) = m^d \bmod n = S_B(m)$$

**Protocol:**

- A → B: $m' = f(m)$
- A ← B: $s' = S_B(m')$
- A computes $g(s')$ and obtains the desired signature using (*).
:::

::: {.callout collapse=true}
## Quick Revision

**Blind signature:** Exploits RSA multiplicativity.

Blinding $f(m) = m \cdot k^e$

Unblinding $g(m) = k^{-1} \cdot m$.

B signs $f(m)$, A obtains $S_B(m)$ without B seeing $m$.
:::

---

## Rabin Signature

**Key generation:**

- Generate two large prime numbers $p$ and $q$
- Compute $n = pq$
- **Public key**: $n$; **Private key**: $(p, q)$

**Signature:**

1. Compute $m_R = R(m)$ (redundancy function)
2. Compute $s = \sqrt{m_R} \bmod n$ (square root mod $n$)
3. Send $s$ (one of the 4 square roots)

**Verification:**

1. Compute $m'_R = s^2 \bmod n$
2. Verify $m'_R \in M_R$ (reject otherwise)
3. Reconstruct $m = R^{-1}(m'_R)$

**Characteristics:**

- Based on the SQROOTP problem (square roots mod composite)
- **Provably secure**: equivalent to factorization
- Vulnerable to active chosen-ciphertext attacks

::: {.callout collapse=true}
## Original Text

**Key generation:**

- Each entity (A) creates a key pair (public and private) as follows:
- A generates two random prime numbers $p$ and $q$ of large size (len$(pq) \geq 1024$).
- A computes $n := pq$.
- The public key of A is $n$, the private key of A is $(p,q)$.

**Signature:**

- A computes the redundancy function of the message $m$: $m_R := R(m)$.
- A uses its private key to compute the signature: $s := m_R^{1/2} \bmod n$ using efficient algorithms to compute square roots mod $p$ and mod $q$.
- A sends $s$ to B ($s$ is one of the 4 obtained square roots).

**Verification:**

- Entity B obtains $n$, the authentic public key of A.
- B computes $m'_R = s^2 \bmod n$, verifies $m'_R \in M_R$ and rejects the signature if $m'_R \notin M_R$
- B retrieves the correctly signed message by A by computing: $m = R^{-1}(m'_R)$.

**Remarks:**

The Rabin procedure is based on the **impossibility of finding square roots modulo a composite of unknown factorization** (SQROOTP problem).

The main interest of this algorithm lies in the fact that it has been **proven to be equivalent to factorization** (SQROOTP ⇔ FACTP). This algorithm therefore belongs to the **provably secure** category for any passive attack.

**Active attacks** can, in some cases, compromise the security of the algorithm. More precisely, if we mount the following chosen ciphertext attack (we ask A to decrypt a chosen ciphertext):

- The attacker M generates an $m$ and sends to A the ciphertext $c = m^2 \bmod n$.
- A responds with a root $m_x$ among the 4 possible $m_1, m_2, m_3, m_4$.
- If $m \not\equiv m_x \pmod{n}$ (probability 0.5), M repeats with a new $m$.
- Otherwise, A computes $\text{gcd}(m - m_x, n)$ and thus obtains one of the two factors of $n$...

This attack could be avoided if the procedure required sufficient redundancy in the plaintexts allowing A to identify without ambiguity which of the possible solutions is the original plaintext. In this case, A would always respond with $m$ and discard the other solutions that do not have the predefined level of redundancy.
:::

::: {.callout collapse=true}
## Quick Revision

**Rabin:** $s = \sqrt{m_R} \bmod n$.

Verify: $m'_R = s^2 \bmod n$.

**Provably secure** (equivalent to factorization).

Vulnerable to active chosen-ciphertext attacks.
:::

---

## ElGamal Signature

**Key generation:**

- Generate prime $p$ and generator $\alpha \in \mathbb{Z}_p^*$
- Generate random secret $a$, compute $y = \alpha^a \bmod p$
- **Public key**: $(p, \alpha, y)$; **Private key**: $a$

**Signature:**

1. Compute $m_h = H(m)$
2. Generate random $k$ with $\text{gcd}(k, p-1) = 1$
3. Compute $r = \alpha^k \bmod p$
4. Compute $s = k^{-1}(m_h - ar) \bmod (p-1)$
5. Signature: $(r, s)$

**Verification:**

1. Verify $1 \leq r \leq p-2$ (reject otherwise)
2. Compute $v_1 = y^r r^s \bmod p$
3. Compute $v_2 = \alpha^{H(m)} \bmod p$
4. Accept if $v_1 = v_2$

**Proof:** If $s \equiv k^{-1}(m_h - ar) \pmod{p-1}$, then $m_h \equiv ar + ks \pmod{p-1}$

So $v_2 = \alpha^{m_h} \equiv \alpha^{ar+ks} \equiv (\alpha^a)^r (\alpha^k)^s \equiv y^r r^s = v_1 \pmod{p}$

**Characteristics:**

- Works only with appendix (hash)
- Base of DSA (Digital Signature Algorithm)
- $k$ must be unique for each signature

::: {.callout collapse=true}
## Original Text

**Key generation:**

- Each entity (A) creates a key pair (public and private) as follows:
- A generates a prime number $p$ (len$(p) \geq 1024$ bits) and a generator $\alpha$ of $\mathbb{Z}_p^*$.
- A generates a random number $a$, such that $1 \leq a \leq p-2$ and computes $y := \alpha^a \bmod p$.
- The public key of A is $(p, \alpha, y)$, the private key of A is $a$.

**Signature:**

- A uses a hash function $H$ and computes $m_h := H(m)$.
- A generates a random number $k$ ($1 \leq k \leq p-2$ and $\text{gcd}(k,p-1) = 1$) and computes $k^{-1} \bmod (p-1)$
- A computes $r := \alpha^k \bmod p$ and then $s := k^{-1}(m_h - ar) \bmod (p-1)$
- The signature of A on the message $m$ is the pair $(r,s)$.

**Verification:**

- Entity B obtains $(p, \alpha, \alpha^a \bmod p)$, the authentic public key of A.
- B verifies that $1 \leq r \leq p-2$, otherwise rejects the signature.
- B computes $v_1 := y^r r^s \bmod p$.
- B computes $H(m)$ and $v_2 := \alpha^{H(m)} \bmod p$
- B accepts the signature iff $v_1 = v_2$.

**Remarks:**

**Proof that the scheme works:** If $s \equiv k^{-1}(m_h - ar) \pmod{p-1}$, we have:
$$m_h \equiv (ar + ks) \pmod{p-1}$$ 
and
$$v_2 = \alpha^{H(m)} \bmod p$$

if, as we wish to show $m_h = H(m)$, by reducing exponents mod $(p-1)$, we can rewrite $v_2$:
$$v_2 \equiv \alpha^{ar+ks} \pmod{p}$$

On the other hand:
$$v_1 = y^r r^s \equiv \alpha^{ar} \alpha^{ks} \equiv \alpha^{ar+ks} \pmod{p}$$ 
Q.E.D.

By construction, the ElGamal scheme works **only with appendix** (result of applying a hash function). The Nyberg-Rueppel scheme introduces a variation allowing message recovery.

The **Digital Signature Algorithm (DSA)**, approved by the US National Institute of Standards and Technology has become the most commonly used signature standard. It is built on the basis of a direct derivative of the ElGamal scheme with the SHA-1 hash function.
:::

::: {.callout collapse=true}
## Quick Revision

**ElGamal:** $(r,s)$ with $r = \alpha^k \bmod p$, $s = k^{-1}(m_h - ar) \bmod (p-1)$.

Verify: $y^r r^s \stackrel{?}{=} \alpha^{H(m)} \bmod p$.

Base of DSA.

$k$ unique crucial.
:::

---

## Signatures and Cryptocurrencies

Cryptocurrencies massively use digital signatures to authenticate transactions.

**Bitcoin and Ethereum:**

- Use **ECDSA** (Elliptic Curve Digital Signature Algorithm)
- Derivative of ElGamal on elliptic curves
- Security based on ECDLP

**Transaction process:**

Each spending/transmission requires:

- Signature with the **current holder's private key**
- The holder was the recipient of the previous transaction
- Each transaction forms an authentication chain

**ECDSA advantages:**

- Shorter keys for equivalent security
- More efficient computations
- Suitable for blockchain constraints

::: {.callout collapse=true}
## Original Text

Most cryptocurrencies are based on asymmetric cryptography. Bitcoin e.g. uses digital signatures to authenticate its transactions.

The spending or transmission of bitcoins requires the signature with the private key of the holder (who was in turn the recipient of the previous transaction).

Bitcoin and Ethereum use the **ECDSA (Elliptic Curve Digital Signature Algorithm)** algorithm derived from the ElGamal signature algorithm on elliptic curves whose security relies on ECDLP.

[Image: Diagram showing the Bitcoin transaction chain with signatures]

Source Image: Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto
:::

::: {.callout collapse=true}
## Quick Revision

**Cryptocurrencies:** Bitcoin/Ethereum use **ECDSA** (ElGamal on elliptic curves).

Each transaction signed with holder's private key.

Security based on ECDLP.
:::

---

## Summary Table of Schemes

| Class | Scheme | Message Recovery | Base Problem |
|--------|---------|------------------|------------------|
| **Classical Signatures** | RSA | Yes | RSAP |
| | Rabin | Yes | SQROOTP |
| | ElGamal | No | DLP |
| | DSS | No | DLP |
| **One-time Signatures** | Lamport | No | depends on OWF |
| | Bos-Chaum | No | depends on OWF |
| **Undeniable Signatures** | Chaum-van Antwerpen | No | DLP |
| **Fail-Stop Signatures** | van Heyst-Pedersen | No | DLP |
| **Blind Signatures** | Chaum | Yes | RSAP |

::: {.callout collapse=true}
## Original Text

[Complete table with all above information]

The operation of One-time, Undeniable and Fail-Stop signature schemes can be consulted in [Men97].
:::

::: {.callout collapse=true}
## Quick Revision

**Classical signatures:**

- RSA/Rabin (recovery)
- ElGamal/DSS (appendix)

**Specialized:**

- One-time
- Undeniable
- Fail-stop
- Blind

Base problems: RSAP, SQROOTP, DLP, depends on OWF.
:::

---

## Types of Attacks

**Criteria for "breaking" a scheme:**

- **Total Break**: Compute the private key or efficient generation algorithm
- **Selective forgery**: Generate signature for fixed message/class
- **Existential forgery**: Forge at least one signature (without message control)

**Basic attacks:**

- **Key-only**: Only the public key is known
- **Known-messages**: Access to signatures of known messages
- **Chosen-messages**: Attacker chooses messages to be signed
- **Adaptive chosen-messages**: Choice depends on previous responses

These attacks are equivalent to attacks on encryption systems (known/chosen-plaintext/ciphertext) but applied to messages.

::: {.callout collapse=true}
## Original Text

**Criteria for "breaking" a digital signature scheme:**

- **Total Break**: Compute the signer's private key or an efficient (polynomial) algorithm to generate signatures.
- **Selective forgery**: The adversary is able to generate a valid signature for a fixed message (or class of messages).
- **Existential forgery**: The adversary is able to forge a signature for (at least) one message (which they do not control).

**Basic attacks:**

- **Key-only attacks**: The adversary only has knowledge of the signer's public key.
- **Message-based attacks**: The adversary has access to signatures corresponding to:
  - known-messages
  - chosen-messages
  - adaptive chosen-messages

Equivalent to x-ciphertext attacks but with messages!
:::

::: {.callout collapse=true}
## Quick Revision

**Breaking signature:**

- Total break (private key)
- selective forgery (fixed message)
- existential (one message)

**Attacks:**

- key-only
- known/chosen/adaptive-chosen-messages.
:::

Here is the **exact English translation** of your document, preserving all content, structure, formatting, and technical terminology:

---

# Authentication

## Authentication of Data Origin and Entities

### Authentication Methods

Authentication of origin ensures that a message genuinely comes from the claimed sender.

**Symmetric Methods:**

- **MAC alone**: `A → B: X, MACk(X)` – B verifies using the shared key *k*
- **MDC + encryption**: `A → B: X, Ek(MDC(X))` or `A → B: Ek(X, MDC(X))`

**Asymmetric Method:**

- **MDC + signature**: `A → B: X, Sigpriv-A(MDC(X))` – Also provides non-repudiation

**Limitations:** These simple protocols do not protect against replay attacks or ensure message freshness. Time- or context-aware mechanisms are required.

::: {.callout-note collapse="true"}
### Original Text

**Authentication of Data Origin**

**1) MAC with a symmetric key *k* known to A and B:**
`A → B: X, MACk(X)`
If B computes `MACk(X)` independently and obtains the same value ⇒ the message originates from A.

**2) MDC + symmetric encryption (key *k* known to A and B):**
`A → B: X, Ek(MDC(X))`
B computes `MDC(X)` then `Ek(MDC(X))`. If equal ⇒ message comes from A.

**3) As 2) with confidentiality of X:**
`A → B: Ek(X, MDC(X))`

**4) MDC + digital signature:**
`A → B: X, Sigpriv-A(MDC(X))`
B computes `MDC(X)` and verifies `Sigpriv-A(MDC(X))` using an authentic copy of *pub-A*. If equal ⇒ A is the originator.
This solution also provides **non-repudiation of origin**.

These simple protocols offer no support for **uniqueness** or **freshness (timeliness)** of received messages and are vulnerable to **replay attacks**. They require mechanisms accounting for time or transaction context.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**4 Methods**

- MAC alone
- MDC + encryption
- MDC + confidential encryption
- MDC + signature

**Warning:** Vulnerable to replay attacks without temporal mechanisms
:::

```{mermaid}
graph LR
    A[Sender A] -->|X, MAC/Signature| B[Receiver B]
    B -->|Verifies| C{Authentic?}
    C -->|Yes| D[Accept]
    C -->|No| E[Reject]

    style A fill:#e1f5ff
    style B fill:#e1f5ff
    style D fill:#d4edda
    style E fill:#f8d7da
```

---

### Entity Authentication – Introduction

#### Objectives of a Robust Protocol

Entity authentication (or identification) aims to prove an entity’s identity in real time.

**Required Properties:**

1. If A and B are honest and A authenticates, B must accept A’s identity.
2. B cannot reuse A’s information to impersonate A to C.
3. Negligible probability that entity C successfully impersonates A.
4. Property 3 holds even if C has observed or participated in prior protocol instances.

**Basic Elements:**

- **Something known**: passwords, PINs, keys
- **Something possessed**: smart cards, password generators
- **Something inherent**: biometrics (fingerprints, retina, DNA)

**Classification:**

- **Weak authentication**: Reveals the secret (userid/password)
- **Strong authentication**: Proves possession of the secret without revealing it
- **Zero-knowledge**: Strong authentication without revealing any information about the secret

::: {.callout-note collapse="true"}
### Original Text

**Entity Authentication (Entity Identification)**

**Objectives of a Robust Identification Protocol:**

1. If A and B are "honest": if A can authenticate to B, B must accept A’s identity.
2. B cannot reuse information provided by A to identify as A to C.
3. The probability that a third party C successfully impersonates A to B is negligible.
4. Point 3) remains true even if:
   - C has observed a large (polynomial) number of identification protocol instances between A and B
   - C has participated (possibly impersonating someone else) in prior protocol executions with A or B
   - Multiple protocol instances (possibly initiated by C) may run simultaneously without compromising the identification process

**Terminology**: The user (A) is called the **claimant** (the one claiming to be A), and the system (B) is the **verifier**.

**Basic Authentication Elements:**

- **Something known**: passwords, PINs, private or secret keys, etc.
- **Something possessed**: passport, smart card, password generators, etc.
- **Something inherent to the individual**: biometric properties like fingerprints, retina, DNA, etc.

**Weak Authentication**: The user presents a pair (userid, password) to the system. The userid is the claimed identity, and the password is the corroborating evidence.

**Strong Authentication**: The secret used to corroborate identity is not explicitly revealed. The user provides proof of possession of the secret.

**Zero-Knowledge Authentication**: Strong authentication protocols that additionally prove identity without revealing any information (not even a hint) about the secret itself. This involves proving an assertion without disclosing any details.

**Weak authentication protocols** satisfy points 1) and 3). **Strong authentication protocols** satisfy (at least partially) points 2) and 4) as well.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**3 Levels**: Weak (reveals secret) < Strong (proof of possession) < Zero-knowledge (no info revealed)

**4 Objectives**

- Acceptance if honest
- Non-reusability
- Impersonation resistance
- Observation resistance
:::

---

## Attacks and Countermeasures

### Dictionary Attacks

#### Principle and Countermeasures

A dictionary attack systematically tests probable passwords against a cryptographic system.

**Attack Methods:**

- **Offline**: The attacker obtains the hashed password database or captures exchanges
- **Online**: Direct attempts against the system (typically rate-limited)

**Vulnerability Example:**

- `A → B: A`
- `A ← B: R` (random challenge)
- `A → B: Ep(R)`

The pair `(R, Ep(R))` enables an offline dictionary attack.

**Countermeasures:**

- Limit online attempts
- Salting (adding a random element)
- Use slow key derivation functions
- Strong authentication avoiding password transmission

::: {.callout-note collapse="true"}
### Original Text

**Dictionary Attacks**

A dictionary attack uses a database containing dictionary words from one or more languages (including variants) as input to an encryption or hashing system to obtain secret keys or passwords.

This attack is highly effective for obtaining poor-quality passwords, even today, with large databases containing word variations and complex mnemonic rules to "crack" higher-entropy passwords.

**A dictionary attack can be mounted:**

- By obtaining the system’s password database (encrypted or hashed)
- From one or more authentication exchange instances following a passive attack (network packet observation). For example:
  - `A → B: A` (A sends its identity)
  - `A ← B: R` (R = random number, challenge)
  - `A → B: Ep(R)` (A encrypts R with its password)

The pair `(R, Ep(R))` enables an **offline** dictionary attack.

Dictionary attacks are typically less effective **online** because operating systems limit the number of failed authentication attempts.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Offline** (via DB or capture) > **Online** (system-limited)

**Protection**: Salting, attempt limiting, strong authentication
:::

---

### Plaintext Equivalence

#### Concept and Risks

A string is **plaintext-equivalent** to a password if it grants the same access as the password itself.

**Vulnerability Example:**

If the system stores `H(p)` and the protocol is: `A → B: H(p)`

Then `H(p)` is plaintext-equivalent to `p` because the attacker can use it directly.

**Counterexample (Classic UNIX):**

The system stores `H(p)` but the protocol transmits `p`. The stored hash is thus not plaintext-equivalent.

**Security Principle:** Server-stored information must be neither plaintext-equivalent to passwords nor exposed to offline dictionary attacks.

::: {.callout-note collapse="true"}
### Original Text

**Plaintext Equivalence**

A data string is **plaintext-equivalent** to a password if it can be used to obtain the same access level as the password.

**Example:** If system B stores a list of all hashed passwords in the following authentication process:
`A → B: H(p)` (A sends B the hash of the password)

The string `H(p)` is **plaintext-equivalent** to the password `p`.

This is equivalent to saying that applying a hash function for password storage provides no additional security for the system.

**Counterexample:** In the classic UNIX authentication system, the password hash stored in `/etc/passwd` is **not** plaintext-equivalent to the password because it is `p` (not `H(p)`) that is exchanged between client and server.

This property is essential because password databases are typically protected by logical mechanisms that are often compromised by server OS vulnerabilities.

If these central databases contain passwords in cleartext or plaintext-equivalent information, the consequences of an attack are devastating.

**The ideal case** is that server-stored information is neither plaintext-equivalent to passwords nor exposed to offline dictionary attacks.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Plaintext-equivalent**: Data usable like the original password

**Danger**: If the system transmits `H(p)` and stores `H(p)` → `H(p)` is plaintext-equivalent

**Good Design**: System transmits `p`, stores `H(p)` → not plaintext-equivalent
:::

---

## Weak Authentication

### Fixed Passwords

#### Storage and Protection

Fixed-password systems exhibit significant vulnerabilities.

**Storage Techniques:**

- **Cleartext**: Protected by OS access control (vulnerable to OS flaws, backups)
- **Encrypted or hashed**: Vulnerable to offline attacks (guessing, dictionary, collisions)

**Major Problem:** The password can be replayed after observation on an unprotected network.

**Protection Techniques:**

- Strict creation rules (minimum entropy)
- Rate-limiting and attempt restrictions
- **Salting**: Adding a random element before hashing
- Restrict password file dissemination

**Typical Password Entropy:** Low (~40 bits for an 8-character random password, much less for common words).

::: {.callout-note collapse="true"}
### Original Text

**Weak Authentication – Fixed Password**

Weak authentication systems are divided into two main categories:

- **Fixed password**: The password does not depend on time or the number of protocol executions. This includes systems where the password is changed by user decision or system security measures.
- **Variable password**: Password modification based on time and/or execution count is part of the identification protocol.

**Storage Techniques for Fixed-Password Systems:**

- **Cleartext password storage** in a file protected by the OS’s access control mechanisms.
  - Problems: OS vulnerabilities, "super-user" privileges, backups, etc.

- **Encrypted or hashed password storage** (possibly making the file publicly accessible, cf. UNIX example).
  - Problems: offline attacks, i.e., guessing attacks, brute-force dictionary attacks, collision identification, etc.

**Most serious fixed-password problem**: It can be replayed after eavesdropping on an unprotected network.

**Fixed-Password System Protection Techniques:**

- Strict rules for password creation, maintenance, and updates, considering the low entropy of user-chosen passwords
- Slowing the identification process and limiting failed attempts to counter "online brute-force attacks"
- **Salting** (cf. UNIX example)
- Restrict or avoid dissemination of password files, even when encrypted
:::

::: {.callout-tip collapse="true"}
### Quick Review

**2 Types**: Fixed password (static) vs. Variable password (changes per instance)

**Storage**: Cleartext (highly vulnerable) vs. Encrypted/Hashed (offline attacks)

**Protections**: Strict rules, attempt limiting, salting, non-dissemination
:::

---

### Variable Passwords

#### One-Time Passwords and Generators

Variable passwords change with each authentication, reducing replay risk.

**Lamport Scheme (S/Key):**

```
Initialization:
  A generates secret w, chooses t
  A → B: wt = Ht(w)
  B stores: wstored := wt, n := t-1

Identification (t-n)th:
  A → B: A, n, wn = Hn(w)
  B tests: H(wn) == wstored
  If OK: n := n-1, wstored := wn
```

**Attacks if B is not authenticated:**

- **Pre-play attack**: C obtains `wn` before A and replays it
- **Small `n` attack**: C requests an `n` < current n

**Hardware Generators (SecureID):**

- Card generates a code every 30–60 seconds
- Based on a secret key shared with the system
- Vulnerable to pre-play but with limited time window

::: {.callout-note collapse="true"}
### Original Text

**Weak Authentication: Variable Password**

The two best-known variable-password identification techniques are **one-time passwords** and **hardware random number generators**.

**One-Time Passwords – Lamport Scheme (S/Key):**

**Initialization:**

- A generates a secret w
- A constant t (~1000, number of identifications) and a OWF H are chosen
- `A → B: wt = Ht(w)` (H applied t times to w)
- B stores: `wstored := wt`, `n := t-1`

**Messages for the (t-n)th identification:**

- `A → B: A` (A’s identity)
- `A → B: n` (current iteration for A)
- `A → B: wn = Hn(w)`
- B tests: `H(wn) == wstored`. If OK ⇒ `n := n - 1` and `wstored := wn`

**End:** When n == 0, A chooses a new w and restarts...

**Attacks:** **B must be authenticated!** Otherwise, C impersonates B and:

- obtains the current password wn and can replay it (**pre-play attack**)
- provides an n < current n and can thus generate all Hm>n(wn) (**small n attack**)

**Hardware Random Number Generators:**

- These are smart cards that periodically (~every 30 or 60 seconds) generate different numbers used to identify (along with a PIN and user identity information) the cardholder.
- Generation is based on a secret key present on the card and known to the system.
- The best-known is **SecureID** by RSA Security.
- It has been adopted by many banks for Internet tele-banking authentication.
- It is also vulnerable to pre-play attacks, but the replay window is limited to the change frequency (30 or 60 seconds).

**Conclusions on Weak Authentication:**

- Fixed passwords offer very low security.
- Variable passwords are a significant step toward strong authentication but require additional precautions.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Lamport**: wn+1 = H(wn), authentication via hash chain verification

**Hardware**: Synchronized generator (30–60s), limited pre-play window

**Warning**: Requires B’s authentication to prevent pre-play and small-n attacks
:::

---

## Strong Authentication

### Symmetric

#### Basic Protocols

##### Challenge-Response

Strong authentication uses cryptography to prove secret possession without revealing it.

**Basic Unilateral Authentication:**

```
A → B: A
A ← B: R (random challenge)
A → B: Ek-AB(R)
B verifies by decrypting
```

Session key: `K := R`

**Improvements:**

- Add B’s identity: `Es(B, ra)` for key confirmation
- Add timestamp: `Es(B, ta, ra)` for freshness (requires synchronized clocks)
- Use MAC instead of encryption: `Hk-AB(R)` (faster)

**Vulnerabilities:**

- Man-in-the-Middle if no mutual authentication
- Chosen-plaintext attacks possible
- Replay if challenges are poorly managed

::: {.callout-note collapse="true"}
### Original Text

**Strong Authentication: Symmetric Solutions**

Strong authentication protocols use symmetric or asymmetric cryptographic techniques.

**Unilateral Authentication with Shared Symmetric Key:**

```
A → B: A (A sends its identity)
A ← B: R (R = random number, challenge)
A → B: Ek-AB(R) (A encrypts R with the shared key)
```

B decrypts `Ek-AB(R)` and identifies A if it finds R.

**Remarks:**

- B must ensure the challenge R is random and not repeated.
- This protocol is a significant improvement over password authentication because varying challenges prevent Eve from replaying protocol parts.
- Eve can attempt an **offline known-plaintext attack** from a (typically small) number of pairs (R, Ek-AB(R)), but most encryption systems are secure in this regard (DES is vulnerable only after 2^47 pairs).
- C can impersonate B and choose challenges R to mount a **chosen-plaintext attack** (DES vulnerability is also 2^47, but other systems are more sensitive to such attacks).
- C could mount an **Active Man-in-the-Middle** attack by impersonating B since B is not authenticated, but must convince A to start the protocol.
- A **MDC**: `H(k-AB,R)` or a **MAC**: `Hk-AB(R)` can replace `Ek-AB(R)` to speed up identification.
- After initial identification, a secure (at least authenticated) channel must be established using cryptographic protection to prevent C from injecting packets while impersonating A.

Protocols of this type, where one entity must respond based on a challenge from the other, are called **challenge-and-response protocols** and are the most common form of strong authentication.

**Unilateral Authentication with Shared Symmetric Key, 2nd Variant:**

```
A → B: A, Ek-AB(timestamp)
```

Requires synchronized clocks between A and B.

**Advantage:** One fewer message and stateless protocol

**But:**

- Clock synchronization is difficult to achieve in practice, and "drifts" can be exploited by an adversary.
- Moreover, if B’s clock is "advanced," some past identification instances may become valid again.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Challenge-Response**: B sends challenge R, A responds with E_k(R)

**Alternative**: MAC instead of encryption (faster)

**With Timestamp**: One fewer message but requires clock synchronization
:::

---

#### Mutual Authentication

##### Robust Protocols and Reflection Attacks

Bilateral authentication requires precautions against reflection attacks.

**Vulnerable (Naive) Protocol:**

```
A → B: A, R2
A ← B: R1, Ek-AB(R2)
A → B: Ek-AB(R1)
```

**Reflection Attack:** C can start two instances and use B’s response to its own request to complete authentication.

**Robust Protocol:**

```
(1) A → B: A, R2
(2) A ← B: Ek-AB(R1, R2, A)
(3) A → B: Ek-AB(R2, R1)
```

**Protections:**

- Inclusion of A’s identity in (2) to prevent reflection attacks
- Asymmetry in challenge order (R1,R2) vs. (R2,R1)
- Inclusion of challenges in the encrypted message

::: {.callout-note collapse="true"}
### Original Text

**Strong Authentication: Symmetric Solutions (Mutual Authentication)**

**Bilateral Authentication with Shared Symmetric Key (Intuitive Solution):**

```
A → B: A, R2
A ← B: R1, Ek-AB(R2)
A → B: Ek-AB(R1)
```

At first glance, the protocol seems robust, but observe what an adversary C can do by starting two identification processes:

```
C → B: A, R2 (C pretends to be A)
C ← B: R1, Ek-AB(R2) (B responds)
```

At this point, C starts a second instance:

```
C → B: A, R1
C ← B: R3, Ek-AB(R1) (C cannot proceed further but...)
```

Successfully completes the first identification instance with:

```
C → B: Ek-AB(R1) (and it’s done!)
```

Because C returns to B the same R it received from B, such attacks are called **reflection attacks**.

Since the key is shared, C could have achieved the same result (even more discreetly) by executing the second instance with A (pretending to be B).

**Bilateral Authentication with Shared Symmetric Key (Robust Solution):**

```
(1) A → B: A, R2
(2) A ← B: Ek-AB(R1, R2, A)
(3) A → B: Ek-AB(R2, R1)
```

The presence of **A** in (2) adds extra security in case obvious reflection attacks are not detected by the protocol. Otherwise, if A initiates authentication with what it believes to be B but is actually C:

```
A → C: A, R2 (*)
```

Then C starts a new authentication instance with A using the same R2:

```
C → A: B, R2
```

If A does not see R2 as an obvious reflection, it responds:

```
C ← A: Ek-AB(R1, R2) (As in (2) but without the 'A')
```

Which C uses to complete its protocol (*). However, if A responds with B inside the packet as recommended in the protocol:

```
A → C: Ek-AB(R1, R2, B)
```

This can no longer be used by C to continue (*) because it would require A instead of B.

Note also that including R1 in the encrypted part protects against **chosen plaintext attack** risks from the previous solution.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Reflection Attack**: Use one session’s response to authenticate another

**Protection**: Include identities + asymmetry in challenges (R1,R2) vs. (R2,R1)
:::

---

### Asymmetric

#### Public-Key Protocols

Asymmetry avoids secret sharing but requires precautions against chosen-ciphertext attacks.

**Vulnerable Protocol:**

```
A → B: A
A ← B: Epub-A(R)
A → B: R
```

**Problem:** B can make A decrypt anything.

**Robust Protocol:**

```
A → B: A
A ← B: H(R), B, Epub-A(B, R)
A → B: R (after verifying H(R) and B)
```

**Protection:** Structure the encrypted text and prove plaintext knowledge via `H(R)`.

**Mutual Authentication (Needham-Schroeder):**

```
(1) A → B: Epub-B(r1, A)
(2) A ← B: Epub-A(r1, r2)
(3) A → B: Epub-B(r2)
```

The presence of A in (1) prevents chosen-ciphertext attacks.

::: {.callout-note collapse="true"}
### Original Text

**Strong Authentication: Asymmetric Solutions**

**Unilateral Authentication with Asymmetric Key (Intuitive Solution...):**

```
A → B: A
A ← B: Epub-A(R) (B encrypts with A’s public key)
A → B: R (A returns R after decryption)
```

**Remarks:**

- B must know A’s authentic key to avoid man-in-the-middle attacks.
- But especially: B can mount **chosen-ciphertext attacks** (i.e., B can make A decrypt anything!).

**Unilateral Authentication with Asymmetric Key (Robust Solution):**

Idea: Structure the text encrypted with pub-A and show that B knows the plaintext:

```
A → B: A
A ← B: H(R), B, Epub-A(B, R) (H(R) proves B knows R)
```

A decrypts `Epub-A(B, R)` and obtains B' and R'.
A aborts the protocol if `h(R') ≠ h(R)` or `B' ≠ B`, otherwise:

```
A → B: R
```

B identifies A if it matches the initial R.

A dual protocol can be imagined using A’s signature with priv-A (instead of encryption with pub-A), but the same structural precautions apply to prevent A from signing a "malicious" message generated by B.

**Bilateral Authentication with Asymmetric Key. Robust Solution by Needham and Schroeder:**

```
(1) A → B: Epub-B(r1, A)
(2) A ← B: Epub-A(r1, r2)
(3) A → B: Epub-B(r2)
```

Note that the presence of A in (1) thwarts chosen-ciphertext attacks.

The protocol can be strengthened by adding a "witness" `H(r1)` in (1).

**Final Remarks on Classical Authentication:**

- Entity authentication is a highly complex process full of unexpected pitfalls.
- Some protocols, like the one proposed by ISO in 1988 for authentication in distributed directories, have flaws very similar to those highlighted here.
- When identification occurs within a session, it is imperative that all session packets be authenticated (e.g., by establishing a secure channel with session key establishment).
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Vulnerability**: Chosen-ciphertext attacks if no structure

**Protection**: Include H(R), B’s identity in the encrypted message; A verifies before revealing R

**Needham-Schroeder**: 3 messages with identity inclusion to prevent chosen-ciphertext
:::

---

## Zero-Knowledge Proofs

### Concepts

#### Definitions and Principles

Zero-knowledge proofs allow proving possession of a secret without revealing any information about it.

**Required Properties:**

- **Completeness**: If A and B are honest, B accepts A’s proof
- **Soundness**: If C succeeds in deceiving B, then C holds A’s secret (or equivalent)
- **Zero-knowledge**: B learns nothing about A’s secret

**Generic Structure:**

```
(1) A → B: witness
(2) A ← B: challenge
(3) A → B: response
```

**ZKIP Types:**

- **Computational ZKIP**: A polynomial-time observer cannot distinguish a real proof from a simulation
- **Perfect ZKIP**: No probabilistic difference between real proof and simulation (guaranteed by information theory)

**Principle:**

- A commits to a class of questions (1)
- B chooses a question from this class (2)
- A answers using its secret (3)
- Repeat to reduce guessing probability.

::: {.callout-note collapse="true"}
### Original Text

**Zero-Knowledge Proofs: Definitions**

Problem with "classical" authentication methods: B (or even an observer) can obtain information about A’s secret:

- In weak authentication methods (password-based), the secret is fully revealed.
- In classical challenge-and-response methods, B can obtain [plaintext/ciphertext] pairs useful for cryptanalysis.

**Definition:** An interactive protocol is a **proof of knowledge** if it has the following two characteristics:

- **Completeness**: If A and B are "honest," B accepts the proof provided by A.
- **Soundness**: If a "dishonest" entity C can "deceive" B, then C holds A’s secret (or polynomially equivalent information). This is equivalent to requiring secret possession for proof success.

A proof of knowledge is called a **zero-knowledge interactive proof (ZKIP)** if it additionally has the property that A can convince B of a fact without revealing any information about its secret.

A protocol is a **computational ZKIP** if an observer capable of probabilistic polynomial-time tests cannot distinguish a genuine proof (where A responds) from a simulated proof (e.g., by a random generator).

A protocol is a **perfect ZKIP** if there is no probabilistic difference between the real proof and the simulated proof. The absence of information in the proof is guaranteed by Shannon’s information theory, not computational criteria.

**Generic ZKIP Structure:**

```
(1) A → B: witness
(2) A ← B: challenge
(3) A → B: response
```

- **(1)** A chooses a random secret number and sends B proof of possession of this secret. This constitutes a commitment from A and defines a class of questions to which A claims to know the answers.
- **(2)** The challenge sent by B randomly selects a question from this class.
- **(3)** A responds (using its secret).

If necessary, the protocol is repeated to minimize the probability of an "impostor" guessing the correct answers by chance.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**3 Properties**: Completeness (accepts if honest), Soundness (requires secret), Zero-knowledge (no info revealed)

**Structure**: Witness → Challenge → Response (repeat n times)

**Perfect ZK**: Indistinguishable from simulation even with infinite resources
:::

```{mermaid}
sequenceDiagram
    participant A as Prover A
    participant B as Verifier B

    Note over A: Generates witness<br/>with secret s
    A->>B: (1) Witness
    Note over B: Chooses random<br/>challenge
    B->>A: (2) Challenge
    Note over A: Computes response<br/>with secret s
    A->>B: (3) Response
    Note over B: Verifies<br/>Accepts/Rejects

    Note over A,B: Repeat n times for<br/>security 1/2^n
```

---

### ZKIP – Intuitive Example (Ali Baba’s Cave)

#### Concept Illustration

This example intuitively illustrates the zero-knowledge principle.

**Scenario:**

- A knows the secret passage between y and z in a cave
- B wants to verify this knowledge without learning how to traverse

**Protocol:**

1. B stands at entrance E
2. A chooses to go to y or z (witness)
3. B enters and stops at point x
4. B asks A to return from the right or left (challenge)
5. A uses the secret to comply (if needed)

**Repetition:** n times. If A does not know the secret: success probability = $2^{-n}$

**Properties:**

- B confirms A can traverse but learns nothing about how
- B cannot convince a third party B' (A and B could have agreed on sequences)
- Inspired by the "cut-and-choose" technique

::: {.callout-note collapse="true"}
### Original Text

**ZKIP: Intuitive Example**

This example is described in [Qui89] (Quisquater et al., "How to Explain Zero-Knowledge Protocols to Your Children", Crypto'89). Suppose A knows a passage between y and z (the secret).

```
    E
    |
    x
   / \
  y   z
```

**(1)** B stands at the cave entrance at point E.

**(2)** A chooses a direction and goes to points y or z (witness choice).

**(3)** Once A is inside the cave, B enters and stops at point x.

**(4)** B asks A to return to point x from the right or left (the challenge).

**(5)** Using the secret to move from y to z (or vice versa) if necessary, A complies with B’s instructions.

**Repeat steps 1 to 5 n times.** If A does not know the secret, it has a $2^{-n}$ probability of successfully deceiving B (guessing "correctly").

In this example, B sees that A can traverse the yz passage at will but obtains no information on how to do so, even if the protocol is executed millions of times.

Moreover, B cannot convince B' that A knows the secret (as would be the case if A encrypted information using a private key, for example). B' might suspect A and B of agreeing on the sequences (right/left).

Such protocols are inspired by the **"cut-and-choose"** technique, where A and B fairly share a pie as follows:
- A cuts the pie.
- B chooses a piece.
- A takes the remaining piece.

The first ZKIP was published in 1985 by S. Goldwasser [Gol85]. The application of the cut-and-choose paradigm to cryptographic protocols is due to Rabin [Rab78].
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Cave**: A enters randomly (y or z), B asks for exit (left/right)

**Cheating Probability**: $2^{-n}$ after n repetitions

**ZK**: B verifies knowledge but learns no secret, cannot convince third party
:::

---

### ZKIP – Graph Isomorphism

::: {.callout collapse="true"}
### ZKIP – Graph Isomorphism

#### Formal Protocol

Zero-knowledge proofs can be constructed on hard mathematical problems.

**Context:** Two graphs $G_1$ and $G_2$ are isomorphic if there exists a permutation $\pi$ such that for every edge $\{u,v\} \in E_1$, $\{\pi(u), \pi(v)\} \in E_2$.

**Property:** Finding the permutation $\pi$ between two ~1000-node graphs is computationally hard (no known polynomial algorithm).

**Protocol:**

```
Init: A chooses G1 and creates G2 = π(G1) with π secret
(1) A → B: H (A creates H = φ(G2) randomly)
(2) A ← B: i ∈ {1,2}
(3) A → B: ψ such that H = ψ(Gi)
    If i=2: ψ := φ
    If i=1: ψ := φ ∘ π
(4) B verifies H = ψ(Gi)
(5) Repeat n times
```

**Perfect Zero-Knowledge Verification:** Protocol transcripts are indistinguishable (probabilistic distribution) from those produced by a simulator.
:::

::: {.callout-note collapse="true"}
### Original Text

**ZKIP: Graph Isomorphism**

Two graphs $G_1 = (V_1,E_1)$ and $G_2=(V_2,E_2)$ are **isomorphic** if there exists a permutation $\pi$ such that $\{u,v\} \in E_1$ if and only if $\{\pi(u), \pi(v)\} \in E_2$.

**Example:** $G_1 = (V, E_1)$ and $G_2=(V, E_2)$ with $V = \{1,2,3,4\}$, $E_1= \{12,13,23,24\}$, and $E_2 = \{12,13,14,34\}$ are isomorphic with the permutation $G_1 \to G_2 : \{4,1,3,2\}$:

```
G1:  1---2    G2:  4---1
     |\ /|         |\ /|
     | X |         | X |
     |/ \|         |/ \|
     3---4         3---2
```

From a graph $G_1$, one can easily (in polynomial time) find a permutation $\pi$ such that $G_2 = \pi(G_1)$.

However, no polynomial-time algorithm is known to determine if two sufficiently large graphs (~1000 nodes) are isomorphic (i.e., find the permutation $\pi$ from $G_1$ and $G_2$).

**ZKIP Based on Graph Isomorphism:**

**(Initialization)** A chooses a sufficiently large graph $G_1$ and invents a permutation $\pi$ (the secret) to compute a second graph $G_2 = \pi(G_1)$. $G_1$ and $G_2$ are made public.

```
(1) A → B: H
```
A chooses a random permutation $\phi$ such that $H = \phi(G_2)$ and sends H to B (the witness).

```
(2) A ← B: i
```
B chooses an integer $i \in \{1,2\}$ and sends it to A (the challenge).

```
(3) A → B: ψ
```
A computes $\psi$ such that $H = \psi(G_i)$:
- If $i = 2$: $\psi := \phi$
- If $i = 1$: $\psi := \phi \circ \pi$

**(4)** B checks if $H = \psi(G_i)$ and accepts the step as correct.

**(5)** Repeat (1) to (4) enough times to minimize "guessing" risks.

**Property Verification:**

- **Completeness**: The protocol is accepted if A knows the secret (i.e., the permutation $\pi$ between the two graphs).
- **Soundness**: If C tries to impersonate A without knowing $\pi$, it can fix a j and provide a correct permutation $\psi(G_j)$ but cannot find a correct permutation for both graphs. It must guess the challenge provided by B.
- **Zero-Knowledge**: A succeeds in convincing B that the two graphs are isomorphic but learns nothing about $\pi$. B only sees a random graph H isomorphic to $G_1$ and $G_2$ and a permutation between H and $G_1$ or between H and $G_2$.
- **Perfect Zero-Knowledge**: This means B could generate such information alone (using a random generator and polynomial computations). It can be proven that the transcripts provided by the protocol are indistinguishable (from a probabilistic distribution perspective) from those produced by a simulator.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Problem**: Finding permutation between two isomorphic graphs = hard

**Protocol**: A creates random H, B asks for permutation to G1 or G2, A responds

**Perfect ZK**: Transcripts indistinguishable from a simulator
:::

---

### ZKIP – Fiat-Shamir Algorithm

#### Practical Protocol

Fiat-Shamir is an efficient and practical ZKIP based on the square root modulo composite problem.

**Initialization:**

- Trusted third party T chooses $n = pq$ (keeps p,q secret)
- A chooses secret $s$ with $\gcd(s,n) = 1$
- A computes $v = s^2 \bmod n$ and distributes v (certified public key)

**Protocol:**

```
(1) A → B: x = r² mod n
    (A chooses random r, witness)

(2) A ← B: e ∈ {0,1}
    (B sends challenge)

(3) A → B: y = r·sᵉ mod n
    (A computes response with secret s)

B rejects if y = 0
B accepts if y² ≡ x·vᵉ (mod n)
```

**Repetition:** Multiple times for security $2^{-nk}$

**Properties:**

- **Soundness**: An impostor can easily answer e=0, but for e=1, it must compute $\sqrt{x} \bmod n$ (hard by SQROOTP)
- **Perfect Zero-Knowledge**: The pairs (x,y) can be simulated by B by choosing y randomly and computing $x = y^2$ or $y^2/v$
- B cannot impersonate A because it cannot predict challenges

::: {.callout-note collapse="true"}
### Original Text

**ZKIP: Fiat-Shamir Algorithm**

**Goal:** Allow A to identify itself by proving knowledge of a secret s (associated with A via authentic public information) to B without revealing any information about s.

This is a protocol serving as the basis for real and efficient implementations.

**Algorithm:**

**(Initialization):**

(a) A trusted third party T chooses and publishes an n such that $n = pq$ and keeps p and q secret.

(b) A chooses a secret s with $1 \leq s \leq n -1$ and $\gcd(s,n) = 1$, computes $v = s^2 \bmod n$, and distributes v as a public key certified by T.

```
(1) A → B: x = r² mod n
```
A chooses a random r and sends a witness $r^2$.

```
(2) A ← B: e ∈ {0,1}
```
B sends its challenge.

```
(3) A → B: y = r·sᵉ mod n
```
A computes the response using the secret s.

B rejects the proof if $y = 0$ (an impostor could falsify the proof with $r = 0$) and accepts the proof if $y^2 \equiv x \cdot v^e \pmod{n}$.

Steps (1) to (3) are repeated until a sufficient confidence margin is reached.

**Property Verification:**

- **Completeness**: If A knows s, the protocol accepts the identification proof.

- **Soundness**: In the simple case, an impostor could only answer $e = 0$. Otherwise, it could choose a random r and send $x = r^2/v$ in (1) and respond to the challenge $e = 1$ with a correct answer $y = r$. For $e = 0$, it would need to compute the square root of x mod n (n composite with unknown factorization), which is hard by SQROOTP. Proof success thus requires secret possession.

- **Zero-Knowledge**: B cannot obtain any information about s because when $e = 1$, it is hidden by a random number (blinding factor).

- **Perfect Zero-Knowledge**: The pairs (x,y) obtained from A can also be simulated by B by choosing a random y and computing $x = y^2$ or $y^2/v \bmod n$. It can be proven that these pairs have an identical probabilistic distribution to those provided by A (who computes them differently!).

Note that, despite this last property, B is unable to impersonate A to B' because it cannot predict the challenge values e.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Secret**: $s$ such that $v = s^2 \bmod n$ (public key)

**Protocol**: Witness $r^2$, challenge $e \in \{0,1\}$, response $y = r \cdot s^e$

**Verification**: $y^2 \equiv x \cdot v^e \pmod{n}$

**Perfect ZK**: Pairs (x,y) simulatable by B
:::

---

### ZKIP – Practical Implementations

#### Efficient Protocols

Practical implementations improve Fiat-Shamir’s efficiency.

**Feige-Fiat-Shamir (FSS):**

- Uses multiple witnesses and challenges (k values) per iteration
- Cheating probability: $2^{-nk}$ for n iterations
- Reduces required exchanges

**Guillou-Quisquater (GQ):**

- Based on Fiat-Shamir but with expanded challenge domain
- Reduces guessing probability without increasing exchanges
- Better efficiency/security trade-off

**Schnorr:**

- Based on discrete logarithm difficulty (DLP)
- Very large challenge domain
- **Identification in just 3 exchanges**
- Sometimes sacrifices perfect zero-knowledge for efficiency

**Advantages:** More efficient than RSA, implementable on low-capacity devices (smart cards).

::: {.callout-note collapse="true"}
### Original Text

**ZKIP: Common Implementations**

**Feige-Fiat-Shamir (FSS):**

- Based on the Fiat-Shamir protocol but using multiple witnesses and challenges (sets of k values) per iteration; for n iterations, this gives a probability of $2^{-nk}$ of guessing all responses.

**Guillou-Quisquater (GQ):**

- Also based on Fiat-Shamir but increasing the challenge choice, which reduces the guessing probability without increasing the number of transferred instances and protocol steps.

**Schnorr:**

- Based on the difficulty of computing discrete logarithms (DLP)
- It also uses a very large challenge domain, allowing identification in **just 3 message exchanges**.

These protocols are significantly more efficient than RSA and can be implemented on low-computing-capacity devices (smart cards).

They satisfy completeness and soundness properties, but the zero-knowledge property is sometimes sacrificed (as in Schnorr’s case) to increase efficiency.

For a detailed description of these protocols, refer to [Men97] or [Sti95].
:::

::: {.callout-tip collapse="true"}
### Quick Review

**FSS**: Multiple witnesses/challenges → probability $2^{-nk}$

**GQ**: Expanded challenge domain → fewer exchanges

**Schnorr**: DLP + large challenges → **3 exchanges only**

**All**: More efficient than RSA, suitable for smart cards
:::

---

### ZKIP – Mafia Attack and Final Remarks

#### Vulnerabilities and Countermeasures

Even robust ZKIP protocols can be vulnerable to sophisticated attacks.

**Mafia Attack (1989, Adi Shamir):**

Scenario: C (attacker) and D (accomplice) collaborate so D impersonates A to B.

```
A ↔ C: ZKIP Instance     D ↔ B: ZKIP Instance
```

C relays A’s messages to D (accomplice), who uses them to authenticate to B. The attack is transparent to A and B.

**Countermeasures:**

- **Faraday cages** (blocking radio communications)
- **Strong synchronization** to prevent side exchanges
- **Distance bounding protocols** limiting response delay

**General Recommendations:**

- Choose proven solutions over inventing new ones
- Verify objectives are met
- Analyze practically (reflection attacks, redundancy, etc.)
- Analyze formally (BAN logic, model checking)

::: {.callout-note collapse="true"}
### Original Text

**ZKIP: Final Remarks**

ZKIPs offer a very high level of cryptographic security. They allow identifications while minimizing the chances of a hypothetical impostor and, most importantly, protecting the secret information of "honest" users.

In 1989 (SECURICOM'89), Adi Shamir said about ZKIPs: "I could go to a Mafia-owned store a million times in a row, and they still wouldn’t be able to impersonate me"...

**And yet**: A participates in a ZKIP with C (Mafia); simultaneously, D (C’s accomplice) participates in another ZKIP pretending to be A to B (an "honest" verifier).

```
(1) A → C: t1 (witness that C forwards via radio to D)
(1') D → B: t1
(2') D ← B: d1 (B sends the challenge to D; D forwards it to C...)
(2) A ← C: d1 (C resumes the challenge in its dialogue with A)
(3) A → C: r1 (the response using its secret, which C sends to D)
(3') D → B: r1 (B accepts r1 and so on!)
```

**Solutions:**

- Conduct identifications in Faraday cages...
- Use strong synchronization algorithms to prevent side exchanges.

**Authentication: Summary – Attacks and Protections**

| Attack | Description | Protection |
|--------|-------------|------------|
| replay | replay a previous identification instance | zero-knowledge, challenge-and-response, one-time password (beware of pre-play!) |
| known/chosen-plaintext | obtain plaintext/ciphertext pairs | zero-knowledge |
| chosen-ciphertext | make A decrypt (or sign) carefully chosen information | zero-knowledge, ch. & resp. + knowledge witness + structure (redundancy!) |
| reflection | return the same number received | include target entity in messages, asymmetry in messages |
| interleaving | use messages from multiple simultaneous protocol instances | include target entity in messages, introduce cryptographic chaining between messages of the same identification instance |
| collusion | collusion between participants | Faraday cage, strong synchronization |
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Mafia Attack**: Relay messages via accomplice → transparent fraudulent authentication

**Protections**: Faraday cage, strong synchronization, distance bounding

**Attack Table**: replay, chosen-plaintext/ciphertext, reflection, interleaving, collusion
:::

## Summary – Attacks and Protections

| Attack | Description | Protection |
|--------|-------------|------------|
| replay | replay a previous identification instance | zero-knowledge, challenge-and-response, one-time password (beware of pre-play!) |
| known/chosen-plaintext | obtain plaintext/ciphertext pairs | zero-knowledge |
| chosen-ciphertext | make A decrypt (or sign) carefully chosen information | zero-knowledge, ch. & resp. + knowledge witness + structure (redundancy!) |
| reflection | return the same number received | include target entity in messages, asymmetry in messages |
| interleaving | use messages from multiple simultaneous protocol instances | include target entity in messages, introduce cryptographic chaining between messages of the same identification instance |
| collusion | collusion between participants | Faraday cage, strong synchronization |

Here is the **exact English translation** of your *Key Establishment Protocols (KEP)* document, preserving all content, structure, technical terms, and formatting:

---

# Key Establishment Protocols (KEP)

## KEP Definition and Properties

### Definitions and Classification

**Key Establishment Protocol (KEP):** A mechanism enabling entities to share a secret for their cryptographic exchanges.

**Two Types:**

- **Key Transport Protocol (KTP):** One entity creates and transmits the key.
- **Key Agreement Protocol (KAP):** Entities jointly derive the key.

**Temporal Classification:**

- **Pre-distribution:** Keys determined in advance.
- **Dynamic Key Establishment (DKE):** Keys change with each execution.

<table border="1" cellspacing="0" cellpadding="6">
  <tr>
    <th colspan="3" style="text-align: center;">Key Establishment Protocols</th>
  </tr>
  <tr>
    <th colspan="2" style="text-align: center;">Key Agreement</th>
    <th>Key Transport</th>
  </tr>
  <tr>
    <td>Symmetric + pre-dist.</td>
    <td>Symmetric + DKE</td>
    <td>Symmetric + DKE</td>
  </tr>
  <tr>
    <td>Asymmetric + pre-dist.</td>
    <td>Asymmetric + DKE</td>
    <td>Asymmetric + DKE</td>
  </tr>
</table>

::: {.callout-note collapse="true"}
### Original Text

A **key establishment protocol (KEP)** is one that provides the involved entities with a **shared secret** (a key) to serve as the basis for subsequent cryptographic exchanges.

The two variants of KEPs are **key transport protocols (KTP)** and **key agreement protocols (KAP)**.

- A **key transport protocol (KTP)** is a mechanism allowing one entity to **create a secret key and transfer it** to its correspondent(s).
- A **key agreement protocol (KAP)** is a mechanism allowing two (or more) entities to **derive a key** from information specific to each entity.

**Key pre-distribution schemes** are those where the keys used are entirely **determined a priori** (e.g., from initial calculations).

**Dynamic key establishment schemes (DKE)** are those where the keys **change for each protocol execution**.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**KEP:** Protocols to establish a shared secret.

- **KTP:** Key transport
- **KAP:** Mutual key agreement
- **Pre-distribution** vs. **DKE** (dynamic)
:::

---

### KEP Properties

**Authentication Properties:**

- **Implicit key authentication:** Assurance that only the correspondent can access the key (without proof of possession).
- **Key confirmation:** Assurance that the correspondent effectively possesses the key.
- **Explicit key authentication:** Implicit + confirmation.
- **Authenticated KEP:** A KEP providing key authentication.

**Temporal Security Properties:**

- **Perfect Forward Secrecy (PFS):** Compromise of long-term keys does not reveal past session keys.
- **Future Secrecy:** Future keys are protected even if long-term keys are compromised (by a passive attacker).
- **Deniability/Repudiability:** Inability to prove participation to a third party (like Zero-Knowledge).

**Types of Attacks:**

- **Passive attack:** Recording and analyzing exchanges.
- **Active attack:** Modifying or injecting messages.
- **Known-key attack:** Exploiting a compromised session key to attack future keys.

::: {.callout-note collapse="true"}
### Original Text

**Key Establishment Protocol Properties:**

- **Implicit key authentication** (or key authentication): A property by which an entity is assured that only its correspondent(s) can access a secret key. However, this does not specify anything about actually possessing the key.

- **Key confirmation:** A property allowing an entity to be sure that its correspondents are in possession of the generated session keys.

- **Explicit key authentication:** = implicit key authentication + key confirmation.

- An **authenticated KEP** is a KEP capable of providing key authentication.

**Attacks:**

- A **passive attack** attempts to break a cryptographic system by **recording and analyzing** exchanges.

- An **active attack** involves an adversary who **modifies or injects** messages.

- A protocol is said to be vulnerable to a **known-key attack** if, when a previous session key is compromised, it becomes possible to: (a) compromise future keys via a passive attack and/or (b) mount active attacks aiming at identity impersonation.

**Modern Properties:**

- **Perfect Forward Secrecy (PFS)** is a characteristic that guarantees the **confidentiality of past session keys** even if long-term keys (e.g., the recipient’s private key) are compromised.

- **Future Secrecy:** The protocol guarantees the **security of future exchanges** (future session keys are protected) even if long-term keys are compromised by a passive attacker.

- **Deniability / Repudiability:** Similar to Zero-Knowledge authentication protocols, this allows entities to ensure exchange authentication without providing information that would allow proving their participation in the cryptographic exchange to a third party.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Authentication:**

- **Implicit:** Only the correspondent can access the key
- **Key confirmation:** Proof of possession
- **Explicit:** Implicit + confirmation

**Security:**

- **PFS:** Past keys protected if compromise occurs
- **Future Secrecy:** Future keys protected
- **Deniability:** Participation not provable
:::

---

## KAP

### Symmetric

#### with Pre-distribution

**Trivial Case:**

For $n$ users with a Key Distribution Center (KDC):

1. KDC generates $\frac{n(n-1)}{2}$ different keys (one per user pair).
2. KDC distributes $n-1$ keys to each user via a confidential channel.

**Advantages:**

- Information-theoretically secure against user collusion.

**Disadvantages:**

- $O(n^2)$ storage complexity for the KDC.
- $O(n)$ keys per user.
- Not scalable.

::: {.callout-note collapse="true"}
### Original Text

**Symmetric KAP with Pre-distribution – Trivial Case**

Given $n$ users with a **Key Distribution Center (KDC)**.

A trivial symmetric KAP with pre-distribution can be constructed as follows:

(1) The KDC generates $n(n-1)/2$ different keys (one different key for each user pair).

(2) The KDC then distributes the keys via a **confidential and authentic channel**, giving $n-1$ keys to each user.

If the KDC generates the keys in a truly **random** manner, this system is **information-theoretically secure against user collusion** (even if $n-2$ users collude, they cannot find the key of the other two) by protocol construction.

**Problem with this protocol:**

- $O(n^2)$ **key storage** for the KDC.
- $O(n)$ **secret keys exchanged** for each entity.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Trivial symmetric KAP:**

- $n(n-1)/2$ keys for $n$ users
- Information-theoretically secure
- Problem: $O(n^2)$ storage
:::

---

#### with Dynamic Key Establishment (DKE)

##### Simple Example

**Initialization:** A and B share a long-term key $S$.

**Protocol:**

1. $A \rightarrow B: r_a$ (random number)
2. $A \leftarrow B: r_b$ (random number)
3. Session key: $K := E_S(r_a \oplus r_b)$

**Properties:**

- ❌ Entity authentication
- ✅ Implicit key authentication
- ❌ Key confirmation
- ❌ Perfect Forward Secrecy

##### AKEP2 (Authenticated Key Exchange Protocol 2)

**Initialization:** A and B share $S$ (for MAC) and $S'$ (for session key).

**Protocol:**

1. $A \rightarrow B: r_a$
2. $A \leftarrow B: T = (B,A,r_a,r_b), h_S(T)$
3. $A \rightarrow B: (A, r_b), h_S(A,r_b)$
4. Session key: $K := h'_{S'}(r_b)$

**Properties:**

- ✅ Mutual entity authentication
- ✅ Implicit key authentication
- ❌ Key confirmation
- ❌ Perfect Forward Secrecy

**Note:** The key depends only on $B$ and the long-term key $S'$!

::: {.callout-note collapse="true"}
### Original Text

**Symmetric KAP with Dynamic Key Establishment**

These methods allow the involved entities to derive **short-term keys** (typically session keys) from **long-term secrets**, which, for these protocols, are symmetric keys.

**Intuitive Example:**

(Initialization): A and B share a long-term symmetric key $S$.

(1) $A \rightarrow B: r_a$; A generates a random number and sends it to B.

(2) $A \leftarrow B: r_b$; B does the same.

A and B compute the session key: $K := E_S(r_a \oplus r_b)$.

**Properties:**
- **Entity authentication:** NO: By protocol construction, the $r_i$ can be sent by any entity.
- **Implicit key authentication:** YES: Only entities sharing the long-term symmetric key $S$ can access the session key $K$.
- **Key confirmation:** NO: Since the $r_i$ are random, they can be modified by an adversary, preventing A and B from agreeing on the session key $K$. This would not be detected by the protocol.
- **Perfect Forward Secrecy:** NO: If the long-term key $S$ is compromised, all previous session keys can be easily computed by an adversary who recorded all exchanges.

**Authenticated Key Exchange Protocol 2 (AKEP2)**

(Init.): A and B share two long-term symmetric keys $S$ and $S'$. $S$ is used to generate MACs $h_S()$ (to ensure integrity and entity authentication), and $S'$ is used for session key $K$ generation.

(1) $A \rightarrow B: r_a$; A generates a random number and sends it to B.

(2) $A \leftarrow B: T = (B,A,r_a,r_b), h_S(T)$; B does the same + identities + MAC of everything.

(3) $A \rightarrow B: (A, r_b), h_S(A,r_b)$; A verifies the identities and the $r_a$ provided by B; then sends identity + $r_b$ + MAC of everything.

The key is bilaterally computed using a dedicated MAC $h'_{S'}()$: $K := h'_{S'}(r_b)$.

**Properties:**
- **Entity authentication:** YES (mutual, provided by MACs).
- **Implicit key authentication:** YES.
- **Key confirmation:** NO (no evidence that the key $S'$ is known to the correspondent).
- **Perfect Forward Secrecy:** NO (if the key $S'$ is compromised, previous session keys $K$ are also compromised).

The key depends only on B (and the long-term key $S'$), but the protocol can be easily modified so that the key also depends on A, making it a "true" KAP.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Symmetric KAP with DKE:**

- **Simple:** $K := E_S(r_a \oplus r_b)$ – no PFS
- **AKEP2:** Uses MACs for authentication + key derived as $K := h'_{S'}(r_b)$
- No PFS if $S'$ is compromised
:::

---

### Asymmetric with Pre-distribution

#### Diffie-Hellman

**Initialization:** Public prime $p$ and generator $\alpha \in \mathbb{Z}_p^*$.

**Protocol:**

1. $A \rightarrow B: \alpha^x \mod p$ (A chooses secret $x$)
2. $A \leftarrow B: \alpha^y \mod p$ (B chooses secret $y$)
3. Shared key: $K := \alpha^{xy} \mod p$

- A computes $K := (\alpha^y)^x \mod p$
- B computes $K := (\alpha^x)^y \mod p$

**Security:**

- Based on the Diffie-Hellman Problem (DHP): Impossible to compute $\alpha^{xy}$ from $\alpha^x$ and $\alpha^y$.
- Proven result: DHP $\equiv$ DLP.

**Man-in-the-Middle (MIM) Attack:**

Adversary C intercepts and replaces:

- $\alpha^x$ with $\alpha^{x'}$ to B
- $\alpha^y$ with $\alpha^{y'}$ to A
- C establishes two keys: $\alpha^{xy'}$ with A and $\alpha^{x'y}$ with B

**Properties (Unauthenticated DH):**

- ❌ Entity authentication
- ❌ Implicit key authentication (vulnerable to MIM)
- ❌ Key confirmation

**Symmetric Key Generation:**

DH keys are not bit secure.

Solution: Apply a MDC (SHA, MD5) to the entire key $K$:

$$K_{sym} := \text{SHA-256}(K)$$

Result: KAP with Dynamic Key Establishment.

::: {.callout-note collapse="true"}
### Original Text

**Asymmetric KAP with Pre-Distribution – Diffie-Hellman**

Published in 1976, this is the **precursor of asymmetric protocols**.

It allows two entities that have never met to construct a **shared key** by exchanging messages over a **non-confidential channel**.

**Protocol:**

Initialization: A prime number $p$ is generated, and a generator $\alpha$ of $\mathbb{Z}_p^*$, such that $\alpha \in \mathbb{Z}_{p-1}$. Both numbers are made public.

(1) $A \rightarrow B: \alpha^x \mod p$; A chooses a secret $x \in \mathbb{Z}_{p-1}$ and sends the public part.

(2) $A \leftarrow B: \alpha^y \mod p$; B chooses a secret $y \in \mathbb{Z}_{p-1}$ and sends the public part.

A computes the secret key: $K := (\alpha^y)^x \mod p$, and B does the same: $K := (\alpha^x)^y \mod p$.

The **security** of this scheme lies in the impossibility of finding $\alpha^{xy} \mod p$ from $\alpha^x \mod p$ and $\alpha^y \mod p$ (**Diffie-Hellman Problem: DHP**).

**Proven result:** DHP $\equiv$ DLP.

Diffie-Hellman is **secure** (as much as DHP) against **passive attacks**. In other words, an adversary limited to observing messages cannot find the key $K$.

This is no longer true for **active attacks**; let’s see what C can do by modifying messages:

C exchanges secret keys with A and B, respectively: $\alpha^{xy'} \mod p$ and $\alpha^{x'y} \mod p$ (C controls $x'$ and $y'$). If C re-encrypts each packet it receives with the corresponding public key, the attack will be transparent to A and B.

This attack is called **Man-in-the-Middle (MIM)** and applies to all asymmetric protocols.

It is due to the **lack of authentication of public keys**, i.e., when A "talks" to B, it must use the **authentic** public key of B.

**Characteristics of Diffie-Hellman (unauthenticated):**

- **Entity Authentication:** NO.
- **Implicit key authentication:** NO (due to the MIM attack).
- **Key confirmation:** NO (due to the MIM risk, A cannot be sure that B possesses the shared secret key).

**Generating Symmetric Keys from a Diffie-Hellman Shared Key:**

The quantities manipulated in DH (notably $K$) are 512–1024 bits in size (depending on the prime $p$ used).

An intuitive approach to generate smaller symmetric keys (64–128 bits) would be to take a subset of bits from the key $K$.

Unfortunately, it can be proven that DH keys are not **bit secure**, meaning that subsets of bits (especially the Least Significant Bits) can be computed with an effort not proportional to that required to compute the entire key.

To generate keys securely, it is recommended to **apply a MDC** (like SHA or MD5) to the entire key (possibly chaining MDC applications to obtain successive symmetric keys).

This method yields a KAP with Dynamic Key Establishment.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Diffie-Hellman:**

- $K := \alpha^{xy} \mod p$ computed independently by A and B
- Secure against passive attacks (DHP $\equiv$ DLP)
- Vulnerable to MIM without authentication
- Generate symmetric keys: $K_{sym} := \text{SHA}(K)$
:::

---

### Asymmetric with DKE

#### Station to Station Protocol (STS)

**Authenticated Diffie-Hellman** with digital signatures.

**Initialization:** Public prime $p$ and generator $\alpha$. A and B have authentic copies of each other’s public keys.

**Protocol:**

1. $A \rightarrow B: \alpha^x \mod p$
2. $A \leftarrow B: \alpha^y \mod p, E_k(S_B(\alpha^x, \alpha^y))$
   - B computes $k := (\alpha^x)^y \mod p$
   - B signs and encrypts the public parts
3. $A \rightarrow B: E_k(S_A(\alpha^y, \alpha^x))$
   - A decrypts, verifies B’s signature
   - A signs and encrypts in reverse order

**Properties:**

- ✅ Mutual entity authentication (via signatures)
- ✅ Implicit key authentication (DHP + signatures prevent MIM)
- ✅ Key confirmation (encryption proves possession of $k$)
- ✅ Explicit key authentication (authentication + key confirmation)
- ✅ **Perfect Forward Secrecy** (compromise of signature private key does not reveal past session keys)

**Efficient Variant:** Replace $E_k(S_B(...))$ with $(sig, h_k(sig))$ using MAC instead of symmetric encryption.

::: {.callout-note collapse="true"}
### Original Text

**Asymmetric KAP with DKE – Station to Station Protocol**

(Notation) $S_A$: Signature with A’s private key.

(Initialization):
(a) Choose a prime $p$ and a generator $\alpha$ of $\mathbb{Z}_p^*$, such that $\alpha \in \mathbb{Z}_{p-1}$. Both numbers are made public (and optionally associated with the participants’ public keys).

(b) Participants have access to authentic copies of the correspondents’ public keys. Certificates may be exchanged if needed in (2) and (3).

(1) $A \rightarrow B: \alpha^x \mod p$; A generates a secret $x$ and sends the public part.

(2) $A \leftarrow B: \alpha^y \mod p, E_k(S_B(\alpha^x, \alpha^y))$; B generates a secret $y$ and computes the key: $k := (\alpha^x)^y \mod p$ + signs and encrypts the public parts.

(3) $A \rightarrow B: E_k(S_A(\alpha^y, \alpha^x))$; A decrypts by computing $k := (\alpha^y)^x \mod p$, verifies B’s signature and the public parts; if OK, A signs + encrypts in reverse order.

B decrypts and verifies A’s signature on the public parts. If OK => END.

**Characteristics:**

- **Entity Authentication:** YES (mutual, provided by signatures).
- **Implicit key authentication:** YES, keys are protected by DHP. The MIM attack is made impossible by signatures.
- **Key confirmation:** YES, both entities prove possession of the key by encrypting quantities with it.
- **Explicit key authentication:** YES: implicit key authentication + key confirmation.
- **Perfect Forward Secrecy:** YES. The only long-term key is the one used for signing/verification. If this key is compromised, past session keys are protected because they are not explicitly exchanged but rather computed via DH.

Obviously, once the signature key is compromised (private key theft), the stated properties no longer hold for future exchanges.

The protocol additionally provides **anonymity** since the parties’ identities are protected by $k$.

**Variant:** In (2), compute $sig := S_B(\alpha^x, \alpha^y)$, and send $(sig, h_k(sig))$ instead of $E_k(S_B(\alpha^x, \alpha^y))$. Same for (3), observing the protocol’s asymmetries.

More efficient solution as it uses a **MAC** rather than symmetric encryption.

Robust and efficient algorithm chosen as the base for key generation in **IPv6**.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Station to Station (STS):**

- DH + digital signatures
- ✅ PFS: Past session keys protected
- ✅ Explicit key authentication
- Used in IPv6
:::

---

#### Off-The-Record (OTR) and Signal Protocols

##### Off-The-Record (OTR)

Protocol (2004) for instant messaging with **repudiability**.

**SIGMA Technique (SIGn-and-MAC):**

- DH signatures + ephemeral authentication via MAC
- Key Derivation Function (KDF) generates two keys: $K_e$ (AES-CTR encryption) and $K_m$ (MAC)
- Key change per conversation
- **Revelation of previous MAC keys** to ensure repudiability

**Simplified Protocol:**

1. $A \rightarrow B: \alpha^x \mod p$
2. $A \leftarrow B: \alpha^y \mod p, S_B(\alpha^x, \alpha^y), \text{MAC}_{K_m}(B)$
   - B computes $k := (\alpha^x)^y \mod p$
   - $(K_m, K_e) := \text{KDF}(k)$
3. $A \rightarrow B: S_A(\alpha^y, \alpha^x), \text{MAC}_{K_m}(A)$

Messages encrypted with $K_e$.

##### Signal Protocol

Evolution of OTR for social networks (WhatsApp, Facebook Messenger).

**Characteristics:**

- Ephemeral asymmetric and symmetric keys
- DH on elliptic curves
- ✅ PFS
- ✅ Future Secrecy
- ✅ Repudiability

::: {.callout-note collapse="true"}
### Original Text

**Off-The-Record (OTR) Protocol**

Protocol designed in 2004 to provide authentication and confidentiality services in instant messaging exchanges while preserving the "**repudiable**" nature of an "off-the-record" conversation.

The protocol also satisfies **PFS** and **Future Secrecy** properties in case of long-term key compromise.

It follows the same principles as the Station-to-Station protocol, adding **ephemeral authentication via a MAC** to the DH parameter signatures. This dual technique is called **SIGMA** (SIGn-and-MAC).

It uses a **Key Derivation Function (KDF)** to generate an encryption key ($K_e$) preserving message confidentiality with AES CTR-mode and a MAC key ($K_m$) ensuring message origin authenticity.

Each conversation involves a **key change** (new DH parameter exchange) with an additional **plaintext exchange of the MAC keys** ($K_m$) used in the previous exchange to ensure repudiability!

**Schematic OTR Protocol Exchanges:**

(1) $A \rightarrow B: \alpha^x \mod p$; A generates a secret $x$ and sends the public part.

(2) $A \leftarrow B: \alpha^y \mod p, S_B(\alpha^x, \alpha^y), \text{MAC}_{K_m}(B)$

B generates a secret $y$, computes the session key $k := (\alpha^x)^y \mod p$, and signs the DH public parts. It then generates keys $K_e$ and $K_m$ via the KDF: $(K_m, K_e) := \text{KDF}(k)$.

(3) $A \rightarrow B: S_A(\alpha^y, \alpha^x), \text{MAC}_{K_m}(A)$; A does the same.

Messages are then encrypted with key $K_e$.

Numerous evolutions of the original OTR protocol have addressed vulnerabilities and improved efficiency.

**The Signal Protocol**

The Signal protocol is an evolution of the OTR protocol targeting message exchange protection in **social networks**. It also uses ephemeral asymmetric and symmetric keys to ensure **PFS**, **Future Secrecy**, and **repudiability** with DH computations on elliptic curves.

Signal is used to protect messaging platforms such as **WhatsApp** and **Facebook Messenger**, among others.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**OTR/Signal:**

- SIGMA: signature + MAC
- KDF: generates $K_e$ (encryption) and $K_m$ (MAC)
- Reveals old MAC keys → repudiability
- ✅ PFS, ✅ Future Secrecy
- Used in: WhatsApp, Facebook Messenger
:::

---

#### Secure Remote Password (SRP)

Asymmetric KAP protocol **based on password**, resistant to dictionary attacks.

**Initialization:**

- $m := 2p+1$ (safe prime), $\alpha$ generator of $\mathbb{Z}_p^*$
- $P$: A’s password, $x := H(P)$ with $H$ a CRHF
- B stores the **verifier**: $v := \alpha^x \mod m$ (not the password!)

**Protocol:**

1. $A \rightarrow B: \gamma := \alpha^r \mod m$ (A generates secret $r$)
2. $A \leftarrow B: \delta := (v + \alpha^t) \mod m, u$ (B generates random $t, u$)
3. A computes $k := (\delta - v)^{r+ux} \mod m$
4. B computes $k := (\gamma v^u)^t \mod m$
5. Key confirmation

**Properties:**

- ✅ Protects passwords from dictionary attacks
- ✅ **Verifier-based:** B does not store passwords
- ✅ All KEP properties
- Included in SSL/TLS, EAP

::: {.callout-note collapse="true"}
### Original Text

**Asymmetric KAP with DKE – Secure Remote Password Protocol**

(a) Let $m$ be a safe prime with $m := 2p+1$ and $p$ prime.
(b) Let $\alpha$ be a generator of $\mathbb{Z}_p^*$, such that $\alpha \in \mathbb{Z}_{p-1}$.
(c) Let $P$ be A’s password and $x := H(P)$ with $H$ a CRHF.
(d) B stores in its password database the **verifier** $v := \alpha^x \mod m$.

(1) $A \rightarrow B: \gamma := \alpha^r \mod m$; A generates a secret random number $r$.

(2) $A \leftarrow B: \delta := (v + \alpha^t) \mod m, u$; B generates a secret random number $t$ and another random number $u$.

A computes the symmetric key: $k := (\delta - v)^{r+ux} \mod m$.

B computes the symmetric key: $k := (\gamma v^u)^t \mod m$.

A and B prove knowledge of $k$ (key confirmation) in a subsequent exchange.

- SRP **protects passwords** from dictionary attacks.
- B does not store passwords but **verification values** (verifier-based).
- SRP also satisfies **all KEP properties** and is included in many standards (SSL/TLS, EAP, etc.).
:::

::: {.callout-tip collapse="true"}
### Quick Review

**SRP:**

- Password-based KAP
- B stores verifier $v := \alpha^x$ (not password)
- Resistant to dictionary attacks
- ✅ All KEP properties
:::

---

## Attacks on DH and PFS

**Logjam Attack (2015):**

Active attack enabling:

1. **Downgrade:** Man-in-the-Middle forces use of 512-bit DH group.
2. **Discrete logarithm computation** with Number Field Sieve:
   - One-week precomputation for a fixed prime $p$.
   - ~1-minute individual computation after precomputation.
3. **Precomputation reuse:** Many servers use the same $p$.

**Consequence:**

State-level actors can compromise PFS on widespread 1024-bit groups.

**Solutions:**

- Use groups $\geq$ 2048 bits.
- Diversify the primes $p$ used.

::: {.callout-note collapse="true"}
### Original Text

**Recent Attacks on Diffie-Hellman and PFS**

In 2015, a group of researchers published a series of attacks on the TLS/SSL protocol allowing:

- Performing a **downgrade** via an active attack called **Logjam**, whereby a man-in-the-middle successfully reduces the Diffie-Hellman group size to **512 bits** for the shared secret key establishment.

- Subsequently computing the **discrete logarithms** of $\alpha^x \mod p$ and $\alpha^y \mod p$ using the **Number Field Sieve** technique.

- For a group based on a fixed prime $p$, they perform a **precomputation phase** lasting approximately **one week**.

- Once this initial phase is complete, individual logarithm computations take only **about one minute**!

- A statistical observation shows that a significant percentage of servers rely on the **same group** (same prime $p$), allowing the same precomputation phase to be used to compromise multiple servers.

- One of the conclusions of this research is that **major actors with state-level resources** would currently be able to break PFS when it is based on (very common today...) **1024-bit groups**.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Logjam (2015):**

- Downgrade → DH 512 bits
- Precomputation (1 week) + individual computation (1 min)
- Reuse if same $p$
- ⚠️ States can break PFS on 1024-bit groups
:::

---

## KTP

### Symmetric

#### Trivial Case

**Initialization:** A and B share long-term key $S$.

**Protocol:**

1. $A \rightarrow B: E_S(r_a)$
2. Session key: $K := r_a$

**Properties:**

- ❌ Entity authentication
- ✅ Implicit key authentication
- ❌ Key confirmation (improvement: $E_S(B, r_a)$)
- ❌ Perfect Forward Secrecy

**Timestamp Variant:** $A \rightarrow B: E_S(B, t_a, r_a)$ (requires synchronized clocks).

#### Shamir’s No-Key Protocol

DH equivalent in key transport.

**Initialization:** Public prime $p$, A and B generate secrets $a, b \in \mathbb{Z}_{p-1}$ with $\gcd(a,p-1)=1$ and $\gcd(b,p-1)=1$.

**Protocol:**

1. $A \rightarrow B: K^a \mod p$ (A chooses key $K$ and hides it with $^a$)
2. $A \leftarrow B: (K^a)^b \mod p$ (B exponentiates with $b$)
3. $A \rightarrow B: (K^{ab})^{a^{-1}} \mod p = K^b \mod p$ (A undoes $^a$)
4. B computes $K$ by exponentiating with $b^{-1} \mod (p-1)$

**Problem:** Vulnerable to Man-in-the-Middle (like DH).

::: {.callout-note collapse="true"}
### Original Text

**Symmetric Key Transport Protocol – Trivial Case**

(Init.) A and B share a long-term symmetric key $S$.

(1) $A \rightarrow B: E_S(r_a)$; A generates a random number and encrypts it with $S$.

The session key used by both entities is $K := r_a$.

**Properties:**

- **Entity Authentication:** NO.
- **Implicit Key Authentication:** YES (only A and B have access to the key).
- **Key Confirmation:** NO. B cannot be sure that A possesses the key because $r_a$ is a random number. By adding redundancy (e.g., B’s identity), B can achieve unilateral key confirmation (and thus, explicit key authentication):

(1)' : $A \rightarrow B: E_S(B, r_a)$

- **Perfect Forward Secrecy:** NO.

If B cannot judge the freshness of (1) from $r_a$ alone, it can ask A to include a timestamp, provided synchronized clocks are available:

(1)'' : $A \rightarrow B: E_S(B, t_a, r_a)$

**Symmetric KTP: Shamir’s No-Key Protocol**

Number Theory Reminder: If $p$ is prime and $r \equiv t \mod p-1$, then $a^r \equiv a^t \mod p$ $\forall a \in \mathbb{Z}$, and thus: $r \cdot r^{-1} \equiv 1 \mod p-1$ implies $a^{r \cdot r^{-1}} \equiv a \mod p$.

(Init.)
(a) Choose and publish a prime $p$ for which it is difficult (by DLP) to compute discrete logarithms in $\mathbb{Z}_p$.

(b) A (resp. B) generates a secret number $a$ (resp. $b$), such that $\{a,b\} \in \mathbb{Z}_{p-1}$ and $\gcd(a,p-1) = 1$ and $\gcd(b,p-1) = 1$ (so that inverses exist).

(c) For the following, A precomputes $a^{-1} \mod p-1$ and B precomputes $b^{-1} \mod p-1$.

(1) $A \rightarrow B: K^a \mod p$; A chooses a key $K \in \mathbb{Z}_p$ and hides it with $^a$.

(2) $A \leftarrow B: (K^a)^b \mod p$; B exponentiates in turn with $b$.

(3) $A \rightarrow B: (K^{ab})^{a^{-1}} \mod p$; A undoes the exponentiation with $a^{-1} \mod p-1$; but the key remains protected by $^b$.

B only needs to compute $K$ by exponentiating with $b^{-1} \mod p-1$.

This protocol is the key transport equivalent of Diffie-Hellman (in DH, the key is not transported but bilaterally computed). It suffers from the same problems (notably Man-in-the-Middle) as the latter.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Symmetric KTP:**

- Trivial: $K := r_a$ with $E_S(r_a)$
- Shamir: Transport via successive exponentiations
- No PFS
:::

---

### Asymmetric

#### Needham-Schroeder

**Initialization:** A and B have authentic copies of each other’s public keys.

**Protocol:**

1. $A \rightarrow B: E_{pub_B}(k_1, A)$
2. $A \leftarrow B: E_{pub_A}(k_1, k_2)$
3. $A \rightarrow B: E_{pub_B}(k_2)$
4. Session key: $K := H(k_1, k_2)$

**Properties:**

- ✅ Entity authentication + implicit key authentication + key confirmation
- ❌ Perfect Forward Secrecy (keys entirely determined by exchanged quantities)

::: {.callout-note collapse="true"}
### Original Text

**Asymmetric Key Transport Protocol – Needham-Schroeder Public Key Protocol**

(Notation): $E_{pub_E}(X)$ means encrypting with entity E’s public key.

(Init): A and B possess an authentic copy (possibly a certificate) of the other’s public key.

(1) $A \rightarrow B: E_{pub_B}(k_1, A)$; A generates a random number $k_1$ + A + Encrypt.

(2) $A \leftarrow B: E_{pub_A}(k_1, k_2)$; B does the same for $k_2$ + concatenates with $k_1$ + Encrypt.

(3) $A \rightarrow B: E_{pub_B}(k_2)$; A verifies if $k_1$ matches, if yes, encrypts $k_2$; B verifies if $k_2$ matches with (2).

The key is generated using a cryptographic hash function: $K := H(k_1, k_2)$.

**Characteristics:**

- **Entity Authentication** + **implicit key authentication** + **key confirmation:** YES.
- **Perfect Forward Secrecy:** NO: The keys are entirely determined by the exchanged quantities.

A similar protocol (only (3) changes) can be used for entity authentication.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Asymmetric Needham-Schroeder:**

- $K := H(k_1, k_2)$ with encrypted exchanges
- ✅ Full authentication
- ❌ No PFS
:::

---

### Hybrid

#### Encrypted Key Exchange (EKE)

**Hybrid protocol** (symmetric + asymmetric) resistant to dictionary attacks.

**Initialization:** A and B share password $p$.

**Protocol:**

1. $A \rightarrow B: A, E_p(pub_A)$ (A generates key pair, sends public key encrypted)
2. $A \leftarrow B: E_p(E_{pub_A}(k))$ (B generates session key $k$, double encryption)
3. $A \rightarrow B: E_k(r_a)$ (Key confirmation)
4. $A \leftarrow B: E_k(r_a, r_b)$
5. $A \rightarrow B: E_k(r_b)$

**Advantages:**

- Robust even if password $p$ is weak.
- Eve cannot guess without also "breaking" the asymmetric algorithm.

**Properties:**

- ✅ Entity authentication + implicit + confirmation
- ✅ Perfect Forward Secrecy **if** $pub_A/priv_A$ is regenerated each time
- ❌ No PFS if long-term keys

::: {.callout-note collapse="true"}
### Original Text

**Hybrid KTP: Encrypted Key Exchange (EKE)**

This protocol uses **symmetric and asymmetric schemes** to minimize the risk of cryptanalysis via dictionary attacks inherent to symmetric systems.

(Init.): A and B share a symmetric secret $p$ (password).

(1) $A \rightarrow B: A, E_p(pub_A)$; A generates a public/private key pair and sends the public part to B encrypted with $p$.

(2) $A \leftarrow B: E_p(E_{pub_A}(k))$; B generates a session key $k$ and sends it encrypted.

(3) $A \rightarrow B: E_k(r_a)$; A generates a random number and sends it encrypted with $k$.

(4) $A \leftarrow B: E_k(r_a, r_b)$; B generates $r_b$ and sends it with $r_a$ encrypted with $k$.

(5) $A \rightarrow B: E_k(r_b)$; Confirmation from A. If $r_b =$ OK => END.

(1) and (2) are responsible for **key transport**; (3) to (5) for **key confirmation**.

This protocol is **robust even if the password** $p$ shared between A and B is of poor quality. Indeed, Eve cannot attempt to guess without also "breaking" the asymmetric algorithm.

**Properties:**

- **Entity Authentication** + **implicit key authentication** + **key confirmation:** YES.
- **Perfect Forward Secrecy:** YES if the $pub_A/priv_A$ pair is regenerated for each protocol instance. NO if $pub_A/priv_A$ is a long-term key.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**EKE (Hybrid):**

- Password + asymmetric crypto
- Robust even with weak password
- PFS if keys regenerated each time
:::

---

### Symmetric with Key Distribution Center (KDC)

#### Symmetric Needham-Schroeder

Protocol with **Key Distribution Center (KDC)**.

**Initialization:** A shares $K_{AT}$ with T (KDC), B shares $K_{BT}$ with T.

**Protocol:**

1. $A \rightarrow T: A, B, r_a$
2. $A \leftarrow T: E_{K_{AT}}(r_a, B, k_{AB}, E_{K_{BT}}(k_{AB}, A))$
3. $A \rightarrow B: E_{K_{BT}}(k_{AB}, A)$
4. $A \leftarrow B: E_{k_{AB}}(r_b)$
5. $A \rightarrow B: E_{k_{AB}}(r_b - 1)$

**Properties:**

- ✅ Entity authentication of A to B
- ❌ Entity authentication of B to A (A never saw $r_b$)
- ✅ Implicit key authentication
- ❌ Key confirmation (only B knows A possesses the key)
- ❌ Perfect Forward Secrecy

**Vulnerabilities:**

- **Replay attacks:** A can replay (3) without B’s control.
- **Known-key attack:** If an old key $k$ is compromised, an adversary can make B accept it.

**Solutions:**

- **Key confirmation and mutual entity authentication:**

  Replace 3. and 4. with:

  3. $A \rightarrow B: E_{k_{AB}}(r_a'), E_{K_{BT}}(k_{AB}, A)$
  4. $A \leftarrow B: E_{k_{AB}}(r_a' - 1, r_b)$

- **Exchange freshness:**

  Add timestamp in 3.: $E_{K_{BT}}(k_{AB}, A, t)$

::: {.callout-note collapse="true"}
### Original Text

**Symmetric KTP with Key Distribution Center – Symmetric Needham-Schroeder**

(Notation): Let T be the **Key Distribution Center**.

(Init.): A and T share the symmetric key $K_{AT}$. B and T share $K_{BT}$.

(1) $A \rightarrow T: A, B, r_a$; A generates a random number $r_a$ and sends it to T with the identities.

(2) $A \leftarrow T: E_{K_{AT}}(r_a, B, k_{AB}, E_{K_{BT}}(k_{AB}, A))$; T generates $k_{AB}$ and sends it encrypted.

(3) $A \rightarrow B: E_{K_{BT}}(k_{AB}, A)$; A forwards the packet to B.

(4) $A \leftarrow B: E_{k_{AB}}(r_b)$; Confirmation from B using $k_{AB}$ and a random number $r_b$.

(5) $A \rightarrow B: E_{k_{AB}}(r_b - 1)$; Confirmation from A.

**Properties:**

- **Entity Authentication:**
  - A to B: YES.
  - B to A: NO: A never saw $r_b$ (it could be $E_{k'}(r_b')$).
- **Implicit Key Authentication:** YES (keys are always protected by $K_{AT}$ and $K_{BT}$). However, in case of a known-key attack, this no longer holds for B.
- **Key Confirmation:** Only B is assured that A possesses the key due to the flaw described in entity authentication.
- **Perfect Forward Secrecy:** NO. If either $K_{AT}$ or $K_{BT}$ is compromised, session keys $k$ immediately become visible.

**Solution to achieve key confirmation and mutual entity authentication:**

Replace (3) and (4) with:

(3') $A \rightarrow B: E_{k_{AB}}(r_a'), E_{K_{BT}}(k_{AB}, A)$

(4') $A \leftarrow B: E_{k_{AB}}(r_a' - 1, r_b)$

Provided the $r_i$ are carefully controlled by the participants.

However: Beware of **reflection attacks**!

**Problem:** A can replay (3) as many times as desired, without any control from B. This problem worsens if an old key $k$ is compromised:

**Vulnerable to known-key attack:** If a previously used session key $k$ is obtained by an adversary C, it can easily make B accept it by replaying (3) and computing the challenge sent by B in (5). In this case, the properties of entity authentication, implicit key authentication, and key confirmation of A to B are also compromised.

**Solution:** Add a **timestamp** in (3) attesting to the freshness of the exchanges:

(3'') $A \rightarrow B: E_{K_{BT}}(k_{AB}, A, t)$ (this is the solution adopted by **Kerberos**).
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Symmetric Needham-Schroeder:**

- KDC generates and distributes $k_{AB}$
- Vulnerable to replay and known-key attacks
- Solution: Add timestamp
- Basis for Kerberos
:::

---

#### Kerberos

**Authentication and key distribution protocol** based on Needham-Schroeder with corrections.

**Architecture:**

- **Authentication Server (AS):** Issues tickets for TGS.
- **Ticket Granting Server (TGS):** Issues tickets for services.
- **Tickets:** Encrypted structures containing session keys.

**Simplified Protocol:**

**Phase 1: TGT (Ticket Granting Ticket) Request**

1. $A \rightarrow AS: A, TGS, r_a$
2. $A \leftarrow AS: E_{K_A}(k_{AT}, r_a), Ticket_{AT} := E_{K_T}(A, TGS, t_1, t_2, k_{AT})$

**Phase 2: Ticket Request for Service B**

3. $A \rightarrow TGS: Authenticator_{AT} := E_{k_{AT}}(A, t), Ticket_{AT}, B, r_a'$
4. $A \leftarrow TGS: E_{k_{AT}}(k_{AB}, r_a'), Ticket_{AB} := E_{K_B}(A, B, t_1, t_2, k_{AB})$

**Phase 3: Authentication with B**

5. $A \rightarrow B: Authenticator_{AB} := E_{k_{AB}}(A, t), Ticket_{AB}, r_a'', [request]$
6. $A \leftarrow B: E_{k_{AB}}(r_a''), [response]$

**Properties:**

- ✅ Entity authentication (all entities)
- ✅ Implicit key authentication
- ⚠️ Partial key confirmation (not between A and AS)
- ❌ Perfect Forward Secrecy

**Vulnerabilities:**

- **Password guessing attacks** on $E_{K_A}(k_{AT}, r_a)$ (Solution: pre-authentication)
- **Replay attacks** if $r_a$ is poorly controlled
- Requires clock synchronization

::: {.callout-note collapse="true"}
### Original Text

**Symmetric KTP with Key Distribution Center – Kerberos**

Kerberos is a protocol for **entity authentication** and **key distribution** within a user network.

Originally, Kerberos was designed as a replacement solution to address security issues (weak authentication, cleartext transactions, etc.) inherent to UNIX environments.

Kerberos was created at MIT as part of the ATHENA project.

The first three versions were unstable. **Version 4** achieved considerable success in both industrial and academic environments and remains predominant. **Version 5**, although safer and better structured, is more complex and less performant, which has slowed its deployment.

Kerberos also defines a mode of collaboration between domains belonging to distinct administrative authorities (the **realms**). This allows users from one domain to use resources from another domain "without leaving" the secure Kerberos environment.

For inter-realm transactions, symmetric cryptography constitutes a significant obstacle as it requires confidential channels for key pre-distribution.

**Kerberos Version 5**

(Notation):
- A and B want to establish a secure transaction; in the Kerberos environment, this typically involves a **client** and a **server** providing services.
- The Kerberos KDC is subdivided into two functional entities: the **Authentication Server (AS)** and the **Ticket Granting Server (TGS)**. Both access the password database.
- The $r_a^{(n)}$ are random numbers, $t$ is a timestamp, $t_1$ and $t_2$ indicate a validity time window.

(Initialization): A and B share a secret key with AS, namely: $K_A$ and $K_B$ (for clients, this is a OWF of the password). TGS also has a secret key $K_T$.

(1) $A \rightarrow AS: A, TGS, r_a$

(2) $A \leftarrow AS: E_{K_A}(k_{AT}, r_a), Ticket_{AT} := E_{K_T}(A, TGS, t_1, t_2, k_{AT})$; AS generates $k_{AT}$.

(3) $A \rightarrow TGS: Authenticator_{AT} := E_{k_{AT}}(A, t), Ticket_{AT}, B, r_a'$

(4) $A \leftarrow TGS: E_{k_{AT}}(k_{AB}, r_a'), Ticket_{AB} := E_{K_B}(A, B, t_1, t_2, k_{AB})$; TGS generates $k_{AB}$.

(5) $A \rightarrow B: Authenticator_{AB} := E_{k_{AB}}(A, t), Ticket_{AB}, r_a'', [request]$

(6) $A \leftarrow B: E_{k_{AB}}(r_a''), [response]$; [request] and [response] optionally encrypted with $k_{AB}$.

(1) + (2): TGT request.
(3) + (4): Ticket request for B.
(5) + (6): Authentication and key establishment between A and B.

**Kerberos Characteristics**

**Properties:**

- **Entity Authentication:** YES, for all involved entities.
- **Implicit Key Authentication:** YES: All generated keys are protected by keys shared between the AS and all participants.
- **Key Confirmation:**
  - Between A and AS: NO: AS has no proof that A possesses the key $K_A$.
  - Between A and TGS: YES for $k_{AT}$ (redundant quantities encrypted with $k_{AT}$ are exchanged between A and TGS); NO for $k_{AB}$ (TGS has no proof from A).
  - Between A and B: YES: Exchange of redundant quantities encrypted with $k_{AB}$.
- **Perfect Forward Secrecy:** NO: All keys are explicitly transferred.

**Problems:**

- Initial keys (like $K_A$) depend (directly) on user-chosen passwords. This makes the protocol vulnerable to password theft or:
  - **Password guessing attacks:** $E_{K_A}(k_{AT}, r_a)$ in (2) helps crack A’s password.
    **Solution:** Pre-authentication in (1): $E_{K_A}(t)$ with $t =$ timestamp (optional in v5).

- The ticket validity window can lead to **replay attacks** if the $r_a^{(n)}$ are not properly controlled by the participants.

- **Clock synchronization** is necessary! This is not always easy in heterogeneous environments.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**Kerberos:**

- AS issues TGT, TGS issues service tickets
- Tickets contain session keys
- Authentication via authenticators
- Vulnerable: password guessing, replay
- Solution: pre-authentication, timestamps
:::

---

## SSL/TLS

SSL/TLS: Secure Socket Layer / Transport Layer Security

Protocol for securing communications between the transport (TCP) and application layers.

**Provided Services:**

- Confidentiality, integrity, flow authentication
- Server identification (client optional)

**Algorithms Used:**

- **Public-key cryptography** (RSA, DH, DSA): Key exchange
- **MACs:** Flow authentication
- **Symmetric cryptography** (DES, AES, IDEA): Flow encryption

**Properties:**

- ✅ Entity authentication (server + optional client via certificates)
- ✅ Implicit key authentication
- ✅ Key confirmation
- ⚠️ Perfect Forward Secrecy: Depends on the exchange protocol (DH → yes, RSA → no)

**Remarks:**

- TLS keys are derived by hashing from random values and the *pre_master_secret*.
- SSL/TLS is the de facto standard for web security (HTTPS).
- Trust relies on root certificates embedded in browsers.
- Major vulnerabilities stem from randomness, implementations, and hash functions.
- Notable attacks: renegotiation (2009), Heartbleed (2014).

### SSL/TLS Architecture

**Three Components:**

1. **SSL Record Protocol:** Encapsulation above TCP (fragmentation + compression + encryption)
2. **SSL Handshake Protocol:** Authentication + parameter negotiation
3. **SSL State Machine:** Session and connection state variables

::: {.callout-note collapse="true"}
### Original Text

**Secure Socket Layer (SSL) / Transport Level Security (TLS)**

Located between the transport layer (TCP) and application layer protocols (not only HTTP but also SMTP, FTP, etc.!).

It is a **meta key establishment protocol** highly configurable, allowing many modes of operation and negotiation options.

Provides **confidentiality**, **integrity**, **data flow authentication**, and **server identification** (and optionally client identification) services.

**Uses the following algorithm families:**

- **Public-key cryptography** (RSA, Diffie-Hellman, DSA, etc.) for symmetric key exchange.
- **MACs** for data flow authentication.
- **Symmetric cryptography** (DES, IDEA, AES, etc.) for data flow encryption.

The use of **CAs** to certify the association between entities and public keys is strongly recommended... but not mandatory!

**Properties:**
- **Entity authentication** via certificates (server and optionally client).
- **Implicit Key Authentication** and **Key Confirmation** are guaranteed.
- **Perfect Forward Secrecy** depends on the protocol chosen for key exchange.

**SSL/TLS Overview**

SSL is a "mini-stack" of protocols with functionalities from the session, presentation, and application layers.

SSL consists of three fundamental blocks:

- **SSL record protocol** allowing encapsulation of higher-level protocols above TCP (fragmentation + compression + encryption).
- **SSL handshake protocol** responsible for participant authentication and encryption parameter negotiation.
- **SSL state machine**. Unlike HTTP, SSL is a **stateful** protocol; it therefore requires a set of variables determining the state of a session and a connection.
:::

### SSL Handshake Protocol

::: {.callout collapse="true" title="Diagram"}
**Phase 1: Hello**

- **Client Hello:** Version, random, session ID, accepted algorithms
- **Server Hello:** Version, random, session ID, selected algorithms
- **Server Certificate** (optional): Server certificate + CA path
- **Server Key Exchange** (optional): Server public key information
- **Certificate Request** (optional): Client certificate request

**Phase 2: Client Authentication and Key Exchange**

- **Client Certificate** (optional): Client certificate + CA path
- **Client Key Exchange:** Generates `pre_master_secret`, sends encrypted with server’s public key
- **Certificate Verify** (optional): Explicit client certificate verification

**Phase 3: Finalization**

- **Finish** (client): First message protected with negotiated parameters
- **Finish** (server): Same for the server

**Phase 4: Application**

- Data protected with derived keys

:::

### SSL/TLS Key Generation

**Cascading Derivation:**

$$master\_secret = MD5(pre\_master\_secret + SHA('A' + pre\_master\_secret + ClientRandom + ServerRandom))$$
$$+ MD5(pre\_master\_secret + SHA('BB' + ...)) + ...$$

$$key\_block = MD5(master\_secret + SHA('A' + master\_secret + ServerRandom + ClientRandom)) + ...$$

**Partition of the key_block:**

- `client_write_MAC_secret[hash_size]`
- `server_write_MAC_secret[hash_size]`
- `client_write_key[key_material]`
- `server_write_key[key_material]`
- `client_write_IV[IV_size]`
- `server_write_IV[IV_size]`

::: {.callout-note collapse="true"}
### Original Text

**Simplified SSL/TLS Handshake Protocol**

[Handshake diagram with 4 phases: Hello, Key Exchange, Finish, Application Data]

**SSL/TLS: Key Generation**

```
master_secret =
 MD5(pre_master_secret + SHA('A' + pre_master_secret +
 ClientHello.random + ServerHello.random)) +
 MD5(pre_master_secret + SHA('BB' + pre_master_secret +
 ClientHello.random + ServerHello.random)) +
 MD5(pre_master_secret + SHA('CCC' + pre_master_secret +
 ClientHello.random + ServerHello.random));

key_block =
 MD5(master_secret + SHA('A' + master_secret +
 ServerHello.random +
 ClientHello.random)) +
 MD5(master_secret + SHA('BB' + master_secret +
 ServerHello.random +
 ClientHello.random)) +
 MD5(master_secret + SHA('CCC' + master_secret +
 ServerHello.random +
 ClientHello.random)) + [...];

 until enough output has been generated. Then the key_block is
 partitioned as follows:

 client_write_MAC_secret[CipherSpec.hash_size]
 server_write_MAC_secret[CipherSpec.hash_size]
 client_write_key[CipherSpec.key_material]
 server_write_key[CipherSpec.key_material]
 client_write_IV[CipherSpec.IV_size] /* non-export ciphers */
 server_write_IV[CipherSpec.IV_size] /* non-export ciphers */
```

**SSL/TLS: Final Remarks**

- Secret keys are the result of applying hash functions (MD5, SHA) to the random numbers from the Hello records and the `pre_master_secret`.

- TLS/SSL has become the **de facto standard** for web security (the basis of **https**).

- SSL clients (Explorer, Firefox, Opera, Chrome, etc.) contain "hard-coded" certificates corresponding to a few root certification authorities (Verisign, Thawte, Microsoft, RSA, etc.) allowing verification of certificates presented by some servers, but SSL is designed to rely on a **global certification network** that currently does not exist.

- The most common **security flaws** in SSL concern key randomness generation as well as the most common implementation defects: buffer overflows, SQL injection, etc. The weakness of hash functions (MD5, SHA) is also a risk factor.

- In November 2009, an attack was discovered allowing a Man-in-the-Middle to inject content (chosen plaintext) into an authentic flow following a **renegotiation** of parameters provided for in the protocol. This is a flaw in the protocol that required a patch in all implementations.

- The **Heartbleed** vulnerability based on a buffer overflow seriously disrupted the Internet community upon its discovery in April 2014.
:::

::: {.callout-tip collapse="true"}
### Quick Review

**SSL/TLS:**

- Meta-protocol between TCP and application
- Handshake: negotiation + authentication
- Keys derived: `master_secret` → `key_block`
- HTTPS standard
- Flaws: randomness, Heartbleed, renegotiation
:::

---

## Final Remarks on KEPs

**Before choosing a KEP:**

1. **Define objectives:** Confidentiality, authentication, non-repudiation.
2. **Define security level:** Key confirmation, PFS, future secrecy.
3. **Establish constraints:** Users, machines, network, attackers.

**Best Practices:**

- ✅ Choose a proven and robust solution.
- ❌ Avoid inventing "from scratch."
- ✅ Verify that properties are satisfied.

**Protocol Verification:**

Two complementary approaches:

- **Practical Analysis:** "On paper" and "on machine"
  - Control random numbers (reflection attacks)
  - Redundancy of encrypted/signed quantities
  - Classic pitfalls

- **Formal Analysis:** Dedicated logics (BAN logic, etc.)

::: {.callout-note collapse="true"}
### Original Text

**Key Establishment Protocols: Final Remarks**

Key establishment protocols are a **cornerstone** of any security solution. Before choosing (designing) a KEP, it is therefore essential to:

- **Define the objectives** (confidentiality, entity/data authentication, non-repudiation, etc.).
- **Define the desired security level** based on the studied properties (key confirmation, perfect forward secrecy, etc.).
- **Establish a list of constraints** related to the environment (users, machines, network, potential attackers, etc.).

Based on these criteria, we can:

- **Choose a proven and robust solution** (better than inventing one from scratch!).
- **Verify that the objectives are met** and the properties satisfied.

**Protocol verification** is a complex and delicate process; moreover, published solutions are not always correct. Two approaches are possible (and necessary):

- **Practical analysis.** Analyze protocol flaws "on paper" and "on machine," considering classic pitfalls: control of random numbers to avoid reflection attacks, redundancy of encrypted/signed quantities, etc.

- **Formal analysis** with logics specifically designed for this purpose (such as **BAN logic**).
:::

::: {.callout-tip collapse="true"}
### Quick Review

**KEP – Best Practices:**

1. Define objectives and constraints
2. Choose a proven solution
3. Verify properties (practical + formal)
4. Avoid pitfalls: reflection, redundancy, randomness control
:::