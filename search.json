[
  {
    "objectID": "exam_notes_fr.html",
    "href": "exam_notes_fr.html",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "",
    "text": "Les services de sécurité sont les objectifs que l’on cherche à atteindre pour protéger un système.\n\nConfidentialité : Protection contre la divulgation non autorisée.\nIntégrité : Protection contre la modification non autorisée.\nDisponibilité : Garantie d’accès pour les utilisateurs légitimes.\nAuthentification :\n\nEntity authentication (Entité) : Certifier l’identité d’un acteur.\nData origin authentication (Origine) : Certifier la source d’une donnée.\n\nNon-répudiation : Impossibilité de nier une transaction.\nNon-Duplication : Protection contre les copies illicites.\nAnonymat : Préservation de l’identité ou de la source.\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nConfidentialité : Protection de l’information d’une divulgation non autorisée.\nIntégrité : Protection contre la modification non autorisée de l’information.\nDisponibilité : S’assurer que les ressources sont accessibles aux utilisateurs légitimes.\nAuthentification :\n\nAuthentification d’entités (entity authentication) : procédé permettant à une entité d’être sûre de l’identité d’une seconde entité à l’appui d’une évidence corroborant (p.ex.: présence physique, cryptographique, biométrique, etc.). Le terme identification est parfois utilisé pour désigner également ce service.\nAuthentification de l’origine de données (data origin authentication) : procédé permettant à une entité d’être sûre qu’une deuxième entité est la source originale d’un ensemble de données. Par définition, ce service assure également l’intégrité de ces données.\n\nNon-répudiation : Offre la garantie qu’une entité ne pourra pas nier être impliquée dans une transaction.\nNon-Duplication : Protection contre les copies illicites.\nAnonymat (d’entité ou d’origine de données) : Permet de préserver l’identité d’une entité, de la source d’une information ou d’une transaction."
  },
  {
    "objectID": "exam_notes_fr.html#dangers-et-attaques-synthèse",
    "href": "exam_notes_fr.html#dangers-et-attaques-synthèse",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Dangers et Attaques : Synthèse",
    "text": "Dangers et Attaques : Synthèse\n\n\n\n\n\n\n\n\nServices\nDangers\nAttaques\n\n\n\n\nConfidentialité\nfuite d’informations\nécoutes illicites, analyse du trafic\n\n\nIntégrité\nmodification de l’information\ncréation, altération ou destruction illicite\n\n\nDisponibilité\ndenial of service, usage illicite\nvirus, accès répétés visant à inutiliser un système\n\n\nAuthentification d’entités\naccès non autorisés\nVol de mot de passe, faille dans le protocole d’authentification\n\n\nAuthentification de données\nfalsification d’informations\nfalsification de signature, faille dans le protocole d’authentification\n\n\nNon-répudiation\nnier la participation à une transaction\nprétendre un vol de clé ou une faille dans le protocole de signature\n\n\nNon-duplication\nduplication\nfalsification, imitation\n\n\nAnonymat\nidentification\nanalyse d’une transaction, accès non autorisés permettant l’identification"
  },
  {
    "objectID": "exam_notes_fr.html#mécanismes-de-protection",
    "href": "exam_notes_fr.html#mécanismes-de-protection",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Mécanismes de Protection",
    "text": "Mécanismes de Protection\n\n\n\n\n\n\n\n\nServices\nMécanismes classiques\nMécanismes digitaux\n\n\n\n\nConfidentialité\nscellés, coffre-forts, cadenas\ncryptage, autorisation logique\n\n\nIntégrité\nencre spéciale, hologrammes\nfonctions à sens unique + cryptage\n\n\nDisponibilité\ncontrôle d’accès physique, surveillance vidéo\ncontrôle d’accès logique, audit, anti-virus\n\n\nAuth. d’entités\nprésence, voix, pièce d’identité, reconnaissance biométrique\nsecret + protocole d’authentification, adresse réseau + userid, carte à puce + PIN\n\n\nAuth. de données\nsceaux, signature, empreinte digitale\nfonctions à sens unique + cryptage\n\n\nNon-répudiation\nsceaux, signature, signature notariale, envoi recommandé\nfonctions à sens unique + cryptage + signature digitale\n\n\nNon-duplication\nencre spéciale, hologrammes, tatouage\ntatouage digital (watermarks), verrouillage cryptographique\n\n\nAnonymat\nbrouilleur de voix, déguisement, argent liquide\nmixers, remailers, argent électronique, deep web"
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis par E-Mail",
    "text": "Programmes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels (malware).\nE-mails visant à provoquer une action (ouvrir une pièce jointe ou cliquer sur un lien).\nAttaques souvent personnalisées grâce à l’ingénierie sociale.\nConséquences principales :\n\nInstallation de malware (ransomware, keyloggers, etc.).\nPerte ou vol de données personnelles.\nDétournement du système et propagation du malware.\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nMalware diffusé par e-mail\nIncitation à cliquer ou ouvrir\nIngénierie sociale\nVol, perte de données, détournement\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nProgrammes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels ou malware.\nE-mails conçus pour inciter le destinataire à ouvrir une pièce jointe ou à suivre un lien contenant de la publicité non souhaitée, des informations offensives, des programmes à risque, etc.\nSouvent ciblés sur la base des intérêts de la victime (travail préliminaire d’ingénierie sociale (social engineering)).\nConséquences :\n\nInstallation de malware (ransomware, keyloggers, etc.) dans le système de la victime (ordinateur, tablette, smartphone, smartwatch, etc.).\nDestruction de données contenues dans l’ordinateur.\nVol d’informations ou de données personnelles.\nDétournement du système pour des fins malicieuses (p.ex.: minage illicite de bitcoins).\nDiffusion de malware (éventuellement à d’autres utilisateurs)."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail-1",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis par E-Mail",
    "text": "Programmes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels ou malware.\nE-mails conçus pour inciter le destinataire à ouvrir une pièce jointe ou à suivre un lien contenant de la publicité non souhaitée, des informations offensives, des programmes à risque, etc.\nSouvent ciblés sur la base des intérêts de la victime (travail préliminaire d’ingénierie sociale (social engineering)).\nConséquences :\n\nInstallation de malware (ransomware, keyloggers, etc.) dans le système de la victime (ordinateur, tablette, smartphone, smartwatch, etc.).\nDestruction de données contenues dans l’ordinateur.\nVol d’informations ou de données personnelles.\nDétournement du système pour des fins malicieuses (p.ex.: minage illicite de bitcoins).\nDiffusion de malware (éventuellement à d’autres utilisateurs)."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis sur le Web",
    "text": "Programmes Malveillants Transmis sur le Web\n\nMéthode appelée drive-by download : infection automatique lors de la visite d’un site web.\nL’origine peut être :\n\nun site malveillant ;\nun site légitime compromis (p. ex. cross-site scripting).\n\nLa prudence des utilisateurs limite fortement ce mode de propagation.\nLes impacts sont similaires aux infections par e-mail.\nLa restriction des scripts (java/javascript) réduit les risques mais peut affecter la navigation.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nDrive-by download = infection sans action de l’utilisateur\nSites malveillants ou compromis\nSensibilisation + scripts restreints = protection\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nProgrammes Malveillants Transmis sur le Web\n\nCette technique, souvent appelée drive-by download, permet d’infecter le système (ordinateur, tablette, smartphone, smartwatch, etc.) sur lequel s’exécute un client web lors de la simple visite d’un site.\nIl peut s’agir soit :\n\nd’un site malicieux qui contient le malware.\nd’un site web légitime qui aurait été infecté au préalable (par exemple, moyennant une technique appelée cross-site scripting). L’infection pouvant affecter seulement certaines pages…\n\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes conséquences sont semblables à celle des transmissions par e-mail.\nL’exécution restreinte des scripts (java/javascript) dans le navigateur peut limiter la portée de l’infection mais risque de contraindre la navigation dans certains sites."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web-1",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis sur le Web",
    "text": "Programmes Malveillants Transmis sur le Web\n\nCette technique, souvent appelée drive-by download, permet d’infecter le système (ordinateur, tablette, smartphone, smartwatch, etc.) sur lequel s’exécute un client web lors de la simple visite d’un site.\nIl peut s’agir soit :\n\nd’un site malicieux qui contient le malware.\nd’un site web légitime qui aurait été infecté au préalable (par exemple, moyennant une technique appelée cross-site scripting). L’infection pouvant affecter seulement certaines pages…\n\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes conséquences sont semblables à celle des transmissions par e-mail.\nL’exécution restreinte des scripts (java/javascript) dans le navigateur peut limiter la portée de l’infection mais risque de contraindre la navigation dans certains sites."
  },
  {
    "objectID": "exam_notes_fr.html#hameçonnage-phishing",
    "href": "exam_notes_fr.html#hameçonnage-phishing",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hameçonnage (Phishing)",
    "text": "Hameçonnage (Phishing)\n\nTechnique visant à collecter des informations privées par des méthodes de pêche indiscriminée.\nLe phishing peut être :\n\ngénéral (ciblage large) ;\nciblé (spear phishing) lorsqu’une personne ou organisation précise est visée.\n\nLe vecteur principal est un e-mail à adresse falsifiée, difficilement détectable.\nL’objectif est d’obtenir des données sensibles (identifiants, mots de passe, informations personnelles ou bancaires).\nLes attaques reposent sur des prétextes crédibles ou menaçants pour pousser la victime à coopérer.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nVol d’informations par tromperie\nE-mails falsifiés\nSpear phishing = attaque ciblée\nPrétextes urgents ou menaçants\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nHameçonnage (Phishing)\n\nLe mot phishing se compose des mots anglais “password” (mot de passe), “harvesting” (moisson) et “fishing” (pêche).\nCette composition de mots illustre le but principal de cette technique qui consiste à récolter un maximum d’informations privées des utilisateurs via des mécanismes de “pêche indiscriminée”.\nLorsque la pêche aux informations est ciblée vers une personne ou organisation spécifique, la technique est dénommée spear phishing (qui provient de spear fishing ou pêche au harpon).\nLe vecteur de transmission consiste normalement dans un e-mail avec une adresse d’expédition falsifiée (mais souvent indétectable…) qui demande à la victime de fournir des informations privées : adresses e-mail, identifiants (twitter, facebook, etc.), mots de passe, numéros d’identité, numéros de comptes bancaires, etc.\nLes prétextes utilisés sont variés (mise à jour du système informatique, arrêt du service, retrait d’un envoi, etc.) et vont jusqu’à menacer l’utilisateur en cas de refus."
  },
  {
    "objectID": "exam_notes_fr.html#hameçonnage-phishing-1",
    "href": "exam_notes_fr.html#hameçonnage-phishing-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hameçonnage (Phishing)",
    "text": "Hameçonnage (Phishing)\n\nLe mot phishing se compose des mots anglais “password” (mot de passe), “harvesting” (moisson) et “fishing” (pêche).\nCette composition de mots illustre le but principal de cette technique qui consiste à récolter un maximum d’informations privées des utilisateurs via des mécanismes de “pêche indiscriminée”.\nLorsque la pêche aux informations est ciblée vers une personne ou organisation spécifique, la technique est dénommée spear phishing (qui provient de spear fishing ou pêche au harpon).\nLe vecteur de transmission consiste normalement dans un e-mail avec une adresse d’expédition falsifiée (mais souvent indétectable…) qui demande à la victime de fournir des informations privées : adresses e-mail, identifiants (twitter, facebook, etc.), mots de passe, numéros d’identité, numéros de comptes bancaires, etc.\nLes prétextes utilisés sont variés (mise à jour du système informatique, arrêt du service, retrait d’un envoi, etc.) et vont jusqu’à menacer l’utilisateur en cas de refus."
  },
  {
    "objectID": "exam_notes_fr.html#pourriels-spam",
    "href": "exam_notes_fr.html#pourriels-spam",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Pourriels (Spam)",
    "text": "Pourriels (Spam)\n\nE-mails indésirables, souvent publicitaires, ou pop-ups non sollicités lors de la navigation web.\nReprésentent environ 60% des e-mails mondiaux.\nConséquences principales :\n\nConsommation de ressources et perte de temps.\nCertains peuvent transmettre des malware.\n\nCiblent souvent les adresses courtes ou proviennent de listes d’adresses vendues/échangées.\nLes filtres anti-spam entraînent des coûts importants pour les organisations.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nE-mails/publicités indésirables\nRisques : perte de temps, ressources, malware\nCiblage : adresses courtes ou listes\nFiltrage coûteux pour entreprises\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nPourriels (Spam)\n\nEnglobe tous les e-mails indésirables (souvent publicitaires) reçus par les personnes et les organisations.\nTerme utilisé également pour désigner les pages/fenêtres pop-up affichées sans le consentement de l’utilisateur lors de la navigation web.\nOn estime que 60% des e-mails qui circulent dans le monde appartiennent à cette catégorie.\nLes conséquences sont souvent limitées à la consommation de ressources de calcul et stockage ainsi qu’au gaspillage de temps associé à la lecture et traitement de ces messages mais…\n… certains e-mails spam peuvent également constituer des vecteurs de transmission de malware.\nIls ont tendance à cibler plus particulièrement les adresses e-mail courtes (p.ex: abc@gmail.com) mais fonctionnent également sur la base des listes (souvent échangées / vendues) contenant tous types d’adresses.\nLes opérations de filtrage anti-spam entraînent des coûts considérables pour les organisations."
  },
  {
    "objectID": "exam_notes_fr.html#pourriels-spam-1",
    "href": "exam_notes_fr.html#pourriels-spam-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Pourriels (Spam)",
    "text": "Pourriels (Spam)\n\nEnglobe tous les e-mails indésirables (souvent publicitaires) reçus par les personnes et les organisations.\nTerme utilisé également pour désigner les pages/fenêtres pop-up affichées sans le consentement de l’utilisateur lors de la navigation web.\nOn estime que 60% des e-mails qui circulent dans le monde appartiennent à cette catégorie.\nLes conséquences sont souvent limitées à la consommation de ressources de calcul et stockage ainsi qu’au gaspillage de temps associé à la lecture et traitement de ces messages mais…\n… certains e-mails spam peuvent également constituer des vecteurs de transmission de malware.\nIls ont tendance à cibler plus particulièrement les adresses e-mail courtes (p.ex: abc@gmail.com) mais fonctionnent également sur la base des listes (souvent échangées / vendues) contenant tous types d’adresses.\nLes opérations de filtrage anti-spam entraînent des coûts considérables pour les organisations."
  },
  {
    "objectID": "exam_notes_fr.html#rançongiciels-ransomware",
    "href": "exam_notes_fr.html#rançongiciels-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Rançongiciels (Ransomware)",
    "text": "Rançongiciels (Ransomware)\n\nMalware type Cheval de Troie qui chiffre les données pour les rendre inaccessibles.\nExige une rançon (souvent en bitcoins) pour récupérer les fichiers.\nPeut rester dormant, déclenché par un événement ou une date.\nPrincipal vecteur : e-mails malveillants.\nAutres effets possibles : attaques par déni de service, extorsion.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nChiffrement des données par Cheval de Troie\nRançon pour restaurer accès\nDormance programmée possible\nInfection via e-mails malveillants\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nRançongiciels (Ransomware)\n\nCette famille spécifique de malware appartient à la catégorie appelée Chevaux de Troie (Trojan Horses).\nLeur comportement plus habituel consiste à chiffrer les données de la victime (locaux et distants) afin de les rendre totalement inaccessibles.\nUn message apparait ensuite pour demander le paiement d’une rançon (souvent en bitcoins ou une autre monnaie virtuelle) permettant potentiellement de récupérer l’accès aux fichiers chiffrés.\nIls peuvent rester en état dormant dans le système infecté et être déclenchés par un événement spécifique ou à une date donnée (attaques synchronisées).\nLeurs vecteurs d’infection sont variés mais les e-mails contenant des pièces jointes malicieuses sont souvent mis en cause lors des infections primaires.\nDes nombreuses variantes existent et continuent à se développer.\nOn observe parfois d’autres comportements associés à ces malware : dénis de service, extorsions ciblées, menaces, etc."
  },
  {
    "objectID": "exam_notes_fr.html#rançongiciels-ransomware-1",
    "href": "exam_notes_fr.html#rançongiciels-ransomware-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Rançongiciels (Ransomware)",
    "text": "Rançongiciels (Ransomware)\n\nCette famille spécifique de malware appartient à la catégorie appelée Chevaux de Troie (Trojan Horses).\nLeur comportement plus habituel consiste à chiffrer les données de la victime (locaux et distants) afin de les rendre totalement inaccessibles.\nUn message apparait ensuite pour demander le paiement d’une rançon (souvent en bitcoins ou une autre monnaie virtuelle) permettant potentiellement de récupérer l’accès aux fichiers chiffrés.\nIls peuvent rester en état dormant dans le système infecté et être déclenchés par un événement spécifique ou à une date donnée (attaques synchronisées).\nLeurs vecteurs d’infection sont variés mais les e-mails contenant des pièces jointes malicieuses sont souvent mis en cause lors des infections primaires.\nDes nombreuses variantes existent et continuent à se développer.\nOn observe parfois d’autres comportements associés à ces malware : dénis de service, extorsions ciblées, menaces, etc."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot",
    "href": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les Dispositifs Internet of Things (IoT)",
    "text": "Attaques sur les Dispositifs Internet of Things (IoT)\n\nAttaques visant les objets connectés (caméras, TV, capteurs, alarmes, etc.).\nCes dispositifs sont faciles à compromettre à cause de :\n\nfailles connues,\nmots de passe par défaut,\nmanque de sensibilisation des utilisateurs.\n\nLa prise de contrôle à distance permet :\n\nun point d’entrée vers le réseau,\nl’utilisation de l’appareil pour des activités illicites (DDoS, hacking, minage).\n\nUn inventaire précis des dispositifs connectés est indispensable.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nCible les objets connectés\nSécurité faible (failles, mots de passe par défaut)\nRisque d’accès au réseau et d’abus\nInventaire des IoT nécessaire\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nAttaques sur les Dispositifs Internet of Things (IoT)\n\nCiblent les objets connectés de toute sorte (caméras, TVs, frigos, capteurs et interrupteurs domotiques, installations d’alarme, etc.).\nIls sont souvent plus faciles à pirater que les systèmes traditionnels par cause de :\n\nnombreuses failles de sécurité souvent connues des attaquants.\nmots de passe par défaut.\nnégligence de la part des utilisateurs qui ignorent les risques qui leurs sont propres.\n\nLa prise de contrôle à distance de ces appareils par une entité malveillante implique :\n\nUne porte d’entrée au réseau domestique/corporatif.\nUn dispositif pouvant être utilisé pour des activités illicites (hacking, attaques DDoS, minage de bitcoins, etc.).\n\nL’établissement d’un répertoire précis de tous les dispositifs de ce type connectés au réseau est nécessaire!"
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot-1",
    "href": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les Dispositifs Internet of Things (IoT)",
    "text": "Attaques sur les Dispositifs Internet of Things (IoT)\n\nCiblent les objets connectés de toute sorte (caméras, TVs, frigos, capteurs et interrupteurs domotiques, installations d’alarme, etc.).\nIls sont souvent plus faciles à pirater que les systèmes traditionnels par cause de :\n\nnombreuses failles de sécurité souvent connues des attaquants.\nmots de passe par défaut.\nnégligence de la part des utilisateurs qui ignorent les risques qui leurs sont propres.\n\nLa prise de contrôle à distance de ces appareils par une entité malveillante implique :\n\nUne porte d’entrée au réseau domestique/corporatif.\nUn dispositif pouvant être utilisé pour des activités illicites (hacking, attaques DDoS, minage de bitcoins, etc.).\n\nL’établissement d’un répertoire précis de tous les dispositifs de ce type connectés au réseau est nécessaire!"
  },
  {
    "objectID": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement",
    "href": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)",
    "text": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant à altérer les informations sur sites web et réseaux sociaux.\nImpact : réputation compromise et dommages économiques.\nSites web : sécurisation du système hôte, configuration restrictive, audits réguliers.\nRéseaux sociaux : mots de passe forts, authentification multi-facteur, fermeture des sessions, suppression des cookies.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAltération des infos sur sites et réseaux sociaux\nRisques : réputation et pertes économiques\nSites : sécurisation + audits\nRéseaux sociaux : mots de passe forts, MFA, sessions fermées, cookies supprimés\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nModification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant l’intégrité de l’information publiée dans les sites web, les réseaux sociaux, etc.\nElles portent atteinte à la réputation et peuvent provoquer d’importants dommages économiques pour les sociétés ayant une présence Internet.\nDans le cas des sites web, la sécurisation du système hôte est essentielle ainsi qu’une configuration aussi restrictive que possible. Des audits des sécurité récurrents sont vivement recommandés.\nLa protection des informations affichées dans les réseaux sociaux dépend directement du processus d’authentification permettant d’accéder au profil à risque :\n\nÉviter les mots de passe trop simples.\nPrivilégier l’authentification forte, si possible multi-facteur.\nFermer proprement les sessions.\nEffacer les cookies."
  },
  {
    "objectID": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement-1",
    "href": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)",
    "text": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant l’intégrité de l’information publiée dans les sites web, les réseaux sociaux, etc.\nElles portent atteinte à la réputation et peuvent provoquer d’importants dommages économiques pour les sociétés ayant une présence Internet.\nDans le cas des sites web, la sécurisation du système hôte est essentielle ainsi qu’une configuration aussi restrictive que possible. Des audits des sécurité récurrents sont vivement recommandés.\nLa protection des informations affichées dans les réseaux sociaux dépend directement du processus d’authentification permettant d’accéder au profil à risque :\n\nÉviter les mots de passe trop simples.\nPrivilégier l’authentification forte, si possible multi-facteur.\nFermer proprement les sessions.\nEffacer les cookies."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos",
    "href": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques Dénis de Service (Denial of Service / DDoS)",
    "text": "Attaques Dénis de Service (Denial of Service / DDoS)\n\nVise à rendre inaccessibles des systèmes informatiques, surtout pour les organisations.\nDDoS : attaque distribuée par des milliers de dispositifs, générant un trafic massif.\nProtections classiques (firewalls, sondes IDS (Intrusion Detection System) / IPS (Intrusion Prevention System)) souvent insuffisantes.\nConséquences :\n\nRéputation affectée\nPertes financières (parfois rançons)\nRisques élevés pour les infrastructures critiques (hôpitaux, centrales, Internet backbone)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nDDoS = systèmes inaccessibles via attaques massives\nProtections limitées\nRisques : réputation, finances, infrastructures critiques\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nAttaques Dénis de Service (Denial of Service / DDoS)\n\nAttaques destinées à rendre inaccessibles des systèmes informatiques de toute sorte visant surtout les organisations privées ou étatiques.\nLe terme DDoS (Distributed Denial of Service) désigne une famille d’attaques dans laquelle des multiples (souvent des dizaines de milliers) de dispositifs ciblent simultanément le(s) système(s) victime(s).\nLe trafique généré atteint plusieurs centaines de gigabits / seconde.\nL’efficacité des mécanismes de protection traditionnels (firewalls, sondes de prévention et de détection d’intrusion, etc.) est limitée.\nL’indisponibilité d’un service peut engendrer :\n\ndes problèmes réputationnels.\nd’importantes pertes financières (des demandes de rançon peuvent être exigées pour les désactiver).\ndes hauts risques de sécurité (même physique!) lorsque des infrastructures critiques (hôpitaux, centrales électriques, backbone de l’Internet, etc.) sont ciblées."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos-1",
    "href": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques Dénis de Service (Denial of Service / DDoS)",
    "text": "Attaques Dénis de Service (Denial of Service / DDoS)\n\nAttaques destinées à rendre inaccessibles des systèmes informatiques de toute sorte visant surtout les organisations privées ou étatiques.\nLe terme DDoS (Distributed Denial of Service) désigne une famille d’attaques dans laquelle des multiples (souvent des dizaines de milliers) de dispositifs ciblent simultanément le(s) système(s) victime(s).\nLe trafique généré atteint plusieurs centaines de gigabits / seconde.\nL’efficacité des mécanismes de protection traditionnels (firewalls, sondes de prévention et de détection d’intrusion, etc.) est limitée.\nL’indisponibilité d’un service peut engendrer :\n\ndes problèmes réputationnels.\nd’importantes pertes financières (des demandes de rançon peuvent être exigées pour les désactiver).\ndes hauts risques de sécurité (même physique!) lorsque des infrastructures critiques (hôpitaux, centrales électriques, backbone de l’Internet, etc.) sont ciblées."
  },
  {
    "objectID": "exam_notes_fr.html#fonctions-de-hachage-cryptographiques",
    "href": "exam_notes_fr.html#fonctions-de-hachage-cryptographiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fonctions de Hachage Cryptographiques",
    "text": "Fonctions de Hachage Cryptographiques\n\nFonctions faciles à calculer dans un sens mais virtuellement impossibles à inverser.\nToute modification du document source change radicalement le digest (effet avalanche).\nPropriétés clés :\n\nOne-way : impossible de retrouver l’entrée depuis le hash.\nCollision-free : impossible de trouver deux entrées avec le même hash.\n\nTaille des digests : 160 à 512 bits.\nAlgorithmes (très performants) : SHA-1, SHA-256, SHA-3.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nOne-way + collision-free.\nTaille : 160-512 bits.\nAlgos : SHA-1/256/3.\nUsage : intégrité, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nFonctions faciles à calculer dans un sens mais virtuellement impossibles à calculer dans le sens contraire.\nToute modification (même insignifiante) du document source se traduit par un digest fondamentalement différent.\nIl est virtuellement impossible de retrouver le document source à l’aide seulement du digest (one-way).\nIl est virtuellement impossible de retrouver un deuxième document source produisant le même digest (collision-free).\nLongueur habituelle des digests : 160 à 512 bits.\nLes algorithmes à sens unique sont très performants.\nExemples : SHA-1, SHA-256, SHA-3, etc."
  },
  {
    "objectID": "exam_notes_fr.html#générateurs-pseudo-aléatoires",
    "href": "exam_notes_fr.html#générateurs-pseudo-aléatoires",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Générateurs (Pseudo) Aléatoires",
    "text": "Générateurs (Pseudo) Aléatoires\n\nCaractéristiques\n\naléatoire\nimprévisible\nnon reproductible\n\nCritique pour la sécurité (clés, IV, secrets).\nTypes :\n\nVrais aléatoires : basés sur phénomènes physiques (radioactivité, quantique).\nPseudo-aléatoires : déterministes (basés sur un seed: séquence aléatoire initiale).\n\nRisque : “Pseudo-sécurité” si le seed est prévisible (citation de Pitkin).\nApplications : clés de session, IV (DES-CBC), signatures (ElGamal).\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nVrais aléatoires : physiques (quantique).\nPseudo-aléatoires : déterministes (seed).\nRisque : seed prévisible = faille.\nUsages : clés, IV, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nLa génération de nombre aléatoire est un processus très important pouvant compromettre la sécurité d’un bon nombre de systèmes de cryptage.\nApplications : génération de clés de session, vecteurs d’initialisation (DES - CBC mode), secrets pour signatures (ElGamal), etc.\nUn générateur aléatoire (random generator) est un dispositif capable de générer des nombres de façon aléatoire, imprévisible et non reproductible. (e.g. basé sur phénomènes physiques: source radioactive ou quantique).\nLes générateurs pseudo-aléatoires sont des procédés déterministes développés à partir d’une séquence aléatoire initiale (seed) (e.g. frappe utilisateur, accès disque).\nCitation : R. Pitkin dans [Kau95]: “The use of pseudo-random processes to generate secret quantities can result in pseudo-security”"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique",
    "href": "exam_notes_fr.html#cryptographie-symétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique",
    "text": "Cryptographie Symétrique\n\nHistorique : Utilisée depuis Jules César (Iᵉʳ av. J.-C.).\nPrincipe : Une seule clé pour chiffrer/déchiffrer.\nSchéma : Plaintext → Cryptage (Clé) → Ciphertext → Décryptage (Clé) → Plaintext.\nCaractéristiques :\n\nAlgorithmes : AES, DES, IDEA, RC4.\nServices : Confidentialité, Authentification, Intégrité.\nLimite : Pas de signatures (clé partagée).\nProblème : Échange de clé sécurisé requis.\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\n1 clé pour chiffrer/déchiffrer.\nRapide (AES, DES).\nProblème : échange de clé.\nUsages : documents personnels, groupes fermés.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nAussi appelée cryptographie conventionnelle ou à clés secrètes (I av. JC, Julius Cesar).\nIdée : Sur la base d’une seule clé secrète, réaliser une transformation capable respectivement de rendre illisible et de restituer une pièce d’information.\nSchéma : Plaintext \\(\\to\\) Cryptage (Clé) \\(\\to\\) Ciphertext \\(\\to\\) Décryptage (Clé) \\(\\to\\) Plaintext.\nCaractéristiques :\n\nAlgorithmes : AES, DES, IDEA, RC4, RC5, etc. (certains sont gratuits et de libre accès)\nServices : Confidentialité, Authentification, Intégrité.\nPas de support direct pour signatures digitales (car clé connue des deux).\nNécessite un canal confidentiel pour échanger la clé.\nIdéal pour la protection de documents personnels ou groupes fermés."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique",
    "href": "exam_notes_fr.html#cryptographie-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique",
    "text": "Cryptographie Asymétrique\n\nAussi appelée cryptographie publique (1976, Diffie & Hellman).\nPrincipe\n\nPaire de clés (publique/privée) pour chiffrement et signatures.\n\nDeux usages principaux :\n\nConfidentialité :\n\nChiffrement : clé publique du destinataire\nDéchiffrement : clé privée du destinataire\n\nSignature numérique :\n\nSignature : clé privée de l’expéditeur\nVérification : clé publique de l’expéditeur\nOptimisation : On signe généralement le hash du document\nPropriétés fondamentales :\n\nIntégrité : Toute modification invalide la signature\nNon-collision : Impossible d’avoir 2 documents avec la même signature\nNon-répudiation : Seul le détenteur de la clé privée peut signer\n\n\n\nAspects techniques :\n\nAlgorithmes : RSA, ElGamal\nServices : Intégrité, Authentification, Non-Répudiation\nPerformance : beaucoup plus lent que le symétrique (100x plus lent)\nAvantage : Pas besoin de canal confidentiel pour l’échange de clés\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\n2 clés : publique (chiffrer/vérifier) + privée (déchiffrer/signer)\n2 usages :\n\nConfidentialité : chiffrer pour un destinataire\nSignature : prouver l’authenticité\n\nSignatures :\n\nIntégrité + non-répudiation\n\nAlgorithmes : RSA/ElGamal\nAvantage : Pas besoin de canal sécurisé pour échanger les clés\nDésavantage : Lente\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique\n\nAussi appelée cryptographie publique ou à clés publiques (1976, W. Diffie & M. Hellman).\nIdée : Utiliser deux clés différentes - une secrète et une publique - respectivement pour les opérations de cryptage et décryptage.\nChaque utilisateur dispose d’un porte-clés (keyring).\n\nConfidentialité : * Expéditeur crypte avec la clé publique du destinataire. * Destinataire décrypte avec sa clé privée. * Uniquement clé du destinataire utilisée !\nSignature Digitale : * Expéditeur signe avec sa clé privée. * Destinataire vérifie avec la clé publique de l’expéditeur. * Uniquement clé de l’expéditeur utilisée ! * Note : On signe généralement le digest du document (hash) pour des raisons de performance.\nCaractéristiques des signatures : * La signature change si le document change, alors que la clé privée reste la même. * En cas de modification du document ou de la signature, la vérification échoue (intégrité garantie). * Il est virtuellement impossible, même pour le détenteur de la clé privée, de générer un second document produisant la même signature (fonction à sens unique sans collisions). * Seul le détenteur de la clé privée peut générer une signature vérifiable à l’aide de la clé publique correspondante (non-répudiation). * Algorithmes : RSA, ElGamal. * Services : Intégrité, Authentification, Non-Répudiation. * Lenteur : Jusqu’à 50 fois plus lent que la cryptographie symétrique. * Avantage : Pas besoin de canal confidentiel pour échanger les clés (contrairement au symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique",
    "text": "Cryptographie Asymétrique\n\nAussi appelée cryptographie publique ou à clés publiques (1976, W. Diffie & M. Hellman).\nIdée : Utiliser deux clés différentes - une secrète et une publique - respectivement pour les opérations de cryptage et décryptage.\nChaque utilisateur dispose d’un porte-clés (keyring).\n\nConfidentialité : * Expéditeur crypte avec la clé publique du destinataire. * Destinataire décrypte avec sa clé privée. * Uniquement clé du destinataire utilisée !\nSignature Digitale : * Expéditeur signe avec sa clé privée. * Destinataire vérifie avec la clé publique de l’expéditeur. * Uniquement clé de l’expéditeur utilisée ! * Note : On signe généralement le digest du document (hash) pour des raisons de performance.\nCaractéristiques des signatures : * La signature change si le document change, alors que la clé privée reste la même. * En cas de modification du document ou de la signature, la vérification échoue (intégrité garantie). * Il est virtuellement impossible, même pour le détenteur de la clé privée, de générer un second document produisant la même signature (fonction à sens unique sans collisions). * Seul le détenteur de la clé privée peut générer une signature vérifiable à l’aide de la clé publique correspondante (non-répudiation). * Algorithmes : RSA, ElGamal. * Services : Intégrité, Authentification, Non-Répudiation. * Lenteur : Jusqu’à 50 fois plus lent que la cryptographie symétrique. * Avantage : Pas besoin de canal confidentiel pour échanger les clés (contrairement au symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#crypto-asymétrique-symétrique-hybride",
    "href": "exam_notes_fr.html#crypto-asymétrique-symétrique-hybride",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Crypto Asymétrique + Symétrique (Hybride)",
    "text": "Crypto Asymétrique + Symétrique (Hybride)\n\nPrincipe : Utiliser l’asymétrique pour échanger une clé symétrique (clé de session).\nÉtapes :\n\nA génère une clé symétrique aléatoire \\(K_s\\).\nA chiffre \\(K_s\\) avec la clé publique de B.\nA et B communiquent ensuite avec \\(K_s\\) (symétrique).\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAsymétrique : échange de clé symétrique.\nSymétrique : chiffrement des données.\nAvantage : combine sécurité + performance.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nIdée : Utiliser la cryptographie publique uniquement pour échanger des clés symétriques (Clés de session).\nA génère une clé aléatoire \\(K_s\\) et la transmet à B en l’encryptant avec la clé publique de B.\nA & B communiquent ensuite en utilisant \\(K_s\\) (symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Fonctionnement (RSA)",
    "text": "Cryptographie Asymétrique : Fonctionnement (RSA)\n\nConstruction des clés\n\nChoix des nombres premiers :\n\n\\(p\\) et \\(q\\) : deux grands nombres premiers (&gt; 1024 bits)\n\\(n = pq\\) : module RSA (taille = 2048+ bits)\n\nCalcul de l’indicatrice d’Euler :\n\n\\(\\phi(n) = (p-1)(q-1)\\)\nPropriété : Pour tout \\(a\\) premier avec \\(n\\), \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\n\nSélection des exposants :\n\n\\(e\\) : entier premier avec \\(\\phi(n)\\) (exposant public)\n\\(d\\) : inverse modulaire de \\(e\\) (exposant privé), tel que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\n\n\n\nProcessus de chiffrement/déchiffrement\n\nClé publique : \\((n,e)\\)\nClé privée : \\((d)\\)\nChiffrement : \\(C = P^e \\pmod{n}\\)\nDéchiffrement : \\(P = C^d \\pmod{n}\\)\n\n\n\nPreuve mathématique\n\nCongruence fondamentale :\n\n\\(ed = 1 + k\\phi(n)\\) (par définition de \\(d\\))\n\nApplication du théorème d’Euler :\n\n\\(P^{\\phi(n)} \\equiv 1 \\pmod{n}\\) (si \\(P\\) premier avec \\(n\\))\n\nDémonstration :\n\\[\\begin{align*}\n(P^e)^d &\\equiv P^{ed} \\pmod{n} \\\\\n&\\equiv P^{1 + k\\phi(n)} \\pmod{n} \\\\\n&\\equiv P \\cdot (P^{\\phi(n)})^k \\pmod{n} \\\\\n&\\equiv P \\cdot 1^k \\pmod{n} \\\\\n&\\equiv P \\pmod{n}\n\\end{align*}\\]\n\n\n\nSécurité du système\n\nProblème difficile : Factorisation de \\(n\\) en \\(p\\) et \\(q\\)\nTaille recommandée :\n\n\\(n\\) : 2048 bits (minimum pour sécurité actuelle)\n\\(p\\) et \\(q\\) : 1024+ bits chacun\n\nVulnérabilités connues :\n\nAttaques par canal auxiliaire (timing, power analysis)\nChoix inapproprié des paramètres (\\(e\\) trop petit, \\(p\\) et \\(q\\) trop proches)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nClés :\n\nPublique : \\((n,e)\\) où \\(n = pq\\)\nPrivée : \\((d)\\) avec \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\nOpérations :\n\nChiffrement : \\(P^e \\mod n\\)\nDéchiffrement : \\(C^d \\mod n\\)\n\nSécurité : Factorisation de \\(n\\) difficile\nTaille : 2048+ bits pour \\(n\\)\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique: Fonctionnement (RSA)\n\nSoit \\(n := pq\\) avec \\(p\\) et \\(q\\) deux nombres premiers grands (&gt; 1024 bits).\nSoit \\(\\phi(n) = (p-1)(q-1)\\).\nSoit \\(e\\) et \\(d\\) tels que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nPar définition des congruences: \\(ed = 1 + k\\phi(n)\\)\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption : \\(C = P^e \\pmod n\\). Clé publique : \\((n,e)\\).\nDécryption : \\(P = C^d \\pmod n\\). Clé privée : \\((d)\\).\nPreuve : \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique: Fonctionnement (RSA)",
    "text": "Cryptographie Asymétrique: Fonctionnement (RSA)\n\nSoit \\(n := pq\\) avec \\(p\\) et \\(q\\) deux nombres premiers grands (&gt; 1024 bits).\nSoit \\(\\phi(n) = (p-1)(q-1)\\).\nSoit \\(e\\) et \\(d\\) tels que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nPar définition des congruences: \\(ed = 1 + k\\phi(n)\\)\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption : \\(C = P^e \\pmod n\\). Clé publique : \\((n,e)\\).\nDécryption : \\(P = C^d \\pmod n\\). Clé privée : \\((d)\\).\nPreuve : \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-conclusions",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-conclusions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Conclusions",
    "text": "Cryptographie Asymétrique : Conclusions\n\nAlgorithmes dominants : RSA (le plus utilisé), Rabin, ElGamal\nServices complets :\n\nConfidentialité\nAuthentification\nIntégrité\nSignature digitale & Non-répudiation\nNon-duplication\n\nPerformances :\n\n50x plus lent que le symétrique\nSolution optimale : Combinaison asymétrique (échange de clés) + symétrique (chiffrement)\n\nGestion des clés :\n\nAvantage : Échange de clés publiques sans canal confidentiel\nRisque : Nécessité de vérifier l’authenticité des clés publiques\n\nCanal d’acquisition authentifié ou\nCertification par tiers de confiance\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAlgos : RSA (dominant), Rabin, ElGamal\nServices : Confidentialité + Authentification + Intégrité + Signatures\nLenteur : 50x vs symétrique → hybride recommandé\nClés : Échange public simple mais authentification cruciale\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique : Conclusions\n\nIl existe quelques systèmes de cryptage asymétrique (Rabin, ElGamal, etc.) mais le plus utilisé est RSA.\nServices supportés : Confidentialité, Authentification, Intégrité, Signature Digitale & Non-Refus, (Non Duplication).\nLes opérations liées à la cryptographie asymétrique sont jusqu’à 50 fois (!) plus lentes que celles de la cryptographie symétrique. Une combinaison des deux méthodes est souvent souhaitable.\nLa distribution des clés est simplifiée par le fait que seules des clés publiques doivent être échangées entre les intervenants (pas besoin d’un canal confidentiel alternatif) mais…\n… il est nécessaire de vérifier que la clé publique appartient réellement au destinataire :\n\nSoit le canal d’acquisition de la clé publique est protégé contre toute modification (authentifié)\nSoit la clé est certifiée exacte par un tiers"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-conclusions-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-conclusions-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Conclusions",
    "text": "Cryptographie Asymétrique : Conclusions\n\nIl existe quelques systèmes de cryptage asymétrique (Rabin, ElGamal, etc.) mais le plus utilisé est RSA.\nServices supportés : Confidentialité, Authentification, Intégrité, Signature Digitale & Non-Refus, (Non Duplication).\nLes opérations liées à la cryptographie asymétrique sont jusqu’à 50 fois (!) plus lentes que celles de la cryptographie symétrique. Une combinaison des deux méthodes est souvent souhaitable.\nLa distribution des clés est simplifiée par le fait que seules des clés publiques doivent être échangées entre les intervenants (pas besoin d’un canal confidentiel alternatif) mais…\n… il est nécessaire de vérifier que la clé publique appartient réellement au destinataire :\n\nSoit le canal d’acquisition de la clé publique est protégé contre toute modification (authentifié)\nSoit la clé est certifiée exacte par un tiers"
  },
  {
    "objectID": "exam_notes_fr.html#comparaison-symétrique-vs-asymétrique",
    "href": "exam_notes_fr.html#comparaison-symétrique-vs-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Comparaison Symétrique vs Asymétrique",
    "text": "Comparaison Symétrique vs Asymétrique\n\nAvantages comparés\n\nSymétrique :\n\nPerformance : 100x plus rapide\nImplémentation : Facile en hardware\nClés : Courtes (128 bits = 16 caractères mémorisables)\n\nAsymétrique :\n\nÉchange de clés : Canal authentifié suffisant (pas besoin de confidentialité)\nGestion : 1 paire de clés pour n correspondants (vs n clés en symétrique)\n\n\n\n\nProblématiques communes\n\nMaillon faible : Gestion des clés par les utilisateurs\nBase de sécurité : Empirique plutôt que théorique\nContraintes légales : Restrictions d’usage et d’exportation\n\n\n\nRecommandations d’usage\n\n\n\n\n\n\n\n\nCas d’usage\nSolution recommandée\nJustification\n\n\n\n\nDocuments personnels\nSymétrique\nVitesse + clés mémorisables\n\n\nGroupes d’utilisateurs proches\nSymétrique\nVitesse + échange confidentiel facile\n\n\nUtilisateurs distants/inconnus\nAsymétrique\nPas besoin de canal confidentiel\n\n\nTransactions distantes\nHybride (Asymétrique + Symétrique)\nAsymétrique pour l’échange de clé, symétrique pour les données\n\n\nProtection logicielle (distribution)\nHybride\nClé symétrique unique par version, encryptée avec asymétrique\n\n\nSegments réseaux\nSymétrique\nVitesse + environnement contrôlé (échange de clés facile entre administrateurs)\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nSymétrique :\n✅ Rapide (100x)\n✅ Clés courtes (128 bits)  \n❌ Échange de clés confidentiel requis\nAsymétrique :\n✅ Échange de clés simplifié\n✅ 1 paire de clés pour n correspondants\n❌ Lent (50x)\n❌ Clés longues (1024+ bits)\nHybride : Meilleur des deux mondes Problèmes communs : Gestion des clés, base empirique, restrictions légales\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nCryptographie Symétrique vs. Asymétrique\n\nIl existe des centaines d’algorithmes symétriques et asymétriques capables de fournir un niveau de confidentialité suffisant.\nLes solutions symétriques offrent les avantages suivants :\n\nRapidité (jusqu’à 100 fois plus rapide que les solutions asymétriques)\nFacilité d’implantation en hardware\nLongueur de clé réduite : 128 bits (= 16 caractères ⇒ mémorisable !) au lieu de 1024 bits pour des équivalents asymétriques.\n\nLes solutions asymétriques ont comme arguments principaux :\n\nÉchange de clés simplifié : les clés doivent être échangées par un canal authentifié mais non-confidentiel\nGestion de clés simplifiée : une seule paire de clés publique/privée suffit à un utilisateur pour recevoir des messages confidentiels de n utilisateurs (au lieu de n clés différentes dans le cas symétrique).\n\nProblèmes propres aux deux techniques :\n\nLa gestion de clés par l’utilisateur reste le maillon le plus faible\nSécurité (normalement) basée sur des arguments empiriques plutôt que théoriques\nRestrictions légales d’usage et d’exportation\n\n\n\n\nCryptographie Symétrique vs. Asymétrique (II)\n\n\n\n\n\n\n\n\nActivité\nRecommandation\nRemarques\n\n\n\n\nProtection de documents personnels\nCrypto symétrique\nVitesse, clés facilement mémorisables\n\n\nProtection de documents dans un groupe d’utilisateurs proches\nCrypto symétrique\nVitesse, facilité d’échange des clés confidentielles\n\n\nÉtablissement de canaux confidentiels entre utilisateurs distants (inconnus)\nCrypto asymétrique\nPas besoin d’avoir un canal confidentiel : authenticité suffit\n\n\nTransactions entre deux utilisateurs distants, Protection de logiciel (distribution multicast)\nCrypto asymétrique pour protection de clé symétrique + Crypto symétrique pour protection des données\nVitesse, Seule la clé symétrique doit être ré-encryptée pour chaque correspondant, Copie cryptée du logiciel peut être rendue publique\n\n\nProtection des segments réseaux\nCrypto symétrique\nVitesse, Environnement stable → échange confidentiel des clés facile entre sysadmins"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique",
    "href": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique vs. Asymétrique",
    "text": "Cryptographie Symétrique vs. Asymétrique\n\nIl existe des centaines d’algorithmes symétriques et asymétriques capables de fournir un niveau de confidentialité suffisant.\nLes solutions symétriques offrent les avantages suivants :\n\nRapidité (jusqu’à 100 fois plus rapide que les solutions asymétriques)\nFacilité d’implantation en hardware\nLongueur de clé réduite : 128 bits (= 16 caractères ⇒ mémorisable !) au lieu de 1024 bits pour des équivalents asymétriques.\n\nLes solutions asymétriques ont comme arguments principaux :\n\nÉchange de clés simplifié : les clés doivent être échangées par un canal authentifié mais non-confidentiel\nGestion de clés simplifiée : une seule paire de clés publique/privée suffit à un utilisateur pour recevoir des messages confidentiels de n utilisateurs (au lieu de n clés différentes dans le cas symétrique).\n\nProblèmes propres aux deux techniques :\n\nLa gestion de clés par l’utilisateur reste le maillon le plus faible\nSécurité (normalement) basée sur des arguments empiriques plutôt que théoriques\nRestrictions légales d’usage et d’exportation"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique-ii",
    "href": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique-ii",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique vs. Asymétrique (II)",
    "text": "Cryptographie Symétrique vs. Asymétrique (II)\n\n\n\n\n\n\n\n\nActivité\nRecommandation\nRemarques\n\n\n\n\nProtection de documents personnels\nCrypto symétrique\nVitesse, clés facilement mémorisables\n\n\nProtection de documents dans un groupe d’utilisateurs proches\nCrypto symétrique\nVitesse, facilité d’échange des clés confidentielles\n\n\nÉtablissement de canaux confidentiels entre utilisateurs distants (inconnus)\nCrypto asymétrique\nPas besoin d’avoir un canal confidentiel : authenticité suffit\n\n\nTransactions entre deux utilisateurs distants, Protection de logiciel (distribution multicast)\nCrypto asymétrique pour protection de clé symétrique + Crypto symétrique pour protection des données\nVitesse, Seule la clé symétrique doit être ré-encryptée pour chaque correspondant, Copie cryptée du logiciel peut être rendue publique\n\n\nProtection des segments réseaux\nCrypto symétrique\nVitesse, Environnement stable → échange confidentiel des clés facile entre sysadmins"
  },
  {
    "objectID": "exam_notes_fr.html#dissection-dune-attaque-ransomware",
    "href": "exam_notes_fr.html#dissection-dune-attaque-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Dissection d’une Attaque : Ransomware",
    "text": "Dissection d’une Attaque : Ransomware\n\nDéfinition et Impact\n\nDéfinition : Logiciel malveillant qui chiffre les données et exige une rançon pour leur restitution.\nLimites de la définition classique :\n\nNe couvre pas l’impact sur l’infrastructure critique (ex : Colonial Pipeline, mai 2021)\nSous-estime la portée systémique des attaques\n\nStatistiques alarmantes :\n\nMilliards d’attaques annuelles\nConsidéré comme la menace cyber la plus dangereuse en 2021 (“Ransomware Everywhere”)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nMalware : Chiffre les données → demande rançon\nImpact : Infrastructure critique (ex : Colonial Pipeline)\nMenace n°1 en cybersécurité (2021)\nCibles : Particuliers + entreprises + États\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n“Un rançongiciel (de l’anglais ransomware), logiciel rançonneur, logiciel de rançon ou logiciel d’extorsion, est un logiciel malveillant qui prend en otage des données personnelles. Pour ce faire, un rançongiciel chiffre des données personnelles puis demande à leur propriétaire d’envoyer de l’argent en échange de la clé de déchiffrement” (Wikipedia 21 septembre 2021).\n\nDéfinition incomplète car les ransomwares portent sur un vaste spectre de l’infrastructure informatique\nÀ titre d’exemple, en mai 2021, une attaque ransomware dirigée contre la société Colonial Pipeline a provoqué une coupure d’approvisionnement de combustible d’une grande partie de la côte des États-Unis\nAvec un nombre d’attaques global chiffré en milliards par année, “Ransomware Everywhere” est globalement considérée comme la menace la plus directe, visible et dangereuse pour utilisateurs et entreprises en 2021 !"
  },
  {
    "objectID": "exam_notes_fr.html#cycle-de-vie-dune-attaque-ransomware",
    "href": "exam_notes_fr.html#cycle-de-vie-dune-attaque-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cycle de Vie d’une Attaque Ransomware",
    "text": "Cycle de Vie d’une Attaque Ransomware\n\nPrévention et Réponse\n\n\n\n\n\n\n\nPhase\nMesures\n\n\n\n\nPrévention\n- Patching régulier- Solutions de détection (Firewalls, WAFs, IDS/IPS)- Scans anti-malware (e-mails, fichiers)\n\n\nProtection\n- Backups offline (essentiel !)- Politiques de sécurité strictes- Formation des utilisateurs\n\n\nRéponse\n- Ne pas payer (recommandation officielle)- Analyse forensique- Restauration depuis backups\n\n\n\n\n\nDissection Technique\n\nInfection :\n\nVecteurs : Phishing, exploits, RDP vulnérable\nPropagation : Latérale (réseau) ou verticale (système)\n\nExécution :\n\nChiffrement des fichiers ciblés\nSuppression des shadow copies\nPersistance (registre, tâches planifiées)\n\nExtorsion :\n\nAffichage de la demande de rançon\nPaiement en cryptomonnaies (Bitcoin, Monero)\nDélais de paiement avec majoration\n\nOccultation :\n\nObfuscation du code\nCommunication via TOR/Deep Web\nEffacement des logs\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nCycle d’attaque :\n\nInfection (phishing/exploits)\nExécution (chiffrement + persistance)\nExtorsion (rançon en crypto)\nOccultation (TOR + effacement traces)\n\nContre-mesures :\n✅ Backups offline\n✅ Patching + détection\n✅ Formation\n❌ Ne pas payer"
  },
  {
    "objectID": "exam_notes_fr.html#cryptolocker-analyse-technique",
    "href": "exam_notes_fr.html#cryptolocker-analyse-technique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptolocker : Analyse Technique",
    "text": "Cryptolocker : Analyse Technique\n\nSchéma d’Attaque\n\n\n\n\n\ngraph TD\n    A[Infection initiale] --&gt; B[Chiffrement des fichiers]\n    B --&gt; C[Stockage clé privée sur serveurs C2]\n    C --&gt; D[Demande de rançon]\n    D --&gt; E{Paiement ?}\n    E --&gt;|Oui| F[Envoi clé de déchiffrement via TOR]\n    E --&gt;|Non| G[Perte définitive des données]\n\n\n\n\n\n\n\n\nCibles Privilégiées\n\nExtensions critiques (extrait) :\n\nDocuments : .docx, .xlsx, .pdf, .pptx\nBases de données : .mdb, .sql, .sqlite\nMédias : .jpg, .png, .mp4, .avi\nDéveloppement : .java, .cpp, .py, .php\nFinancier : .qbw, .qbb, .wallet\n\nComportement :\n\nChiffrement sélectif (fichiers récents/modifiés)\nDouble extorsion : Chiffrement + menace de fuite\nRaaS (Ransomware-as-a-Service) : Modèle économique\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nMécanisme : - Clé privée stockée sur serveurs C2 - Paiement → clé via TOR - Cibles : 100+ extensions (docs, DB, médias)\nÉvolutions récentes : - Double extorsion (chiffrement + fuite) - RaaS (location de ransomware)\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nRansomware : Vue Intégrale\n(Source : 2017 State of Cybersecurity, F-Secure Inc.)\n\n\nRansomware : Vue Intégrale\n\nPrévision, Remédiation et Réaction\n\nPatching\nDétection active et passive (Firewalls, WAFs, IDS, IPS, e-mail malware scan, etc.)\nBackups offline !\nPolitique de Sécurité - Règles de bon usage de la messagerie\nFormation !\nPayer ou pas payer…\n\n\n\nDissection Technique de l’Attaque\n\nInfection et propagation\nExécution\nPaiement (Crypto-currencies / Bitcoin)\nOccultation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nSchéma Générique d’un Ransomware Cryptolocker\n\nLes clés privées de déchiffrement sont stockées dans les serveurs de l’attaquant\nElles sont envoyées à la victime après paiement en bitcoins\nLa trace est broyée à l’aide des réseaux TOR\n\n\n\n\nRansomware Cryptolocker : Cibles\nExtensions de fichiers ciblées : .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource : Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-vue-intégrale",
    "href": "exam_notes_fr.html#ransomware-vue-intégrale",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware : Vue Intégrale",
    "text": "Ransomware : Vue Intégrale\n(Source : 2017 State of Cybersecurity, F-Secure Inc.)"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-vue-intégrale-1",
    "href": "exam_notes_fr.html#ransomware-vue-intégrale-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware : Vue Intégrale",
    "text": "Ransomware : Vue Intégrale\n\nPrévision, Remédiation et Réaction\n\nPatching\nDétection active et passive (Firewalls, WAFs, IDS, IPS, e-mail malware scan, etc.)\nBackups offline !\nPolitique de Sécurité - Règles de bon usage de la messagerie\nFormation !\nPayer ou pas payer…\n\n\n\nDissection Technique de l’Attaque\n\nInfection et propagation\nExécution\nPaiement (Crypto-currencies / Bitcoin)\nOccultation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nSchéma Générique d’un Ransomware Cryptolocker\n\nLes clés privées de déchiffrement sont stockées dans les serveurs de l’attaquant\nElles sont envoyées à la victime après paiement en bitcoins\nLa trace est broyée à l’aide des réseaux TOR"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-cryptolocker-cibles",
    "href": "exam_notes_fr.html#ransomware-cryptolocker-cibles",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware Cryptolocker : Cibles",
    "text": "Ransomware Cryptolocker : Cibles\nExtensions de fichiers ciblées : .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource : Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_fr.html#principe-de-kerckhoffs",
    "href": "exam_notes_fr.html#principe-de-kerckhoffs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Principe de Kerckhoffs",
    "text": "Principe de Kerckhoffs\n\nPrincipe fondamental : la sécurité repose uniquement sur la clé, pas sur le secret de l’algorithme.\nLe système doit rester sûr même si l’algorithme est public.\nLa clé doit être facilement modifiable et le système simple à utiliser.\nRejet explicite de la sécurité par l’obscurité.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nSécurité basée sur la clé\nAlgorithme public\nPas de sécurité par l’obscurité\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nPrincipe de Kerckhoffs\nAuguste Kerckhoffs publie en 1883 deux articles définissant six principes pour les chiffrements militaires :\n\nLe système doit être pratiquement, voire mathématiquement indéchiffrable.\nIl ne doit pas nécessiter de confidentialité et rester sûr même s’il tombe aux mains de l’ennemi.\nLa clé doit pouvoir être mémorisée, transmise et modifiée facilement, sans notes écrites.\nLe système doit être compatible avec les communications télégraphiques.\nIl doit être portable et utilisable par une seule personne.\nIl doit être simple à utiliser, sans procédures complexes ni contraintes excessives.\n\nKerckhoffs affirme dès le XIXe siècle que la sécurité doit être mathématiquement démontrable et qu’il n’existe pas de sécurité par l’obscurité."
  },
  {
    "objectID": "exam_notes_fr.html#principe-de-kerckhoffs-1",
    "href": "exam_notes_fr.html#principe-de-kerckhoffs-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Principe de Kerckhoffs",
    "text": "Principe de Kerckhoffs\nAuguste Kerckhoffs publie en 1883 deux articles définissant six principes pour les chiffrements militaires :\n\nLe système doit être pratiquement, voire mathématiquement indéchiffrable.\nIl ne doit pas nécessiter de confidentialité et rester sûr même s’il tombe aux mains de l’ennemi.\nLa clé doit pouvoir être mémorisée, transmise et modifiée facilement, sans notes écrites.\nLe système doit être compatible avec les communications télégraphiques.\nIl doit être portable et utilisable par une seule personne.\nIl doit être simple à utiliser, sans procédures complexes ni contraintes excessives.\n\nKerckhoffs affirme dès le XIXe siècle que la sécurité doit être mathématiquement démontrable et qu’il n’existe pas de sécurité par l’obscurité."
  },
  {
    "objectID": "exam_notes_fr.html#classification-des-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#classification-des-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Classification des systèmes de cryptage",
    "text": "Classification des systèmes de cryptage\n\nSécurité inconditionnelle\n(unconditional security / perfect secrecy)\n\nSécurité indépendante de la puissance de calcul.\nCiphertext n’apporte aucune info sur le plaintext.\nConditions : clé ≥ message, jamais réutilisée.\nUsage surtout théorique.\nExemple : one-time pad.\n\n\n\nAs hard as / équivalent / provable security\n\nCryptanalyse aussi difficile qu’un problème mathématique difficile.\nRSA et Rabin prouvés équivalent à la factorisation.\n\nDémontrée par réduction (reduction proof).\n\nConcept central mais controversé.\n\n\n\nSécurité calculatoire\n(computational security / practical security)\n\nSécurité basée sur le coût irréaliste des attaques.\nCatégorie la plus utilisée en pratique.\nExemples : AES, DES, IDEA, RC4.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nInconditionnelle : parfaite, théorique (one-time pad).\nProvable security : équivalence à problème mathématique difficile.\nCalculatoire : sûre en pratique.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nSécurité inconditionnelle (unconditional security aussi appelée perfect secrecy) :\n\nLa sécurité du système de cryptage n’est pas compromise par la puissance de calcul destinée à la cryptanalyse.\nCette catégorie s’appuie sur la théorie de l’information publiée par Shannon en 1949.\nPlus précisément, un système de cryptage est inconditionnellement sûr si la probabilité de rencontrer un plaintext x après l’observation du ciphertext correspondant y est identique à la probabilité à priori de rencontrer le plaintext x.\nEn d’autres termes, le fait de disposer de couples plaintext/ciphertext (x,y) ne constitue aucune aide pour la cryptanalyse.\nUne condition nécessaire pour qu’un système soit inconditionnellement sûr est que la clé soit au moins de la même taille que le message et, surtout, qu’elle ne soit pas réutilisée pour encrypter des messages différents.\nCette condition rend ces systèmes peu adaptés aux besoins cryptographiques habituels et réduit leur domaine d’intérêt à un cadre théorique.\nL’exemple classique est le one-time pad inventé en 1917 par J. Mauborgne and G. Vernam.\nFondements théoriques des systèmes inconditionnellement sûrs + d’autres exemples dans [Sti06].\n\nAs hard as / équivalent / provable security\n\nLorsqu’on peut prouver que la cryptanalyse de l’algorithme est aussi difficile que de résoudre un problème mathématique réputé difficile.\nPar exemple la factorisation de grands nombres, le calcul de racines carrées modulo un “composite”, le calcul de logarithmes discrets dans un groupe fini, etc.\nL’algorithme de Rabin et RSA (cas générique^1 ) sont “prouvés” équivalents à la factorisation.\nUne telle preuve s’appelle de “réduction” (reduction proof).\nLa notion de provable security est à l’origine d’une importante controverse dans le monde cryptographique.\n\nSécurité calculatoire (computational security aussi appelé practical security)\n\nUn système de cryptage est dans cette catégorie si l’effort calculatoire nécessaire à le “casser” en utilisant les meilleures techniques possibles est au delà (avec une marge raisonnable) des ressources de calcul d’un adversaire hypothétique.\nLa grande majorité de systèmes de cryptage symétriques (AES, DES, IDEA, RC4, etc.) sont dans cette catégorie."
  },
  {
    "objectID": "exam_notes_fr.html#entropie",
    "href": "exam_notes_fr.html#entropie",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Entropie",
    "text": "Entropie\n\nL’entropie (Shannon, 1948) mesure la quantité d’information effective contenue dans un message.\nL’entropie conditionnelle mesure l’incertitude qui reste sur le plaintext après observation du ciphertext.\n\n\nPropriétés\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0\\) → aucune incertitude\n\\(H(X) = \\log n\\) → tous les résultats équiprobables\n\n\n\nInterprétation\n\nApproxime le nombre de bits nécessaires pour encoder \\(X\\).\nLa redondance = différence entre codage effectif et entropie.\n\n\n\nEntropie conditionnelle\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\)\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\nMesure l’incertitude restante sur le plaintext après observation du ciphertext.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nEntropie : quantité d’information d’un message.\nEntropie conditionnelle : incertitude sur le plaintext après le ciphertext.\nRedondance : différence entre codage effectif et entropie.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nUne définition essentielle en cryptographie est la quantité d’information effective contenue dans un message.\nPar exemple, les jours de la semaine (lundi, …, dimanche) peuvent intuitivement être encodés comme des chaînes de caractères de longueur (\\(\\le \\text{len}(\\text{``mercredi''})\\)), soit \\((8 \\times 8 = 64)\\) bits. Cependant, la quantité d’information effective de la variable jour de la semaine peut être encodée de manière optimale sur 3 bits (car \\((2^3 = 8)\\) est suffisant pour représenter les 7 variations possibles).\nL’entropie (Shannon, 1948) est la formalisation mathématique de cette définition.\n\n\nDéfinition formelle\nSoit \\(X\\) une variable aléatoire avec un ensemble fini de valeurs possibles \\({x_1, x_2, \\dots, x_n}\\), telles que \\(P(X=x_i) = p_i\\), avec \\(0 \\le p_i \\le 1\\) et \\(\\sum p_i = 1\\). L’entropie de \\(X\\), notée \\(H(X)\\), est définie par\n\\(H(X) = - \\sum_{i=1}^{n} p_i \\log p_i = \\sum_{i=1}^{n} p_i \\log \\left(\\frac{1}{p_i}\\right)\\)\nPar convention : \\(p_i \\log p_i = 0\\) si \\(p_i = 0\\). Tous les logarithmes sont en base 2.\n\n\nInterprétation\n\nApproximation du nombre de bits nécessaires pour encoder les éléments de \\(X\\).\nLa redondance est la différence entre le codage effectif et l’entropie.\n\n\n\nPropriétés\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0 \\iff \\exists i : p_i = 1, p_j = 0 \\ \\forall j \\ne i\\)\n\\(H(X) = \\log n \\iff p_i = 1/n \\ \\forall i\\)\n\n\n\nEntropie conditionnelle\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\),\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\n\nMesure l’incertitude sur \\(X\\) (plaintext) après avoir observé \\(Y\\) (ciphertext)."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#attaques-sur-les-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les systèmes de cryptage",
    "text": "Attaques sur les systèmes de cryptage\n\nCiphertext-only : Adversaire a seulement le ciphertext.\nKnown-plaintext : Adversaire a des couples plaintext/ciphertext.\nChosen-plaintext : Adversaire peut choisir le plaintext et voir le ciphertext (et essaye de trouver le plaintext pour d’autres messages).\nAdaptive chosen-plaintext : dépend des ciphertexts reçus.\nChosen-ciphertext : Adversaire choisit le ciphertext et obtient le plaintext (vise à trouver la clé).\nAdaptive Chosen-ciphertext : Chosen-ciphertext dépend des plaintexts reçus"
  },
  {
    "objectID": "exam_notes_fr.html#oracles-et-modèles-de-sécurité",
    "href": "exam_notes_fr.html#oracles-et-modèles-de-sécurité",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Oracles et Modèles de Sécurité",
    "text": "Oracles et Modèles de Sécurité\n\nOracles Aléatoires et Modèles de Sécurité\n\nOracle Aléatoire (Random Oracle) : Une fonction théorique “parfaite” qui renvoie une valeur uniforme et aléatoire pour chaque nouvelle entrée, mais reste déterministe pour une entrée déjà vue.\nROM (Random Oracle Model - Modèle de l’Oracle Aléatoire) : Cadre de preuve mathématique utilisant cet oracle idéal comme substitut aux fonctions de hachage.\nModèle Standard : Cadre où la sécurité repose uniquement sur la puissance de calcul de l’adversaire face à des algorithmes réels.\nLimite : Une preuve de sécurité en ROM ne garantit pas la sécurité absolue dans le monde réel (avec SHA-256, etc.).\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nUn oracle aléatoire est une entité abstraite accessible aux parties légitimes et aux adversaires.\n\nComportement : Il répond aux requêtes d’entrée \\(x\\) par des réponses parfaitement aléatoires \\(Orc(x)\\).\nDéterminisme : La seule exception réside dans les entrées précédemment traitées (\\(x_1, x_2, \\dots, x_n\\)). Si \\(x_1' = x_1\\), alors \\(Orc(x_1') = Orc(x_1)\\).\nModélisation : On le modélise par une fonction \\(Orc : X \\to Y\\) où \\(\\forall x \\in X, \\Pr(Orc(x) = y) = \\frac{1}{|Y|}\\).\nUtilité : Il se comporte comme une fonction de hachage cryptographique « idéale », outil précieux pour prouver la sécurité dans le Modèle d’Oracle Aléatoire.\nComparaison : Le modèle standard limite les adversaires par des facteurs computationnels. Un protocole sûr dans le modèle d’oracle aléatoire peut devenir vulnérable s’il est utilisé avec une fonction de hachage « réelle » (SHA-1, SHA-256).\n\n\n\n\n\n\n\nOracles de Chiffrement, Déchiffrement et Signature\n\nFonction : Entités qui exécutent des opérations (chiffrer/signer) pour l’adversaire en utilisant des clés secrètes sans jamais les révéler.\nCryptographie symétrique : L’oracle fournit \\(E_k(x)\\) ou \\(D_k(y)\\).\nCryptographie asymétrique : L’oracle est crucial pour les opérations privées (déchiffrement/signature), car les opérations publiques sont déjà libres d’accès.\n\n\n\n\n\n\n\nNoneVersion originale : Oracles Opérationnels\n\n\n\n\n\nUn oracle de chiffrement/déchiffrement/signature est une entité abstraite offrant un service « à la demande ».\n\nAccès aux clés : Il utilise les mêmes clés que les propriétaires légitimes (systèmes symétriques et asymétriques) sans les divulguer.\nPrimitives symétriques : Pour une primitive \\(E\\) et une clé \\(k\\), il renvoie \\(y = E_k(x)\\) ou le clair \\(x\\) correspondant.\nSystèmes à clé publique : L’oracle n’est nécessaire que pour les opérations à clé privée (\\(priv_k\\)).\n\nDéchiffrement : renvoie \\(x\\) tel que \\(E'_{pubk}(x) = y\\).\nSignature : Pour un système \\(S\\), il renvoie \\(y = S_{privk}(x)\\).\n\nAttaques : Les modèles d’attaques par texte clair choisi (CPA) et par texte chiffré choisi (CCA) reposent sur la mise à disposition de ces oracles pour l’adversaire.\n\n\n\n\n\n\n\nIndiscernabilité et Sécurité Sémantique (IND-CPA)\n\nPropriété : Un adversaire ne doit pas pouvoir distinguer les chiffrés de deux messages clairs différents.\nIND-CPA (Indistinguishability under Chosen Plaintext Attack - Indiscernabilité sous attaque à texte clair choisi) : Si l’adversaire ne devine le bon message qu’avec une probabilité de \\(1/2 + \\epsilon\\), le système est considéré comme sûr.\nSécurité Sémantique : Équivalente à l’IND-CPA, elle assure qu’aucune information utile ne fuite du chiffré.\n\n\n\n\n\n\n\nNoneVersion originale : Sécurité Sémantique\n\n\n\n\n\nL’indiscernabilité des textes chiffrés garantit l’incapacité de distinguer les chiffrés de messages clairs donnés.\n\nExpérience (Jeu de sécurité IND-CPA) :\n\nL’adversaire choisit deux messages \\(M_0\\) et \\(M_1\\).\nL’oracle choisit un indice aléatoire \\(i \\in \\{0,1\\}\\) et renvoie \\(c_i = E_k(M_i)\\).\nL’adversaire peut effectuer d’autres calculs ou appels oracles.\n\nDéfinition IND-CPA : Le système est sûr si l’avantage de l’adversaire est négligeable (\\(Prob = 1/2 + \\epsilon\\) avec \\(\\epsilon\\) petit).\nNote : En clé publique, l’oracle de chiffrement est inutile car l’adversaire possède déjà la clé publique. L’IND-CPA offre la sécurité sémantique.\n\n\n\n\n\n\n\nLe Chiffrement Probabiliste et l’OAEP\n\nProblème : Le chiffrement déterministe permet les attaques par dictionnaire (comparaison de chiffrés connus).\nSolution : Ajouter de l’aléa au message avant chiffrement pour que \\(E(M)\\) soit différent à chaque exécution.\nOAEP (Optimal Asymmetric Encryption Padding - Remplissage asymétrique optimal) : Standard utilisé avec RSA. Il combine le message \\(P\\) avec un nombre aléatoire \\(R\\) via des fonctions de hachage \\(h\\) et des XOR (\\(\\oplus\\)).\n\n\n\n\n\n\n\nNoneVersion originale : Déterminisme vs Probabilisme\n\n\n\n\n\nLe comportement déterministe (mêmes entrées = mêmes sorties) crée des failles.\n\nExemple : Si Alice envoie “Oui” ou “Non”, l’adversaire peut calculer \\(C_{yes} = E_{pub}(``Oui\")\\) et comparer. Il peut créer un livre de codes (dictionnaire) pour identifier les messages sans casser la clé.\nChiffrement probabiliste : Ajoute un caractère aléatoire. L’objectif est la sécurité sémantique pour la clé publique.\nOAEP : Utilisé dans RSA-PKCS1. Le texte \\(P\\) est combiné avec un aléa \\(R\\) :\n\n\\(M_1 := P \\oplus h(R)\\)\n\\(M_2 := R \\oplus h(M_1)\\)\nLe chiffrement porte sur \\(M_1\\) et \\(M_2\\). Au déchiffrement, on retrouve \\(R = M_2 \\oplus h(M_1)\\), puis \\(P = h(R) \\oplus M_1\\).\n\n\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nOracle Aléatoire : Fonction de hachage “idéale” (modèle théorique).\nOracles CPA/CCA : Simulent un accès à la clé secrète pour tester la résistance.\nIND-CPA : Impossibilité de distinguer deux chiffrés (Sécurité Sémantique).\nChiffrement Probabiliste : Indispensable pour contrer les livres de codes (attaques par dictionnaire).\nOAEP : Méthode de padding (remplissage) ajoutant l’aléa nécessaire au RSA."
  },
  {
    "objectID": "exam_notes_fr.html#histoire-de-la-cryptographie-et-sécurité-inconditionnelle",
    "href": "exam_notes_fr.html#histoire-de-la-cryptographie-et-sécurité-inconditionnelle",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Histoire de la Cryptographie et Sécurité Inconditionnelle",
    "text": "Histoire de la Cryptographie et Sécurité Inconditionnelle\n\nSystèmes de Cryptage Historiques\nLa cryptographie a longtemps été limitée à la seule recherche de la confidentialité. Les systèmes historiques reposent sur deux principes fondamentaux : la substitution et la transposition.\n\nChiffre de César (substitution mono-alphabétique) : Décalage fixe des lettres. Très vulnérable à l’analyse de fréquences.\nChiffre de Vigenère (substitution polyalphabétique) : Utilisation d’une clé pour varier le décalage. Plus complexe, mais cassable en identifiant la longueur de la clé.\nChiffre de Transposition : Réorganisation des caractères du texte original selon une permutation définie par une clé.\n\n\n\n\n\n\n\nNoneVersion originale : Cryptographie Historique\n\n\n\n\n\nPendant des siècles la confidentialité a été la seule application de la cryptographie…\n\nI av. JC, Caesar Cipher : Cryptage à substitution mono-alphabétique \\(e_k(x) = (x + k) \\pmod{26}\\), \\(d_k(y) = (y - k) \\pmod{26}\\) où \\(x, y, k \\in \\mathbb{Z}_{26}\\).\n\nExemple: \\(E_1(\\text{'bonjour'}) = \\text{'cpokpws'}\\).\nCryptanalyse : facile, basée sur la fréquence des caractères.\n\nXVI siècle, Vigenère : Cryptage à substitution polyalphabétique \\(e_k(x_1, \\dots, x_n) = (x_1 + k_1, \\dots, x_m + k_m, x_{m+1} + k_1, \\dots) \\pmod{26}\\).\n\nCryptanalyse : trouver la taille \\(m\\) de la clé en identifiant les portions de ciphertext répétées et analyser les blocs séparés comme dans le Caesar Cipher.\n\nTransposition Ciphers (Porta, 1563) : La clé définit une permutation sur le plaintext.\nCes techniques sont toujours à la base des systèmes de cryptage actuels (ex: Enigma, qualifiée par W. Churchill d’arme secrète ayant gagné la guerre).\n\n\n\n\n\n\nLe One-Time Pad (Masque Jetable)\nLe One-Time Pad (OTP), ou chiffre de Vernam, est le seul système prouvé inconditionnellement sûr (sécurité parfaite).\n\nPrincipe : Le message est combiné à une clé de même longueur via l’opération XOR (\\(\\oplus\\)).\nSécurité Inconditionnelle : L’observation du message chiffré n’apporte aucune information sur le message clair. Même un adversaire avec une puissance de calcul infinie ne peut pas le briser.\nContraintes de Shannon : La clé doit être aussi longue que le message, purement aléatoire, et utilisée une seule fois.\nRéutilisation de la clé : Si une clé est réutilisée pour deux messages, un attaquant peut éliminer la clé par XOR (\\(y_a \\oplus y_b = x_a \\oplus x_b\\)) et retrouver les messages clairs.\n\n\n\n\n\n\n\nNoneVersion originale : Le One-Time Pad\n\n\n\n\n\nSoit \\(n \\ge 1\\) et les espaces \\(P, C, K\\) tels que \\(P, C, K = (\\mathbb{Z}_2)^n\\). Les opérations d’encryption et decryption d’un one-time pad (Vernam Cipher) sont : \\(E_k(x_i) = x_i \\oplus k_i\\) et \\(D_k(y_i) = y_i \\oplus k_i\\) pour \\(1 \\le i \\le n\\).\n\nSécurité inconditionnelle : Si \\(k_i\\) sont aléatoires et indépendants, l’observation des ciphertexts n’aide pas la cryptanalyse. L’entropie de \\(X\\) ne diminue pas : \\(H(X|C) = H(X)\\).\nThéorème de Shannon : Condition nécessaire : \\(H(K) \\ge H(X)\\). La longueur de la clé aléatoire doit être au moins aussi grande que celle du plaintext.\nRéutilisation de clé : \\(y_a \\oplus y_b = x_a \\oplus x_b\\). Avec des messages de faible entropie, on retrouve les clairs et la clé (\\(k = y_a \\oplus x_a\\)).\nVulnérable à l’attaque Known Plaintext (si la clé est réutilisée).\nProblème majeur : La distribution et gestion des clés de grande taille. Relancé par la cryptographie quantique proposant des canaux confidentiels de distribution de clés de longueur illimitées.\n\n\n\n\n\n\nStéganographie\nÀ l’inverse de la cryptographie qui rend le message illisible, la stéganographie dissimule l’existence même du message.\n\nMéthode : Utiliser un “canal subliminal” (un support innocent comme une image ou un texte banal).\nTechnique moderne : Insertion de données dans les bits les moins significatifs (LSB - Least Significant Bits) de fichiers multimédias, permettant de cacher de gros volumes de données sans altération visible.\n\n\n\n\n\n\n\nNoneVersion originale : Stéganographie\n\n\n\n\n\nLa stéganographie cache un message à l’intérieur d’un autre. Éléments constituants :\n\nUn canal physique ou logique différent (canal subliminal).\nUn mécanisme secret pour identifier ce canal.\n\n\nExemples classiques : Premières lettres des mots d’un texte, encre invisible.\nExemple moderne : Utiliser les least significant bits (bits les moins significatifs) des frames d’un CD Photo.\nPour une image 2048x3072 (RGB 24 bits), cacher un message sur 1 bit permet de stocker 2.3 Mb sans détériorer la qualité.\n\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nHistorique : Substitution (César/Vigenère) et Transposition (permutation).\nOne-Time Pad : Sécurité absolue si la clé est aléatoire, unique et aussi longue que le message (\\(H(K) \\ge H(X)\\)).\nStéganographie : Cacher l’existence du message (ex: technique des LSB dans les images)."
  },
  {
    "objectID": "exam_notes_fr.html#stream-ciphers-cryptage-en-chaîne",
    "href": "exam_notes_fr.html#stream-ciphers-cryptage-en-chaîne",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Stream Ciphers (Cryptage en chaîne)",
    "text": "Stream Ciphers (Cryptage en chaîne)\n\nIntroduction aux Stream Ciphers\n\nDéfinition et Principe\nLes stream ciphers (chiffrements en flux) sont une famille de systèmes de cryptage caractérisés par :\n\nTaille de bloc unitaire : chaque bloc encrypté = 1 bit\nArchitecture en deux phases :\n\nGénération du keystream : production de la séquence de clés\nSubstitution : opération sur les bits du plaintext en fonction du keystream\n\n\nExemple classique : le one-time pad\n\nGénération : générateur (pseudo-)aléatoire\nSubstitution : opération XOR (\\(\\oplus\\)) avec le keystream\n\n\n\nCaractéristiques Générales\nAvantages :\n\nRapidité : cryptage au niveau des registres, idéal pour le streaming en temps réel (vidéo)\nLégèreté : fonctionnent sur systèmes à ressources CPU limitées\nFaible mémoire : pas ou peu de buffering nécessaire\nErreurs non propagées : retransmission des paquets défectueux suffisante (adapté aux transmissions sans fil - WiFi)\n\nInconvénients :\n\nDépendance à la qualité du keystream : le caractère aléatoire (randomness) détermine la robustesse\nRéutilisation dangereuse : la réutilisation du keystream permet une cryptanalyse facile\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nCryptage en chaîne (Stream Ciphers)\n\nLes stream ciphers constituent une famille de systèmes de cryptage où la taille du bloc encrypté est égale à 1 bit.\nLes stream ciphers sont généralement composés de deux phases:\n\nUne phase de génération de la séquence d’éléments formant la clé (le keystream).\nUne phase de substitution où les bits du plaintext subissent une opération spécifique dépendante du keystream.\n\nUn exemple évident d’un stream cipher est le one-time pad avec:\n\nUne phase de génération du keystream effectuée par un générateur (pséudo-) aléatoire.\nUne phase de substitution qui consiste à effectuer un xor (\\(\\oplus\\)) avec le keystream.\n\n\n\n\nStream Ciphers: Caractéristiques\n\nRapidité: Le cryptage se fait directement au niveau des registres. Idéal pour des applications nécessitant un cryptage “on the fly” comme le video streaming.\nFacilité: Les opérations peuvent être effectuées par des systèmes ayant des ressources CPU limitées.\nPas (ou peu…) besoin de mémoire/buffering.\nPropagation des erreurs limitée ou absente: la retransmission des paquets fautifs suffit normalement (adapté aux applications où les pertes de paquets sont fréquentes comme les transmissions sans fil (WiFi)).\nInconvénients:\n\nLa qualité en termes de randomness du keystream généré détermine la robustesse du système.\nLa réutilisation du keystream permet une cryptanalyse facile (cf. le one-time pad).\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nStream Ciphers = cryptage bit par bit en 2 phases (génération keystream + substitution).\nAvantages : rapides, légers, pas de propagation d’erreurs.\nInconvénients : qualité du keystream critique, réutilisation = vulnérabilité.\n\n\n\n\n\n\n\nStream Ciphers Synchrones\n\nPrincipe de Fonctionnement\nDans un stream cipher synchrone, le keystream dépend uniquement de la clé, indépendamment du plaintext et du ciphertext.\nÉquations du processus :\n\\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nOù :\n\n\\(\\sigma_i\\) : état à l’instant \\(i\\) (état initial \\(\\sigma_0\\) peut dépendre de \\(k\\))\n\\(k\\) : clé secrète\n\\(f\\) : fonction de transition d’état\n\\(g\\) : fonction de production du keystream \\(z_i\\)\n\\(h\\) : fonction de sortie produisant le ciphertext \\(c_i\\) à partir du plaintext \\(m_i\\)\n\n\n\n\n\n\ngraph LR\n    A[Clé k] --&gt; B[État σi]\n    B --&gt; C[Fonction f]\n    C --&gt; D[État σi+1]\n    B --&gt; E[Fonction g]\n    E --&gt; F[Keystream zi]\n    F --&gt; G[Fonction h]\n    H[Plaintext mi] --&gt; G\n    G --&gt; I[Ciphertext ci]\n    D -.-&gt;|boucle| B\n\n\n\n\n\n\n\n\nCaractéristiques\nExigence de synchronisation :\n\nÉmetteur et récepteur doivent partager la même clé \\(k\\) ET le même état \\(\\sigma_i\\)\nPerte de synchronisation = nécessité de mécanismes externes (marqueurs, analyse de redondance)\n\nPropriétés :\n\nPas de propagation d’erreur : modification du ciphertext n’affecte pas les séquences ultérieures\nAttention : suppression d’un ciphertext = désynchronisation du récepteur\n\nVulnérabilités aux attaques actives :\n\n✓ Détection : insertion, élimination, replay de fragments\n✗ Modification de bits : adversaire peut modifier des bits et analyser l’impact sur le plaintext\nSolution : mécanismes d’authentification supplémentaires nécessaires\n\n\n\nCas particulier : Stream Cipher Additif\nLe cas le plus fréquent où :\n\nFonctions \\(f\\) et \\(g\\) remplacées par un générateur aléatoire\nFonction \\(h\\) = addition modulo 2 (XOR : \\(\\oplus\\))\n\nFormule : \\(c_i = z_i \\oplus m_i\\)\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers Synchrones\n\nLe keystream généré dépend seulement de la clé et non pas du plaintext ni du ciphertext.\nLe processus d’encryption d’un stream cipher synchrone est décrit par les équations suivantes: \\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] avec \\(\\sigma_i\\) l’état initial qui peut dépendre de la clé \\(k\\), \\(f\\) la fonction qui détermine l’état suivant, \\(g\\) la fonction qui produit le keystream \\(z_i\\) et \\(h\\) la fonction de sortie qui produit le ciphertext \\(c_i\\) à partir du plaintext \\(m_i\\).\n\n\n\nStream Ciphers Synchrones: Caractéristiques\n\nNécessitent la synchronisation de l’émetteur et du récepteur: En plus d’utiliser la même clé \\(k\\), les deux doivent se trouver dans le même état pour que le processus fonctionne. Si la synchronisation est perdue il faut des mécanismes externes pour la récupérer (marqueurs spéciaux, analyses de redondance du plaintext, etc.)\nPas de propagation d’erreur. La modification du ciphertext pendant la transmission n’entraîne pas des perturbations dans des séquences de ciphertext ultérieures (cependant, la suppression d’un ciphertext provoquerait la désynchronisation du récepteur).\nAttaques actives: L’insertion, l’élimination ou le replay de parties de ciphertext sont détectés par le récepteur. Cependant, un adversaire pourrait modifier certains bits du ciphertext et analyser l’impact sur le plaintext correspondant. Des mécanismes d’authentification d’origine supplémentaires sont nécessaires afin de détecter ces attaques.\nCas les plus fréquent des Stream Cipher Synchrones: le stream cipher additif (cf. le one-time pad) où les fonctions \\(f\\) et \\(g\\) générant le keystream sont remplacées par un générateur aléatoire et la fonction \\(h\\) est une addition modulo 2 (xor).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nSynchrone : keystream = \\(f\\)(clé uniquement). Équations : \\(\\sigma_{i+1} = f(\\sigma_i, k)\\), \\(z_i = g(\\sigma_i, k)\\), \\(c_i = h(z_i, m_i)\\).\nExige synchronisation émetteur/récepteur. Pas de propagation d’erreur mais vulnérable aux modifications de bits.\nCas fréquent : cipher additif avec XOR.\n\n\n\n\n\n\n\nStream Ciphers Asynchrones\n\nPrincipe de Fonctionnement\nAussi appelés auto-synchronisés (self-synchronizing ciphers).\nLe keystream dépend de la clé ET d’un nombre fixe de ciphertexts précédents.\nÉquations du processus :\n\\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nOù \\(\\sigma_i\\) représente un buffer des \\(t\\) derniers ciphertexts.\n\n\n\n\n\ngraph LR\n    A[Clé k] --&gt; B[Fonction g]\n    C[Buffer: ci-t...ci-1] --&gt; B\n    B --&gt; D[Keystream zi]\n    D --&gt; E[Fonction h]\n    F[Plaintext mi] --&gt; E\n    E --&gt; G[Ciphertext ci]\n    G -.-&gt;|feedback| C\n\n\n\n\n\n\n\n\nCaractéristiques\nAuto-synchronisation :\n\nEn cas d’insertion/élimination de ciphertexts, le récepteur se re-synchronise automatiquement\nMécanisme : mémorisation (buffer) des derniers ciphertexts\n\nPropagation d’erreurs limitée :\n\nErreur se propage uniquement sur la taille du buffer (\\(t\\) bits)\nAprès épuisement du buffer, décryption correcte reprend\n\nSécurité face aux attaques actives :\n\nMeilleure détection : modifications détectées grâce à la propagation d’erreurs\nAttention : l’auto-synchronisation permet au récepteur de continuer même après insertions/suppressions\nSolution : vérification de l’intégrité et l’authenticité du flux entier nécessaire\n\nDiffusion des statistiques du plaintext :\n\nChaque bit du plaintext influence tous les ciphertexts subséquents\nRésultat : meilleure dispersion des statistiques vs. cas synchrone\nApplication : utiliser pour plaintexts à faible entropie ou fortement redondants\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers Asynchrones\n\nAussi appelés auto-synchronisés (self synchronizing ciphers).\nLe keystream généré dépend de la clé ainsi que d’un nombre fixé de ciphertexts précédents.\nLe processus d’encryption d’un stream cipher asynchrone est décrit par les équations suivantes: \\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] avec \\(\\sigma_i\\), \\(g\\) et \\(h\\) comme pour le cas synchrone.\n\n\n\nStream Ciphers Asynchrones: Caractéristiques\n\nAuto-synchronisation: En cas d’élimination ou d’insertion de ciphertexts en cours de route, le récepteur est capable de se re-synchroniser avec l’émetteur grâce à la mémorisation (buffer) d’un nombre de ciphertext précédents.\nPropagation d’erreurs limitée: La propagation d’erreurs s’étend uniquement au nombre de bits du ciphertext mémorisés (taille du buffer). Après, la decryption se déroule à nouveau correctement.\nAttaques actives: La modification de fragments du ciphertext sera plus facilement détecté que dans le cas synchrone à cause de la propagation d’erreurs. Cependant, comme le récepteur est capable de s’auto-synchroniser avec l’émetteur, même si des ciphertexts sont éliminés ou insérés en cours de route, il convient de vérifier l’intégrité et l’authenticité du flot entier.\nDiffusion des statistiques du plaintext: Le fait que chaque bit du plaintext aura une influence sur la totalité des ciphertexts subséquents se traduit par une plus grande dispersion des statistiques du plaintext comparée au cas synchrone…\n… Il convient, donc, d’utiliser des stream ciphers asynchrones lorsque l’entropie des plaintexts est limitée et pourrait permettre des attaques ciblées aux plaintexts fortement redondants.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nAsynchrone (auto-synchronisé) : keystream = \\(f\\)(clé + derniers ciphertexts). État \\(\\sigma_i\\) = buffer de \\(t\\) ciphertexts précédents.\nAuto-synchronisation automatique. Propagation d’erreur limitée au buffer.\nMeilleure diffusion des statistiques → idéal pour plaintexts redondants/faible entropie.\n\n\n\n\n\n\n\nGénérateurs de Keystreams : LSFR\n\nContexte et Nécessité\nProblématique : générer un keystream de longueur \\(m\\) à partir d’une clé secrète de longueur \\(l\\) avec \\(l \\ll m\\).\nSolution : Linear Feedback Shift Register (LSFR ou LFSR)\n\n\nCaractéristiques des LSFR\nAvantages :\n\nImplémentation hardware optimale : circuits très efficaces\nPériodes longues : séquences de grande longueur\nBonne qualité aléatoire : randomness notable\nBase mathématique : propriétés algébriques des combinaisons linéaires\n\nStructure générique : LSFR de longueur \\(L\\)\n\n\n\n\n\ngraph LR\n    A[bit L-1] --&gt; B[bit L-2]\n    B --&gt; C[...]\n    C --&gt; D[bit 1]\n    D --&gt; E[bit 0]\n    E --&gt; F[Output]\n    A -.-&gt;|feedback| G[⊕]\n    D -.-&gt;|coeff| G\n    C -.-&gt;|coeff| G\n    G --&gt; A\n\n\n\n\n\n\n\n\nRemarques Importantes sur les LSFR\nHistorique et Usage :\n\nConstruction très répandue en cryptographie et théorie des codes\nNombreux stream ciphers militaires basés sur LSFR\n\nLimites de Sécurité :\n\nNiveau de sécurité insuffisant comparé aux block ciphers modernes\nVulnérabilité : l’algorithme de Berlekamp-Massey permet de :\n\nDéterminer la complexité linéaire d’un LSFR\nCalculer un nombre arbitraire de séquences générées\n\n\nMétrique : Complexité linéaire (linear complexity)\nSolution d’Amélioration :\nRemplacer la combinaison linéaire par une fonction non linéaire \\(f\\)\n→ Non Linear Feedback Shift Registers (NLFSR)\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers: Générateurs de Keystreams\n\nLorsqu’il convient de générer un keystream d’une longueur \\(m\\) à partir d’une clé secrète de longueur \\(l\\) avec \\(l \\ll m\\), on fait appel à des générateurs de keystreams.\nLe plus courant de ces générateurs est le Linear Feedback Shift Register (LSFR).\nUn LSFR a les caractéristiques suivantes:\n\nS’adapte très bien aux implantations hardware.\nProduit des séquences de périodes longues et avec une qualité aléatoire notable (randomness assez forte)\nSe base sur les propriétés algébriques des combinaisons linéaires.\n\n\n\n\nLSFRs: Quelques Remarques\n\nLes LSFRs sont des constructions très répandues dans la cryptographie et dans la théorie de codes.\nUn grand nombre de stream ciphers basés sur les LSFRs (surtout dans la sphère militaire) ont été développés dans le passé.\nMalheureusement, le niveau de sécurité offert par ces systèmes est jugé insuffisant de nos jours (comparé à celui des blocks ciphers…)\nLa métrique permettant d’analyser un LFSR est sa complexité linéaire (linear complexity). L’algorithme de Berlekamp-Massey permet de déterminer la complexité linéaire d’un LSFR et de calculer ainsi un nombre arbitrairement grand de séquences générées par un LSFR.\nUne solution pour augmenter la complexité est de substituer la combinaison linéaire des bits du ciphertext par une fonction non linéaire \\(f\\). Ce sont les Non Linear Feedback Shift Registers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nLSFR : générateur de keystream long (\\(m\\)) depuis clé courte (\\(l\\)). Base = combinaisons linéaires.\nAvantages : hardware efficace, périodes longues.\nProblème : sécurité insuffisante, vulnérable à Berlekamp-Massey (calcul de complexité linéaire).\nSolution : NLFSR (fonction non linéaire).\n\n\n\n\n\n\n\nRC4 : Stream Cipher Logiciel\n\nPrésentation Générale\nRC4™ (Rivest Cipher 4) développé en 1987 par Ron Rivest pour RSA Security.\nCaractéristiques principales :\n\nClé variable : longueur flexible\nExtrêmement rapide : 10× plus rapide que DES\nMode synchrone : keystream indépendant du plaintext/ciphertext\n\nHistorique :\n\n1987-1994 : breveté, détails confidentiels (contrat NDA requis)\n1994 : publication non officielle dans un newsgroup\nDepuis : analyse intensive par la communauté cryptographique\n\n\n\nArchitecture\nComposants clés :\n\nS-box : boîte de substitution 8×8 (256 entrées)\n\nContenu : permutation des nombres 0 à 255\nDépend de la clé principale de longueur variable : \\(0 &lt; len(k) \\leq 255\\)\n\nCombinaisons : linéaires et non linéaires\nChiffrement final : XOR entre keystream et plaintext\n\n\n\nApplications et Sécurité\nUtilisations commerciales (nombreuses) :\n\nLotus Notes\nOracle SQL\nMicrosoft Windows\nSSL/TLS\nEt bien d’autres…\n\nAnalyses et Vulnérabilités :\n\nTravaux exhaustifs sur le key scheduling et le PRGA\nFaille majeure : implémentation dans WEP (WiFi Wired Equivalent Privacy)\n\nProtocole WEP complètement compromis\nProblème : mode d’utilisation défaillant, pas l’algorithme RC4 lui-même\n\n\n\n\nFonctionnement\nRC4 se décompose en deux étapes :\n\nKey Scheduling Algorithm (KSA)\n\nResponsable de la permutation initiale de la S-box\nFonction de la clé de longueur variable \\(len(k) = l\\)\n\nPseudo Random Generator Algorithm (PRGA)\n\nGénère le keystream de taille arbitraire\nS’appuie sur la S-box permutée par KSA\n\n\n\n\n\n\n\ngraph TB\n    A[Clé k de longueur variable] --&gt; B[KSA: Key Scheduling]\n    B --&gt; C[S-box permutée]\n    C --&gt; D[PRGA: Génération]\n    D --&gt; E[Keystream zi]\n    E --&gt; F[XOR]\n    G[Plaintext mi] --&gt; F\n    F --&gt; H[Ciphertext ci]\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nSoftware Cipher Streams: RC4\n\nLe grand désavantage des stream ciphers basés sur des registres est qu’ils sont très lents en version programmée dans une machine générique. RC4™ est un stream cipher à clé variable développé en 1987 par Ron Rivest pour la société RSA security. Il est très rapide (10 fois plus rapide que DES !)\nPendant 7 ans, cet algorithme était breveté et les détails son fonctionnement interne était dévoilés seulement après la signature d’un contrat de confidentialité. Depuis sa publication (non officielle) dans un newsgroup en 1994, il est globalement discuté et analysé dans toute la communauté cryptographique.\nL’algorithme travaille en mode synchrone (le keystream est indépendant du ciphertext et du plaintext).\nIl est composé de combinaisons linéaires et non linéaires. L’élément clé est une boîte de substitution (S-box) de taille 8×8 dont les entrées sont une permutation des chiffres 0 à 255. La permutation est une fonction de la clé principale de taille variable avec \\(0 &lt; len(k) \\leq 255\\). L’encryption finale est obtenue par un xor entre le keystream et le plaintext.\nRC4 est utilisé dans un grand nombre d’applications commerciales: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. Il est l’objet d’un grand nombre de travaux analytiques et exhaustifs qui ont réussi à compromettre la sécurité du key scheduling et du PRGA.\nEn particulier l’application de RC4 sur les Wired Equivalent Privacy (WiFi WEP) protocole a été “cassée” suite à une faille dans le mode d’utilisation du protocole.\n\n\n\nRC4: Fonctionnement\n\nL’algorithme est constitué de deux étapes:\n\nLe Key Scheduling Algorithm (KSA): Responsable de la permutation initiale qui remplira la S-box en fonction de la clé de longueur variable \\(len(k) = l\\).\nLe Pseudo Random Generator Algorithm (PRGA): Génère le keystream de taille arbitraire en s’appuyant sur la S-box.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nRC4 : stream cipher logiciel, clé variable, 10× plus rapide que DES.\nArchitecture : S-box 8×8 (permutation 0-255) + XOR.\n2 étapes : KSA (permutation S-box) + PRGA (génération keystream). Mode synchrone.\nVulnérabilité : WEP cassé (faille d’utilisation). Utilisé dans SSL, Windows, Oracle…"
  },
  {
    "objectID": "exam_notes_fr.html#block-ciphers-cryptage-par-blocs",
    "href": "exam_notes_fr.html#block-ciphers-cryptage-par-blocs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Block Ciphers (Cryptage par Blocs)",
    "text": "Block Ciphers (Cryptage par Blocs)\n\n1. Introduction aux Block Ciphers\n\nDéfinition et Principe\nUn block cipher (chiffrement par blocs) est une fonction cryptographique qui :\n\nTransforme des blocs de taille fixe : fait correspondre un bloc de \\(n\\) bits à un autre bloc de la même taille\nEst paramétrisée par une clé : la clé \\(K\\) de \\(k\\) bits définit la transformation\nDoit être bijective : pour permettre un décryptage unique\nChaque clé = bijection différente : garantit la variabilité\n\nTaille nominale : taille d’entrée du bloc sur lequel s’applique l’encryption\n\n\nCritères de Qualité\n1. Taille/Entropie de la clé\n\nClés idéalement équiprobables avec entropie = \\(k\\) bits\nForte entropie protège contre les attaques brute-force\nMinimum requis : 128 bits pour les block ciphers modernes\n\n2. Performances\n\nVitesse d’exécution\nEfficacité en software/hardware\n\n3. Taille du bloc\n\nBloc trop petit = vulnérabilité aux dictionnaires plaintext/ciphertext\nStandard moderne : blocs ≥ 128 bits\n\n4. Résistance cryptographique\n\nRésistance aux techniques connues :\n\nCryptanalyse linéaire\nCryptanalyse différentielle\nMeet in the middle\n\nEffort de cryptanalyse équivalent au brute force\n\n\n\n\n\n\ngraph LR\n    A[Plaintext n bits] --&gt; B[Block Cipher]\n    C[Clé K k bits] --&gt; B\n    B --&gt; D[Ciphertext n bits]\n    \n    style B fill:#e1f5ff\n    style C fill:#fff4e1\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\nCryptage par Blocs (Block Ciphers)\n\nLes block ciphers symétriques constituent la pierre angulaire de la cryptographie. Leur fonctionnalité principale est la confidentialité mais ils sont également à la base des services d’authentification, fonctions de hachage, génération aléatoire, etc.\nDéfinition: Un block cipher est une fonction qui fait correspondre à un bloc de \\(n\\) bits un autre bloc de la même taille. La fonction est paramètrée par une clé \\(K\\) de \\(k\\) bits. Afin de permettre une decryption unique, la fonction doit être bijective. Chaque clé définit une bijection différente. La taille d’entrée du bloc sur lequel s’applique l’encryption s’appelle aussi taille nominale de l’algorithme.\nCritères pour évaluer la qualité d’un block cipher:\n\nTaille/Entropie de la clé: Idéalement, les clés sont équiprobables et l’espace des clés a une entropie égale à \\(k\\). Une forte entropie de la clé protège des attaques brute-force à partir de chosen/known plaintexts. Les block ciphers modernes doivent avoir des clés d’au moins 128 bits.\nPerformances\nTaille du bloc: Un bloc trop petit permettrait des attaques où des “dictionnaires” plaintext/ciphertext seraient construits. De nos jours, des blocs de taille ≥ 128 bits deviennent courants.\nRésistance cryptographique: Le block cipher doit se montrer résistant à des techniques de cryptanalyse connues: cryptanalyse linéaire ou différentielle, meet in the middle, etc. L’effort inhérent à ces attaques (complexité, stockage, parallélisation, etc.) doit être équivalent à celui d’une attaque brute force.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nBlock cipher : fonction bijective transformant blocs de \\(n\\) bits avec clé \\(K\\) de \\(k\\) bits. Critères : entropie clé ≥ 128 bits, taille bloc ≥ 128 bits, résistance cryptanalyse = effort brute force. Usage : confidentialité, authentification, hachage, génération aléatoire.\n\n\n\n\n\n\n\n2. Modes d’Opération des Block Ciphers\n\n2.1 Electronic Codebook (ECB)\nPrincipe : chaque bloc de plaintext est encrypté indépendamment avec la même clé.\n\\[c_i = E_K(m_i)\\] \\[m_i = D_K(c_i)\\]\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        P1[Plaintext Block 1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext Block 1]\n        \n        P2[Plaintext Block 2] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext Block 2]\n    end\n    \n    style E1 fill:#ffcccc\n    style E2 fill:#ffcccc\n    style K1 fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\nCaractéristiques :\n\n✗ Plaintexts identiques → ciphertexts identiques (prévisible)\n✓ Pas de propagation d’erreurs : erreur sur \\(c_j\\) n’affecte que \\(m_j\\)\n✗ Patterns visibles : structure du plaintext transparente dans le ciphertext\n✓ Parallélisable : chaque bloc traité indépendamment\n\n⚠️ Vulnérabilité majeure : Ne doit PAS être utilisé pour des données redondantes\n\n\n\n2.2 Cipher Block Chaining (CBC)\nPrincipe : chaque bloc de plaintext est XORé avec le ciphertext précédent avant encryption.\n\\[c_i = E_K(m_i \\oplus c_{i-1})\\] \\[m_i = D_K(c_i) \\oplus c_{i-1}\\]\nAvec \\(c_0 = IV\\) (Initialization Vector)\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        IV[IV] --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext c1]\n        \n        C1 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ccffcc\n    style E2 fill:#ccffcc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Patterns effacés : chaînage masque la structure\n✓ Propagation d’erreurs limitée : erreur sur \\(c_j\\) affecte \\(m_j\\) et \\(m_{j+1}\\) uniquement\n✗ Non parallélisable en encryption (séquentiel)\n✓ Parallélisable en décryption\n\nIV (Initialization Vector) :\n\nDoit être aléatoire ou pseudo-aléatoire\nPeut être transmis en clair\nDoit être différent pour chaque message avec la même clé\n\n\n\n\n2.3 Cipher Feedback Mode (CFB)\nPrincipe : fonctionne comme un stream cipher où le keystream est généré par le block cipher. Le keystream dépend des ciphertexts précédents (mode asynchrone).\n\\[c_i = m_i \\oplus E_K(c_{i-1})\\] \\[m_i = c_i \\oplus E_K(c_{i-1})\\]\nAvec \\(c_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph CFB_Encryption\n        IV[IV / ci-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        C1 -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#ffccff\n    style X1 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Chaînage : dépendances entre ciphertexts\n⚠️ Propagation d’erreurs : erreur sur \\(c_j\\) affecte \\(\\frac{n}{r}\\) blocs suivants\n\n\\(n\\) = taille nominale du block cipher\n\\(r\\) = taille des plaintexts\n\n✗ Non parallélisable\n⚠️ IV non confidentiel mais doit être transmis\n\nUsage : adapté aux transmissions avec pertes de paquets fréquentes\n\n\n\n2.4 Output Feedback Mode (OFB)\nPrincipe : fonctionne comme un stream cipher synchrone. Le keystream est entièrement déterminé par la clé et l’IV, indépendant du plaintext et du ciphertext.\n\\[z_i = E_K(z_{i-1})\\] \\[c_i = m_i \\oplus z_i\\] \\[m_i = c_i \\oplus z_i\\]\nAvec \\(z_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph OFB_Mode\n        IV[IV / zi-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; Z[zi keystream]\n        Z --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        Z -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#cce5ff\n    style X1 fill:#ffffcc\n    style Z fill:#e1ffe1\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Pas de propagation d’erreurs : erreur sur \\(c_j\\) n’affecte que \\(m_j\\)\n✓ Keystream pré-calculable : efficace\n⚠️ CRITIQUE : ne JAMAIS réutiliser le même IV avec la même clé (sinon keystream identique)\n✓ Parallélisable si keystream pré-calculé\n\n⚠️ Attention réutilisation : Modifier l’IV pour chaque nouveau message !\n\n\n\n\n\n\nNote📄 Texte original (Modes CFB et OFB)\n\n\n\n\n\nModes CFB et OFB: Caractéristiques\nLes modes CFB et OFB fonctionnent comme un stream cipher avec un keystream généré par le bloc de cryptage. Dans CFB, le keystream dépend des ciphertexts précédents (asynchrone) alors que dans OFB, le keystream est entièrement déterminé par la clé et le IV (synchrone).\nParticularités de CFB:\n\nComme dans le mode CBC, des plaintext identiques sont traduits en ciphertexts différents si le IV change. Le IV n’est pas nécessairement confidentiel et peut être échangé en clair entre les parties.\nLe chaînage introduit également des dépendances entre les ciphertexts courants et les ciphertexts précédents. En particulier, si \\(n\\) est la taille nominale de l’algorithme et \\(r\\) est la taille des plaintexts, le ciphertext courant dépendra des \\(\\frac{n}{r}\\) ciphertexts précédents (chaque itération décalera l’entrée fautive de \\(r\\) positions, après \\(\\frac{n}{r}\\) itérations le ciphertext fautif sera “expulsé” complètement).\nLa propagation d’erreurs obéit au même principe: une erreur dans un ciphertext se traduira par une mauvaise decryption des \\(\\frac{n}{r}\\) ciphertexts suivants.\n\nParticularités de OFB:\n\nOFB a un comportement identique aux modes CBC et CFB pour l’encryption de plaintext identiques.\nPas de propagation d’erreurs sur les ciphertexts adjacents.\nModifiez le IV si la clé ne change pas pour éviter la réutilisation du keystream !!!\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Modes CFB/OFB)\n\n\n\n\n\nCFB (asynchrone) : keystream = \\(f\\)(ciphertexts précédents). Propagation erreur limitée (\\(\\frac{n}{r}\\) blocs).\nOFB (synchrone) : keystream = \\(f\\)(clé + IV uniquement). Pas propagation erreur.\nCRITIQUE : ne JAMAIS réutiliser même IV avec même clé. IV transmissible en clair.\n\n\n\n\n\n\n2.5 Counter Mode (CTR)\nPrincipe : le keystream est généré par l’encryption d’un compteur incrémenté à chaque bloc.\n\\[c_i = m_i \\oplus E_K(counter + i)\\] \\[m_i = c_i \\oplus E_K(counter + i)\\]\n\n\n\n\n\ngraph TB\n    subgraph CTR_Mode\n        CTR1[Counter + 0] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; C1[Ciphertext c1]\n        \n        CTR2[Counter + 1] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ffe6cc\n    style E2 fill:#ffe6cc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Mode synchrone : keystream = \\(f\\)(compteur)\n✓ Parallélisable : keystream pré-calculable pour encryption ET décryption\n✓ Accès aléatoire : chaque bloc décryptable indépendamment\n✓ Pas de propagation d’erreurs\n✓ Profite des architectures SIMD : pas de dépendances entre blocs\n⚠️ Compteur : doit être de taille \\(2^b\\) (\\(b\\) = taille du bloc)\n⚠️ CRITIQUE : ne JAMAIS réutiliser le même compteur avec la même clé\n\nGestion du compteur :\n\nIncrémenter modulo \\(2^b\\) après chaque itération\nSolution : toujours incrémenter pour chaque flux encrypté\nPremier bloc du flux \\(i+1\\) &gt; dernier bloc du flux \\(i\\)\n\nApplications :\n\nATM (Asynchronous Transfer Mode)\nIPsec (IP security)\nLignes à haut débit : transmission sélective des blocs\nTransferts de grands volumes : vidéo\n\n\n\n\n\n\n\nNote📄 Texte original (Counter Mode)\n\n\n\n\n\n\nCounter Mode (CTR Mode)\nFréquemment utilisé comme support d’encryption dans des protocoles de transfert de données comme ATM (Asynchronous Transfer Mode) et IPsec (IP security).\n\n\nCounter Mode (II)\n\nLe keystream est généré par l’encryption d’un compteur aléatoire de taille \\(2^b\\) (avec \\(b\\) la taille du bloc) et nécessaire pour la décryption. Ce compteur est incrémenté modulo \\(2^b\\) après chaque itération.\nTravaille en mode synchrone. La réutilisation d’un même compteur se traduit par un keystream identique !\nSolution: Toujours incrémenter le compteur pour chaque flot encrypté de telle sorte que le compteur du premier bloc d’un flot soit plus grand que le dernier bloc du flot précédent.\nFacilement parallélisable: Le keystream peut être pré-calculé aussi bien pour l’encryption que pour la décryption. Profite pleinement des architectures SIMD car contrairement aux autres modes de chaînage il n’y a pas des dépendances entre les opérations des différents blocs.\nAccès aléatoire à l’encryption/décryption de chaque bloc: Contrairement aux autres modes de chaînage où la \\(i\\)-ème opération dépend de la \\((i-1)\\)-ème opération.\nSi à ceci on ajoute l’absence de propagation d’erreurs, le mode compteur facilite la (re)transmission sélective des blocs de ciphertext, ce qui le rend très attractif pour la sécurisation de lignes à haut débit ainsi que pour les transferts encryptés de grands volumes d’information (p.ex. vidéo).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Counter Mode)\n\n\n\n\n\nCTR : keystream = \\(E_K\\)(compteur + \\(i\\)).\nAvantages : parallélisable (encryption + décryption), accès aléatoire, pas propagation erreur, SIMD-friendly.\nCRITIQUE : ne jamais réutiliser compteur.\nUsage : ATM, IPsec, haut débit, vidéo.\n\n\n\n\n\n\n\n3. Product Ciphers et Feistel Ciphers\n\nProduct Ciphers\nDéfinition : schéma de cryptage combinant une série de transformations successives pour renforcer la résistance à la cryptanalyse.\nTransformations courantes :\n\nTranspositions (permutations)\nSubstitutions (S-boxes)\nXORs\nCombinaisons linéaires\nMultiplications modulaires\n\n\n\nFeistel Ciphers\nDéfinition : product cipher itératif avec structure spécifique.\nPrincipe de fonctionnement :\n\nEntrée : plaintext de \\(2t\\) bits = \\((L_0, R_0)\\) (deux sous-blocs de \\(t\\) bits)\nSortie : ciphertext de \\(2t\\) bits = \\((R_r, L_r)\\) après \\(r\\) étapes (rounds)\nChaque étape : bijection inversible (pour décryption unique)\n\nÉquations d’une étape \\(i\\) (\\(1 \\leq i \\leq r\\)) :\n\\[(L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\]\nAvec :\n\n\\(L_i = R_{i-1}\\)\n\\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph Feistel_Round\n        L0[Li-1] --&gt; R1[Ri = Li-1 ⊕ f]\n        R0[Ri-1] --&gt; L1[Li = Ri-1]\n        R0 --&gt; F[Function f]\n        K[Key Ki] --&gt; F\n        F --&gt; XOR[⊕]\n        L0 --&gt; XOR\n        XOR --&gt; R1\n    end\n    \n    style F fill:#ffcccc\n    style XOR fill:#ffffcc\n    style K fill:#fff4e1\n\n\n\n\n\n\nCaractéristiques :\n\n\\(K_i\\) : sous-clés générées à partir de la clé principale \\(K\\)\nNombre d’étapes \\(r\\) : généralement pair et \\(\\geq 3\\)\n\nExemple : DES a 16 étapes\n\nPermutation finale : \\((L_r, R_r) \\rightarrow (R_r, L_r)\\)\nDécryption : identique à l’encryption mais sous-clés appliquées en ordre inverse (de \\(K_r\\) à \\(K_1\\))\n\nOpérations fréquentes :\n\nPermutations\nSubstitutions (S-boxes)\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\nProduct Ciphers et Feistel Ciphers\n\nUn product cipher est un schéma de cryptage combinant une série de transformations successives dans le but de renforcer la résistance à la cryptanalyse. Des transformations courantes pour un product cipher sont: des transpositions, des substitutions, des XORs, des combinaisons linéaires, des multiplications modulaires, etc.\nUn Feistel cipher est un product cipher itératif capable de transformer un plaintext de \\(2t\\) bits de la forme \\((L_0, R_0)\\) composé par deux sous-blocs \\(L_0\\) et \\(R_0\\) de \\(t\\) bits en un ciphertext de taille \\(2t\\) de la forme \\((R_r, L_r)\\) après \\(r\\) étapes (rounds) successives avec \\(r \\geq 1\\). Chaque étape définit une bijection (inversible !) pour permettre une decryption unique.\nDes permutations et des substitutions sont les opérations les plus fréquentes.\nLes étapes \\(1 \\leq i \\leq r\\) s’écrivent: \\((L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\) avec \\(L_i = R_{i-1}\\) et \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\). Les \\(K_i\\) sont des sous-clés, différentes pour chaque étape, générées à partir de la clé principale \\(K\\) du schéma de cryptage.\nLe nombre d’étapes propres à un Feistel cipher est normalement pair et \\(\\geq 3\\) (p.ex. DES a 16 étapes)\nAprès l’exécution de toutes les étapes, un Feistel cipher effectue une permutation des deux parties \\((L_r, R_r)\\) en \\((R_r, L_r)\\).\nLa decryption d’un Feistel Cipher est identique à l’encryption sauf que les sous-clés \\(K_i\\) sont appliquées en ordre inverse (De \\(K_r\\) à \\(K_1\\)).\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nProduct cipher : combinaison de transformations successives (transpositions, substitutions, XOR).\nFeistel cipher :\n\nproduct cipher itératif\nplaintext \\(2t\\) bits = \\((L_0, R_0)\\)\n\\(r\\) rounds avec \\(L_i = R_{i-1}\\) et \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\).\nDécryption = encryption avec sous-clés inversées.\nExemple : DES (16 rounds).\n\n\n\n\n\n\n\n\n4. Data Encryption Standard (DES)\n\nPrésentation Générale\nDES (Data Encryption Standard) : algorithme cryptographique le plus important jusqu’à l’avènement d’AES en 2001.\nCaractéristiques principales :\n\nType : Feistel Cipher\nTaille des blocs : 64 bits (taille nominale)\nTaille de la clé : 56 bits effectifs (64 bits totaux avec 8 bits de parité)\nNombre d’étapes : 16 rounds\nSous-clés : 16 sous-clés de 48 bits (une par étape)\nModes d’utilisation : ECB, CBC, CFB, OFB\n\n\n\n\n\n\ngraph TB\n    subgraph DES_Overview\n        P[Plaintext 64 bits] --&gt; DES[DES Encryption]\n        K[Key 56 bits] --&gt; DES\n        DES --&gt; C[Ciphertext 64 bits]\n        \n        C --&gt; DES_INV[DES Decryption]\n        K2[Key 56 bits] --&gt; DES_INV\n        DES_INV --&gt; P2[Plaintext 64 bits]\n    end\n    \n    style DES fill:#ffcccc\n    style DES_INV fill:#ccffcc\n    style K fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\n\n\nStructure de DES\nComposants principaux :\n\nPermutation initiale (IP) : permutation des 64 bits d’entrée\n16 rounds Feistel : transformation itérative\nPermutation finale (IP⁻¹) : inverse de IP\n\nChaque round applique :\n\nDivision en deux moitiés : \\(L_{i-1}\\) et \\(R_{i-1}\\) (32 bits chacune)\nFonction \\(f\\) sur \\(R_{i-1}\\) avec sous-clé \\(K_i\\)\nXOR avec \\(L_{i-1}\\)\nÉchange des moitiés\n\n\n\n\n\n\ngraph TB\n    Plain[Plaintext 64 bits] --&gt; IP[Initial Permutation IP]\n    IP --&gt; Split[Split L0, R0]\n    \n    Split --&gt; Round1[Round 1]\n    K1[K1] --&gt; Round1\n    Round1 --&gt; Round2[Round 2]\n    K2[K2] --&gt; Round2\n    Round2 --&gt; Dots[...]\n    Dots --&gt; Round16[Round 16]\n    K16[K16] --&gt; Round16\n    \n    Round16 --&gt; Swap[Swap R16, L16]\n    Swap --&gt; IP_inv[Final Permutation IP⁻¹]\n    IP_inv --&gt; Cipher[Ciphertext 64 bits]\n    \n    style IP fill:#e1f5ff\n    style IP_inv fill:#e1f5ff\n    style Round1 fill:#ffcccc\n    style Round2 fill:#ffcccc\n    style Round16 fill:#ffcccc\n\n\n\n\n\n\n\n\nFonction Cipher de DES\nLa fonction \\(f\\) pour chaque round :\n\nExpansion E : 32 bits → 48 bits (table E)\nKey Addition : XOR avec sous-clé \\(K_i\\) (48 bits)\nS-boxes : 8 S-boxes transforment 48 bits → 32 bits\n\nChaque S-box : 6 bits entrée → 4 bits sortie\n\nPermutation P : permutation des 32 bits résultants\n\n\n\n\n\n\ngraph TB\n    R[Ri-1 32 bits] --&gt; E[Expansion E]\n    E --&gt; E_out[48 bits]\n    E_out --&gt; XOR1[⊕]\n    K[Ki 48 bits] --&gt; XOR1\n    XOR1 --&gt; S[8 S-boxes]\n    S --&gt; S_out[32 bits]\n    S_out --&gt; P[Permutation P]\n    P --&gt; F_out[f output 32 bits]\n    \n    style E fill:#cce5ff\n    style S fill:#ffcccc\n    style P fill:#e1ffe1\n    style XOR1 fill:#ffffcc\n\n\n\n\n\n\nFonctionnement des S-boxes :\nEntrée : \\(a_1a_2a_3a_4a_5a_6\\) (6 bits)\n\nLigne : \\(a_1 + 2a_6\\) (bits externes)\nColonne : \\(a_2 + 2a_3 + 4a_4 + 8a_5\\) (bits internes)\nSortie : valeur de la cellule correspondante (4 bits)\n\n\n\nGénération des Sous-clés\nProcessus :\n\nClé principale : 64 bits (56 effectifs + 8 parité)\nPermuted Choice 1 (PC-1) : sélection de 56 bits\nDivision en deux moitiés : \\(C_0\\) et \\(D_0\\) (28 bits chacune)\nPour chaque round \\(i\\) :\n\nRotation circulaire gauche de \\(C_{i-1}\\) et \\(D_{i-1}\\)\nPermuted Choice 2 (PC-2) : sélection de 48 bits pour \\(K_i\\)\n\n\nRotations :\n\nRounds 1, 2, 9, 16 : 1 position\nAutres rounds : 2 positions\n\n\n\n\n\n\n\nNote📄 Texte original (DES Fonctionnement)\n\n\n\n\n\nDES: Fonctionnement\nCipher Fonction\n\nExpansion E: Les 32 bits de l’entrée sont transformés en un vecteur de 48 bits en utilisant la table E. La première ligne de cette table indique comment sera généré le premier sous-bloc de 6 bits: on prendra en premier le 32e bit et après les bits 1,2,3,4,5. Le deuxième sous-bloc commence par le 4e bit ensuite les bits 5,6,7,8,9 et ainsi de suite…\nKey addition: XOR du vecteur de 48 bits avec la clé.\nS-boxes: On applique 8 S-boxes sur le vecteur de 48 bits résultant du XOR précédent. Chacune de ces S-boxes prend un sous-bloc de 6 bits et le transforme en un sous-bloc de 4 bits. L’opération s’effectue de la manière suivante: Si on dénote les 6 bits d’input de la S-box comme: \\(a_1a_2a_3a_4a_5a_6\\). La sortie est donnée par le contenu de la cellule située dans la ligne \\(a_1 + 2a_6\\) et la colonne \\(a_2 + 2a_3 + 4a_4 + 8a_5\\).\nPermutation P: La permutation P fonctionne comme suit: Le premier bit est envoyé à la 16e position, le deuxième à la 7e position et ainsi de suite.\n\nPermutations IP et IP⁻¹\n\nAgissent respectivement au début et à la fin du traitement du bloc et sur l’ensemble des 64 bits.\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (DES)\n\n\n\n\n\nDES : Feistel cipher, 64 bits blocs, 56 bits clé effective, 16 rounds.\nFonction \\(f\\) : Expansion E (32→48 bits) → XOR \\(K_i\\) → 8 S-boxes (48→32 bits) → Permutation P.\nS-box : 6 bits input → 4 bits output via table (ligne = bits externes, colonne = bits internes).\nPermutations : IP (initiale) et IP⁻¹ (finale) sur 64 bits.\n\n\n\n\n\n\n\n5. Triple-DES et Sécurité de DES\n\nVulnérabilités de DES\nProblème principal : taille de l’espace de clés \\(\\{0,1\\}^{56}\\) insuffisante.\nAttaque brute force :\n\n1999 : clé trouvée en 24 heures\nTechnique : brute force massivement parallèle (100’000 PCs sur Internet)\nKnown plaintext attack\n\n\n\nTriple-DES (3DES)\nSolution : augmenter l’espace des clés à \\(\\{0,1\\}^{112}\\).\nSchéma :\n\\[C = E_{K_1}(D_{K_2}(E_{K_1}(P)))\\]\nAvec :\n\n\\(E\\) : encryption DES\n\\(D\\) : décryption DES\n\\(K_1, K_2\\) : deux clés de 56 bits\n\n\n\n\n\n\ngraph LR\n    P[Plaintext 64 bits] --&gt; E1[DES Encrypt K1]\n    E1 --&gt; D[DES Decrypt K2]\n    D --&gt; E2[DES Encrypt K1]\n    E2 --&gt; C[Ciphertext 64 bits]\n    \n    K1a[Key K1 56 bits] --&gt; E1\n    K2[Key K2 56 bits] --&gt; D\n    K1b[Key K1 56 bits] --&gt; E2\n    \n    style E1 fill:#ffcccc\n    style D fill:#ccffcc\n    style E2 fill:#ffcccc\n\n\n\n\n\n\nAvantages :\n\n✓ Sécurité satisfaisante : espace de clés \\(2^{112}\\)\n✓ Compatibilité : réutilisation du hardware/software DES existant\n✓ Migration progressive : en attendant AES\n\nInconvénient :\n\n✗ Performances : 3× plus lent (3 exécutions DES successives)\n\n\n\nPropriétés de DES\n1. DES n’est pas un groupe\nDES n’est PAS un groupe pour la composition :\n\\[\\nexists K_3 \\text{ tel que } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)\\]\nConséquence : encryption composée (Triple-DES) augmente considérablement la sécurité.\nSi DES était un groupe : recherche exhaustive sur \\(\\{0,1\\}^{56}\\) casserait l’algorithme indépendamment du nombre d’exécutions consécutives.\n2. Clés faibles et semi-faibles\n\nClé faible : \\(E_K(E_K(x)) = x\\)\nPaire de clés semi-faibles : \\(E_{K_1}(E_{K_2}(x)) = x\\)\n\nCaractéristique : clés faibles génèrent des sous-clés identiques par paires :\n\n\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)\nFacilite la cryptanalyse\n\nDES a 4 clés faibles :\n\n\n\nClé faible (hexadécimal)\n\n\n\n\n0101 0101 0101 0101\n\n\n0101 0101 FEFE FEFE\n\n\nFEFE FEFE FEFE FEFE\n\n\nFEFE FEFE 0101 0101\n\n\n\nEt 6 paires de clés semi-faibles\n\n\n\n\n\n\nNote📄 Texte original (DES et 3DES)\n\n\n\n\n\n\nDES et Triple-DES\n\nLa taille de l’ensemble de clés (\\(\\{0,1\\}^{56}\\)) constitue la plus grande menace qui pèse sur DES avec les ressources de calcul actuels. En 1999 il a suffit de 24 heures pour trouver la clé à partir d’un known plaintext en utilisant une technique brute force massivement parallèle (100’000 PCs connectés sur Internet).\nTriple DES nous met à l’abri de ces attaques brute force en augmentant l’espace des clés possibles à \\(\\{0,1\\}^{112}\\).\nCette alternative permet de continuer à utiliser les “boîtes” DES (hardware et software) en attendant une migration vers AES.\nLe niveau de sécurité obtenu par cette solution est très satisfaisant.\nL’impact en termes de performances de trois exécutions successives de DES reste un inconvénient pour certaines applications.\n\n\n\nDES: propriétés\n\nDES n’est pas un groupe (au sens algébrique) avec la composition: En d’autres termes, DES étant une permutation: \\(\\{0,1\\}^{64} \\rightarrow \\{0,1\\}^{64}\\), si DES était un groupe pour la composition, ceci voudrait dire que: \\(\\exists K_3\\) t.q. \\(E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)\\)\nCette propriété permet d’assurer que l’encryption composée (comme Triple-DES) augmente considérablement la sécurité de DES. Si DES était un groupe, la recherche exhaustive sur l’ensemble de clés possibles (\\(\\{0,1\\}^{56}\\)) permettrait de “casser” l’algorithme indépendamment du nombre d’exécutions consécutives de DES.\nClés faibles et mi-faibles (weak and semi-weak keys):\n\nUne clé \\(K\\) est dite faible si \\(E_K(E_K(x)) = x\\).\nUne paire de clés \\((K_1, K_2)\\) est dite mi-faible si \\(E_{K_1}(E_{K_2}(x)) = x\\).\n\nLes clés faibles ont la particularité de générer de sous-clés identiques par paires (\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)), ce qui facilite la cryptanalyse.\nDES a 4 clés faibles (et 6 paires de clés mi-faibles).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (3DES et sécurité)\n\n\n\n\n\nVulnérabilité DES : espace clés \\(2^{56}\\) cassable en 24h (1999). Triple-DES : \\(E_{K_1}(D_{K_2}(E_{K_1}(P)))\\), espace \\(2^{112}\\), réutilise hardware DES, 3× plus lent. DES ≠ groupe → encryption composée renforce sécurité. 4 clés faibles générant sous-clés identiques par paires → facilite cryptanalyse.\n\n\n\n\n\n\n\n6. Advanced Encryption Standard (AES)\n\nPrésentation Générale\nAES (Advanced Encryption Standard) : standard adopté en novembre 2001.\nConception : Johan Daemen et Vincent Rijmen (nom original : Rijndael)\nCaractéristiques principales :\n\nType : block cipher itératif (mais PAS un Feistel Cipher)\nTaille des blocs : 128 bits\nTaille de clé variable : 128, 192 ou 256 bits\nNombre de rounds : dépend de la taille de clé\n\n10 rounds pour clé 128 bits\n12 rounds pour clé 192 bits\n14 rounds pour clé 256 bits\n\nModes d’utilisation : ECB, CBC, CFB, OFB, CTR\n\nAvantages par rapport à DES :\n\n✓ Processus ouvert : consultation et analyse par experts mondiaux\n✓ ~2× plus performant en software\n✓ ~10²² fois plus sûr (théoriquement)\n✓ Évolutif : taille de clé augmentable si nécessaire\n\n\n\nStructure d’AES\nUnité de base : matrice State de 4 lignes × 4 colonnes (pour clé 128 bits)\n\nChaque élément = 1 byte\nTotal : 16 bytes = 128 bits\n\nOpérations sur le corps \\(GF(2^8)\\) :\n\nByte = élément de \\(GF(2^8)\\)\nCorps fini de polynômes de degré ≤ 7 avec coefficients dans \\(GF(2)\\)\nAdditions, multiplications définies dans \\(GF(2^8)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph State_Matrix\n        S00[s0,0] --- S01[s0,1]\n        S01 --- S02[s0,2]\n        S02 --- S03[s0,3]\n        \n        S10[s1,0] --- S11[s1,1]\n        S11 --- S12[s1,2]\n        S12 --- S13[s1,3]\n        \n        S20[s2,0] --- S21[s2,1]\n        S21 --- S22[s2,2]\n        S22 --- S23[s2,3]\n        \n        S30[s3,0] --- S31[s3,1]\n        S31 --- S32[s3,2]\n        S32 --- S33[s3,3]\n    end\n    \n    style S00 fill:#ffe6cc\n    style S11 fill:#ffe6cc\n    style S22 fill:#ffe6cc\n    style S33 fill:#ffe6cc\n\n\n\n\n\n\n\n\nDétail d’un Round AES\nQuatre opérations par round :\n1. SubBytes (ByteSub)\n\nSubstitution non linéaire via S-box\nChaque byte transformé indépendamment\nRésistance à la cryptanalyse linéaire et différentielle\n\n2. ShiftRows\n\nPermutation des bytes avec décalages variables par ligne\nLigne 0 : pas de décalage\nLigne 1 : décalage gauche 1 position\nLigne 2 : décalage gauche 2 positions\nLigne 3 : décalage gauche 3 positions\n\n3. MixColumns\n\nChaque colonne = combinaison linéaire des autres colonnes\nMultiplication de matrices dans \\(GF(2^8)\\)\nDiffusion maximale\n\n4. AddRoundKey\n\nXOR de la matrice State avec la sous-clé du round\nSous-clé = résultat du Key Schedule\n\n\n\n\n\n\ngraph TB\n    Input[State Input] --&gt; SB[SubBytes]\n    SB --&gt; SR[ShiftRows]\n    SR --&gt; MC[MixColumns]\n    MC --&gt; ARK[AddRoundKey]\n    K[Round Key] --&gt; ARK\n    ARK --&gt; Output[State Output]\n    \n    style SB fill:#ffcccc\n    style SR fill:#ccffcc\n    style MC fill:#cce5ff\n    style ARK fill:#ffffcc\n\n\n\n\n\n\nRound final : identique SAUF pas de MixColumns\n\n\nKey Schedule (Génération des Sous-clés)\nProcessus :\n\nKey Expansion : génération d’une matrice étendue\n\nClé 128 bits → matrice 4 × 4 × (\\(N_e\\) + 1) bytes\n\\(N_e\\) = nombre de rounds\n\nKey Selection : extraction des sous-clés\n\nPremière sous-clé : 4 premières colonnes\nDeuxième sous-clé : 4 colonnes suivantes\nEtc.\n\n\nOpérations :\n\nRotations de bytes\nSubstitutions via S-box\nXOR avec constantes (Rcon)\n\n\n\nPseudo-code AES\nRijndael(State, CipherKey) {\n    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule\n    \n    AddRoundKey(State, ExpandedKey[0..3]); // XOR initial\n    \n    for(i = 1; i &lt; Ne; i++) {\n        Round(State, ExpandedKey[4*i...(4*i)+3]);\n    }\n    \n    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Sans MixColumns\n}\n\n\nDécryption AES\nPrincipe : appliquer les opérations inverses dans chaque round.\nOpérations inverses :\n\nInvSubBytes : substitution inverse via S-box⁻¹\nInvShiftRows : décalages droite (au lieu de gauche)\nInvMixColumns : multiplication matricielle inverse\nAddRoundKey : auto-inverse (XOR)\n\nOrdre : inverse de l’encryption avec sous-clés en ordre inverse\n\n\n\n\n\n\nNote📄 Texte original (AES)\n\n\n\n\n\nAdvanced Encryption Standard (AES)\n\nAdopté comme standard en Novembre 2001, conçu par Johan Daemen et Vincent Rijmen (d’où son nom original Rijndael).\nIl s’agit également d’un block cipher itératif (comme DES) mais pas d’un Feistel Cipher.\nBlocs Plaintext/Ciphertext: 128 bits.\nClé de longueur variable: 128, 192, ou 256 bits.\nContrairement à DES, AES est issu d’un processus de consultation et d’analyse ouvert à des experts mondiaux.\nTechniques semblables à DES (substitutions, permutations, XOR…) complémentées par des opérations algébriques simples et très performantes.\nToutes les opérations s’effectuent dans le corps \\(GF(2^8)\\): le corps fini de polynômes de degré ≤ 7 avec des coefficients dans \\(GF(2)\\).\nEn particulier, un byte pour AES est un élément dans \\(GF(2^8)\\) et les opérations sur les bytes (additions, multiplications,…) sont définies comme sur \\(GF(2^8)\\).\n~2 fois plus performant (en software) et ~10²² fois (en théorie…) plus sûr que DES…\nÉvolutif: La taille de la clé peut être augmentée si nécessaire.\n\n\nDétail d’une Etape (round) AES\nL’unité de base sur laquelle s’appliquent les calculs est une matrice de 4 lignes et 4 colonnes (dans le cas d’une clé de 128 bits) dont les éléments sont des bytes:\n\nByteSub: Opération non linéaire (S-box) conçu pour résister à la cryptanalyse linéaire et différentielle.\nShiftRow: Permutation des bytes introduisant des décalages variables sur les lignes.\nMixColumn: Chaque colonne est remplacée par des combinaisons linéaires des autres colonnes (multiplication des matrices !)\nAddRoundKey: XOR de la matrice courante avec la sous-clé correspondante à l’étape courante.\n\n\n\nAES: Fonctionnement Global\n\nLe nombre d’étapes d’AES varie en fonction de la taille de la clé. Pour une clé de 128 bits, il faut effectuer 10 étapes. Chaque augmentation de 32 bits sur la taille de la clé, entraîne une étape supplémentaire (14 étapes pour des clés de 256 bits).\nLa decryption consiste en appliquer les opérations inverses dans chacune des étapes (InvSubBytes, InvShiftRows, InvMixColumns). AddRoundKey (à cause du XOR) est sa propre inverse.\nLe Key Schedule consiste en:\n\nUne opération d’expansion de la clé principal. Si \\(N_e\\) est le nombre d’étapes (dépendant de la clé), une matrice de 4 lignes et 4 × (\\(N_e\\) + 1) colonnes est générée.\nUne opération de sélection de la clé d’étape: La première sous-clé sera constituée des 4 premières colonnes de la matrice générée lors de l’expansion et ainsi de suite.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (AES)\n\n\n\n\n\nAES (Rijndael 2001) : block cipher itératif (PAS Feistel), 128 bits blocs, clés 128/192/256 bits → 10/12/14 rounds.\nState : matrice 4×4 bytes dans \\(GF(2^8)\\).\n4 opérations/round :\n\nSubBytes (S-box non linéaire)\nShiftRows (décalages lignes)\nMixColumns (combinaisons linéaires)\nAddRoundKey (XOR sous-clé).\n\n2× plus rapide que DES, 10²² fois plus sûr.\n\n\n\n\n\n\n\n7. Attaques et Sécurité d’AES\n\nForces d’AES\nSimplicité et performances :\n\n✓ Algorithme simple et efficace\n✓ Fonctionne sur plateformes limitées (cartes à puce 8 bits)\n✓ Optimisations hardware et software\n\n\n\nAttaques Publiées\n1. Attaques algébriques (2002)\nTechnique XSL (N. Courtois et P. Pieprzyk) :\n\nReprésente AES comme système de 8000 équations quadratiques avec 1600 inconnues binaires\nEffort estimé : \\(2^{100}\\) opérations (encore une conjecture)\nCaractéristique : nécessite peu de known plaintexts\nDistinction : différent des attaques linéaires/différentielles\n\nCritique : basées sur le caractère “fortement algébrique” d’AES (largement contesté)\n2. Related Key Attacks (2009-2011)\nPrincipe : attaques basées sur des clés similaires\n\nRésultats intéressants sur versions réduites d’AES\nNe compromettent pas AES complet\n\n3. Side Channel Attacks\nPrincipe : attaques sur l’implémentation (pas l’algorithme)\nTechniques :\n\nCache timing attacks : analyse des accès cache\nPower analysis : consommation électrique\nElectromagnetic analysis : émissions électromagnétiques\n\nExemple (2005) : Osvik, Shamir, Tromer\n\nExtraction de clé 128 bits avec 6-7 couples plaintext/ciphertext\nBasée sur analyse des accès cache\n\n4. Meet in the Middle sur structures bicycliques (2011-2015)\nRésultat :\n\nRéduit l’effort pour AES-128 à \\(2^{126}\\) (facteur 4 vs brute force)\nReste largement au-dessus des capacités actuelles\n\n\n\nSécurité Pratique\nHypothèse fondamentale : clé d’entropie maximale\nAttaques récentes (WPA2, etc.) :\n\nExploitent la faiblesse des passwords/passphrases\nPas de faille dans AES lui-même\nProblème : génération de clés depuis passwords faibles\n\n⚠️ Rappel critique : qualité de la clé = sécurité du système\n\n\n\n\n\n\nNote📄 Texte original (Attaques AES)\n\n\n\n\n\n\nAES: Remarques Finales et Attaques (I)\n\nLa plus grande force de AES réside dans sa simplicité et dans ses performances, y compris sur des plate-formes à capacité de calcul réduite (p.ex. des cartes à puces avec des processeurs à 8 bits).\nDepuis sa publication officielle, des nombreux travaux de cryptanalyse ont été publiés avec des résultats très intéressants. En particulier, N. Courtois et P.Pieprzyk ont présenté une technique appelée XSL permettant de représenter AES comme un système de 8000 équations quadratiques avec 1600 inconnues binaires. L’effort nécessaire pour casser ce système est estimé (il s’agit encore d’une conjecture…) à \\(2^{100}\\).\nCes attaques se basent sur le caractère fortement algébrique (et largement contesté…) de AES. De plus, il suffit de quelques known plaintexts pour les mettre en place, ce qui les distingue des attaques linéaires et différentielles.\nCes dernières années (2009-2011) des attaques basées sur des clés similaires (related key attacks) ont obtenu des résultats intéressants sur des versions réduites d’AES.\nUne autre famille d’attaques dénommée side channel attacks agissant directement sur l’implémentation de l’algorithme permet d’extraire des informations d’intérêt cryptographique lors de l’exécution de l’encryption.\n\n\n\nAES: Remarques finales et Attaques (II)\n\nEn 2015 une attaque de type Meet in the Middle basé sur des structure bicycliques a montré qu’il était possible de réduire l’effort nécessaire pour trouver une clé AES-128 à \\(2^{126}\\), soit un facteur 4 par rapport au brute force. Ceci reste tout de même largement au dessus des capacités de calcul actuelles.\nUne autre famille d’attaques dénommée side channel attacks agissant directement sur l’implémentation de l’algorithme permet d’extraire des informations d’intérêt cryptographique lors de l’exécution de l’encryption. En particulier, les auteurs arrivent à extraire la clé de 128 bits avec seulement 6-7 couples plaintext/ciphertexts en se basant sur les accès cache.\nLa sécurité de AES (comme pour tout autre algorithme d’encryption) se base toujours sur l’hypothèse d’une clé d’entropie maximale. Les attaques publiées récemment sur des protocoles basés sur AES (comme WPA2) exploitent la faiblesse des passwords/passphrases qui sont à l’origine des clés utilisées.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Sécurité AES)\n\n\n\n\n\nForces : simplicité, performances (même cartes 8 bits). Attaques : XSL (\\(2^{100}\\), algébrique), related keys (versions réduites), side channel (implémentation, cache), Meet-in-Middle bicyclique (\\(2^{126}\\)). Sécurité : hypothèse clé entropie max. Attaques pratiques = passwords faibles, pas faille AES.\n\n\n\n\n\n\n\n8. Techniques de Cryptanalyse des Block Ciphers\n\n8.1 Cryptanalyse Différentielle\nPrincipe : attaque chosen plaintext analysant la propagation des différences entre deux plaintexts à travers les rounds.\nMéthode :\n\nChoisir deux plaintexts avec différence connue : \\(x_a\\) et \\(x_b\\)\nObserver la propagation : \\(\\Delta x = x_a \\oplus x_b\\)\nAnalyser les ciphertexts : \\(\\Delta y = y_a \\oplus y_b\\)\nAttribuer des probabilités aux clés selon les changements observés\nClé la plus probable = clé correcte (après nombreux essais)\n\nCaractéristiques :\n\nNécessite \\(2^{47}\\) couples chosen plaintext pour DES\nProbabilités : dépendent des S-boxes et de la structure\nPlus le nombre de couples augmente, plus la probabilité de succès augmente\n\nSensibilité : très sensible au nombre de rounds\n\nChances de réussite augmentent exponentiellement quand rounds diminuent\n\n\n\n8.2 Cryptanalyse Linéaire\nPrincipe : attaque known plaintext créant un simulateur linéaire du block cipher.\nMéthode :\n\nCréer des approximations linéaires de l’algorithme\nAnalyser un grand nombre de paires plaintext/ciphertext\nLes bits de la clé du simulateur tendent à coïncider avec ceux de la clé réelle (calcul probabiliste)\n\nComplexité pour DES :\n\n\\(2^{38}\\) known plaintexts → probabilité 10% de deviner juste\n\\(2^{43}\\) known plaintexts → probabilité 85% de succès\n\nCaractéristiques :\n\nAttaque analytique la plus puissante à ce jour sur block ciphers\nAussi sensible au nombre de rounds\n\n\n\n8.3 Comparaison Différentielle vs Linéaire\nDifficultés communes :\n\n✗ Parallélisation : moins efficace que brute force parallèle\n⚠️ Sensibilité aux rounds : efficacité diminue exponentiellement avec le nombre de rounds\n\nDES et ces attaques :\n\nConjecture répandue : concepteurs de DES connaissaient ces attaques (années 1970, inédites à l’époque)\nDesign des S-boxes : résistance très grande aux deux techniques\n\n\n\n8.4 Attaque Meet-in-the-Middle\nPrincipe : exploite les constructions composées du type \\(y = E_{K_2}(E_{K_1}(x))\\).\nMéthode :\n\nConstruire liste \\(L_1\\) : \\(L_1 = \\{E_{K_1}(x) \\mid K_1 \\in \\text{KeySpace}\\}\\)\nConstruire liste \\(L_2\\) : \\(L_2 = \\{D_{K_2}(y) \\mid K_2 \\in \\text{KeySpace}\\}\\)\nIdentifier éléments répétés dans \\(L_1\\) et \\(L_2\\)\nVérifier hypothèse avec deuxième known plaintext\nLes clés \\(K_1\\) et \\(K_2\\) associées sont probablement les clés recherchées\n\nExemple pour DES :\nEspace de clés intuitif pour \\(E_{K_2}(E_{K_1}(x))\\) : \\(\\{0,1\\}^{112}\\)\nEffort réel :\n\n\\(2^{57}\\) opérations pour établir les deux listes\n\\(2^{56}\\) blocs de 64 bits de stockage\nNettement inférieur au \\(2^{112}\\) estimé intuitivement\n\nApplications :\n\nAttaques sur constructions composées\nCryptanalyse interne des block ciphers\n\n\n\n\n\n\ngraph TB\n    subgraph Meet_in_Middle\n        X[Known Plaintext x] --&gt; E1[Encrypt K1]\n        E1 --&gt; M[Middle Value m]\n        M --&gt; E2[Encrypt K2]\n        E2 --&gt; Y[Known Ciphertext y]\n        \n        X2[x] --&gt; L1[List L1: EK1 pour tous K1]\n        Y2[y] --&gt; L2[List L2: DK2 pour tous K2]\n        \n        L1 -.match.-&gt; Match[Trouver m commun]\n        L2 -.match.-&gt; Match\n    end\n    \n    style M fill:#ffffcc\n    style Match fill:#ccffcc\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original (Cryptanalyse)\n\n\n\n\n\n\nTechniques de Cryptanalyse sur les Block Ciphers\nCryptanalyse Différentielle\n\nIl s’agit d’une attaque chosen plaintext qui s’intéresse à la propagation des différences dans deux plaintexts au fur et à mesure qu’ils évoluent dans les différentes étapes de l’algorithme.\nIl attribue des probabilités aux clés qu’il “devine” en fonction des changements qu’elles induisent sur les ciphertexts. La clé la plus probable a des bonnes chances d’être la clé correcte après un grand nombre de couples plaintext/ciphertext.\nNécessite \\(2^{47}\\) couples chosen plaintext (pour DES) pour obtenir des résultats corrects.\n\nCryptanalyse Linéaire\n\nIl s’agit d’une attaque known plaintext qui crée un simulateur du bloc à partir des approximations linéaires. En analysant un grand nombre de paires plaintext/ciphertexts, les bits de la clé du simulateur ont tendance à coïncider avec ceux du block cipher analysés (calcul probabiliste)\nPour DES une attaque basée sur cette technique nécessite \\(2^{38}\\) known plaintexts pour obtenir une probabilité de 10% de deviner juste et \\(2^{43}\\) pour un 85% !\nIl s’agit de l’attaque analytique la plus puissante à ce jour sur les block ciphers.\n\n\n\nTechniques de Cryptanalyse sur les Block Ciphers (II)\n\nLa mise en pratique des attaques différentielles et linéaires présente des difficultés dans la parallélisation des calculs par rapport à une recherche exhaustive de la clé.\nCes deux attaques sont très sensibles au nombre d’étapes du block cipher: les chances de réussite augmentent exponentiellement au fur et à mesure que le nombre d’étapes de l’algorithme diminue.\nUne conjecture très répandue parmi les cryptographes est que ces attaques, à l’époque inédites, étaient connues par les concepteurs des DES. En particulier, le design des S-boxes offre une résistance très grande aux deux techniques.\n\nAttaque Meet-in-the-Middle\n\nS’applique aux constructions du type \\(y := E_{K_2}(E_{K_1}(x))\\). Pour DES, l’espace de clés pour cette solution serait de \\(\\{0,1\\}^{112}\\). On construit d’abord deux listes \\(L_1\\) et \\(L_2\\) de \\(2^{56}\\) messages de la forme: \\(L_1 = E_{K_1}(x)\\) et \\(L_2 = D_{K_2}(y)\\) avec \\(E\\) et \\(D\\) les opérations d’encryption et decryption respectivement. Il faut alors identifier des éléments qui se répètent dans les deux listes et vérifier notre hypothèse avec un deuxième known plaintext. Les \\(K_1\\) et \\(K_2\\) associées à cette paire de known plaintexts seront (en toute vraisemblance) les clés recherchées !\nEffort nécessaire à réaliser les attaques (pour DES): \\(2^{57}\\) opérations pour établir les deux listes + \\(2^{56}\\) blocs de 64 bits de stockage pour mémoriser les résultats intermédiaires… nettement inférieur au \\(2^{112}\\) estimé intuitivement…\nCes techniques meet-in-the-middle sont aussi appliquées à la cryptanalyse interne des block ciphers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Cryptanalyse)\n\n\n\n\n\nDifférentielle : chosen plaintext, propagation différences, probabilités sur clés, \\(2^{47}\\) couples (DES).\nLinéaire : known plaintext, approximations linéaires, \\(2^{38}\\)-\\(2^{43}\\) plaintexts (DES), attaque la plus puissante.\nMeet-in-Middle : constructions composées, 2 listes \\(2^{56}\\), effort \\(2^{57}\\) &lt;&lt; \\(2^{112}\\).\nSensibilité : très dépendantes du nombre de rounds."
  },
  {
    "objectID": "exam_notes_fr.html#fondements-mathématiques",
    "href": "exam_notes_fr.html#fondements-mathématiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fondements Mathématiques",
    "text": "Fondements Mathématiques\n\nThéorème Fondamental de l’Arithmétique et Fonction Phi d’Euler\nLa cryptographie asymétrique repose sur des fondements mathématiques solides issus de la théorie des nombres. Deux concepts sont essentiels :\nThéorème Fondamental de l’Arithmétique : Tout nombre entier strictement positif \\(n\\) s’écrit de façon unique (à l’ordre près) comme produit de puissances de nombres premiers :\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nFonction Phi d’Euler \\(\\phi(n)\\) : Nombre d’entiers positifs plus petits que \\(n\\) qui sont premiers avec \\(n\\).\nPour calculer \\(\\phi(n)\\) :\n\\[\\phi(n) = \\prod_{i=1}^{m} p_i^{e_i} \\cdot \\left(1 - \\frac{1}{p_i}\\right)\\]\nCas particulier important : Si \\(n = p \\cdot q\\) avec \\(p\\) et \\(q\\) premiers, alors :\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques\nThéorème Fondamental de l’Arithmétique : Tout nombre entier strictement positif \\(n\\) s’écrit de façon unique (à l’ordre près) comme un produit de puissances de nombres premiers \\(p_i\\) distincts :\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nFonction Phi d’Euler : Soit \\(n \\in \\mathbb{Z}^+\\), la fonction phi d’Euler \\(\\phi(n)\\) est égale au nombre d’entiers positifs plus petits que \\(n\\) qui sont relativement premiers à \\(n\\).\nCalcul de la fonction phi d’Euler : D’après le théorème fondamental de l’arithmétique, tout nombre entier \\(n &gt; 1\\) s’écrit :\n\\[n = \\prod_{i=1}^{m} p_i^{e_i}\\]\nalors \\(\\phi(n)\\) se calcule :\n\\[\\phi(n) = \\prod_{i=1}^{m} \\left(p_i^{e_i} - p_i^{e_i-1}\\right)\\]\nEn particulier, si \\(n = p \\cdot q\\) avec \\(p\\) et \\(q\\) premiers, alors :\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nDécomposition unique : tout entier = produit de nombres premiers\n\\(\\phi(n)\\) : compte les entiers \\(&lt; n\\) premiers avec \\(n\\)\nClé pour RSA : si \\(n = pq\\) (premiers) alors \\(\\phi(n) = (p-1)(q-1)\\)\n\n\n\n\n\n\n\nThéorèmes d’Euler et de Fermat\nCes théorèmes sont au cœur du fonctionnement de RSA et d’autres algorithmes asymétriques.\nThéorème d’Euler : Si \\(n \\in \\mathbb{Z}^+\\) et \\(a \\in \\mathbb{Z}\\) avec \\(\\text{pgcd}(a,n) = 1\\), alors :\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nPetit Théorème de Fermat (cas particulier si \\(n = p\\) premier) : Si \\(a \\in \\mathbb{Z}\\) et \\(p\\) premier ne divise pas \\(a\\) :\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nApplications importantes :\n\nRéduction des exposants : Si \\(n\\) est produit de premiers distincts et \\(r \\equiv s \\pmod{\\phi(n)}\\), alors : \\[a^r \\equiv a^s \\pmod{n}\\]\nCalcul des inverses : \\(a^{\\phi(n)-1}\\) est l’inverse de \\(a\\) modulo \\(n\\). En particulier, si \\(p\\) est premier, \\(a^{p-2}\\) est l’inverse de \\(a\\) modulo \\(p\\).\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques (II)\nThéorème d’Euler : Soient \\(n \\in \\mathbb{Z}^+\\) et \\(a \\in \\mathbb{Z}\\) avec \\(\\text{pgcd}(a,n) = 1\\), alors on a :\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nPetit Théorème de Fermat (cas particulier du théorème d’Euler si \\(n\\) est premier) : Soient \\(a \\in \\mathbb{Z}\\) et \\(p\\) un nombre premier tel que \\(p\\) ne divise pas \\(a\\), alors on a :\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nÀ noter que puisque \\(p\\) est premier, on a \\(\\phi(p) = p-1\\).\nRéduction des exposants \\(\\bmod \\phi(n)\\) : Si \\(n\\) est le produit de premiers distincts et \\(r, s \\in \\mathbb{Z}\\) t.q. \\(r \\equiv s \\pmod{\\phi(n)}\\) alors \\(\\forall a \\in \\mathbb{Z}\\) :\n\\[a^r \\equiv a^s \\pmod{n}\\]\nApplication du Théorème d’Euler au calcul des inverses : Suite au théorème d’Euler, on a que :\n\\[a \\cdot a^{\\phi(n)-1} \\equiv 1 \\pmod{n}\\]\nce qui signifie que \\(a^{\\phi(n)-1}\\) est l’inverse de \\(a\\) modulo \\(n\\). En particulier, \\(a^{p-2}\\) est l’inverse de \\(a\\) modulo \\(n\\) si \\(p\\) est premier.\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\nFermat : cas spécial si \\(p\\) premier : \\(a^{p-1} \\equiv 1 \\pmod{p}\\)\nInverse modulaire : \\(a^{-1} \\equiv a^{\\phi(n)-1} \\pmod{n}\\)\nBase de RSA : permet encryption/decryption avec exposants\n\n\n\n\n\n\n\nGroupes Multiplicatifs et Générateurs\nGroupe multiplicatif \\(\\mathbb{Z}_n^*\\) : Ensemble des éléments de \\(\\mathbb{Z}_n\\) premiers avec \\(n\\) :\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{pgcd}(a,n) = 1\\}\\]\nSi \\(n\\) est premier : \\(\\mathbb{Z}_n^* = \\{1, 2, \\ldots, n-1\\}\\)\nOrdre d’un élément : Plus petit entier positif \\(t\\) tel que \\(a^t \\equiv 1 \\pmod{n}\\)\nGénérateur : Un élément \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) si son ordre est \\(\\phi(n)\\). On dit alors que \\(\\mathbb{Z}_n^*\\) est cyclique.\nPropriétés des générateurs :\n\n\\(\\mathbb{Z}_n^*\\) a un générateur ssi \\(n = 2, 4, p^k\\) ou \\(2p^k\\) (avec \\(p\\) premier, \\(p \\neq 2\\) et \\(k \\geq 1\\))\nSi \\(p\\) est premier, \\(\\mathbb{Z}_p^*\\) a toujours un générateur\nSi \\(\\alpha\\) est générateur, tous les éléments s’écrivent : \\(\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i &lt; \\phi(n)\\}\\)\nLe nombre de générateurs est \\(\\phi(\\phi(n))\\)\n\nTest de générateur\n\n\\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) ssi \\(\\forall\\) premier \\(p\\) divisant \\(\\phi(n)\\), \\(\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\)\nsi \\(n = 2p+1\\) est un “safe prime” avec \\(p\\) premier : \\(\\alpha\\) est générateur ssi \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) et \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques (III)\nDéfinition : Le groupe multiplicatif de \\(\\mathbb{Z}_n\\), noté \\(\\mathbb{Z}_n^*\\) est :\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{pgcd}(a,n) = 1\\}\\]\nEn particulier, si \\(n\\) est premier : \\(\\mathbb{Z}_n^* = \\{a \\mid 1 \\leq a \\leq n-1\\}\\)\nLe nombre d’éléments ou ordre du groupe multiplicatif \\(\\mathbb{Z}_n^*\\) est \\(\\phi(n)\\) (par définition de \\(\\phi\\)).\nDéfinition : Soit \\(a \\in \\mathbb{Z}_n\\), l’ordre de \\(a\\) est le plus petit entier positif \\(t\\) pour lequel :\n\\[a^t \\equiv 1 \\pmod{n}\\]\nDéfinition : Soit \\(\\alpha \\in \\mathbb{Z}_n^*\\), si l’ordre de \\(\\alpha\\) est \\(\\phi(n)\\), alors \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\). Lorsqu’un groupe \\(\\mathbb{Z}_n^*\\) a un générateur, on dit qu’il est cyclique.\nPropriétés des générateurs :\n\n\\(\\mathbb{Z}_n^*\\) a un générateur ssi \\(n = 2, 4, p^k\\) ou \\(2p^k\\), avec \\(p\\) premier, \\(p \\neq 2\\) et \\(k \\geq 1\\). En particulier, si \\(p\\) est premier, \\(\\mathbb{Z}_p^*\\) a un générateur.\nSi \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\), alors tous les éléments de \\(\\mathbb{Z}_n^*\\) s’écrivent : \\[\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i \\leq \\phi(n)-1\\}\\]\nLe nombre de générateurs de \\(\\mathbb{Z}_n^*\\) est \\(\\phi(\\phi(n))\\).\n\\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) ssi pour tout premier \\(p\\) divisant \\(\\phi(n)\\), on a : \\[\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\]\n\nEn particulier si \\(n\\) est un premier de la forme \\(n = 2p+1\\) avec \\(p\\) premier (un tel \\(n\\) est appelé un safe prime), \\(\\alpha\\) est générateur de \\(\\mathbb{Z}_n^*\\) ssi \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) et \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\n\\(\\mathbb{Z}_n^*\\) : éléments premiers avec \\(n\\), cardinal = \\(\\phi(n)\\)\nGénérateur : élément d’ordre \\(\\phi(n)\\) (génère tout le groupe)\nCrucial pour DH et ElGamal : sécurité basée sur logarithme discret dans groupe cyclique\nSafe prime : \\(n = 2p+1\\) avec \\(p\\) et \\(n\\) premiers\n\n\n\n\n\n\n\nFast Exponentiation (Exponentiation Rapide)\nCalcul efficace de \\(a^k \\bmod n\\) en temps polynomial, essentiel pour tous les algorithmes asymétriques.\nPrincipe : Utiliser la représentation binaire de l’exposant \\(k\\).\nExemple : Calcul de \\(2^{644} \\bmod 645\\)\n\nReprésentation binaire : \\((644)_{10} = (1010000100)_2\\)\nCalculer les puissances de 2 successives modulo 645 :\n\n\\(2^1 \\bmod 645\\)\n\\(2^2 \\bmod 645\\)\n\\(2^4 \\bmod 645\\)\n\\(2^8 \\bmod 645\\)\n…\n\\(2^{512} \\bmod 645\\)\n\nCombiner selon les bits à 1 : \\(2^{644} = 2^{512} \\cdot 2^{128} \\cdot 2^4\\)\n\nComplexité : \\(O(\\log^3 n)\\) - très efficace !\nApplication : Calcul de l’inverse avec le théorème d’Euler en temps polynomial.\nAlternative : Algorithme d’Euclide étendu pour trouver \\(x\\) tel que \\(ax \\equiv 1 \\pmod{n}\\) en résolvant \\(ax - kn = 1 = \\text{pgcd}(a,n)\\). Complexité également \\(O(\\log^3 n)\\).\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFast Exponentiation\nFast exponentiation : En utilisant la représentation binaire d’un nombre, on peut calculer des puissances très efficacement.\nExemple : calcul de \\(2^{644} \\bmod 645\\)\n\\((644)_{10} = (1010000100)_2\\)\nMaintenant, on calcule les exposants correspondants aux puissances de 2, soient :\n\\[2^1 \\bmod 645, \\quad 2^2 \\bmod 645, \\quad 2^4 \\bmod 645, \\quad \\ldots, \\quad 2^{512} \\bmod 645\\]\nD’après la représentation binaire, on calcule :\n\\[2^{644} = 2^{512+128+4} = 2^{512} \\cdot 2^{128} \\cdot 2^4 = 160 \\cdot 153 \\cdot 6 \\bmod 645\\]\nLa complexité de cet algorithme fast exponentiation est \\(O(\\log^3 n)\\).\nEn s’appuyant sur le théorème d’Euler, le calcul de l’inverse d’un nombre dans un tel groupe est donc effectué en temps polynomial.\nL’algorithme d’Euclide étendu peut être également utilisé pour trouver un \\(x\\) tel que :\n\\[ax \\equiv 1 \\pmod{n}\\]\npuisque cette congruence s’écrit : \\(ax - 1 = kn\\) et donc :\n\\[ax - kn = 1 = \\text{pgcd}(a,n)\\]\nLa complexité de cet algorithme est également \\(O(\\log^3 n)\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nIdée : représentation binaire de l’exposant\nComplexité : \\(O(\\log^3 n)\\) - polynomial !\nEssentiel : rend RSA, ElGamal, DH praticables\nAlternative : algorithme d’Euclide étendu pour inverses\n\n\n\n\n\n\n\nThéorème des Restes Chinois (CRT)\nLe CRT permet de résoudre des systèmes de congruences simultanées, avec des applications importantes en cryptographie.\nThéorème : Soient \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) premiers deux à deux (pgcd\\((n_i, n_j) = 1\\) si \\(i \\neq j\\)) et \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Alors le système :\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\na une solution unique \\(x \\bmod N\\) avec \\(N := n_1 \\cdot n_2 \\cdots n_t\\).\nAlgorithme de Gauss (1801) pour calculer \\(x\\) :\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\navec :\n\n\\(N_i = N/n_i\\)\n\\(M_i = N_i^{-1} \\bmod n_i\\) (inverse modulaire)\n\nComplexité : \\(O(\\log^3 n)\\) - polynomial !\nApplications cryptographiques :\n\nAccélération des calculs RSA (utiliser \\(p\\) et \\(q\\) séparément)\nPartage de secret (secret sharing schemes)\nCertaines attaques sur RSA (si exposant petit et messages multiples)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nThéorème des Restes Chinois\nLe Théorème des Restes Chinois (IIIe siècle!) permet de résoudre des systèmes linéaires de congruences simultanées. Il résout des problèmes soulevés dans des anciens puzzles chinois. Il s’agissait, par exemple, de trouver un nombre qui produit un reste de 1 lorsqu’il est divisé par 3, de 2 lorsqu’il est divisé par 5 et de 3 lorsqu’il est divisé par 7… Il fut également utilisé pour calculer le moment exact d’alignement de plusieurs astres ayant des orbites (et donc des périodes) différentes.\nThéorème des Restes Chinois : Soient \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) premiers deux à deux (c.à.d. pgcd\\((n_i, n_j) = 1\\), \\(\\forall i \\neq j\\)) et \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Alors, le système de congruences :\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\na une solution unique \\(x \\bmod N := n_1 n_2 \\cdots n_t\\)\nAlgorithme de Gauss (1801) pour le calcul de \\(x\\) :\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\navec \\(N_i = N/n_i\\) et \\(M_i = N_i^{-1} \\bmod n_i\\).\nLa complexité de cet algorithme est \\(O(\\log^3 n)\\).\nIl est donc possible en temps polynomial de passer des congruences mod \\(n_i\\) aux congruences mod \\(N\\) !\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nRésout : systèmes de congruences avec moduli premiers entre eux\nSolution unique : modulo produit des moduli\nComplexité : \\(O(\\log^3 n)\\) (polynomial)\nUsage crypto : optimisation RSA, attaques si petit exposant"
  },
  {
    "objectID": "exam_notes_fr.html#problèmes-de-base-et-complexité",
    "href": "exam_notes_fr.html#problèmes-de-base-et-complexité",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Problèmes de Base et Complexité",
    "text": "Problèmes de Base et Complexité\n\nClassification des Problèmes Difficiles\nLa sécurité de la cryptographie asymétrique repose sur des problèmes mathématiques réputés difficiles :\nProblèmes génériques :\n\nFactorisation (FACTP) : Étant donné \\(n\\), trouver sa factorisation en nombres premiers\n\nBase de RSA et Rabin\n\nLogarithmes discrets (DLP) : Étant donné \\(p\\) premier, un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et \\(\\beta \\in \\mathbb{Z}_p^*\\), trouver \\(x\\) tel que : \\[\\alpha^x \\equiv \\beta \\pmod{p}\\]\n\nBase de ElGamal et Diffie-Hellman\n\nRacine carrée modulo composite (SQROOTP) : Étant donné \\(n\\) composite et un résidu quadratique \\(a\\), trouver \\(\\sqrt{a} \\bmod n\\)\n\nBase de Rabin\n\n\nProblèmes spécifiques :\n\nRSA Problem (RSAP) : Étant donné \\(n = pq\\), \\(e\\) avec pgcd\\((e, \\phi(n)) = 1\\) et \\(c\\), trouver \\(m\\) tel que \\(m^e \\equiv c \\pmod{n}\\)\nDiffie-Hellman Problem (DHP) : Étant donné \\(p\\) premier, \\(\\alpha\\) générateur, \\(\\alpha^a \\bmod p\\) et \\(\\alpha^b \\bmod p\\), trouver \\(\\alpha^{ab} \\bmod p\\)\n\nÉquivalences prouvées :\n\nDHP ⟺ DLP (équivalent sous certaines conditions)\nRSAP ⟺ FACTP (prouvé équivalent pour le cas générique)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nProblèmes de Base\nProblèmes génériques principaux :\n\nFactorisation (FACTP) : Étant donné un entier positif \\(n\\), trouver sa factorisation en nombres premiers.\nLogarithmes discrets (DLP) : Étant donné un nombre premier \\(p\\), un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et un élément \\(\\beta \\in \\mathbb{Z}_p^*\\), trouver l’entier \\(x\\), \\(0 \\leq x \\leq p-2\\), tel que : \\(\\alpha^x \\equiv \\beta \\pmod{p}\\).\nRacine carrée dans \\(\\mathbb{Z}_n\\) si \\(n\\) est composite (SQROOTP) : Étant donné un entier composite \\(n\\) et un résidu quadratique \\(a\\), trouver la racine carrée de \\(a\\) mod \\(n\\).\n\nProblèmes spécifiques (propres à un système de cryptage) :\n\nRSA (RSAP) : Étant donné un entier positif \\(n = pq\\), un entier positif \\(e\\) avec gcd\\((e, (p-1)(q-1)) = 1\\) et un entier \\(c\\), trouver un entier \\(m\\) avec \\(m^e \\equiv c \\pmod{n}\\).\nDiffie-Hellman (DHP) : Étant donné un nombre premier \\(p\\), un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et les éléments \\(\\alpha^a \\bmod p\\) et \\(\\alpha^b \\bmod p\\), trouver \\(\\alpha^{ab} \\bmod p\\).\n\nRésultats prouvés :\n\nDHP ⟺ DLP (Équivalent sous certaines conditions)\nRSAP ⟺ FACTP (Prouvé équivalent pour le problème générique)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nFACTP : factoriser \\(n\\) → base de RSA/Rabin\nDLP : trouver logarithme discret → base ElGamal/DH\nSQROOTP : racine carrée mod composite → Rabin\nÉquivalences : cassage = résolution du problème de base\n\n\n\n\n\n\n\nTechniques de Factorisation\nLa sécurité de RSA dépend de la difficulté de factoriser de grands nombres.\nMéthodes à temps exponentiel : \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division (division successive)\nCrible d’Ératosthène (IIe siècle av. J.-C.)\nMéthode de Fermat (~1650)\nMéthode \\(\\rho\\) de Pollard (1975)\nMéthode \\(p-1\\) de Pollard (1974)\n\nMéthodes à temps sous-exponentiel : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981) - très efficace en pratique\nNumber Field Sieve - NFS (1990) - le plus rapide actuellement\nGeneral Number Field Sieve - GNFS (2006)\n\nMéthodes à temps polynomial :\n\nAlgorithme de Shor (1994) : \\(O(\\log^c n)\\) sur ordinateur quantique\n\nRecords actuels (2020) :\n\nPlus grand nombre factorisé : RSA-829 (250 chiffres, 829 bits)\nTemps de calcul : 2700 années-cœur (CPUs Intel Xeon Gold 6130)\nMéthode : General Number Field Sieve\n\nImplications :\n\nClés RSA &lt; 1024 bits : vulnérables\nClés RSA 1024 bits : limites (états avec ressources importantes)\nRecommandation : 2048 bits minimum (3072-4096 pour long terme)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nClassical Factoring Techniques et New Developments\nTemps exponentiel : \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division\nEratosthenes’ Sieve (II B.C.)\nFermat’s Difference of Squares Method (~1650)\nSquare Form Factorization (1971)\nPollard’s p-1 method (1974)\nPollard’s Rho Method (1975)\n\nTemps sous-exponentiel : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981)\nNumber Field Sieve - NFS (1990)\nGeneral Number Field Sieve - GNFS (2006)\n\nTemps polynomial :\n\nShor’s Algorithm in a Quantum Computer (1994) : \\(O(\\log^c n)\\)\n\nDéveloppements récents :\n\nL’ordinateur NFS spécifique de Bernstein pour factoriser un nombre de 1536 bits prendrait le même temps qu’un calcul 512 bits sur machine conventionnelle\nPlus grande factorisation à ce jour (2020) : RSA-829 (nombre de 250 chiffres) utilisant NFS\nTemps de calcul total : 2700 années-cœur (CPUs Intel Xeon Gold 6130 à 2.1GHz)\n\nFactorisation sur ordinateur quantique :\n\nProblèmes significatifs (erreurs, dispersion, etc.)\n2001 : ordinateur 7 qubits (IBM Almaden)\nFaisabilité d’un ordinateur avec millions de qubits… ?\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nSous-exponentiel : NFS actuellement le plus rapide\nRecord 2020 : RSA-829 (829 bits) en 2700 années-cœur\nRecommandation : clés ≥ 2048 bits pour RSA\nMenace future : ordinateurs quantiques (Shor)"
  },
  {
    "objectID": "exam_notes_fr.html#lalgorithme-rsa",
    "href": "exam_notes_fr.html#lalgorithme-rsa",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "L’Algorithme RSA",
    "text": "L’Algorithme RSA\n\nFonctionnement de RSA (Encryption/Decryption)\nRSA (Rivest-Shamir-Adleman, 1978) est l’algorithme asymétrique le plus utilisé.\nGénération des clés :\n\nChoisir deux nombres premiers grands \\(p\\) et \\(q\\) (≥ 1024 bits chacun)\nCalculer \\(n := p \\cdot q\\) et \\(\\phi(n) = (p-1)(q-1)\\)\nChoisir exposant d’encryption \\(e\\) avec :\n\n\\(1 &lt; e &lt; \\phi(n)\\)\npgcd\\((e, \\phi(n)) = 1\\)\n\nCalculer exposant de décryption \\(d\\) tel que : \\[e \\cdot d \\equiv 1 \\pmod{\\phi(n)}\\] (avec algorithme d’Euclide étendu ou fast exponentiation)\n\nClés résultantes :\n\nClé publique : \\((n, e)\\)\nClé privée : \\(d\\) (garder \\(p\\) et \\(q\\) secrets aussi !)\n\nEncryption (par Bob, vers Alice) :\n\nObtenir clé publique authentique \\((n, e)\\) d’Alice\nTransformer plaintext en entiers \\(m_i \\in [0, n-1]\\)\nCalculer ciphertexts : \\(c_i := m_i^e \\bmod n\\)\nEnvoyer les \\(c_i\\) à Alice\n\nDecryption (par Alice) :\n\nUtiliser clé privée \\(d\\) pour calculer : \\[m_i = c_i^d \\bmod n\\]\n\nPreuve de fonctionnement :\n\\[c^d \\equiv (m^e)^d \\equiv m^{ed} \\pmod{n}\\]\nComme \\(ed \\equiv 1 \\pmod{\\phi(n)}\\), il existe \\(k\\) tel que \\(ed = 1 + k\\phi(n)\\), donc :\n\\[c^d \\equiv m^{1+k\\phi(n)} \\equiv m \\cdot (m^{\\phi(n)})^k \\equiv m \\cdot 1^k \\equiv m \\pmod{n}\\]\n(par le théorème d’Euler)\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nProcédé d’Encryption/Decryption de RSA et Preuve\nGénération des clés :\n\nChaque entité (A) crée une paire de clés (publique et privée) comme suit :\n\nA choisit la taille du modulus \\(n\\) (p.ex. taille\\((n) = 1024\\) ou taille\\((n) = 2048\\)).\nA génère deux nombres premiers \\(p\\) et \\(q\\) de grande taille \\((n/2)\\).\nA calcule \\(n := pq\\) et \\(\\phi(n) = (p-1)(q-1)\\).\nA génère l’exposant d’encryption \\(e\\), avec \\(1 &lt; e &lt; \\phi(n)\\) t.q. pgcd\\((e, \\phi(n)) = 1\\).\nA calcule l’exposant de decryption \\(d\\), t.q. : \\(ed \\equiv 1 \\pmod{\\phi(n)}\\) avec l’algorithme d’Euclide étendu ou avec l’algorithme fast exponentiation.\n\nLe couple \\((n,e)\\) est la clé publique de A ; \\(d\\) est la clé privée de A.\n\nEncryption :\n\nL’entité B obtient \\((n,e)\\), la clé publique authentique de A.\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, n-1]\\) \\(\\forall i\\).\nB calcule le ciphertext \\(c_i := m_i^e \\bmod n\\), \\(\\forall i\\) avec l’algorithme fast exponentiation.\nB envoie à A tous les ciphertext \\(c_i\\).\n\nDecryption :\n\nA utilise sa clé privée pour calculer les plaintexts \\(m_i = c_i^d \\bmod n\\).\n\nPreuve : Soit \\(m\\) le plaintext et \\(c\\) le ciphertext avec \\(c := m^e \\bmod n\\), il s’agit de prouver : \\(m \\stackrel{!}{=} c^d \\bmod n\\)\nEn substituant \\(c\\) par sa valeur on obtient : \\[c^d \\bmod n = m^{ed} \\bmod n \\quad (*)\\]\nmais, on sait que : \\[ed \\equiv 1 \\pmod{\\phi(n)}\\]\net donc par définition des congruences, il existe un entier \\(k\\) avec : \\[ed - 1 = k\\phi(n)\\]\nen substituant dans (*) : \\[c^d \\equiv m^{k\\phi(n)+1} \\equiv m^{k\\phi(n)} \\cdot m \\pmod{n}\\]\nSi pgcd\\((m,n) = 1\\), on a par le théorème d’Euler : \\[m^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\ndonc : \\[c^d \\equiv (m^{\\phi(n)})^k \\cdot m \\equiv m \\pmod{n}\\] c.q.f.d. !\nSi pgcd\\((m,n) \\neq 1\\), \\(m\\) est nécessairement multiple de \\(p\\) ou de \\(q\\) (cas très peu probable…), on peut montrer en faisant les calculs mod \\(p\\) et mod \\(q\\) que la congruence reste vraie.\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nClé publique : \\((n, e)\\) avec \\(n = pq\\)\nClé privée : \\(d\\) tel que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\nChiffrement : \\(c = m^e \\bmod n\\)\nDéchiffrement : \\(m = c^d \\bmod n\\)\nSécurité : basée sur difficulté de factoriser \\(n\\)\n\n\n\n\n\n\n\n\n\ngraph LR\n    A[Plaintext m] --&gt;|Encryption: m^e mod n| B[Ciphertext c]\n    B --&gt;|Decryption: c^d mod n| C[Plaintext m]\n    D[Clé publique: n, e] -.-&gt;|utilisée pour| A\n    E[Clé privée: d] -.-&gt;|utilisée pour| B\n    F[p, q premiers secrets] --&gt;|n = pq| D\n    F --&gt;|φn = p-1q-1| E\n\n\n\n\n\n\n\n\n\nSécurité de RSA\nÉquivalence problème RSA ⟺ Factorisation :\n\nTrouver \\(d\\) ⟺ factoriser \\(n\\) (prouvé équivalent)\nDécrypter sans \\(d\\) n’est pas prouvé aussi difficile que factoriser, mais…\nAucune méthode plus rapide que factorisation n’est connue\n\nComplexité de la factorisation :\n\nMéthodes les plus rapides : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\) (sous-exponentiel)\nCalculatoirement impossible pour \\(n \\geq 1024\\) bits\nRecommandation actuelle : 2048 bits minimum (3072-4096 pour sécurité durable)\n\nChoix des exposants :\n\nExposant d’encryption \\(e\\) :\n\nSouvent petit pour accélérer : \\(e = 3, 17, 65537\\) (commun)\nAttention : si \\(e\\) trop petit ET \\(m &lt; n^{1/e}\\), attaque possible (racine \\(e\\)-ième dans \\(\\mathbb{Z}\\))\nSolution : randomization (padding) du message\n\nExposant de décryption \\(d\\) :\n\nDoit être grand : au moins la moitié de la taille de \\(n\\)\nSi \\(d\\) petit : vulnérable à l’attaque de Wiener\n\n\nConséquence performance :\n\nEncryption rapide (\\(e\\) petit)\nDecryption lente (\\(d\\) grand)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nRSA: Sécurité\nLe problème RSAP consistant à trouver \\(m\\) à partir de \\(c\\) n’est pas prouvé comme étant aussi difficile que la factorisation mais… :\n\nOn peut prouver que si on trouve \\(d\\) on peut facilement calculer \\(p\\) et \\(q\\). Ceci équivaut à dire que factoriser \\(n\\) et trouver \\(d\\) nécessitent un effort de calcul équivalent.\nOn sait que les méthodes les plus rapides pour factoriser ont une complexité sub-exponentielle \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\). Le problème reste donc calculatoirement impossible pour des modulus \\(\\geq 1048\\) bits (2048 bits est un choix fréquent pour une sécurité durable…).\nAfin d’améliorer la vitesse d’encryption, on a tendance à choisir des exposants \\(e\\) assez petits (typiquement : \\(e := 3\\), \\(e := 17\\) et \\(e := 19\\)). On a cependant prouvé que le calcul d’une \\(i\\)-ème racine (avec \\(i\\) petit) modulo un composite \\(n\\) peut être nettement plus facile que la factorisation de \\(n\\). Par contre, en 2008 on a prouvé que la résolution générique du problème RSA est équivalent à la factorisation.\nL’exposant de decryption \\(d\\) doit impérativement être de grande taille (au moins la moitié de la taille de \\(n\\)) pour garantir la sécurité du système.\nPar conséquent, l’encryption est normalement nettement plus rapide que la decryption puisque les exposants utilisés sont beaucoup plus petits !\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nSécurité : basée sur difficulté de FACTP (factorisation)\nTaille recommandée : \\(n \\geq 2048\\) bits\n\\(e\\) petit : encryption rapide (3, 17, 65537)\n\\(d\\) grand : au moins \\(\\text{taille}(n)/2\\)\nClés séparées : encryption ≠ signature\n\n\n\n\n\n\n\nAttaques sur RSA\n\nAttaque sur exposant petit avec même message\nSi on envoie le même message \\(m\\) à 3 destinataires avec \\(e = 3\\) :\n\n\\(c_1 \\equiv m^3 \\pmod{n_1}\\)\n\\(c_2 \\equiv m^3 \\pmod{n_2}\\)\n\\(c_3 \\equiv m^3 \\pmod{n_3}\\)\n\nLe Théorème des Restes Chinois donne une solution unique \\(x \\bmod n_1n_2n_3\\) telle que : \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nSi \\(m^3 &lt; n_1n_2n_3\\) (souvent vrai), alors \\(x = m^3\\) dans \\(\\mathbb{Z}\\) et on peut calculer \\(m\\) en prenant simplement la racine cubique entière !\nProtection : toujours randomizer le message avant encryption (padding OAEP)\n\n\nAttaque si message petit\nSi \\(m &lt; n^{1/e}\\), alors \\(m^e &lt; n\\), donc \\(c = m^e\\) (dans \\(\\mathbb{Z}\\), pas modulo). On peut calculer directement la racine \\(e\\)-ième !\nProtection : padding obligatoire\n\n\nPropriété multiplicative\n\\[E(m_1) \\cdot E(m_2) \\equiv (m_1 \\cdot m_2)^e \\equiv E(m_1 \\cdot m_2) \\pmod{n}\\]\nPermet des attaques de type chosen-ciphertext et blind signatures.\n\n\nAttaque générale\nLa méthode la plus efficace reste la factorisation de \\(n\\) (si paramètres bien choisis et implémentation correcte).\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nRSA: Attaques\nLors qu’on souhaite encrypter le même message pour un groupe de correspondants, il convient d’introduire des variations (randomization) avant l’encryption pour éviter l’attaque suivante :\nAdmettons qu’on calcule des ciphertexts \\(c_1, c_2, c_3\\) à partir du même plaintext \\(m\\) et du même exposant \\(e := 3\\) adressés à trois entités avec des modulus : \\(n_1, n_2, n_3\\).\nLe Théorème des Restes Chinois nous dit qu’il existe une solution \\(x \\bmod n_1n_2n_3\\), t.q. : \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nMais si \\(m\\) ne change pas pour les trois encryptions, on a que \\(x = m^3 \\bmod n_1n_2n_3\\) et, de plus : \\(m^3 &lt; n_1n_2n_3\\). On peut, donc, trouver \\(m\\) en calculant la racine cubique entière de \\(m^3\\), en sachant que pour ce calcul il existe des algorithmes efficaces !\nPlus généralement, si \\(m &lt; n^{1/e}\\), on peut appliquer des algorithmes rapides (dans \\(\\mathbb{Z}\\)) pour calculer les racines \\(e\\)-ièmes de \\(m^e\\). Il convient donc d’effectuer des opérations de “randomization” de \\(m\\) avant d’encrypter !\nLa propriété multiplicative de RSA : \\((m_1 m_2)^e \\equiv m_1^e \\cdot m_2^e \\equiv c_1 \\cdot c_2 \\pmod{n}\\)\ndonne lieu à des failles dangereuses (voir signatures aveugles).\nEn admettant que les paramètres sont correctement choisis et que l’implantation n’a pas de failles, la méthode la plus efficace pour “casser” l’algorithme générique RSA reste la factorisation de \\(n\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nMême message, petit \\(e\\) : CRT permet d’extraire \\(m\\) !\nMessage trop petit : \\(m &lt; n^{1/e}\\) → racine directe\nPropriété multiplicative : \\(E(m_1) \\cdot E(m_2) = E(m_1 m_2)\\)\nProtection : toujours padding/randomization (OAEP)"
  },
  {
    "objectID": "exam_notes_fr.html#lalgorithme-elgamal",
    "href": "exam_notes_fr.html#lalgorithme-elgamal",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "L’Algorithme ElGamal",
    "text": "L’Algorithme ElGamal\nSystème asymétrique (1985) basé sur le problème du logarithme discret (DLP).\nClés :\n\nChoisir premier \\(p\\), générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\), secret \\(a\\)\nCalculer \\(y = \\alpha^a \\bmod p\\)\nPublique : \\((p, \\alpha, y)\\) | Privée : \\(a\\)\n\nChiffrement : Pour message \\(m\\), choisir aléatoire \\(k\\) unique\n\n\\(\\gamma = \\alpha^k \\bmod p\\)\n\\(\\delta = m \\cdot y^k \\bmod p\\)\nEnvoyer \\((\\gamma, \\delta)\\)\n\nDéchiffrement : \\(m = \\delta \\cdot \\gamma^{-a} \\bmod p\\)\n\n\n\n\n\n\nNoteTexte original du cours\n\n\n\n\n\nProcédé d’Encryption/Decryption d’ElGamal\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère un nombre premier \\(p\\) (len(\\(p\\)) ≥ 1024 bits) et un générateur \\(\\alpha\\) du groupe multiplicatif \\(\\mathbb{Z}_p^*\\)\nA génère un nombre aléatoire \\(a\\), t.q. \\(1 \\leq a \\leq p-2\\) et calcule \\(y := \\alpha^a \\bmod p\\)\nLa clé publique de A est \\((p, \\alpha, y)\\), la clé privée de A est \\(a\\)\n\nEncryption\n\nL’entité B obtient \\((p, \\alpha, \\alpha^a \\bmod p)\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nPour chaque message \\(m_i\\) :\n\nB génère un nombre aléatoire unique \\(k\\), t.q. \\(1 \\leq k \\leq p-2\\)\nB calcule \\(\\gamma := \\alpha^k \\bmod p\\) et \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) et envoie le ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA utilise sa clé privée \\(a\\) pour calculer \\(\\gamma^{p-1-a} \\bmod p\\) (à noter que: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrouve le plaintext en calculant: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBase : DLP dans \\(\\mathbb{Z}_p^*\\)\nChiffré : \\((\\alpha^k, m \\cdot y^k)\\)\nSécurité : \\(k\\) doit être unique et grand\nInconvénient : double la taille du message\n\n\n\n\nRemarques essentielles\n\nPreuve : \\(\\delta \\cdot \\gamma^{-a} = m \\cdot (\\alpha^a)^k \\cdot (\\alpha^k)^{-a} = m \\bmod p\\)\nSécurité : basée sur DLP (complexité sub-exponentielle proche de la factorisation)\nExposants : \\(k\\) et \\(a\\) doivent être grands (sinon vulnérable à baby-step giant-step)\nRéutilisation interdite : si \\(k\\) répété, \\(\\delta_1/\\delta_2 = m_1/m_2\\) révèle les messages\nInconvénient majeur : expansion ×2 de la taille du chiffré\nGénéralisation : fonctionne sur \\(GF(2^n)\\) ou courbes elliptiques\n\n\n\n\n\n\n\nNoteTexte original - Remarques\n\n\n\n\n\nPreuve que le schéma fonctionne : Si \\(s \\equiv k^{-1}(m_h - ar) \\bmod (p-1)\\), on a que: \\(m_h \\equiv (ar + ks) \\bmod (p-1)\\) et \\(v_2 = \\alpha^{H(m)} \\bmod p\\). Si, comme on souhaite montrer \\(m_h = H(m)\\), en réduisant les exposants mod \\((p-1)\\), on peut réécrire \\(v_2\\): \\(v_2 \\equiv \\alpha^{ar+ks} \\bmod p\\). D’autre part: \\(v_1 = y^r\\alpha^{rs} \\equiv \\alpha^{ar}\\alpha^{ks} \\equiv \\alpha^{ar+ks} \\bmod p\\).\nLe procédé d’ElGamal se base sur la difficulté de calculer des logarithmes discrets modulo un nombre premier (problème DLP) même s’il n’a pas été prouvé qu’il soit strictement équivalent à ce problème.\nLes algorithmes les plus efficaces connus ont une complexité sub-exponentielle très proche de celle de la factorisation (on utilise souvent les mêmes algorithmes).\nLes exposants choisis (\\(k\\), \\(a\\)) doivent être de grande taille car il existe des algorithmes efficaces pour calculer des logarithmes discrets modulo un nombre premier lorsque l’exposant est petit (baby-step giant-step algorithm).\nUn inconvénient d’ElGamal est qu’il multiplie par 2 la longueur du ciphertext.\nIl est essentiel pour la sécurité du procédé que le nombre aléatoire \\(k\\) ne soit pas répété, autrement: soient \\((\\gamma_1, \\delta_1)\\) et \\((\\gamma_2, \\delta_2)\\) les deux ciphertexts générés, on a que \\(\\delta_1/\\delta_2 = m_1/m_2\\) et par conséquent, il est trivial de retrouver un plaintext à partir de l’autre.\nLe procédé d’ElGamal peut se généraliser à d’autres groupes comme \\(GF(2^n)\\) ou les courbes elliptiques.\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Remarques\n\n\n\n\n\nÉquivalence : basé sur DLP (non prouvé équivalent)\n\\(k\\) unique : CRITIQUE - sinon \\(m_1/m_2\\) révélé\nTaille clés : exposants grands nécessaires\nExtensions : \\(GF(2^n)\\), courbes elliptiques"
  },
  {
    "objectID": "exam_notes_fr.html#procédé-dencryptiondecryption-delgamal",
    "href": "exam_notes_fr.html#procédé-dencryptiondecryption-delgamal",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Procédé d’Encryption/Decryption d’ElGamal",
    "text": "Procédé d’Encryption/Decryption d’ElGamal\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère un nombre premier \\(p\\) (len(\\(p\\)) ≥ 1024 bits) et un générateur \\(\\alpha\\) du groupe multiplicatif \\(\\mathbb{Z}_p^*\\)\nA génère un nombre aléatoire \\(a\\), t.q. \\(1 \\leq a \\leq p-2\\) et calcule \\(y := \\alpha^a \\bmod p\\)\nLa clé publique de A est \\((p, \\alpha, y)\\), la clé privée de A est \\(a\\)\n\nEncryption\n\nL’entité B obtient \\((p, \\alpha, \\alpha^a \\bmod p)\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nPour chaque message \\(m_i\\) :\n\nB génère un nombre aléatoire unique \\(k\\), t.q. \\(1 \\leq k \\leq p-2\\)\nB calcule \\(\\gamma := \\alpha^k \\bmod p\\) et \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) et envoie le ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA utilise sa clé privée \\(a\\) pour calculer \\(\\gamma^{p-1-a} \\bmod p\\) (à noter que: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrouve le plaintext en calculant: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)"
  },
  {
    "objectID": "exam_notes_fr.html#algorithme-de-rabin",
    "href": "exam_notes_fr.html#algorithme-de-rabin",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Algorithme de Rabin",
    "text": "Algorithme de Rabin\nSystème asymétrique équivalent à la factorisation (provably secure).\nClés :\n\nGénérer deux premiers \\(p\\), \\(q\\) (≥1024 bits total), calculer \\(n = pq\\)\n\nPublique : \\(n\\)\nPrivée : \\((p, q)\\)\n\n\nChiffrement : \\(c = m^2 \\bmod n\\)\nDéchiffrement :\n\nCalculer les 4 racines carrées de \\(c \\bmod n\\) (via racines mod \\(p\\) et mod \\(q\\))\nIdentifier le bon message par redondance\n\n\n\n\n\n\n\nNoteTexte original du cours\n\n\n\n\n\nProcédé d’Encryption/Decryption de Rabin\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère deux nombres premiers aléatoires \\(p\\) et \\(q\\) de grande taille (len(\\(pq\\)) ≥ 1024)\nA calcule \\(n := pq\\)\nLa clé publique de A est \\(n\\), la clé privée de A est \\((p, q)\\)\n\nEncryption\n\nL’entité B obtient \\(n\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB calcule \\(c_i = m_i^2 \\bmod n\\) pour chaque message \\(m_i\\)\nB envoie tous les ciphertext \\(c_i\\) à A\n\nDecryption\n\nA utilise sa clé privée \\((p, q)\\) pour retrouver les 4 solutions de l’équation: \\(c_i = x^2 \\bmod n\\) en utilisant des algorithmes efficaces pour calculer des racines carrées \\(\\bmod p\\) et \\(\\bmod q\\)\nA détermine soit par une indication supplémentaire de B, soit par une analyse de redondance lequel des 4 messages \\(m_1, m_2, m_3, m_4\\) est le plaintext original\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBase : SQROOTP (racine carrée mod composite)\nAvantage : équivalent prouvé à factorisation\nProblème : 4 solutions possibles, nécessite redondance\nVulnérabilité : attaque chosen-ciphertext révèle facteurs\n\n\n\n\nRemarques essentielles\n\nSécurité prouvée : SQROOTP ⟺ FACTP (seul algorithme avec équivalence prouvée)\nAttaque chosen-ciphertext : si A décrypte \\(c = m^2 \\bmod n\\) choisi par adversaire M\n\nM reçoit une racine \\(m_x\\) parmi 4 possibles\nSi \\(m \\neq m_x \\bmod n\\) (prob. 0.5), alors \\(\\gcd(m - m_x, n)\\) donne un facteur de \\(n\\)\n\nSolution : exiger redondance suffisante pour identifier solution unique sans ambiguïté\n\n\n\n\n\n\n\nNoteTexte original - Remarques\n\n\n\n\n\nLe procédé de Rabin est basé sur l’impossibilité de trouver des racines carrées modulo un composite de factorisation inconnue (problème SQROOTP).\nL’intérêt principal de cet algorithme réside dans le fait qu’il a été prouvé comme étant équivalent à la factorisation (SQROOTP ⟺ FACTP). Cet algorithme appartient donc à la catégorie provably secure pour toute attaque passive.\nLes attaques actives peuvent, dans certains cas, compromettre la sécurité de l’algorithme. Plus précisément, si on monte l’attaque chosen ciphertext suivant:\n\nL’attaquant M génère un \\(m\\) et envoie à A le ciphertext \\(c = m^2 \\bmod n\\).\nA répond avec une racine \\(m_x\\) parmi les 4 possibles \\(m_1, m_2, m_3, m_4\\).\nSi \\(m \\neq m_x \\bmod n\\) (probabilité 0.5), M recommence avec un nouveau \\(m\\).\nSinon, A calcule \\(\\gcd(m - m_x, n)\\) et obtient ainsi un des deux facteurs de \\(n\\).\n\nCette attaque pourrait être évitée si le procédé exigeait une redondance suffisante dans les plaintexts permettant à A d’identifier sans ambiguïté laquelle des solutions possibles est le plaintext original. Dans ce cas, A répondrait toujours \\(m\\) et jetterait les autres solutions n’ayant pas le niveau de redondance préétabli.\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Remarques\n\n\n\n\n\nUnique : seul algorithme prouvé équivalent à FACTP\nAttaque : chosen-ciphertext donne facteurs (prob. 0.5)\nParade : redondance obligatoire dans messages"
  },
  {
    "objectID": "exam_notes_fr.html#procédé-dencryptiondecryption-de-rabin",
    "href": "exam_notes_fr.html#procédé-dencryptiondecryption-de-rabin",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Procédé d’Encryption/Decryption de Rabin",
    "text": "Procédé d’Encryption/Decryption de Rabin\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère deux nombres premiers aléatoires \\(p\\) et \\(q\\) de grande taille (len(\\(pq\\)) ≥ 1024)\nA calcule \\(n := pq\\)\nLa clé publique de A est \\(n\\), la clé privée de A est \\((p, q)\\)\n\nEncryption\n\nL’entité B obtient \\(n\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB calcule \\(c_i = m_i^2 \\bmod n\\) pour chaque message \\(m_i\\)\nB envoie tous les ciphertext \\(c_i\\) à A\n\nDecryption\n\nA utilise sa clé privée \\((p, q)\\) pour retrouver les 4 solutions de l’équation: \\(c_i = x^2 \\bmod n\\) en utilisant des algorithmes efficaces pour calculer des racines carrées \\(\\bmod p\\) et \\(\\bmod q\\)\nA détermine soit par une indication supplémentaire de B, soit par une analyse de redondance lequel des 4 messages \\(m_1, m_2, m_3, m_4\\) est le plaintext original"
  },
  {
    "objectID": "exam_notes_fr.html#comparaison-rsa---elgamal---rabin",
    "href": "exam_notes_fr.html#comparaison-rsa---elgamal---rabin",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Comparaison RSA - ElGamal - Rabin",
    "text": "Comparaison RSA - ElGamal - Rabin\n\n\n\n\n\n\n\n\n\nCritère\nRSA\nElGamal\nRabin\n\n\n\n\nProblème\nRSAP\nDLP\nSQROOTP\n\n\nSécurité\nÉquiv. factorisation (cas générique)\nBasée sur DLP\nProuvée ⟺ factorisation\n\n\nExpansion\n1:1\n1:2\n1:1\n\n\nDéchiffrement\nDéterministe\nDéterministe\n4 solutions\n\n\nSignature\nOui\nOui\nOui (avec précautions)"
  },
  {
    "objectID": "exam_notes_fr.html#courbes-elliptiques-idée-de-base",
    "href": "exam_notes_fr.html#courbes-elliptiques-idée-de-base",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Courbes Elliptiques (Idée de base)",
    "text": "Courbes Elliptiques (Idée de base)\n\nConcept fondamental\nUne courbe elliptique \\(E\\) est définie par : \\(y^2 = x^3 + ax + b\\) (avec discriminant \\(4a^3 + 27b^2 \\neq 0\\)).\nOpération clé : Addition de points\n\nGéométriquement : tracer une droite entre deux points \\(P\\) et \\(Q\\), trouver le 3ᵉ point d’intersection, puis prendre son symétrique\nForme un groupe commutatif avec point à l’infini \\(\\mathcal{O}\\) comme identité\nMultiplication scalaire : \\(kP = P + P + ... + P\\) (\\(k\\) fois)\n\nAvantage cryptographique :\n\nLe problème ECDLP : trouver \\(k\\) tel que \\(Q = kP\\) est très difficile (effort exponentiel)\nClés plus courtes pour même sécurité qu’en \\(\\mathbb{Z}_p^*\\)\n\n\n\n\n\n\n\nNoteTexte original - Définition\n\n\n\n\n\nUne courbe elliptique est un ensemble de points \\(E\\) défini par l’équation: \\(y^2 = x^3 + ax + b\\), avec \\(x, y, a\\) et \\(b\\) des nombres rationnels, entiers ou entiers modulo \\(m\\) (\\(m &gt; 1\\)). L’ensemble \\(E\\) contient également un “point à l’infini” noté \\(\\mathcal{O}\\). Le point \\(\\mathcal{O}\\) n’est pas dans la courbe mais il est l’élément identité de \\(E\\).\nOn choisira pour nos calculs les courbes elliptiques n’ayant pas de racines multiples ou, en d’autres termes, des courbes où le discriminant \\(4a^3 + 27b^2 \\neq 0\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Concept\n\n\n\n\n\nÉquation : \\(y^2 = x^3 + ax + b\\)\nStructure : groupe avec \\(\\mathcal{O}\\)\nOpération : addition géométrique\nProblème dur : ECDLP\n\n\n\n\n\nAddition sur courbes elliptiques\nSoit \\(P := (x, y) \\in E\\), on définit \\(-P := (x, -y)\\) (symétrique par rapport à l’axe des \\(x\\)). On a \\(P + (-P) = \\mathcal{O}\\).\nPour deux points \\(P, Q \\in E\\) avec \\(Q \\neq -P\\), on définit \\(P + Q := R\\) où \\(-R\\) est le 3ᵉ point d’intersection entre la courbe et la droite passant par \\(P\\) et \\(Q\\).\nPour le doublement : \\(2P = R\\) où \\(-R\\) est le point d’intersection de la courbe avec la tangente à la courbe au point \\(P\\).\n\n\n\n\n\n\nNoteTexte original - Addition\n\n\n\n\n\nSoit \\(P := (x, y) \\in E\\), on définit \\(-P\\) comme \\(-P := (x, -y)\\). Graphiquement, \\(-P\\) est le point symétrique de \\(P\\) par rapport à l’axe des \\(x\\). À noter que \\(P + (-P) = \\mathcal{O}\\).\nSoient deux points \\(P, Q \\in E\\), tels que \\(Q \\neq -P\\), on définit l’addition \\(P + Q := R\\) où \\(R \\in E\\) tel que \\(-R\\) est le 3ᵉ point d’intersection entre la courbe et la droite qui passe par \\(P\\) et \\(Q\\).\nL’ensemble \\(E\\) avec \\(\\oplus\\) définit un groupe commutatif pour l’addition.\nSoit \\(P \\in E\\), le point \\(2P = R\\), tel que \\(-R\\) est le point d’intersection de la courbe avec la droite tangente à la courbe au point \\(P\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Addition\n\n\n\n\n\nInverse : \\(-P = (x, -y)\\)\nAddition : 3ᵉ point d’intersection + symétrie\nDoublement : tangente + symétrie\nPropriété : groupe commutatif\n\n\n\n\n\nECDLP et avantages cryptographiques\nLorsque la courbe elliptique est définie sur le corps \\(\\mathbb{Z}_p\\) avec \\(p\\) premier de grande taille (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), le calcul de \\(k \\in \\mathbb{Z}_p\\) tel que \\(Q = kP\\) avec \\((P, Q)\\) connus est très difficile (effort exponentiel). Ce problème est le Elliptic Curve Discrete Logarithm Problem (ECDLP).\nAvantage principal : taille des clés beaucoup plus petite pour une sécurité équivalente.\n\n\n\n\n\n\nNoteTexte original - ECDLP et avantages\n\n\n\n\n\nLorsque la courbe elliptique est définie sur le corps \\(\\mathbb{Z}_p\\) avec \\(p\\) un nombre premier de grande taille (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), le calcul de \\(k \\in \\mathbb{Z}_p\\) tel que \\(Q = kP\\) avec \\((P, Q)\\) connus, est très difficile (nécessite un effort exponentiel). Ce problème est connu comme: Elliptic Curve Discrete Logarithm Problem (ECDLP).\nL’avantage principal de la cryptographie publique basée sur des courbes elliptiques est que la taille des nombres utilisés (et donc, des clés) est plus petite.\nCeci est dû à la complexité accrue des calculs sur \\(E_p\\) (courbe elliptique définie sur le corps \\(\\mathbb{Z}_p\\)) par rapport aux corps habituels tels que \\(\\mathbb{Z}_p\\) ou \\(GF(2^m)\\).\nLa représentation d’un plaintext en points de la courbe reste une opération complexe.\nEn Octobre 2003, la US National Security Agency (NSA) a acheté un brevet de Certicom pour l’utilisation de la cryptographie à courbes elliptiques.\nEn Septembre 2013 Claus Diem montré que sous certaines conditions le problème ECDLP pouvait être résolu en temps sub-exponentiel.\n\n\n\n\n\n\n\n\n\nTipRévision rapide - ECDLP\n\n\n\n\n\nProblème : trouver \\(k\\) dans \\(Q = kP\\) (exponentiel)\nGain : clés ~6-10× plus courtes\nLimite : représenter messages en points difficile\nNSA : adopté en 2003\n\n\n\n\n\nTableau de comparaison des tailles de clés\n\n\n\nAES (symétrique)\nRSA/DH\nCourbes Elliptiques\nRapport\n\n\n\n\n56 bits\n512 bits\n112 bits\n1:4.6\n\n\n80 bits\n1024 bits\n160 bits\n1:6.4\n\n\n112 bits\n2048 bits\n224 bits\n1:9.1\n\n\n128 bits\n3072 bits\n256 bits\n1:12\n\n\n256 bits\n15360 bits\n512 bits\n1:30\n\n\n\n\n\n\n\n\n\nNoteTexte original - Tableau\n\n\n\n\n\nCe tableau montre les rapports des tailles des clés par rapport à celles de RSA pour une sécurité équivalente.\n(Tableau extrait du document original)"
  },
  {
    "objectID": "exam_notes_fr.html#elgamal-sur-courbes-elliptiques",
    "href": "exam_notes_fr.html#elgamal-sur-courbes-elliptiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "ElGamal sur Courbes Elliptiques",
    "text": "ElGamal sur Courbes Elliptiques\n\nAdaptation directe\nRemplacer opérations dans \\(\\mathbb{Z}_p^*\\) par opérations sur \\(E_p\\)\nClés :\n\nChoisir courbe \\(E_p\\) et point \\(P_0 \\in E_p\\) de grand ordre\nSecret \\(x\\), calculer \\(P_a = xP_0\\)\nPublique : \\((E_p, P_0, P_a)\\) | Privée : \\(x\\)\n\nChiffrement : Pour message \\(m_i \\in E_p\\)\n\nChoisir \\(k\\) aléatoire\n\\(\\gamma = kP_0\\), \\(\\delta = kP_a + m_i\\)\nEnvoyer \\((\\gamma, \\delta)\\)\n\nDéchiffrement : \\(m_i = \\delta - x\\gamma\\)\n\n\n\n\n\n\nNoteTexte original - ElGamal EC\n\n\n\n\n\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA choisit une courbe elliptique \\(E_p\\) avec \\(p\\), un nombre premier de grande taille (len(\\(p\\)) bits) et un point \\(P_0 \\in E_p\\).\nA génère un nombre aléatoire \\(x\\), tel que \\(1 \\leq x \\leq p\\) et calcule \\(P_a = xP_0\\) (multiplication par un scalaire sur \\(E_p\\), pour laquelle, il existe des algorithmes efficaces).\nLa clé publique de A est \\((E_p, P_0, P_a)\\), la clé privée de A est \\(x\\).\n\nEncryption\nL’entité B obtient \\((E_p, P_0, P_a)\\), la clé publique authentique de A.\n\nB transforme son plaintext en une série d’entiers \\(m_i\\), tel que \\(m_i \\in E_p\\) pour tout \\(i\\).\nPour chaque message \\(m_i\\) :\n\nB génère un nombre aléatoire unique \\(k\\), tel que \\(1 \\leq k \\leq p\\).\nB calcule \\(\\gamma := kP_0\\) et \\(\\delta := kP_a + m_i\\) et envoie le ciphertext \\(c := (\\gamma, \\delta)\\).\n\n\nDecryption\n\nA utilise sa clé privée \\(x\\) pour calculer: \\(x\\gamma = xkP_0 = kP_a\\).\nA retrouve le plaintext en calculant: \\(\\delta - kP_a = kP_a + m_i - kP_a = m_i\\).\n\nLa sécurité du schéma s’appuie sur ECDLP !\nIl est également nécessaire d’authentifier les parties publiques échangées afin d’éviter les attaques man-in-the middle précédemment décrites.\nLes propriétés du protocole sont identiques au cas \\(\\mathbb{Z}_p^*\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide - ElGamal EC\n\n\n\n\n\nPrincipe : même qu’ElGamal sur \\(E_p\\)\nOpérations : + et × scalaire sur points\nSécurité : ECDLP\nAuthentification : nécessaire contre MitM\nAvantage : clés courtes"
  },
  {
    "objectID": "exam_notes_fr.html#fonctions-à-sens-unique-one-way-functions",
    "href": "exam_notes_fr.html#fonctions-à-sens-unique-one-way-functions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fonctions à Sens Unique (One-Way Functions)",
    "text": "Fonctions à Sens Unique (One-Way Functions)\nUne fonction \\(f\\) est à sens unique si \\(f(x) = y\\) est facile à calculer, mais trouver \\(x\\) à partir de \\(y\\) est calculatoirement impossible pour la majorité des valeurs.\nExemples :\n\nCarrés modulo composite : \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\)\nConstruction DES : \\(y = E_k(x) \\oplus x\\) avec \\(k\\) fixée et connue\n\nNote : OWF ≠ OWHF (les hash functions imposent compression et 2nd-preimage resistance).\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUne fonction f est dite à sens unique (one-way function ou OWF) si \\(x \\in X\\) on peut facilement calculer \\(f(x) = y\\) mais pour la grande majorité des \\(y \\in Y\\) il est calculatoirement impossible de trouver un \\(x\\) tel que \\(f(x) = y\\).\nExemples:\n\ncalcul des carrées modulo un composite: \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\) (p et q inconnus) est une one-way function car l’inverse est difficile (voir le problème de base SQROOTP).\non peut construire une one-way function sur la base de DES ou de n’importe quel autre système de cryptage à blocs \\(E\\) comme suit: \\(y = f(x) = E_k(x) \\oplus x\\), \\(\\forall x\\), avec \\(k\\) une clé fixée et connue. On peut considérer que \\(E_k(x) \\oplus x\\) a un comportement (pseudo) aléatoire par construction de \\(E\\). Le calcul de l’inverse revient à trouver un \\(x\\) tel que: \\(x = E_k^{-1}(x \\oplus y)\\), ce qui est considéré difficile avec les propriétés de \\(E\\). A noter que \\(f(x) = E_k(x)\\) ne suffirait pas pour en faire une OWF car, en connaissant la clé, DES est réversible.\n\nOWF ≠ OWHF: A noter qu’une OWHF en tant que hash function impose des restrictions supplémentaires sur les domaines sources et image ainsi que sur la 2nd-preimage resistance qui ne sont pas forcement respectés par des OWFs.\nExemple: \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\) (p et q inconnus) n’est pas une OWHF car étant donné \\(x\\), \\(-x\\) est une collision triviale.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nOWF : facile dans un sens (\\(f(x) \\to y\\)), impossible dans l’autre (\\(y \\to x\\)).\nExemples : carrés modulaires, \\(E_k(x) \\oplus x\\).\nOWF ≠ OWHF (hash functions = plus de contraintes)."
  },
  {
    "objectID": "exam_notes_fr.html#hash-functions-définitions",
    "href": "exam_notes_fr.html#hash-functions-définitions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hash Functions : Définitions",
    "text": "Hash Functions : Définitions\nUne hash function \\(h\\) possède deux propriétés essentielles :\n\nCompression : transforme des données de longueur arbitraire en sortie de longueur fixe\nFacilité de calcul : \\(h(x)\\) est rapide à calculer\n\nClassification :\n\nUnkeyed (sans clé) : MDC (Manipulation Detection Code)\nKeyed (avec clé) : MAC (Message Authentication Code)\n\nPropriétés de sécurité :\n\nPreimage resistance : étant donné \\(y\\), impossible de trouver \\(x\\) tel que \\(h(x) = y\\)\n2nd-preimage resistance (weak collision) : étant donné \\(x\\), impossible de trouver \\(x' \\neq x\\) tel que \\(h(x) = h(x')\\)\nCollision resistance (strong collision) : impossible de trouver \\(x \\neq x'\\) quelconques avec \\(h(x) = h(x')\\)\n\nTerminologie :\n\nOWHF (weak one-way) : satisfait (1) et (2)\nCRHF (strong one-way) : satisfait (2) et (3)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUne fonction de hachage (hash function) est une fonction \\(h\\) ayant les propriétés suivantes:\n\ncompression: la fonction \\(h\\) fait correspondre à un ensemble \\(X\\) composée par des chaînes de bits de longueur finie mais arbitraire, un ensemble \\(Y\\) composé par des chaînes de bits de longueur finie et fixée (et normalement inférieur à la taille de \\(X\\)) avec \\(h(x) = y\\), et \\(x \\in X\\), \\(y \\in Y\\).\nfacile à calculer: partant de \\(h\\) et \\(x \\in X\\), \\(h(x)\\) est facile à calculer.\n\nUne hash function est dite “à clé” (keyed hash function) si une clé intervient dans le calcul de la fonction (\\(h_k(x) = y\\)); sinon on l’appelle “sans clé” (unkeyed hash function).\nLes hash functions ont des nombreuses applications informatiques dont l’archivage structuré facilitant la recherche. Coté sécurité nous allons étudier deux catégories principales:\n\ncodes détecteurs d’altérations (manipulation detection codes (MDC) or message integrity codes (MIC)): ce sont des unkeyed functions permettant de fournir un service d’intégrité sous certaines conditions. Le résultat d’une telle fonction est appelée MDC-value ou, simplement, digest.\ncodes d’authentification de message (message authentication codes ou MAC) qui sont des keyed functions permettant d’authentifier la source du message et d’assurer son intégrité sans utiliser des mécanismes (cryptage) additionnels.\n\nQuelques propriétés de base des hash functions:\n\n1) preimage resistance: étant donné un \\(y \\in Y\\), il est calculatoirement impossible de trouver une pré-image \\(x \\in X\\) satisfaisant \\(h(x) = y\\).\n2) 2nd-preimage resistance: étant donné un \\(x \\in X\\) et son image \\(y \\in Y\\), avec \\(h(x) = y\\), il est calculatoirement impossible de trouver un \\(x' \\neq x\\) tel que \\(h(x) = h(x')\\). Aussi appelée weak collision resistance.\n3) collision résistance: il est calculatoirement impossible de trouver deux pré-images \\(x, x' \\in X\\) distinctes pour lesquels \\(h(x) = h(x')\\) (pas de restriction sur le choix des valeurs). Aussi appelée strong collision resistance.\n\nUne fonction de hachage à sens unique (one way hash function ou OWHF) est un MDC satisfaisant 1) et 2). Aussi appelée: weak one-way hash function.\nUne fonction de hachage résistante aux collisions (collision resistant hash function ou CRHF) est un MDC satisfaisant le propriétés 2) et 3). (A noter que 3) ⇒ 2)). Aussi appelée: strong one-way hash function.\nOWF ≠ OWHF: A noter qu’une OWHF en tant que hash function impose des restrictions supplémentaires sur les domaines sources et image ainsi que sur la 2nd-preimage resistance qui ne sont pas forcement respectés par des OWFs.\nExemple: \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\) (p et q inconnus) n’est pas une OWHF car étant donné \\(x\\), \\(-x\\) est une collision triviale.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nHash function : compression + calcul facile\nMDC (sans clé) pour intégrité\nMAC (avec clé) pour authentification\nPropriétés\n\npreimage resistance\n2nd-preimage resistance\ncollision resistance\n\nOWHF = (1)+(2)\nCRHF = (2)+(3)."
  },
  {
    "objectID": "exam_notes_fr.html#message-authentication-codes-macs",
    "href": "exam_notes_fr.html#message-authentication-codes-macs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Message Authentication Codes (MACs)",
    "text": "Message Authentication Codes (MACs)\nUn MAC est une famille de fonctions \\(h_k\\) paramétrées par une clé secrète \\(k\\) :\nPropriétés :\n\nCompression : entrée arbitraire → sortie fixe\nFacile à calculer : avec \\(k\\) connue, \\(h_k(x)\\) est rapide\nComputation-resistance : sans \\(k\\), impossible de calculer des paires \\((x, h_k(x))\\) valides\n\nImplications :\n\nKey non-recovery : impossible de retrouver \\(k\\) à partir de paires \\((x_i, h_k(x_i))\\)\nPreimage et collision resistance pour quiconque ne possède pas \\(k\\)\n\nUsage : Authentification d’origine + intégrité des messages sans révéler de secret directement.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUn Message Authentication Code (MAC) est une famille de fonctions \\(h_k\\) paramétrisées par une clé secrète \\(k\\) ayant les propriétés suivantes:\n\n1) compression: comme pour les fonctions de hash génériques mais appliqué à \\(h_k\\).\n2) facile à calculer: à partir d’une fonction \\(h_k\\), et d’une clé connue \\(k\\), on peut facilement calculer \\(h_k(x)\\). Le résultat est appelée un MAC-value ou, simplement, un MAC.\n3) résistance calculatoire (computation-resistance): sans connaissance de la clé symétrique \\(k\\), il est (calculatoirement) impossible de calculer des paires \\((x, h_k(x))\\) à partir de 0 ou plusieurs paires connus \\((x_i, h_k(x_i))\\) pour tout \\(x \\neq x_i\\).\n\nLa propriété 3) implique que les paires \\((x_i, h_k(x_i))\\) ne peuvent non plus servir à calculer la clé \\(k\\) (key non-recovery). Cependant la propriété key non-recovery n’implique pas computation-resistance car des attaques chosen/known-plaintext pourraient mener à des paires \\((x, h_k(x))\\) falsifiées.\nL’impossibilité de calculer des paires \\((x, h_k(x))\\) se traduit également en preimage et collision resistance (cf. transparent précédent) pour toute entité ne possédant pas la clé \\(k\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nMAC = hash avec clé \\(k\\)\nSans \\(k\\) : impossible de forger \\((x, h_k(x))\\) ou retrouver \\(k\\)\nGarantit authentification d’origine + intégrité."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-mdcs",
    "href": "exam_notes_fr.html#attaques-sur-les-mdcs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les MDCs",
    "text": "Attaques sur les MDCs\n\nAttaque 2nd-Preimage Resistance\nProblème : Étant donné \\(h(x) = y\\), trouver \\(x'\\) tel que \\(h(x') = h(x)\\).\nAnalyse probabiliste :\nPour un digest de \\(m\\) bits (\\(n = 2^m\\) sorties possibles), la probabilité d’avoir au moins une collision après \\(k\\) essais est :\n\\[P(\\text{collision}) \\approx 1 - (1-1/n)^k \\approx k/n\\]\nPour \\(P = 0.5\\) : \\(k = n/2 = 2^{m-1}\\)\nConclusion : Pour un digest de \\(m\\) bits, il faut environ \\(2^{m-1}\\) essais pour trouver une 2nd-preimage avec probabilité 0.5.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nProblème: étant donné \\(h(x) = y\\), trouver \\(x'\\) tel que \\(h(x')=h(x)\\).\nExemple pratique: on a un texte avec un digest associé portant une signature digitale; on veut créer un faux texte portant la même signature (sans avoir le contrôle sur le texte original). Quelles sont nos chances d’un point de vue probabiliste?\nSoit une hash function \\(h\\) avec \\(n\\) sorties possibles et une valeur donnée \\(h(x)\\). Si \\(h\\) est appliquée à \\(k\\) valeurs aléatoires, quelle doit être la valeur de \\(k\\) pour que la probabilité d’avoir au moins un \\(y\\) tel que \\(h(x) = h(y)\\) soit 0.5?\nPour la première valeur de \\(y\\), la probabilité que \\(h(x) = h(y)\\) est \\(1/n\\). Inversement, la probabilité que \\(h(x) \\neq h(y)\\) est \\(1-1/n\\). Pour \\(k\\) valeurs, la probabilité de n’avoir aucune collision est de: \\((1-1/n)^k\\), soit:\n\\[\\left(1 - \\frac{1}{n}\\right)^k = 1 - \\frac{k}{n} + \\frac{1}{2!}\\left(\\frac{k}{n}\\right)^2 - \\frac{1}{3!}\\left(\\frac{k}{n}\\right)^3 + \\ldots\\]\nce qui pour \\(n\\) très grand peut être approché par \\(1 - k/n\\). Par conséquent, la probabilité complémentaire d’avoir au moins une collision est d’environ \\(k/n\\); c’est qui nous donne \\(k = n/2\\) pour une probabilité de 0.5.\nConclusion: pour un digest de \\(m\\) bits, le nombre d’essais nécessaires à trouver un \\(y\\) tel que \\(h(x) = h(y)\\) avec une probabilité de 0.5 est \\(2^{m-1}\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nPour casser 2nd-preimage resistance avec digest de \\(m\\) bits : \\(2^{m-1}\\) essais (prob 0.5).\n\n\n\n\n\nAttaque Collision Resistance : Birthday Paradox\nProblème : Trouver deux valeurs distinctes \\(x, x'\\) telles que \\(h(x) = h(x')\\).\nParadoxe d’anniversaire : Dans un groupe de 23 personnes, probabilité &gt; 0.5 d’avoir deux anniversaires identiques.\nRésultat mathématique :\nPour \\(n\\) sorties possibles, la probabilité de collision après \\(k\\) calculs :\n\\[P(\\text{au moins 1 collision}) = 1 - e^{-k(k-1)/(2n)}\\]\nPour \\(P \\geq 0.5\\) : \\(k \\approx 1.17\\sqrt{n}\\)\nConséquence cryptographique : Pour un digest de \\(m\\) bits (\\(n = 2^m\\) sorties), il faut environ \\(2^{m/2}\\) calculs pour trouver une collision avec probabilité &gt; 0.5.\nExemple pratique : Modification d’un contrat en 237 variations pour trouver une version frauduleuse ayant le même digest que la version légitime.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nProblème: trouver deux valeurs \\(x, x'\\) distincts tel que \\(h(x) = h(x')\\).\nExemple pratique: On doit faire signer un texte à quelqu’un et on veut appliquer cette signature à un texte falsifié (on contrôle le texte original). Quelles sont nos chances de trouver deux textes originaux satisfaisant ce critère?\nLe birthday paradox est un problème probabiliste classique qui montre que dans une réunion de 23 personnes seulement, on a déjà une chance sur deux d’avoir deux personnes ayant leur anniversaire le même jour.\nSoit \\(y_1, y_2,..., y_n\\) toutes les sorties possibles d’une hash function. Combien des \\(h(x_i)\\): \\(h(x_1), h(x_2),...,h(x_k)\\) devons nous calculer pour avoir une probabilité de collision égale ou supérieure à 0.5 ?\nLe premier choix pour \\(h(x_1)\\) est arbitraire (prob = 1), le deuxième \\(h(x_2) \\neq h(x_1)\\) a une probabilité de \\(1 - 1/n\\), le troisième de \\(1 - 2/n\\), etc. Ce qui nous donne une probabilité de ne pas avoir des collisions égale à:\n\\[P_{\\text{no collision}} = \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right)\\]\nOn prouve facilement (développement en série de \\(e^{-x}\\)) que pour \\(0 \\leq x \\leq 1\\): \\(1-x \\leq e^{-x}\\) et donc:\n\\[P_{\\text{no coll}} \\leq \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right) \\leq \\prod_{i=1}^{k-1} e^{-i/n} = e^{-k(k-1)/(2n)}\\]\nLa probabilité d’avoir au moins une collision est \\(P_{\\text{au-moins1}} = 1 - P_{\\text{no-coll}}\\). Pour connaître la valeur de \\(k\\) pour laquelle \\(P_{\\text{au-moins1}}\\) est plus grand que 0.5, il suffit de calculer:\n\\[\\frac{1}{2} \\leq 1 - e^{-k(k-1)/(2n)}\\]\nSi \\(k\\) est grand, on remplace \\(k(k-1)\\) par \\(k^2\\) et on obtient après des calculs simples:\n\\[k \\geq \\sqrt{2\\ln(2) \\cdot n} \\approx 1.17\\sqrt{n}\\]\nEn prenant \\(n = 365\\) pour l’anniversaire, on obtient \\(k = 22.3\\), ce qui confirme l’énoncé du problème.\nConséquence pour les hash functions: Soit une hash function avec \\(2^m\\) sorties possibles. Si \\(h\\) est appliqué à \\(k = 2^{m/2}\\) entrées on a une probabilité supérieur à 0.5 d’obtenir \\(h(x_i) = h(x_j)\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBirthday paradox : pour casser collision resistance avec digest de \\(m\\) bits : \\(2^{m/2}\\) essais (prob &gt; 0.5).\nExemple : 23 personnes suffisent pour anniversaires identiques."
  },
  {
    "objectID": "exam_notes_fr.html#résistance-calculatoire-récapitulatif",
    "href": "exam_notes_fr.html#résistance-calculatoire-récapitulatif",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Résistance Calculatoire : Récapitulatif",
    "text": "Résistance Calculatoire : Récapitulatif\nPour une hash function avec digest de \\(n\\) bits et clé MAC de \\(t\\) bits :\n\n\n\nType\nPropriété\nDifficulté\nTaille conseillée\n\n\n\n\nOWHF\nPreimage\n\\(2^n\\)\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage\n\\(2^{n-1}\\)\n\n\n\nCRHF\nCollision\n\\(2^{n/2}\\)\n\\(n \\geq 256\\) bits\n\n\nMAC\nKey recovery\n\\(2^t\\)\n\\(t \\geq 256\\) bits\n\n\n\nComputation\n\\(\\min(2^t, 2^n)\\)\n\\(n \\geq 128\\) bits\n\n\n\nImplications pratiques :\n\nPour intégrité seule (OWHF) : 128 bits suffisent\nPour résistance aux collisions (CRHF) : minimum 256 bits\nMACs : clé de 256 bits, digest de 128 bits minimum\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\n\\(n\\): taille du MDC-value ou du MAC-value résultant de l’application de la hash function\n\\(t\\): taille de la clé du MAC\n\n\n\n\n\n\n\n\n\n\nType de Hash Fct.\nCaractéristique\nDifficulté Calculatoire\nBut de l’attaque\nTaille conseillée du digest/clé\n\n\n\n\nOWHF\npreimage resistance\n\\(2^n\\)\ntrouver une préimage\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage résistance\n\\(2^{n-1}\\)\ntrouver \\(x'\\) avec \\(h(x') = h(x)\\)\n\n\n\nCRHF\ncollision resistance\n\\(2^{n/2}\\)\ntrouver une collision\n\\(n \\geq 256\\) bits\n\n\nMAC\nkey non-recovery\n\\(2^t\\)\ntrouver la clé\n\\(n \\geq 128\\)\n\n\n\ncomputation resistance\n\\(\\min(2^t,2^n)\\)\nproduire un \\((x, h_k(x))\\)\n\\(t \\geq 256\\)\n\n\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nEfforts : preimage \\(2^n\\), 2nd-preimage \\(2^{n-1}\\), collision \\(2^{n/2}\\).\nTailles : OWHF ≥128 bits, CRHF ≥256 bits, MAC clé ≥256 bits."
  },
  {
    "objectID": "exam_notes_fr.html#mdcs-basés-sur-des-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#mdcs-basés-sur-des-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "MDCs Basés sur des Systèmes de Cryptage",
    "text": "MDCs Basés sur des Systèmes de Cryptage\nPrincipe : Utiliser un algorithme de cryptage symétrique (DES, AES) pour construire un MDC.\nDéfis à résoudre :\n\nCasser la réversibilité des algorithmes symétriques\nAugmenter la largeur nominale (DES = 64 bits insuffisant pour CRHF)\n\nFonctionnement :\n\nTraitement séquentiel des blocs\nOpérations de chaînage avec XOR\nCombinaison de \\(n\\) boîtes pour digests de taille \\(n \\times\\) largeur nominale\n\nModèles classiques :\n\nMatyas-Meyer-Oseas : \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1}\\)\nDavies-Meyer : \\(H_i = E_{m_i}(H_{i-1}) \\oplus m_i\\)\nMiyaguchi-Preneel : \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1} \\oplus m_i\\)\n\nExemples pratiques :\n\nMDC-2 : utilise 2 boîtes DES → digest 128 bits\nMDC-4 : utilise 4 boîtes DES → digest 128 bits\n\nLimitation : Sécurité fortement dépendante de l’algorithme sous-jacent.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nIdée: utiliser un système de cryptage symétrique connu pour construire un MDC.\nProblèmes à résoudre:\n\nil faut “casser” la réversibilité des algorithmes symétriques pour en faire des OWHF ou des CRHF.\nLa “largeur nominale” de certains systèmes de cryptage (eg. DES) est de 64 bits, ce qui n’est pas suffisant pour construire des CRHF.\n\nPrincipe de fonctionnement:\n\nles blocs de texte sont séquentiellement traités par la “boîte” de cryptage.\nla compression se base sur des opérations de chaînage avec les blocs résultant des itérations précédentes et des fonctions logiques (fondamentalement XOR). Ceci rend également le procédé irréversible.\nSi nécessaire, \\(n\\) boîtes de cryptage seront combinées pour obtenir des longueurs de digests \\(n\\) fois supérieures à la largeur nominale des boîtes utilisées.\n\nAttention: la sécurité de ces algorithmes est fortement dépendante des propriétés des boîtes de cryptage sous-jacents.\nExemples:\n\nLes modèles de Matyas-Meyer-Oseas, Davies-Meyer et Miyaguchi-Preneel.\nMDC-2 et MDC-4 utilisant respectivement 2 et 4 boîtes DES. Digest = 128 bits.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nMDCs à partir de crypto symétrique : casser réversibilité + chaînage XOR.\nModèles : Matyas-Meyer-Oseas, Davies-Meyer, Miyaguchi-Preneel.\nMDC-2/4 avec DES → 128 bits."
  },
  {
    "objectID": "exam_notes_fr.html#customized-mdcs",
    "href": "exam_notes_fr.html#customized-mdcs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Customized MDCs",
    "text": "Customized MDCs\nFonctions conçues spécifiquement pour la génération de digests, optimisées pour vitesse et sécurité.\nÉléments de construction :\n\nPadding + ajout de la longueur du message\nConstantes prédéfinies pour augmenter la dispersion\nRounds successifs avec opérations logiques et rotations\nChaînage des sorties entre rounds\nChaque bit du digest dépend de chaque bit d’entrée\n\nAlgorithmes principaux :\n\n\n\nAlgorithme\nAnnée\nDigest\nStatut\n\n\n\n\nMD5\n1992\n128 bits\n❌ Cassé\n\n\nSHA-0\n1993\n160 bits\n❌ Collisions en \\(2^{39}\\)\n\n\nSHA-1\n1995\n160 bits\n⚠️ Collisions en \\(2^{63}\\)\n\n\nSHA-2\n-\n224-512 bits\n✓ Sûr actuellement\n\n\nSHA-3 (Keccak)\n2012\n224-512 bits\n✓ Standard actuel\n\n\n\nÉvolution des attaques :\n\n2004 : Collisions complètes sur MD5 (X. Wang)\n2005 : SHA-1 cassé théoriquement (\\(2^{63}\\) opérations)\n2008 : Création de certificats CA frauduleux via MD5\n2012 : SHA-3 adopté comme nouveau standard\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nIl s’agit de fonctions conçues exclusivement pour générer des codes d’intégrité (des digests) avec un soucis principal de vitesse et sécurité.\nLeur fonctionnement se base sur les éléments suivants:\n\ndes opérations d’initialisation (padding + rajouter la longueur).\nun ensemble de constantes prédéfinies choisies spécialement pour augmenter la dispersion.\nun ensemble “d’étapes” (rounds) qui vont séquentiellement s’appliquer a tous les blocs des données originaux. Ces rounds vont effectuer une combinaison d’opérations logiques et des rotations sur les données et les constantes.\ndes opérations de chaînage impliquant les sorties des rounds précédents.\n\nDans ces fonctions, chaque bit du digest est une fonction de chaque bit des entrées.\nLes plus connues sont:\n\nMD5: R. Rivest, 1992; RFC 1321. Digest = 128 bits. Cassé!\nSHA-0: NIST, 1993. Digest = 160 bits. Collisions en \\(2^{39}\\) opérations au lieu de \\(2^{80}\\)\nSHA-1: NIST, 1995. Digest = 160 bits. Révision de SHA-0 avec rotation de bits additionnelle. Collisions en \\(2^{63}\\) opérations (au lieu de \\(2^{80}\\)).\nSHA-2: NIST (FIPS 190-3). Comprend: SHA-224, SHA-256, SHA-384 et SHA-512. Les tailles du digest vont de 224 à 512 bits.\nSHA-3: Keccak Algorithm (taille du digest variable de 224 à 512 bits)\n\nDerniers Développements:\n\nX.Wang et al. culminent en 2004 un long travail visant à trouver des collisions dans l’algorithme MD5. Ils publient deux paires de collisions pour des messages de 1024 bits.\nEn 2005, X.Wang et al. prouvent dans la conférence CRYPTO’05 que le nombre d’opérations nécessaires pour trouver des collisions sur SHA-1 (standard actuel pour les fonctions de hashage sécurisées) est seulement de \\(2^{63}\\).\nCes attaques ont pour cible la recherche de collisions arbitraires mais lors de CRYPTO’06 des chercheurs de l’Université de Graz en Autriche proposent une méthode pour contrôler partiellement le contenu des collisions.\nEn Décembre 2008 on montre qu’on peut générer des collisions contrôlées sur MD5 et créer ainsi une Certification Authority illicite permettant des forger des certificats acceptés par n’importe quel browser.\nCes résultats s’appuient sur des approches analytiques (par opposition au brute force!)\nLe processus de sélection de successeur de SHA-1 est semblable à celui ayant désigné AES comme standard de cryptage en blocs. Le NIST a décidé (Octobre 2012) que Keccak serait l’algorithme de base pour SHA-3.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCustomized MDCs\n\nMD5 (cassé)\nSHA-0 (cassé)\nSHA-1 (faible)\nSHA-2 (sûr)\nSHA-3/Keccak (standard actuel).\n\nConstruction : padding + constantes + rounds + chaînage."
  },
  {
    "objectID": "exam_notes_fr.html#macs-basés-sur-des-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#macs-basés-sur-des-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "MACs Basés sur des Systèmes de Cryptage",
    "text": "MACs Basés sur des Systèmes de Cryptage\nCBC-MAC : Utilise un algorithme de chiffrement par blocs en mode CBC.\nFonctionnement :\n\nMode CBC avec IV = 0\nÉlimination des ciphertexts intermédiaires\nSeul le dernier bloc chiffré est conservé comme MAC\n\nAvec DES :\n\nLongueur clé : 56 bits (112 en Triple-DES optionnel)\nLongueur MAC : 64 bits\n\nAvantages :\n\nRéutilisation de l’infrastructure de chiffrement existante\nPerformances acceptables\n\nLimitations :\n\nSécurité limitée par la taille du bloc (64 bits pour DES)\nVulnérable si utilisé incorrectement (ex: sans IV variable)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAlgorithme CBC-MAC basé sur DES-CBC avec IV = 0 et élimination des ciphertext intermédiaires\n\nlongueur de clé = 56 bits (112 en cas d’utilisation de la partie optionnelle)\nLongueur du MAC-value = 64 bits\n\nLe schéma montre le traitement séquentiel des blocs de message \\(M_1, M_2, M_3\\) avec l’algorithme de cryptage \\(E\\) et la clé \\(k\\). Les ciphertexts intermédiaires \\(C_1, C_2\\) sont éliminés. Seul le dernier bloc \\(C_3\\) constitue le MAC.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCBC-MAC : mode CBC + IV=0, seul dernier bloc gardé. DES : clé 56/112 bits, MAC 64 bits."
  },
  {
    "objectID": "exam_notes_fr.html#nested-macs-et-hmacs",
    "href": "exam_notes_fr.html#nested-macs-et-hmacs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Nested MACs et HMACs",
    "text": "Nested MACs et HMACs\nNested MAC (NMAC) : Composition de deux familles de MACs \\(G\\) et \\(H\\) :\n\\[\\text{NMAC}_{k,l}(x) = g_k(h_l(x))\\]\nSécurité : Dépend de deux critères :\n\n\\(G\\) résistante aux collisions\n\\(H\\) résistante aux attaques spécifiques MACs\n\nHMAC (standard FIPS 198, 2002) : Nested MAC utilisant des MDCs sans clé (SHA-1, SHA-256).\nConstruction :\n\nConstantes : ipad = 0x363636...36 et opad = 0x5C5C5C...5C (512 bits)\nClé \\(k\\) de 512 bits\n\n\\[\\text{HMAC-256}_k(x) = \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nAvantages :\n\nMACs les plus utilisés en pratique\nAttaques sur SHA plus difficiles avec clé secrète\nPerformance excellente\nStandardisé et largement supporté\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUn Nested MAC ou NMAC est une composition de 2 familles de fonctions MACs \\(G\\) et \\(H\\) paramètrès par les clés \\(k\\) et \\(l\\) tel que:\n\\[G \\circ H = \\{ g \\circ h \\text{ avec } g \\in G \\text{ et } h \\in H \\} \\text{ avec } g \\circ h_{(k,l)}(x) = g_k(h_l(x))\\]\nLa sécurité d’un NMAC dépend de deux critères:\n\nLa famille de fonctions \\(G\\) est résistante aux collisions.\nLa famille de fonctions \\(H\\) est résistante aux attaques spécifiques pour MACs, i.e.: Il est impossible de trouver un couple \\((x,y)\\) et une clé \\(m\\) fixée mais inconnue, telle que: \\(\\text{MAC}_m(x) = y\\).\n\nUn HMAC (FIPS 198, 2002) est un Nested MAC utilisant à la base des MDCs sans clé dédiées comme SHA-1 ou SHA-256.\nUn HMAC utilise deux constantes de 512 bits dénommés ipad et opad telles que:\n\nopad := 363636 ... 36\nipad := 5C5C5C ... 5C\n\net une clé \\(k\\) de 512 bits.\nLe schéma de fonctionnement de HMAC-256 (sur la base de SHA-256) est le suivant:\n\\[\\text{HMAC-256}_k(x) := \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nLes HMACs sont les MACs les plus utilisés. Les attaques mentionnées sur les fonctions de la famille SHA sont plus difficiles à réaliser sur un HMAC par cause de la clé \\(k\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nHMAC : double hash avec clés dérivées (ipad/opad). \\(\\text{HMAC}_k(x) = H((k \\oplus \\text{opad}) \\parallel H((k \\oplus \\text{ipad}) \\parallel x))\\). Standard, sûr, performant."
  },
  {
    "objectID": "exam_notes_fr.html#applications-des-hash-functions",
    "href": "exam_notes_fr.html#applications-des-hash-functions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Applications des Hash Functions",
    "text": "Applications des Hash Functions\n\nIntégrité des Données\nTrois approches principales :\n\nMAC seul :\n\n\\(A \\to B: X, \\text{MAC}_k(X)\\)\nAuthentification + intégrité garanties\nNécessite clé partagée\n\nMDC + Encryption :\n\n\\(A \\to B: E_k(X, \\text{MDC}(X))\\)\nConfidentialité + intégrité\nClé symétrique partagée\n\nMDC + Canal authentique :\n\n\\(A \\to B: X\\) (canal normal)\n\\(A \\to B: \\text{MDC}(X)\\) (canal authentique)\nSéparation des canaux\n\n\nLimitations : Ces protocoles simples n’offrent pas de protection contre les replay attacks.\nSolution : ajouter timestamps ou numéros de séquence.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nMAC Seul: \\[A \\to B: X, \\text{MAC}_k(X)\\] Si \\(B\\) calcule de son coté \\(\\text{MAC}_k(X)\\) et obtient la même valeur ⇒ le message provient de \\(A\\).\nMDC + cryptage symétrique (clé \\(k\\) connue de \\(A\\) et \\(B\\)) \\[A \\to B: X, E_k(\\text{MDC}(X))\\] \\(B\\) calcule \\(\\text{MDC}(X)\\) et puis \\(E_k(\\text{MDC}(X))\\). Si égal ⇒ message vient de \\(A\\).\nComme 2) avec confidentialité de \\(X\\) en plus: \\[A \\to B: E_k(X,\\text{MDC}(X))\\]\nMDC + signature digitale: \\[A \\to B: X, \\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\] \\(B\\) calcule \\(\\text{MDC}(X)\\) et vérifie \\(\\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\) avec une copie authentique de pub-A. Si égalité ⇒ \\(A\\) est à l’origine du message. Cette solution offre en plus la non-répudiation d’origine.\nCes protocoles simples n’offrent aucun support sur l’unicité ni sur l’actualité (timeliness) des messages reçus et sont exposés à des replay attacks! Ils nécessitent des mécanismes tenant compte du temps ou du contexte de la transaction (cf. authentification d’entités).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nIntégrité : MAC seul, MDC+crypto, MDC+signature.\n⚠️ Vulnérable aux replay sans timestamps/nonces.\n\n\n\n\n\nBlockchains et Proof of Work\nBitcoin et blockchains : Utilisation de hash functions pour chaîner les blocs de transactions.\nCaractéristiques :\n\nTransactions publiques et visibles\nBlocs chaînés via fonctions de hachage cryptographiques\nMinage = résolution d’un puzzle cryptographique (proof of work)\n\nProof of Work :\n\nTrouver un nonce tel que \\(\\text{hash}(\\text{bloc} \\parallel \\text{nonce}) &lt; \\text{target}\\)\nPuzzle coûteux en calcul, validation rapide\nPremier mineur à résoudre reçoit récompense en bitcoins\n\nSécurité :\n\nBlockchain = registre public, décentralisé, immuable\nFalsification nécessiterait effort &gt; tous mineurs honnêtes\nProtection basée sur propriétés CRHF\n\nStatistiques Bitcoin (octobre 2025) :\n\nDifficulty : 150.84 T\nTarget : \\(\\approx 2^{177}\\) (pseudo-collision sur 79 bits)\nHashrate : ~1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hash/sec)\nTemps moyen génération bloc : 10 minutes\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nLes transactions bitcoin sont publiées et visibles par tous les intervenants. Elles sont encapsulées dans des blocs chaînés à l’aide de fonctions de hachage cryptographiques.\nLe minage (mining) consiste à rajouter itérativement des nouveaux blocs contenant les transactions courantes.\nLa génération d’un bloc valable nécessite la résolution d’un puzzle cryptographique (proof of work) très coûteux en temps de calcul (trouver des pseudo-collisions dans les fonctions de hachage cryptographiques). La validation reste très efficace.\nLe premier mineur capable de générer un bloc valable recevra une récompense monétaire (en bitcoins). Le processus de minage est ouvert à tous les mineurs mais seul le premier est récompensé.\nLa chaine de blocs résultante (blockchain) devient alors un registre publique (public ledger), décentralisé et immuable protégeant toutes les transactions passées. La falsification/modification des données protégées par la blockchain nécessiterait un effort calculatoire supérieur à celui effectué par tous les mineurs honnêtes.\nStatistiques Bitcoin 13/10/2025:\n\nDifficulty: 150.84 T\nTarget: \\(2^{224} / \\text{Difficulty} = \\approx 2^{177}\\). Le digest valable pour générer un bloc doit être inférieur à \\(2^{177}\\), ce qui signifie une pseudo-collision sur les 79 bits de poids plus fort. La variation sur les inputs dépend du nonce.\nHashrate: ~ 1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hashes /sec)\nFonctions de hachage exécutées pour obtenir un bloc: ~ \\(660 \\times 10^{21}\\)\nTemps moyen de génération d’un bloc: 10 min\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBlockchain : chaînage de blocs via hash.\nProof of Work : trouver nonce pour hash &lt; target.\nSécurité = effort &gt; tous mineurs.\nBitcoin : ~10 min/bloc, \\(10^{21}\\) hash/sec.\n\n\n\n\n\nAutres Applications\n1. Authentification :\n\nData origin authentication (DOA)\nTransaction authentication (DOA + paramètres temporels)\n\n2. Virus checking :\n\nCréateur publie \\(\\text{digest} = h(\\text{logiciel})\\) via canal sûr\nUtilisateurs vérifient intégrité en recalculant le digest\n\n3. Distribution des clés publiques :\n\nPublier \\(h(\\text{clé publique})\\) au lieu de la clé complète\nVérification d’authenticité simplifiée\n\n4. Timestamp sur documents :\n\nTimestamp appliqué au digest plutôt qu’au document complet\nRéduction des données à signer\n\n5. One-time password (S-Key) :\n\nChaîne de hash : \\(x_1 = h(x_0), x_2 = h(x_1), \\ldots, x_n = h(x_{n-1})\\)\nSystème stocke \\(x_n\\), utilisateur fournit \\(x_{n-1}\\)\nVérification : \\(h(x_{n-1}) = x_n\\)\nAprès validation, système stocke \\(x_{n-1}\\) pour prochaine fois\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification:\n\ndata origin authentication (DOA)\ntransaction authentication (= DOA + time-variant parameters)\n\nVirus checking:\n\nLe créateur d’un logiciel crée un digest = \\(h(x)\\) avec \\(x\\) étant l’original et le distribue par un canal sûr (eg. CD-ROM).\n\nDistribution des clés publiques:\n\nPermet de contrôler l’authenticité d’une clé publique.\n\nTimestamp sur un document:\n\nLe document sur lequel on veut effectuer le timestamp est d’abord soumis à une hash function. Le timestamp (avec la signature de l’entité correspondante) s’applique alors seulement au digest.\n\nOne-time password (S-Key) (mécanisme d’identification):\n\nA partir d’un seed secret \\(x_0\\), on crée une chaîne de hash-values: \\(x_1 = h(x_0)\\), \\(x_2 = h(x_1)\\), … \\(x_n = h(x_{n-1})\\).\nLe système mémorise \\(x_n\\) et l’utilsateur rentre \\(x_{n-1}\\). Si \\(h(x_{n-1}) == x_n\\) ⇒ OK.\nLe système mémorise alors \\(x_{n-1}\\) et ainsi de suite.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nApplications\n\nauthentification\nvirus checking\ndistribution clés publiques\ntimestamp\none-time passwords (chaîne de hash)"
  },
  {
    "objectID": "exam_notes_fr.html#randomized-hash-functions-exemple-unix",
    "href": "exam_notes_fr.html#randomized-hash-functions-exemple-unix",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Randomized Hash Functions : Exemple UNIX",
    "text": "Randomized Hash Functions : Exemple UNIX\nProblème : Fonctions de hachage déterministes produisent toujours le même résultat pour le même mot de passe.\nRisques :\n\nDétection de mots de passe identiques\nAttaques par dictionnaire offline (codebooks pré-calculés)\nRainbow tables\n\nSolution UNIX : Salt\n\nAjout d’un élément pseudo-aléatoire de 12 bits (salt) avant hachage\nSalt différent pour chaque utilisateur\n4096 possibilités (\\(2^{12}\\)) pour chaque mot de passe\n\nAvantages :\n\nEmpêche détection des duplications\nCodebooks pré-calculés deviennent inefficaces\nChaque mot de passe nécessite 4096 entrées dans le dictionnaire\n\nImplémentation UNIX :\n\nFichier /etc/passwd accessible globalement\nFormat : username:hash(salt+password):uid:gid:...\nHash basé sur DES modifié (25 itérations)\nSalt stocké en clair (2 premiers caractères du hash)\n\nExemple :\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nLimitations :\n\nProtection efficace contre dictionnaires pré-calculés\nAttaques online limitées par le système (nombre d’essais)\nAttaques offline possibles si fichier compromis\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUNIX garde ses mots de passe dans un fichier globalement accessible (ou éventuellement distribué par NIS). L’information stockée correspond au résultat produit par une hash function.\nExemple (fictif):\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nProblèmes:\n\nla hash function étant déterministe, elle produit le même résultat pour des mots de passe identiques.\non pourrait créer des “cahiers” (codebooks) contenant le résultat de l’application de la hash function à des entrées données (p.ex. un dictionnaire) et les comparer facilement (off-line) avec les chaînes stockées par UNIX (brute force dictionnary attack).\n\nSolution:\n\nRajouter un élément (pseudo) aléatoire de 12 bits différent pour chaque mot de passe (appelé salt) avant de calculer la hash function et lors de la vérification.\nCet élément permet de rajouter un facteur aléatoire de 4096 possibilités pour chaque mot de passe et de prévenir la détection des duplications.\n\nLe schéma de fonctionnement utilise DES avec 25 itérations, le password comme clé, et le salt pour modifier les E-boxes. Le résultat final de 64 bits est converti en 11 caractères ASCII.\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes attaques dictionnaire sont normalement moins efficaces online car les systèmes d’exploitation limitent le nombre d’essais infructueux d’authentification.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nUNIX salt : 12 bits aléatoires ajoutés au password avant hash.\n4096 variations possibles.\nEmpêche codebooks pré-calculés et détection duplications."
  },
  {
    "objectID": "exam_notes_fr.html#introduction-et-définitions",
    "href": "exam_notes_fr.html#introduction-et-définitions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Introduction et Définitions",
    "text": "Introduction et Définitions\nUne signature digitale est une chaîne de données associant un message à une entité d’origine, équivalent numérique d’une signature manuscrite.\nClassification :\n\nAvec appendice : nécessite le message original pour vérification (ElGamal, DSS)\nAvec reconstitution : permet de reconstruire le message (RSA, Rabin)\n\nLes signatures utilisent principalement la cryptographie asymétrique pour identifier explicitement une entité.\narbitrated digital signatures: technologie symétrique + Thrusted Third Parties (TTP)\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nSignature digitale : chaîne de données permettant d’associer un message (sous forme digitale) à une entité d’origine.\nSchéma de signature digitale : algorithme de génération + algorithme de vérification.\nProcédé de signature : formatage du message + algorithme de génération de signature.\nProcédé de vérification : algorithme de vérification + (reconstruction du message).\nClassification des signatures digitales :\n\nSignatures digitales avec appendice qui nécessitent la présence du message original pour vérifier la validité de la signature. Ce sont les plus couramment utilisées. Exemples : ElGamal, DSS.\nSignatures digitales avec reconstitution du message qui offrent, en plus, la possibilité de reconstruire le message à partir de la signature. Exemples : RSA, Rabin.\n\nLes signatures digitales sont pour la plupart basées sur la crypto asymétrique du fait que la notion clé partagée n’est pas adaptée aux besoins d’identifier une entité de façon explicite.\nDes engagements semblables à ceux obtenus par une signature à clé publique (comme la non-répudiation d’origine) peuvent cependant être obtenus avec la technologie symétrique et des tierces de confiance (Trusted Third Parties ou TTP). Ces méthodes sont nommées : arbitrated digital signatures.\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nSignature digitale = chaîne associant message + entité\nDeux types\n\navec appendice (nécessite message original)\navec reconstitution (reconstruit le message)\n\nBasée sur crypto asymétrique"
  },
  {
    "objectID": "exam_notes_fr.html#cadre-formel-signatures-avec-appendice",
    "href": "exam_notes_fr.html#cadre-formel-signatures-avec-appendice",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cadre Formel : Signatures avec Appendice",
    "text": "Cadre Formel : Signatures avec Appendice\nEspaces de travail :\n\n\\(M\\) : espace des messages\n\\(M_h\\) : messages hashés où \\(m_h = H(m)\\) avec \\(H\\) une fonction de hachage\n\\(S\\) : espace des signatures possibles\n\nFonctionnement :\nChaque entité A définit :\n\n\\(S_A : M_h \\rightarrow S\\) (application de signature, utilise clé privée)\n\\(V_A : M_h \\times S \\rightarrow \\{\\text{vrai}, \\text{faux}\\}\\) (vérification, utilise clé publique)\n\nAvec \\(V_A(m_h, s) = \\text{vrai}\\) si et seulement si \\(S_A(m_h) = s\\)\nPropriétés essentielles :\n\n\\(S_A\\) et \\(V_A\\) faciles à calculer avec les bonnes clés\nImpossible de trouver \\((m', s')\\) valide sans la clé privée de A\n\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nOn admet que chaque entité a une clé privée pour signer des messages et une copie authentique des clés publiques des correspondants.\nNotation : - M : Espace de messages - \\(M_h\\) : \\(m_h = H(m)\\) avec \\(m \\in M\\), \\(m_h \\in M_h\\) et \\(H\\) une hash function - S : Espace des valeurs pouvant être obtenues par un procédé de signature\nDescription :\nChaque entité définit une application injective \\(S_A : M_h \\rightarrow S\\) (ie. la signature)\nL’application \\(S_A\\) donne lieu à une application \\(V_A\\) : \\(V_A : M_h \\times S \\rightarrow \\{\\text{vrai}, \\text{faux}\\}\\) (ie. la vérification)\ntel que \\(\\forall m_h \\in M_h\\), \\(s \\in S\\), on a : \\(V_A(m_h, s) = \\text{vrai}\\) si \\(S_A(m_h) = s\\) et \\(V_A(m_h, s) = \\text{faux}\\) sinon\nLes opérations \\(S_A\\) nécessitent la clé privée de A alors que les opérations \\(V_A\\) utilisent la clé publique de A.\nQuelques propriétés simples :\n\nLes opérations \\(S_A\\) et \\(V_A\\) doivent être faciles à calculer (en ayant les clés corresp.)\nIl est impossible (calculatoirement) pour une entité n’ayant pas la clé privée de A de trouver un \\(m'\\) et un \\(s'\\) avec \\(m' \\in M\\) et \\(s' \\in S\\) tel que \\(V_A(m'_h, s') = \\text{vrai}\\) avec \\(m'_h = H(m')\\).\n\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nSignature : \\(S_A(m_h) = s\\) (clé privée).\nVérification : \\(V_A(m_h, s)\\) (clé publique).\nImpossible de forger sans clé privée."
  },
  {
    "objectID": "exam_notes_fr.html#cadre-formel-signatures-avec-reconstitution",
    "href": "exam_notes_fr.html#cadre-formel-signatures-avec-reconstitution",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cadre Formel : Signatures avec Reconstitution",
    "text": "Cadre Formel : Signatures avec Reconstitution\nEspaces additionnels :\n\n\\(M_S\\) : espace sur lequel s’applique la signature\n\\(R : M \\rightarrow M_S\\) : fonction de redondance (injective, inversible, publique)\n\\(M_R = \\text{Im}(R)\\) : image de \\(R\\)\n\nFonctionnement :\n\nSignature : \\(S_A : M_S \\rightarrow S\\) (injective)\nVérification : \\(V_A : S \\rightarrow M_S\\) avec \\(V_A \\circ S_A = \\text{Identité}\\)\n\nGénération :\n\nCalculer \\(m_R = R(m)\\) et \\(s = S_A(m_R)\\)\nPublier \\(s\\) comme signature de A sur \\(m\\)\n\nVérification :\n\nCalculer \\(m_R = V_A(s)\\) avec clé publique\nVérifier \\(m_R \\in M_R\\) (sinon rejeter)\nReconstituer \\(m = R^{-1}(m_R)\\)\n\nFonction de redondance :\nEssentielle pour la sécurité. Si \\(M_R = M_S\\), il devient trivial de forger des signatures.\nExemple : \\(R(m) = m \\parallel m\\) (concaténation). Probabilité de forger : \\((1/2)^n\\) pour un message de \\(n\\) bits.\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nNotation : en plus des définitions précédentes, on a :\n\\(M_S\\) : L’espace des éléments sur lesquels peut s’appliquer une signature.\n\\(R\\) : Une application injective : \\(M \\rightarrow M_S\\), appelée fonction de redondance. Elle doit être inversible et publique.\n\\(M_R = \\text{Im}(R)\\)\nDescription :\nChaque entité définit une application injective \\(S_A : M_S \\rightarrow S\\) (ie. la signature)\nL’application \\(S_A\\) donne lieu à une application \\(V_A : S \\rightarrow M_S\\) (ie. la vérification) tel que \\(V_A \\circ S_A = \\text{Identité}\\) sur \\(M_S\\)\nA noter que la vérification s’effectue sans la clé privée de A\nGénération de signature : 1. Calculer \\(m_R = R(m)\\) et \\(s = S_A(m_R)\\) 2. Rendre publique \\(s\\) en tant que signature de A sur \\(m\\). Ceci permet aux autres entités de vérifier la signature et reconstituer \\(m\\).\nVérification : 1. Calculer \\(m_R = V_A(s)\\) (avec la clé publique de A) 2. Vérifier que \\(m_R \\in M_R\\) (sinon rejeter la signature) 3. Reconstituer \\(m\\) en calculant : \\(R^{-1}(m_R)\\)\nPropriétés :\n\nLes opérations \\(S_A\\) et \\(V_A\\) doivent être faciles à calculer (en ayant les clés corresp.)\nIl est impossible (calculatoirement) pour une entité n’ayant pas la clé privée de A de trouver un \\(s' \\in S\\) tel que \\(V_A(s') \\in M_R\\)\n\nRemarques sur la fonction de redondance :\n\nLe choix d’une fonction de redondance est essentiel pour la sécurité du système.\nSi \\(M_R = M_S\\) et \\(R\\) et \\(S_A\\) sont des bijections respectivement de \\(M\\) dans \\(M_R\\) et de \\(M_S\\) dans \\(S\\), alors \\(M\\) et \\(S\\) ont une taille identique et, par conséquent, il est trivial de forger des messages portant la signature de A.\n\nExemple de fonction de redondance : soit \\(M = \\{m : m \\in \\{0,1\\}^n\\}\\) (n taille du message) et \\(M_S = \\{t : t \\in \\{0,1\\}^{2n}\\}\\). Soit \\(R : M \\rightarrow M_S\\) tel que \\(R(m) = m \\parallel m\\) (\\(\\parallel\\) étant la concaténation de 2 messages). La probabilité de tomber sur un tel message en essayant de forger un message à partir d’une signature est de : \\(|M_R| / |M_S| = (1/2)^n\\), ce qui est négligeable pour des grands messages.\nAttention ! : Une fonction de redondance adaptée pour un schéma de signature digitale peut provoquer des failles dans un autre différent !\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nAvec reconstitution : Fonction redondance \\(R(m) = m_R\\).\nSignature \\(s = S_A(m_R)\\).\nVérification : \\(m_R = V_A(s)\\), reconstituer \\(m = R^{-1}(m_R)\\).\nRedondance cruciale pour sécurité."
  },
  {
    "objectID": "exam_notes_fr.html#signature-rsa",
    "href": "exam_notes_fr.html#signature-rsa",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Signature RSA",
    "text": "Signature RSA\nGénération des clés :\n\nChoisir deux grands nombres premiers \\(p\\) et \\(q\\)\nCalculer \\(n = pq\\) et \\(\\phi(n) = (p-1)(q-1)\\)\nChoisir \\(e\\) avec \\(\\text{pgcd}(e, \\phi(n)) = 1\\)\nCalculer \\(d\\) tel que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\nClé publique : \\((n, e)\\) ; Clé privée : \\(d\\)\n\nSignature :\n\nCalculer \\(m_R = R(m)\\) (fonction de redondance)\nCalculer \\(s = m_R^d \\bmod n\\)\nEnvoyer \\(s\\)\n\nVérification :\n\nCalculer \\(m'_R = s^e \\bmod n\\)\nVérifier \\(m'_R \\in M_R\\) (rejeter sinon)\nReconstituer \\(m = R^{-1}(m'_R)\\)\n\nVariante avec appendice :\n\nSignature : \\(m_h = H(m)\\), puis \\(s = m_h^d \\bmod n\\)\nVérification : \\(m'_h = s^e \\bmod n\\), accepter si \\(m'_h = H(m)\\)\n\nCaractéristiques :\n\nSignature plus lente que vérification (\\(d\\) grand, \\(e\\) petit)\nDifférencier clés signature/encryption\nVulnérable aux mêmes attaques que RSA encryption\n\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nGénération des clés :\n\nChaque entité (A) crée une paire de clés (publique et privée) comme suit :\nA choisit la taille du modulus \\(n\\) (p.ex. taille\\((n) = 1024\\) ou taille\\((n) = 2048\\)).\nA génère deux nombres premiers \\(p\\) et \\(q\\) de grande taille \\((n/2)\\).\nA calcule \\(n := pq\\) et \\(\\phi(n) = (p-1)(q-1)\\).\nA génère l’exposant de vérification \\(e\\), avec \\(1 &lt; e &lt; \\phi(n)\\) tel que \\(\\text{pgcd}(e, \\phi(n)) = 1\\).\nA calcule l’exposant de signature \\(d\\), tel que : \\(ed \\equiv 1 \\pmod{\\phi(n)}\\) avec l’algorithme d’Euclide étendu ou avec l’algorithme fast exponentiation.\nLe couple \\((n,e)\\) est la clé publique de A ; \\(d\\) est la clé privée de A.\n\nSignature :\n\nA calcule la fonction de redondance du message \\(m\\) : \\(m_R := R(m)\\).\nA calcule la signature : \\(s := m_R^d \\bmod n\\) et envoie \\(s\\) à B.\n\nVérification :\n\nL’entité B obtient \\((n,e)\\), la clé publique authentique de A.\nB calcule \\(m'_R = s^e \\bmod n\\), vérifie \\(m'_R \\in M_R\\) et rejette la signature si \\(m'_R \\notin M_R\\)\nB retrouve le message correctement signé par A en calculant : \\(m = R^{-1}(m'_R)\\).\n\nRemarques :\nLa preuve de fonctionnement est identique à celle du procédé d’encryption. L’ordre d’exponentiation n’a pas d’influence puisque : \\[ed \\equiv de \\equiv 1 \\pmod{\\phi(n)}\\]\nLe procédé peut également être utilisé pour produire des signatures avec appendice avec les modifications suivantes :\nSignature : - A utilise une fonction de hachage \\(H\\) et calcule \\(m_h := H(m)\\). - A calcule la signature de \\(m_h\\) : \\(s := m_h^d \\bmod n\\) et envoie le couple \\((m,s)\\) à B.\nVérification : - B calcule \\(m'_h = s^e \\bmod n\\) et \\(H(m)\\) et vérifie l’égalité \\(m'_h = H(m)\\). - Si l’égalité est vérifiée, B accepte la signature \\(s\\) de A sur le message M.\nLe calcul de signature est plus lent que la vérification à cause de différence de taille entre l’exposant \\(d\\) (taille\\((d) \\approx\\) taille\\((\\phi(n))\\)) et \\(e\\).\nLes risques et attaques mentionnés dans le procédé d’encryption s’appliquent également pour la signature.\nIl convient de différencier les paires de clés d’encryption et de signature puisqu’elles nécessitent des politiques de stockage, sauvegarde et mise à jour distinctes.\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nRSA signature : \\(s = m_R^d \\bmod n\\) (privée).\nVérif : \\(m'_R = s^e \\bmod n\\) (publique).\nAvec appendice : \\(s = H(m)^d \\bmod n\\).\nSignature lente, vérif rapide."
  },
  {
    "objectID": "exam_notes_fr.html#signatures-aveugles-blind-signatures",
    "href": "exam_notes_fr.html#signatures-aveugles-blind-signatures",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Signatures Aveugles (Blind Signatures)",
    "text": "Signatures Aveugles (Blind Signatures)\nPrincipe : A envoie une information à B pour signature. À partir de la réponse, A peut calculer la signature de B sur un message différent, que B n’a jamais vu.\nExploitation de la propriété multiplicative RSA :\n\\[(m_1 m_2)^e \\equiv m_1^e m_2^e \\equiv c_1 c_2 \\pmod{n}\\]\nFonctions de camouflage :\nSoit \\(k\\) un entier avec \\(\\text{pgcd}(n,k) = 1\\) :\n\nBlinding : \\(f(m) = m \\cdot k^e \\bmod n\\)\nUnblinding : \\(g(m) = k^{-1} \\cdot m \\bmod n\\)\n\nRésultat : \\(g(S_B(f(m))) = g(S_B(mk^e \\bmod n)) = g(m^dk \\bmod n) = m^d \\bmod n = S_B(m)\\)\nProtocole :\n\nA → B : \\(m' = f(m)\\) (message camouflé)\nA ← B : \\(s' = S_B(m')\\) (signature du message camouflé)\nA calcule \\(g(s')\\) et obtient \\(S_B(m)\\) (signature du message original)\n\nApplications : Argent électronique anonyme, systèmes de vote électronique.\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nSchéma inventé par Chaum.\nIdée : A envoie une information à B pour signature. B retourne à A l’information signée. A partir de cette signature, A peut calculer la signature de B sur un autre message choisi à priori par A. Ceci permet à A d’avoir une signature de B sur un message que B n’a jamais vu (d’où le nom de signature aveugle…).\nEn fait il s’agit d’une faille basée sur la propriété multiplicative de RSA : \\((m_1m_2)^e \\equiv m_1^e m_2^e \\equiv c_1 c_2 \\pmod{n}\\) qui a été exploitée pour en faire un nouveau procédé de signature.\nAlgorithme : Soit \\(S_B\\) la signature de RSA de B avec \\((n,e)\\) et \\(d\\), resp. les clés publiques et privées de B. Soit \\(k\\) un entier fixé avec \\(\\text{pgcd}(n,k) = 1\\) :\n\\(f : \\mathbb{Z}_n \\rightarrow \\mathbb{Z}_n\\) avec \\(f(m) = m \\cdot k^e \\bmod n\\) (blinding function)\n\\(g : \\mathbb{Z}_n \\rightarrow \\mathbb{Z}_n\\) avec \\(g(m) = k^{-1} \\cdot m \\bmod n\\) (unblinding function)\nce qui donne :\n\\[g(S_B(f(m))) = g(S_B(mk^e \\bmod n)) = g(m^dk \\bmod n) = m^d \\bmod n = S_B(m)\\]\nProtocole :\n\nA → B : \\(m' = f(m)\\)\nA ← B : \\(s' = S_B(m')\\)\nA calcule \\(g(s')\\) et obtient la signature souhaitée en utilisant (*).\n\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nBlind signature : Exploite multiplicativité RSA.\nCamouflage \\(f(m) = m \\cdot k^e\\)\nDécamouflage \\(g(m) = k^{-1} \\cdot m\\).\nB signe \\(f(m)\\), A obtient \\(S_B(m)\\) sans que B voie \\(m\\)."
  },
  {
    "objectID": "exam_notes_fr.html#signature-rabin",
    "href": "exam_notes_fr.html#signature-rabin",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Signature Rabin",
    "text": "Signature Rabin\nGénération des clés :\n\nGénérer deux grands nombres premiers \\(p\\) et \\(q\\)\nCalculer \\(n = pq\\)\nClé publique : \\(n\\) ; Clé privée : \\((p, q)\\)\n\nSignature :\n\nCalculer \\(m_R = R(m)\\) (fonction de redondance)\nCalculer \\(s = \\sqrt{m_R} \\bmod n\\) (racine carrée mod \\(n\\))\nEnvoyer \\(s\\) (une des 4 racines carrées)\n\nVérification :\n\nCalculer \\(m'_R = s^2 \\bmod n\\)\nVérifier \\(m'_R \\in M_R\\) (rejeter sinon)\nReconstituer \\(m = R^{-1}(m'_R)\\)\n\nCaractéristiques :\n\nBasé sur le problème SQROOTP (racines carrées mod composite)\nProvably secure : équivalent à la factorisation\nVulnérable aux attaques chosen-ciphertext actives\n\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nGénération des clés :\n\nChaque entité (A) crée une paire de clés (publique et privée) comme suit :\nA génère deux nombres premiers aléatoires \\(p\\) et \\(q\\) de grande taille (len\\((pq) \\geq 1024\\)).\nA calcule \\(n := pq\\).\nLa clé publique de A est \\(n\\), la clé privée de A est \\((p,q)\\).\n\nSignature :\n\nA calcule la fonction de redondance du message \\(m\\) : \\(m_R := R(m)\\).\nA utilise sa clé privée pour calculer la signature : \\(s := m_R^{1/2} \\bmod n\\) en utilisant des algorithmes efficaces pour calculer des racines carrées mod \\(p\\) et mod \\(q\\).\nA envoie \\(s\\) à B (\\(s\\) est une des 4 racines carrées obtenues).\n\nVérification :\n\nL’entité B obtient \\(n\\), la clé publique authentique de A.\nB calcule \\(m'_R = s^2 \\bmod n\\), vérifie \\(m'_R \\in M_R\\) et rejette la signature si \\(m'_R \\notin M_R\\)\nB retrouve le message correctement signé par A en calculant : \\(m = R^{-1}(m'_R)\\).\n\nRemarques :\nLe procédé de Rabin est basé sur l’impossibilité de trouver des racines carrées modulo un composite de factorisation inconnue (problème SQROOTP).\nL’intérêt principal de cet algorithme réside dans le fait qu’il a été prouvé comme étant équivalent à la factorisation (SQROOTP ⇔ FACTP). Cet algorithme appartient donc à la catégorie provably secure pour toute attaque passive.\nLes attaques actives peuvent, dans certains cas, compromettre la sécurité de l’algorithme. Plus précisément, si on monte l’attaque chosen ciphertext (on demande à A de décrypter un ciphertext choisi) suivant :\n\nL’attaquant M génère un \\(m\\) et envoie à A le ciphertext \\(c = m^2 \\bmod n\\).\nA répond avec une racine \\(m_x\\) parmi les 4 possibles \\(m_1, m_2, m_3, m_4\\).\nSi \\(m \\not\\equiv m_x \\pmod{n}\\) (probabilité 0.5), M recommence avec un nouveau \\(m\\).\nSinon, A calcule \\(\\text{pgcd}(m - m_x, n)\\) et obtient ainsi un des deux facteurs de \\(n\\)…\n\nCette attaque pourrait être évitée si le procédé exigeait une redondance suffisante dans les plaintexts permettant à A d’identifier sans ambiguïté laquelle des solutions possibles est le plaintext original. Dans ce cas, A répondrait toujours \\(m\\) et jetterait les autres solutions n’ayant pas le niveau de redondance préétabli.\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nRabin : \\(s = \\sqrt{m_R} \\bmod n\\).\nVérif : \\(m'_R = s^2 \\bmod n\\).\nProvably secure (équivalent factorisation).\nVulnérable attaques actives chosen-ciphertext."
  },
  {
    "objectID": "exam_notes_fr.html#signature-elgamal",
    "href": "exam_notes_fr.html#signature-elgamal",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Signature ElGamal",
    "text": "Signature ElGamal\nGénération des clés :\n\nGénérer premier \\(p\\) et générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\)\nGénérer secret \\(a\\) aléatoire, calculer \\(y = \\alpha^a \\bmod p\\)\nClé publique : \\((p, \\alpha, y)\\) ; Clé privée : \\(a\\)\n\nSignature :\n\nCalculer \\(m_h = H(m)\\)\nGénérer \\(k\\) aléatoire avec \\(\\text{pgcd}(k, p-1) = 1\\)\nCalculer \\(r = \\alpha^k \\bmod p\\)\nCalculer \\(s = k^{-1}(m_h - ar) \\bmod (p-1)\\)\nSignature : \\((r, s)\\)\n\nVérification :\n\nVérifier \\(1 \\leq r \\leq p-2\\) (rejeter sinon)\nCalculer \\(v_1 = y^r r^s \\bmod p\\)\nCalculer \\(v_2 = \\alpha^{H(m)} \\bmod p\\)\nAccepter si \\(v_1 = v_2\\)\n\nPreuve : Si \\(s \\equiv k^{-1}(m_h - ar) \\pmod{p-1}\\), alors \\(m_h \\equiv ar + ks \\pmod{p-1}\\)\nDonc \\(v_2 = \\alpha^{m_h} \\equiv \\alpha^{ar+ks} \\equiv (\\alpha^a)^r (\\alpha^k)^s \\equiv y^r r^s = v_1 \\pmod{p}\\)\nCaractéristiques :\n\nFonctionne uniquement avec appendice (hash)\nBase du DSA (Digital Signature Algorithm)\n\\(k\\) doit être unique pour chaque signature\n\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nGénération des clés :\n\nChaque entité (A) crée une paire de clés (publique et privée) comme suit :\nA génère un nombre premier \\(p\\) (len\\((p) \\geq 1024\\) bits) et un générateur \\(\\alpha\\) de \\(\\mathbb{Z}_p^*\\).\nA génère un nombre aléatoire \\(a\\), tel que \\(1 \\leq a \\leq p-2\\) et calcule \\(y := \\alpha^a \\bmod p\\).\nLa clé publique de A est \\((p, \\alpha, y)\\), la clé privée de A est \\(a\\).\n\nSignature :\n\nA utilise une fonction de hachage \\(H\\) et calcule \\(m_h := H(m)\\).\nA génère un nombre aléatoire \\(k\\) (\\(1 \\leq k \\leq p-2\\) et \\(\\text{pgcd}(k,p-1) = 1\\)) et calcule \\(k^{-1} \\bmod (p-1)\\)\nA calcule \\(r := \\alpha^k \\bmod p\\) et ensuite \\(s := k^{-1}(m_h - ar) \\bmod (p-1)\\)\nLa signature de A sur le message \\(m\\) est le couple \\((r,s)\\).\n\nVérification :\n\nL’entité B obtient \\((p, \\alpha, \\alpha^a \\bmod p)\\), la clé publique authentique de A.\nB vérifie que \\(1 \\leq r \\leq p-2\\), sinon rejette la signature.\nB calcule \\(v_1 := y^r r^s \\bmod p\\).\nB calcule \\(H(m)\\) et \\(v_2 := \\alpha^{H(m)} \\bmod p\\)\nB accepte la signature ssi. \\(v_1 = v_2\\).\n\nRemarques :\nPreuve que le schéma fonctionne : Si \\(s \\equiv k^{-1}(m_h - ar) \\pmod{p-1}\\), on a que : \\[m_h \\equiv (ar + ks) \\pmod{p-1}\\] et \\[v_2 = \\alpha^{H(m)} \\bmod p\\]\nsi, comme on souhaite montrer \\(m_h = H(m)\\), en réduisant les exposants mod \\((p-1)\\), on peut réécrire \\(v_2\\) : \\[v_2 \\equiv \\alpha^{ar+ks} \\pmod{p}\\]\nD’autre part : \\[v_1 = y^r r^s \\equiv \\alpha^{ar} \\alpha^{ks} \\equiv \\alpha^{ar+ks} \\pmod{p}\\] c.q.f.d.\nPar construction, le schéma d’ElGamal fonctionne uniquement avec appendice (résultat de l’application d’une fonction de hachage). Le schéma de Nyberg-Rueppel introduit une variation permettant la reconstitution du message.\nLe Digital Signature Algorithm (DSA), approuvé par le US National Institute of Standards and Technology est devenu le standard de signature le plus couramment utilisé. Il est construit sur la base d’un dérivé direct du schéma d’ElGamal avec la fonction de hachage SHA-1.\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nElGamal : \\((r,s)\\) avec \\(r = \\alpha^k \\bmod p\\), \\(s = k^{-1}(m_h - ar) \\bmod (p-1)\\).\nVérif : \\(y^r r^s \\stackrel{?}{=} \\alpha^{H(m)} \\bmod p\\).\nBase de DSA.\n\\(k\\) unique crucial."
  },
  {
    "objectID": "exam_notes_fr.html#signatures-et-crypto-monnaies",
    "href": "exam_notes_fr.html#signatures-et-crypto-monnaies",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Signatures et Crypto-monnaies",
    "text": "Signatures et Crypto-monnaies\nLes crypto-monnaies utilisent massivement les signatures digitales pour authentifier les transactions.\nBitcoin et Ethereum :\n\nUtilisent ECDSA (Elliptic Curve Digital Signature Algorithm)\nDérivé d’ElGamal sur courbes elliptiques\nSécurité basée sur ECDLP\n\nProcessus de transaction :\nChaque dépense/transmission nécessite :\n\nSignature avec la clé privée du détenteur actuel\nLe détenteur était le destinataire de la transaction précédente\nChaque transaction forme une chaîne d’authentification\n\nAvantages ECDSA :\n\nClés plus courtes pour sécurité équivalente\nCalculs plus efficaces\nAdapté aux contraintes des blockchains\n\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nLa plupart des crypto-monnaies se basent sur la cryptographie asymétrique. Le bitcoin p.ex. utilise des signatures digitales pour authentifier ses transactions.\nLa dépense ou la transmission de bitcoins nécessite la signature avec la clé privée du détenteur (qui était à son tour le destinataire de la transaction précédente).\nBitcoin et Ethereum utilisent l’algorithme ECDSA (Elliptic Curve Digital Signature Algorithm) dérivé de algorithme de signature de ElGamal sur les courbes elliptiques dont la sécurité repose sur ECDLP.\n[Image : Schéma montrant la chaîne de transactions Bitcoin avec signatures]\nSource Image : Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nCrypto-monnaies : Bitcoin/Ethereum utilisent ECDSA (ElGamal sur courbes elliptiques).\nChaque transaction signée avec clé privée détenteur.\nSécurité basée ECDLP."
  },
  {
    "objectID": "exam_notes_fr.html#tableau-récapitulatif-des-schémas",
    "href": "exam_notes_fr.html#tableau-récapitulatif-des-schémas",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Tableau Récapitulatif des Schémas",
    "text": "Tableau Récapitulatif des Schémas\n\n\n\nClasse\nSchéma\nMessage Recovery\nProblème de base\n\n\n\n\nSignatures Classiques\nRSA\nOui\nRSAP\n\n\n\nRabin\nOui\nSQROOTP\n\n\n\nElGamal\nNon\nDLP\n\n\n\nDSS\nNon\nDLP\n\n\nOne-time Signatures\nLamport\nNon\ndépend de la OWF\n\n\n\nBos-Chaum\nNon\ndépend de la OWF\n\n\nUndeniable Signatures\nChaum-van Antwerpen\nNon\nDLP\n\n\nFail-Stop Signatures\nvan Heyst-Pedersen\nNon\nDLP\n\n\nBlind Signatures\nChaum\nOui\nRSAP\n\n\n\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\n[Tableau complet avec toutes les informations ci-dessus]\nLe fonctionnement des procédés de signature One-time, Undeniable et Fail-Stop peut être consulté dans [Men97].\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nSignatures classiques :\n\nRSA/Rabin (recovery)\nElGamal/DSS (appendice)\n\nSpécialisées :\n\nOne-time\nUndeniable\nFail-Stop\nBlind\n\nProblèmes base : RSAP, SQROOTP, DLP, dépend de la OWF."
  },
  {
    "objectID": "exam_notes_fr.html#types-dattaques",
    "href": "exam_notes_fr.html#types-dattaques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Types d’Attaques",
    "text": "Types d’Attaques\nCritères pour “casser” un schéma :\n\nTotal Break : Calculer la clé privée ou algorithme efficace de génération\nFalsification sélective : Générer signature pour message/classe fixé(e)\nFalsification existentielle : Forger au moins une signature (sans contrôle du message)\n\nAttaques de base :\n\nKey-only : Seule la clé publique est connue\nKnown-messages : Accès à signatures de messages connus\nChosen-messages : Attaquant choisit messages à signer\nAdaptive chosen-messages : Choix dépend des réponses précédentes\n\nCes attaques sont équivalentes aux attaques sur systèmes d’encryption (known/chosen-plaintext/ciphertext) mais appliquées aux messages.\n\n\n\n\n\n\nNoneTexte original\n\n\n\n\n\nCritères pour “casser” un schéma de signature digitale :\n\nTotal Break : Calculer la clé privée du signataire ou un algorithme efficace (polynomial) pour générer des signatures.\nFalsification sélective (selective forgery) : L’adversaire est capable de générer une signature valide pour un message (ou une classe de messages) fixé.\nFalsification existentielle (existential forgery) : L’adversaire est capable de forger une signature pour (au moins) un message (dont il n’a pas le contrôle).\n\nAttaques de base :\n\nAttaques key-only : L’adversaire a seulement connaissance de la clé publique du signataire.\nAttaques basées sur les messages : L’adversaire a accès à des signatures correspondantes à des :\n\nknown-messages\nchosen-messages\nadaptive chosen-messages\n\n\nEquivalents à des attaques x-ciphertext mais avec des messages !\n\n\n\n\n\n\n\n\n\nNoneRévision rapide\n\n\n\n\n\nCasser signature :\n\nTotal break (clé privée)\nfalsification sélective (message fixé)\nexistentielle (un message)\n\nAttaques :\n\nkey-only\nknown/chosen/adaptive-chosen-messages."
  },
  {
    "objectID": "exam_notes_fr.html#authentification-de-lorigine-des-données-et-dentités",
    "href": "exam_notes_fr.html#authentification-de-lorigine-des-données-et-dentités",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Authentification de l’origine des données et d’entités",
    "text": "Authentification de l’origine des données et d’entités\n\nMéthodes d’authentification\nL’authentification de l’origine garantit qu’un message provient bien de l’entité prétendument émettrice.\nMéthodes symétriques :\n\nMAC seul : A → B: X, MACk(X) - B vérifie avec la clé partagée k\nMDC + cryptage : A → B: X, Ek(MDC(X)) ou A → B: Ek(X, MDC(X))\n\nMéthode asymétrique :\n\nMDC + signature : A → B: X, Sigpriv-A(MDC(X)) - Offre en plus la non-répudiation\n\nLimitations : Ces protocoles simples ne protègent ni contre les replay attacks ni ne garantissent l’actualité des messages. Des mécanismes tenant compte du temps ou du contexte sont nécessaires.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification de l’origine des données\n1) MAC avec une clé symétrique k connue de A et B : A → B: X, MACk(X) Si B calcule de son côté MACk(X) et obtient la même valeur ⇒ le message provient de A.\n2) MDC + cryptage symétrique (clé k connue de A et B) A → B: X, Ek(MDC(X)) B calcule MDC(X) puis Ek(MDC(X)). Si égal ⇒ message vient de A.\n3) Comme 2) avec confidentialité de X en plus : A → B: Ek(X,MDC(X))\n4) MDC + signature digitale : A → B: X, Sigpriv-A(MDC(X)) B calcule MDC(X) et vérifie Sigpriv-A(MDC(X)) avec une copie authentique de pub-A. Si égalité ⇒ A est à l’origine du message. Cette solution offre en plus la non-répudiation d’origine.\nCes protocoles simples n’offrent aucun support sur l’unicité ni sur l’actualité (timeliness) des messages reçus et sont exposés à des replay attacks. Ils nécessitent des mécanismes tenant compte du temps ou du contexte de la transaction.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\n4 méthodes\n\nMAC seul\nMDC+cryptage\nMDC+cryptage confidentiel\nMDC+signature\n\nAttention : Vulnérable aux replay attacks sans mécanisme temporel\n\n\n\n\n\n\n\n\ngraph LR\n    A[Émetteur A] --&gt;|X, MAC/Signature| B[Récepteur B]\n    B --&gt;|Vérifie| C{Authentique?}\n    C --&gt;|Oui| D[Accepte]\n    C --&gt;|Non| E[Rejette]\n    \n    style A fill:#e1f5ff\n    style B fill:#e1f5ff\n    style D fill:#d4edda\n    style E fill:#f8d7da\n\n\n\n\n\n\n\n\n\nAuthentification d’Entités - Introduction\n\nObjectifs d’un protocole robuste\nL’authentification d’entités (ou identification) vise à prouver l’identité d’une entité en temps réel.\nPropriétés requises :\n\nSi A et B sont honnêtes et A s’authentifie, B doit accepter l’identité de A\nB ne peut pas réutiliser l’information de A pour se faire passer pour A auprès de C\nProbabilité négligeable qu’une entité C réussisse à usurper l’identité de A\nLa propriété 3 reste vraie même si C a observé ou participé à des instances précédentes\n\nÉléments de base :\n\nSomething known : passwords, PINs, clés\nSomething possessed : carte à puce, générateur de passwords\nSomething inherent : biométrie (empreintes, rétine, ADN)\n\nClassification :\n\nAuthentification faible : Révélation du secret (userid/password)\nAuthentification forte : Preuve de possession du secret sans le révéler\nZero-knowledge : Authentification forte sans révéler aucune information sur le secret\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification d’entités (entity authentication), aussi appelé identification\nObjectifs d’un protocole d’identification robuste :\n\nSi A et B sont “honnêtes” : si A est capable de s’authentifier auprès de B, B doit accepter l’identité de A.\nB ne peut pas réutiliser l’information remise par A pour s’identifier en tant que A auprès de C.\nLa probabilité qu’une tierce entité C réussisse à se faire passer par A auprès de B est négligeable.\nLe point 3) reste vrai même si :\n\nC a observé un grand nombre (polynomial) d’instances du protocole d’identification entre A et B\nC a participé (éventuellement en se faisant passer par quelqu’un d’autre) à des exécutions précédentes du protocole d’identification auprès de A ou B\nPlusieurs instances du protocole (éventuellement initiées par C) peuvent s’exécuter simultanément sans compromettre le processus d’identification\n\n\nTerminologie : L’utilisateur (A) est appelé claimant (celui qui prétend être A), le système (B) est le verifier (celui qui vérifie l’identité).\nÉléments de base pour l’authentification :\n\nsomething known : passwords, PINs, clés privées ou secrètes, etc.\nsomething possessed : passeport, carte à puces, générateurs de passwords, etc.\nsomething inherent to the human individual : propriétés biométriques comme les empreintes digitales, la rétine, le code ADN, etc.\n\nAuthentification faible (weak authentication) : L’utilisateur présente un couple (userid, password) au système. Le userid est l’identité prétendue et le password l’évidence corroborant.\nAuthentification forte (strong authentication) : Le secret permettant de corroborer l’identité n’est pas révélé explicitement. L’utilisateur fournit au système une preuve de possession de ce secret.\nAuthentification par zero knowledge : Protocoles d’authentification forte qui ont en plus la caractéristique de prouver l’identité sans dévoiler aucune information (ni même une piste) sur le secret lui-même. Il s’agit de donner une preuve d’une assertion sans en révéler le moindre détail.\nLes protocoles d’authentification faible satisfont les points 1) et 3). Les protocoles d’authentification forte satisfont (au moins partiellement) les points 2) et 4) en plus.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\n3 niveaux : Faible (révèle secret) &lt; Forte (preuve de possession) &lt; Zero-knowledge (aucune info révélée)\n4 objectifs\n\nAcceptation si honnête\nnon-réutilisation\nrésistance usurpation\nrésistance observation"
  },
  {
    "objectID": "exam_notes_fr.html#attaques-et-contre-mesures",
    "href": "exam_notes_fr.html#attaques-et-contre-mesures",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques et contre-mesures",
    "text": "Attaques et contre-mesures\n\nAttaques Dictionnaire\n\nPrincipe et contre-mesures\nUne attaque dictionnaire teste systématiquement des mots de passe probables contre un système cryptographique.\nMéthodes d’attaque :\n\nOffline : L’attaquant obtient la base de données hashées des mots de passe ou capture des échanges\nOnline : Tentatives directes contre le système (généralement limitées par le système)\n\nExemple de vulnérabilité :\n\nA → B: A\nA ← B: R (challenge aléatoire)\nA → B: \\(E_p\\)(R)\n\nLe couple (R, \\(E_p\\)(R)) permet une attaque dictionnaire offline.\nContre-mesures :\n\nLimitation des tentatives online\nSalting (ajout d’un élément aléatoire)\nUtilisation de fonctions de dérivation lentes\nAuthentification forte évitant la transmission du password\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAttaques Dictionnaire (Dictionary Attacks)\nUne attaque dictionnaire consiste à utiliser une base de données contenant des mots de dictionnaire d’une ou plusieurs langues (ainsi que des variantes) comme entrée à un système d’encryption ou de hachage afin d’obtenir des clés secrètes ou des passwords.\nCette attaque est très efficace pour obtenir des mots de passe de mauvaise qualité même si dès nos jours il existent des bases de données de très grande taille contenant des variations de mots ainsi que des règles mnémotechniques complexes permettant de “casser” des mots de passe de plus forte entropie.\nUne attaque dictionnaire peut être montée :\n\nEn obtenant la base de données des mots de passe (encryptée ou hashée) du système d’authentification\nÀ partir d’un ou plusieurs échanges d’une instance d’authentification, suite à une attaque passive (observation de paquets réseau). Par exemple :\n\nA → B: A (A envoie son identité)\nA ← B: R (R = un nombre aléatoire, challenge)\nA → B: \\(E_p\\)(R) (A encrypte R avec son password)\n\nLe couple (R, \\(E_p\\)(R)) permet de monter une attaque dictionnaire offline.\n\nLes attaques dictionnaire sont normalement moins efficaces online car les systèmes d’exploitation limitent le nombre d’essais infructueux d’authentification.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nOffline (via BdD ou capture) &gt; Online (limitée par le système)\nProtection : salting, limitation tentatives, authentification forte\n\n\n\n\n\n\n\nPlaintext-Equivalence\n\nConcept et risques\nUne chaîne est plaintext-equivalent à un password si elle permet d’obtenir le même accès que le password lui-même.\nExemple de vulnérabilité :\nSi le système stocke H(p) et que le protocole est : A → B: H(p)\nAlors H(p) est plaintext-equivalent à p car l’attaquant peut l’utiliser directement.\nContre-exemple (UNIX classique) :\nLe système stocke H(p) mais le protocole transmet p. Le hash stocké n’est donc pas plaintext-equivalent.\nPrincipe de sécurité : Les informations stockées par le serveur ne doivent être ni plaintext-equivalent aux passwords ni exposées à des attaques dictionnaire offline.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nEquivalence Plaintext (Plaintext-Equivalence)\nUne chaîne de données est dite plaintext-equivalent à un mot de passe si elle peut être utilisée pour obtenir le même niveau d’accès correspondant à l’utilisation du password.\nExemple : Si le système B stocke une liste de tous les mots de passe hashés dans le procédé d’authentification suivant : A → B: H(p) (A envoie à B le hash du password)\nLa chaîne d’information H(p) est plaintext-equivalent au mot de passe p.\nCeci est équivalent à dire que l’application d’une fonction de hachage pour le stockage des passwords ne constitue pas une sécurité supplémentaire pour le système.\nContre-exemple : Dans le système d’authentification classique d’UNIX, le hash du password stocké dans le fichier /etc/passwd n’est pas plaintext-equivalent au mot de passe car c’est p et non pas H(p) qui est échangé entre le client et le serveur.\nCette propriété est essentielle car les bases de données des mots de passe sont normalement protégées par des mécanismes logiques qui sont souvent mis en évidence par des failles du système d’exploitation du serveur.\nSi ces bases de données centrales contiennent des mots de passe en clair ou des informations plaintext-equivalent à ces derniers, les conséquences en cas d’attaque sont dévastatrices.\nLe cas idéal est que les informations stockées par le serveur ne soient ni plaintext-équivalent aux passwords ni exposées à des attaques dictionnaire offline.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nPlaintext-equivalent : Donnée utilisable comme le password original\nDanger : Si le système transmet H(p) et stocke H(p) → H(p) est plaintext-equivalent\nBon design : Système transmet p, stocke H(p) → pas plaintext-equivalent"
  },
  {
    "objectID": "exam_notes_fr.html#authentification-faible",
    "href": "exam_notes_fr.html#authentification-faible",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Authentification Faible",
    "text": "Authentification Faible\n\nPasswords Fixes\n\nStockage et protection\nLes systèmes à password fixe présentent des vulnérabilités importantes.\nTechniques de stockage :\n\nEn clair : Protection par contrôle d’accès OS (vulnérable aux failles OS, backups)\nEncrypté ou hashé : Vulnérable aux attaques offline (guessing, dictionary, collisions)\n\nProblème majeur : Le password peut être rejoué après observation sur un réseau non protégé.\nTechniques de protection :\n\nRègles strictes de création (entropie minimale)\nRalentissement et limitation du nombre de tentatives\nSalting : Ajout d’un élément aléatoire avant hachage\nRestriction de diffusion des fichiers de passwords\n\nEntropie typique des passwords : Faible (~40 bits pour un password de 8 caractères aléatoires, beaucoup moins pour des mots courants).\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification Faible - Password fixe\nLes systèmes d’authentification faible sont divisés en deux catégories principales :\n\nPassword fixe : Le password ne dépend pas du temps ni du nombre de fois que le protocole d’identification a été exécuté. Cette catégorie inclut les systèmes où le password est changé par décision de l’utilisateur ou par mesure de sécurité du système.\nPassword variable : La modification du password en fonction du temps et/ou du nombre d’exécutions fait partie du protocole d’identification.\n\nTechniques de stockage propres aux systèmes à password fixe :\n\nStockage du password en clair dans un fichier protégé par les mécanismes de contrôle d’accès propres au système d’exploitation.\n\nProblèmes : failles dans le OS, privilèges du “super-user”, backups, etc.\n\nStockage du password encrypté ou après l’application d’une one-way function (éventuellement en rendant publique l’accès à ce fichier, cf. exemple UNIX).\n\nProblèmes : attaques off-line, i.e. guessing attacks, brute-force dictionary attacks, identification de collisions, etc.\n\n\nProblème le plus grave du password fixe : il peut être rejoué après avoir écouté une instance d’identification sur un réseau non protégé.\nTechniques de protection des systèmes de password fixe :\n\nRègles strictes de comportement concernant la création, le maintien et la mise à jour des passwords en tenant compte de la faible entropie des passwords choisis habituellement par les utilisateurs\nRalentir le processus d’identification ainsi que limiter le nombre d’essais infructueux afin de contrer les “on-line brute force attacks”\nSalting (cf. exemple UNIX)\nRestreindre ou même éviter la diffusion des fichiers de mots de passe, même encryptés\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\n2 types : Password fixe (statique) vs Password variable (change à chaque instance)\nStockage : Clair (très vulnérable) vs Encrypté/Hashé (attaques offline)\nProtections : Règles strictes, limitation tentatives, salting, non-diffusion\n\n\n\n\n\n\n\nPasswords Variables\n\nOne-time passwords et générateurs\nLes passwords variables changent à chaque authentification, réduisant le risque de replay.\nSchéma de Lamport (S-Key) :\nInitialisation :\n  A génère secret w, choisit t\n  A → B: wt = Ht(w)\n  B stocke: wstored := wt, n := t-1\n\nIdentification (t-n)ème :\n  A → B: A, n, wn = Hn(w)\n  B teste: H(wn) == wstored\n  Si OK: n := n-1, wstored := wn\nAttaques si B non authentifié :\n\nPre-play attack : C obtient wn avant A et le rejoue\nSmall n attack : C demande un n &lt; ncourant\n\nGénérateurs hardware (SecureID) :\n\nCarte générant un code toutes les 30-60 secondes\nBasé sur une clé secrète partagée avec le système\nVulnérable au pre-play mais fenêtre temporelle limitée\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification Faible : Password Variable\nLes deux techniques les plus connues d’identification par password variable sont les one-time passwords et les générateurs (hardware) de nombres aléatoires.\nOne-time passwords - Schéma de Lamport (S-Key) :\nInitialisation :\n\nA génère un secret w\nUne constante t (= nb. d’identifications ~1000) et une OWF H sont choisies\nA → B: wt = Ht(w) (H appliqué t fois à w)\nB stocke : wstored := wt, n := t-1\n\nMessages correspondants à l’identification (t-n)ème :\n\nA → B: A (identité de A)\nA → B: n (itération courante pour A)\nA → B: wn = Hn(w)\nB teste : H(wn) == wstored. Si OK ⇒ n := n - 1 et wstored := wn\n\nFin : Quand n == 0, A choisit un nouveau w et on recommence…\nAttaques : Authentification de B nécessaire! Sinon : C se fait passer par B et :\n\nobtient le mot de passe courant wn et peut le rejouer (pre-play attack)\nfournit un n &lt; ncourant et peut ainsi générer tous les Hm&gt;n(wn) (small n attack)\n\nGénérateurs (hardware) de nombres aléatoires :\n\nIl s’agit de cartes à puces qui générent périodiquement (~ tous les 30 ou 60 secs) des nombres différents servant à identifier (avec en plus, un PIN et des informations sur l’identité de la personne) le détenteur de la carte.\nLa génération se fait à partir d’une clé secrète présente sur la carte et connue du système.\nLe plus connu est SecureId fabriquée par RSA Security.\nIl a été adopté par de nombreuses banques comme support d’authentification du tele-banking sur Internet.\nIl est également exposé au pre-play attack mais le délai pour rejouer le password se limite à la fréquence de changement (30 ou 60 secs).\n\nConclusions authentification faible :\n\nLes password fixes offrent un niveau de sécurité très réduit.\nLes password variables constituent un pas important vers l’authentification forte mais nécessitent des précautions supplémentaires.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nLamport : wn+1 = H(wn), authentification par vérification de la chaîne de hash\nHardware : Générateur synchronisé (30-60s), limité au pre-play\nAttention : Nécessite authentification de B pour éviter pre-play et small-n attacks"
  },
  {
    "objectID": "exam_notes_fr.html#authentification-forte",
    "href": "exam_notes_fr.html#authentification-forte",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Authentification Forte",
    "text": "Authentification Forte\n\nSymétrique\n\nProtocoles de Base\n\nChallenge-Response\nL’authentification forte utilise la cryptographie pour prouver la possession d’un secret sans le révéler.\nAuthentification unilatérale basique :\nA → B: A\nA ← B: R (challenge aléatoire)\nA → B: Ek-AB(R)\nB vérifie en décryptant\nClé de session : K := R\nAméliorations :\n\nAjouter identité de B : Es(B, ra) pour key confirmation\nAjouter timestamp : Es(B, ta, ra) pour freshness (nécessite horloges synchronisées)\nUtiliser MAC au lieu d’encryption : Hk-AB(R) (plus rapide)\n\nVulnérabilités :\n\nMan-in-the-Middle si pas d’authentification mutuelle\nChosen-plaintext attacks possibles\nReplay si challenges mal gérés\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification Forte : Solutions Symétriques\nLes protocoles d’authentification forte utilisent des techniques cryptographiques symétriques ou asymétriques.\nAuthentification unilatérale à clé symétrique partagée :\nA → B: A (A envoie son identité)\nA ← B: R (R = un nombre aléatoire, challenge)\nA → B: Ek-AB(R) (A encrypte R avec la clé partagée)\nB décrypte Ek-AB(R) et identifie A s’il trouve R\nRemarques :\n\nB doit s’assurer que le challenge R est aléatoire et ne doit pas le répéter.\nCe protocole constitue une amélioration remarquable par rapport à l’authentification par password car la variation des challenges empêche Eve de rejouer des parties du protocole.\nEve peut essayer un off-line known-plaintext attack à partir d’un nombre (qui reste normalement réduit) de couples (R, Ek-AB(R)) mais la plupart des systèmes de cryptage sont sûrs à cet égard (DES est vulnérable seulement à partir de 247 paires).\nC peut se faire passer par B et choisir ses challenges R pour monter un chosen-plaintext attack (la vulnérabilité de DES à cet égard est aussi de 247 mais d’autres systèmes de cryptage sont plus sensibles à ces attaques).\nC pourrait monter une attaque Active Man-in-the-Middle en se faisant passer par B puisque B n’est pas authentifié, mais il doit convaincre A pour commencer le protocole.\nUn MDC : H(k-AB,R) ou un MAC : Hk-AB(R) peuvent remplacer Ek-AB(R) et accélérer l’identification.\nAprès l’identification initiale, un canal sûr (au moins authentifié) doit être établi à l’aide d’une protection cryptographique pour éviter que C puisse injecter des paquets en se faisant passer par A.\n\nLes protocoles de ce type où une entité doit répondre en tenant compte d’un challenge proposé par l’autre s’appellent challenge and response protocols et sont la forme la plus répandue d’authentification forte.\nAuthentification unilatérale à clé symétrique partagée, 2ème variante :\nA → B: A, Ek-AB(timestamp)\nHorloges synchronisées entre A et B nécessaires.\nAvantage : un message en moins et protocole stateless\nMais :\n\nLa synchronisation d’horloges est difficile à obtenir dans la réalité et des “flottements” peuvent être exploités par un adversaire.\nDe plus, si on arrive à convaincre B “d’avancer sa montre”, certaines instances d’identification passées peuvent redevenir valables.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nChallenge-Response : B envoie challenge R, A répond avec E_k(R)\nAlternative : MAC au lieu d’encryption (plus rapide)\nAvec timestamp : Un message en moins mais nécessite synchronisation horloges\n\n\n\n\n\n\n\nAuthentification Mutuelle\n\nProtocoles robustes et reflection attacks\nL’authentification bilatérale nécessite des précautions contre les reflection attacks.\nProtocole vulnérable (naïf) :\nA → B: A, R2\nA ← B: R1, Ek-AB(R2)\nA → B: Ek-AB(R1)\nAttaque par réflexion : C peut démarrer deux instances et utiliser la réponse de B à sa propre requête pour compléter l’authentification.\nProtocole robuste :\n(1) A → B: A, R2\n(2) A ← B: Ek-AB(R1, R2, A)\n(3) A → B: Ek-AB(R2, R1)\nProtections :\n\nInclusion de l’identité A dans (2) contre reflection attacks\nAsymétrie dans l’ordre des challenges (R1,R2) vs (R2,R1)\nInclusion des challenges dans le message encrypté\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification Forte : Solutions Symétriques (Authentification mutuelle)\nAuthentification bilatérale à clé symétrique partagée (solution intuitive) :\nA → B: A, R2\nA ← B: R1, Ek-AB(R2)\nA → B: Ek-AB(R1)\nÀ première vue le protocole semble robuste mais observons ce qu’un adversaire C peut faire en démarrant deux processus d’identification :\nC → B: A, R2 (C prétend être A)\nC ← B: R1, Ek-AB(R2) (B répond)\nÀ ce moment, C démarre une deuxième instance :\nC → B: A, R1\nC ← B: R3, Ek-AB(R1) (C ne peut plus poursuivre mais...)\nComplète avec succès la première instance d’identification avec :\nC → B: Ek-AB(R1) (et c'est fait !)\nDu fait que C renvoie à B le même R qu’il a reçu de lui, ce genre d’attaques s’appellent reflection attacks.\nComme la clé est partagée, C aurait pu obtenir le même résultat (même plus discrètement) en exécutant la deuxième instance auprès de A (en prétendant être B).\nAuthentification bilatérale avec clé symétrique partagée (solution robuste) :\n(1) A → B: A, R2\n(2) A ← B: Ek-AB(R1, R2, A)\n(3) A → B: Ek-AB(R2, R1)\nLa présence de A dans (2) rajoute une sécurité supplémentaire au cas où les reflection attacks évidents ne sont pas détectés par le protocole. Autrement, si A lance une authentification avec celui qu’il croit B mais qui est en réalité C :\nA → C: A, R2 (*)\nAlors C commence une nouvelle instance d’authentification avec A avec le même R2 :\nC → A: B, R2\nSi A ne voit pas R2 comme réflexion évidente, alors il répond :\nC ← A: Ek-AB(R1, R2) (Comme dans (2) mais sans le 'A')\nCe qui est utilisé par C pour compléter son protocole (*). Cependant, si A répond avec B à l’intérieur du paquet comme recommandé dans le protocole :\nA → C: Ek-AB(R1, R2, B)\nCeci ne sera plus utilisable par C pour continuer (*) car il faudrait A à la place de B.\nÀ noter également que le fait d’inclure R1 dans la partie encryptée protège également des dangers de chosen plaintext attacks de la solution précédente.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nReflection attack : Utiliser la réponse d’une session pour en authentifier une autre\nProtection : Inclure identités + asymétrie dans challenges (R1,R2) vs (R2,R1)\n\n\n\n\n\n\n\n\nAsymétrique\n\nProtocoles à clés publiques\nL’asymétrie permet d’éviter le partage de secrets mais nécessite des précautions contre les chosen-ciphertext attacks.\nProtocole vulnérable :\nA → B: A\nA ← B: Epub-A(R)\nA → B: R\nProblème : B peut faire décrypter n’importe quoi à A.\nProtocole robuste :\nA → B: A\nA ← B: H(R), B, Epub-A(B, R)\nA → B: R (après vérification de H(R) et B)\nProtection : Structurer le texte encrypté et prouver la connaissance du plaintext via H(R).\nAuthentification mutuelle (Needham-Schroeder) :\n(1) A → B: Epub-B(r1, A)\n(2) A ← B: Epub-A(r1, r2)\n(3) A → B: Epub-B(r2)\nLa présence de A dans (1) empêche les chosen-ciphertext attacks.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification Forte : Solutions Asymétriques\nAuthentification unilatérale à clé asymétrique (solution intuitive…) :\nA → B: A\nA ← B: Epub-A(R) (B encrypte avec la clé publique de A)\nA → B: R (A retourne R après décryptage)\nRemarques :\n\nB doit connaître la clé authentique de A pour éviter des man-in-the-middle attacks.\nMais surtout : B peut monter des chosen-ciphertext attacks (i.e. B peut faire décrypter n’importe quoi à A!).\n\nAuthentification unilatérale avec clé asymétrique (solution robuste) :\nIdée : structurer le texte encrypté avec pub-A et montrer que B connaît le plaintext :\nA → B: A\nA ← B: H(R), B, Epub-A(B, R) (H(R) témoigne du fait que B connaît R)\nA décrypte Epub-A(B, R) et obtient B’ et R’. A suspend le protocole si h(R') ≠ h(R) ou B' ≠ B, sinon :\nA → B: R\nB identifie A si coïncidence avec le R initial.\nUn protocole dual peut être imaginé en utilisant la signature de A avec priv-A (au lieu de l’encryption avec pub-A), mais les mêmes précautions concernant la structure s’appliquent pour éviter que A signe un message “mal intentionné” généré par B.\nAuthentification bilatérale à clé asymétrique. Solution robuste due à Needham et Schroeder :\n(1) A → B: Epub-B(r1, A)\n(2) A ← B: Epub-A(r1, r2)\n(3) A → B: Epub-B(r2)\nÀ noter que la présence de A dans (1) démonte les chosen ciphertext attacks.\nLe protocole peut être renforcé en rajoutant un “témoin” H(r1) dans (1).\nRemarques finales sur authentification classique :\n\nL’authentification d’entités est un processus très complexe rempli de pièges inespérés.\nCertains protocoles comme celui proposé par l’ISO en 1988 pour l’authentification dans les répertoires distribués ont des failles très semblables à celles que nous avons mis en évidence ici.\nLorsque l’identification se fait dans le cadre d’une session, il est impératif que tous les paquets propres à la session soient authentifiés (p.ex. moyennant l’établissement d’un canal sûr avec l’établissement de clés de session).\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nVulnérabilité : Chosen-ciphertext attacks si pas de structure\nProtection : Inclure H(R), identité B dans le message encrypté, A vérifie avant de révéler R\nNeedham-Schroeder : 3 messages avec inclusion identités pour éviter chosen-ciphertext"
  },
  {
    "objectID": "exam_notes_fr.html#zero-knowledge-proofs",
    "href": "exam_notes_fr.html#zero-knowledge-proofs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Zero-Knowledge Proofs",
    "text": "Zero-Knowledge Proofs\n\nConcepts\n\nDéfinitions et principes\nLes preuves à divulgation nulle de connaissance permettent de prouver la possession d’un secret sans révéler aucune information sur celui-ci.\nPropriétés requises :\n\nConsistance (completeness) : Si A et B sont honnêtes, B accepte la preuve de A\nSignificativité (soundness) : Si C réussit à tromper B, alors C détient le secret de A (ou équivalent)\nZero-knowledge : B ne peut rien apprendre sur le secret de A\n\nStructure générique :\n(1) A → B: témoin (witness)\n(2) A ← B: défi (challenge)\n(3) A → B: réponse (response)\nTypes de ZKIP :\n\nComputational ZKIP : Un observateur en temps polynomial ne peut distinguer une vraie preuve d’une simulation\nPerfect ZKIP : Aucune différence probabiliste entre vraie preuve et simulation (garantie par théorie de l’information)\n\nPrincipe :\n\nA s’engage sur une classe de questions (1)\nB choisit une question dans cette classe (2)\nA répond en utilisant son secret (3)\nRépétition pour réduire la probabilité de deviner.\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nZero Knowledge Proofs : Définitions\nProblème avec les méthodes d’authentification “classiques” : B (ou même un observateur) est en mesure d’obtenir des informations sur le secret détenu par A :\n\nDans les méthodes d’authentification faible (par password) c’est le secret dans son intégrité qui est dévoilé.\nDans les méthodes challenge and response classiques, B peut obtenir des couples [plaintext / ciphertext] pouvant servir à la cryptanalyse.\n\nDéfinition : Un protocole interactif est une preuve de connaissance (proof of knowledge) lorsqu’il a les deux caractéristiques suivantes :\n\nConsistance (completeness) : si A et B sont deux entités “honnêtes”, B accepte la preuve fournie par A.\nSignificativité (soundness) : Si une entité “malhonnête” C est capable de “tromper” B alors C détient le secret de A (ou une information polynomialement équivalente au secret). Ceci équivaut à exiger la possession du secret pour la réussite de la preuve.\n\nUne preuve de connaissance interactive est dite “sans apport d’information” (zero knowledge interactive proof ou ZKIP) si elle a, en plus, la propriété que A est capable de convaincre B sur un fait sans ne révéler aucune information sur le secret qu’elle possède.\nUn protocole est une ZKIP calculatoire (computational ZKIP) si un observateur capable d’effectuer des tests probabilistes en temps polynomial n’est pas capable de distinguer une preuve authentique (où A répond) d’une preuve simulée (p.ex. par un générateur aléatoire).\nUn protocole est une ZKIP parfait (perfect ZKIP) s’il n’existe aucune différence (au sens probabiliste) entre la vraie preuve et la preuve simulée. L’absence d’information dans la preuve est garantie par la théorie de l’information de Shannon et non pas par des critères calculatoires.\nStructure générique d’une ZKIP :\n(1) A → B: témoin (witness)\n(2) A ← B: défi (challenge)\n(3) A → B: réponse (response)\n\n(1) A choisit un nombre aléatoire secret et envoie à B une preuve de possession de ce secret. Ceci constitue un engagement de la part de A et définit une classe de questions à laquelle A prétend savoir répondre.\n(2) Le défi envoyé par B choisit (aléatoirement) une question dans cette classe.\n(3) A répond (en utilisant son secret).\n\nSi nécessaire, le protocole est répété afin de réduire au maximum la probabilité qu’un “imposteur” devine “par chance” les réponses correctes.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\n3 propriétés : Consistance (accepte si honnête), Significativité (nécessite secret), Zero-knowledge (aucune info révélée)\nStructure : Témoin → Défi → Réponse (répéter n fois)\nPerfect ZK : Indistinguable d’une simulation même avec ressources infinies\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant A as Prouveur A\n    participant B as Vérifieur B\n    \n    Note over A: Génère témoin&lt;br/&gt;avec secret s\n    A-&gt;&gt;B: (1) Témoin\n    Note over B: Choisit défi&lt;br/&gt;aléatoire\n    B-&gt;&gt;A: (2) Défi\n    Note over A: Calcule réponse&lt;br/&gt;avec secret s\n    A-&gt;&gt;B: (3) Réponse\n    Note over B: Vérifie&lt;br/&gt;Accepte/Rejette\n    \n    Note over A,B: Répéter n fois pour&lt;br/&gt;sécurité 1/2^n\n\n\n\n\n\n\n\n\n\n\nZKIP - Exemple Intuitif (Caverne d’Ali Baba)\n\nIllustration du concept\nCet exemple illustre intuitivement le principe de zero-knowledge.\nScénario :\n\nA connaît le passage secret entre y et z dans une caverne\nB veut vérifier cette connaissance sans apprendre comment traverser\n\nProtocole :\n\nB se tient à l’entrée E\nA choisit d’aller vers y ou z (témoin)\nB entre et s’arrête au point x\nB demande à A de revenir par la droite ou la gauche (défi)\nA utilise le secret pour obéir (si nécessaire)\n\nRépétition : n fois. Si A ne connaît pas le secret : probabilité de succès = \\(2^{-n}\\)\nPropriétés :\n\nB constate que A peut traverser mais n’apprend pas comment\nB ne peut convaincre une tierce partie B’ (A et B auraient pu convenir des séquences)\nInspiré de la technique du “cut and choose”\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nZKIP : Exemple Intuitif\nCet exemple est décrit dans [Qui89] (Quisquater et al., “How to Explain Zero-Knowledge Protocols to Your Children”, Crypto’89). Admettons que A connaît un passage entre y et z (le secret).\n    E\n    |\n    x\n   / \\\n  y   z\n(1) B se tient à l’entrée de la caverne au point E.\n(2) A choisit une direction et se dirige vers les points y ou z (choix de témoin).\n(3) Une fois A à l’intérieur de la caverne, B entre à son tour mais s’arrête au point x.\n(4) B demande à A de se rendre au point x par la droite ou par la gauche (le défi).\n(5) En utilisant le secret pour passer de y à z (ou réciproquement) si nécessaire, A obéit aux instructions de B.\nRépéter les points 1 à 5 n fois. Si A ne connaît pas le secret, il a une probabilité de \\(2^{-n}\\) de réussir à tromper B (de deviner “juste”).\nDans cet exemple, B constate que A peut traverser à volonté le passage yz mais n’obtient aucune information sur la manière de le faire même si le protocole est exécuté des millions de fois.\nPar ailleurs, B ne peut pas convaincre B’ du fait que A connaît le secret (comme il aurait été le cas si A encryptait une information en utilisant une clé privée, p.ex.). B’ pourrait suspecter A et B d’avoir convenu les séquences (droite/gauche).\nCe genre de protocoles sont inspirés de la technique du “cut and choose” où A et B partagent équitablement une tarte en suivant les étapes suivantes : - A coupe la tarte. - B choisit un morceau. - A prend le morceau restant.\nLe premier ZKIP a été publié en 1985 par S. Goldwasser [Gol85]. L’application du paradigme du cut and choose aux protocoles cryptographiques est due à Rabin [Rab78].\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCaverne : A entre aléatoirement (y ou z), B demande sortie (gauche/droite)\nProbabilité triche : \\(2^{-n}\\) après n répétitions\nZK : B vérifie connaissance mais n’apprend pas le secret, ne peut convaincre tierce partie\n\n\n\n\n\n\n\nZKIP - Isomorphisme de Graphes\n\n\n\n\n\n\nNoneZKIP - Isomorphisme de Graphes\n\n\n\n\n\nProtocole formel\nLes preuves zero-knowledge peuvent être construites sur des problèmes mathématiques difficiles.\nContexte : Deux graphes \\(G_1\\) et \\(G_2\\) sont isomorphes s’il existe une permutation \\(\\pi\\) telle que pour tout arc \\(\\{u,v\\} \\in E_1\\), on a \\(\\{\\pi(u), \\pi(v)\\} \\in E_2\\).\nPropriété : Trouver la permutation \\(\\pi\\) entre deux graphes de ~1000 sommets est calculatoirement difficile (pas d’algorithme polynomial connu).\nProtocole :\nInit: A choisit G1 et crée G2 = π(G1) avec π secret\n(1) A → B: H (A crée H = φ(G2) aléatoire)\n(2) A ← B: i ∈ {1,2}\n(3) A → B: ψ tel que H = ψ(Gi)\n    Si i=2: ψ := φ\n    Si i=1: ψ := φ ∘ π\n(4) B vérifie H = ψ(Gi)\n(5) Répéter n fois\nVérification zero-knowledge parfait : Les transcriptions du protocole sont indistinguables (distribution probabiliste) de celles produites par un simulateur.\n\n\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nZKIP : Isomorphisme de Graphes\nDeux graphes \\(G_1 = (V_1,E_1)\\) et \\(G_2=(V_2,E_2)\\) sont isomorphes s’il existe une permutation \\(\\pi\\) t.q. \\(\\{u,v\\} \\in E_1\\) ssi \\(\\{\\pi(u), \\pi(v)\\} \\in E_2\\).\nExemple : \\(G_1 = (V, E_1)\\) et \\(G_2=(V, E_2)\\) avec \\(V = \\{1,2,3,4\\}\\), \\(E_1= \\{12,13,23,24\\}\\), et \\(E_2 = \\{12,13,14,34\\}\\) sont isomorphes avec la permutation \\(G_1 \\to G_2 : \\{4,1,3,2\\}\\):\nG1:  1---2    G2:  4---1\n     |\\ /|         |\\ /|\n     | X |         | X |\n     |/ \\|         |/ \\|\n     3---4         3---2\nÀ partir d’un graphe \\(G_1\\), on peut facilement (en temps polynomial) trouver une permutation \\(\\pi\\) t.q. \\(G_2 = \\pi(G_1)\\).\nCependant, aucun algorithme polynomial n’est connu pour déterminer si deux graphes suffisamment grands (~1000 sommets) sont isomorphes (c.à.d. trouver la permutation \\(\\pi\\) à partir des \\(G_1\\) et \\(G_2\\)).\nZKIP sur la base de l’isomorphisme des graphes :\n(Initialisation) A choisit un graphe \\(G_1\\) suffisamment grand et invente une permutation \\(\\pi\\) (le secret) lui permettant de calculer un deuxième graphe \\(G_2 = \\pi(G_1)\\). \\(G_1\\) et \\(G_2\\) sont rendus publiques.\n(1) A → B: H\nA choisit une permutation aléatoire \\(\\phi\\) telle que \\(H = \\phi(G_2)\\) et envoie H à B (le témoin)\n(2) A ← B: i\nB choisit un entier \\(i \\in \\{1,2\\}\\) et l’envoie à A (le défi)\n(3) A → B: ψ\nA calcule \\(\\psi\\) telle que \\(H = \\psi(G_i)\\) : - Si \\(i = 2\\) : \\(\\psi := \\phi\\) - Si \\(i = 1\\) : \\(\\psi := \\phi \\circ \\pi\\)\n(4) B contrôle si \\(H = \\psi(G_i)\\) et accepte l’étape comme juste.\n(5) Répéter (1) à (4) un nombre de fois assez grand pour minimiser les risques de “deviner juste”.\nVérification des propriétés :\n\nConsistance : Le protocole est accepté si A connaît le secret (i.e. la permutation \\(\\pi\\) entre les deux graphes).\nSignificativité : Si C essaye de se faire passer par A sans connaître \\(\\pi\\), il pourra fixer un j et fournir une permutation correcte \\(\\psi(G_j)\\) mais ne pourra pas trouver une permutation correcte pour les deux graphes. Il devra se contenter de deviner le défi fourni par B.\nZero-Knowledge : A réussit à convaincre B du fait que les deux graphes sont isomorphes mais n’apprend rien sur \\(\\pi\\). B ne voit qu’un graphe aléatoire H isomorphe à \\(G_1\\) et \\(G_2\\) ainsi qu’une permutation entre H et \\(G_1\\) ou entre H et \\(G_2\\).\nZéro-Knowledge parfait : Ceci équivaut à dire que B pourrait générer de telles informations tout seul (à l’aide d’un générateur aléatoire et des calculs polynomiaux). On peut prouver que les transcriptions fournies par le protocole ne peuvent se distinguer (d’un point de vue de distribution probabiliste) de celles produites par un simulateur (même en admettant que B “triche”).\n\nL’utilisation du paradigme de l’isomorphisme de graphes dans les protocoles d’authentification reste relativement marginale dû à des problèmes d’efficacité d’implantation.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nProblème : Trouver permutation entre 2 graphes isomorphes = difficile\nProtocole : A crée H aléatoire, B demande permutation vers G1 ou G2, A répond\nPerfect ZK : Transcriptions indistinguables d’un simulateur\n\n\n\n\n\n\nZKIP - Algorithme de Fiat-Shamir\n\nProtocole pratique\nFiat-Shamir est un protocole ZKIP efficace et pratique basé sur le problème de la racine carrée modulo un composite.\nInitialisation :\n\nTierce de confiance T choisit \\(n = pq\\) (garde p,q secrets)\nA choisit secret \\(s\\) avec \\(\\gcd(s,n) = 1\\)\nA calcule \\(v = s^2 \\bmod n\\) et distribue v (clé publique certifiée)\n\nProtocole :\n(1) A → B: x = r² mod n\n    (A choisit r aléatoire, témoin)\n\n(2) A ← B: e ∈ {0,1}\n    (B envoie défi)\n\n(3) A → B: y = r·sᵉ mod n\n    (A calcule réponse avec secret s)\n\nB rejette si y = 0\nB accepte si y² ≡ x·vᵉ (mod n)\nRépétition : Plusieurs fois pour sécurité \\(2^{-nk}\\)\nPropriétés :\n\nSignificativité : Un imposteur peut répondre à e=0 facilement, mais pour e=1 il devrait calculer \\(\\sqrt{x} \\bmod n\\) (difficile par SQROOTP)\nZero-knowledge parfait : Les paires (x,y) peuvent être simulées par B en choisissant y aléatoire et calculant \\(x = y^2\\) ou \\(y^2/v\\)\nB ne peut se faire passer pour A car il ne peut prédire les défis\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nZKIP : Algorithme de Fiat-Shamir\nBut : Permettre à A de s’identifier en prouvant la connaissance d’un secret s (associé à A au moyen d’informations publiques authentiques) auprès de B sans lui révéler des informations sur s.\nIl s’agit d’un protocole qui sert comme base à des implantations réelles et efficaces.\nAlgorithme :\n(Initialisation) :\n\nUn tierce de confiance, T choisit et publie un n t.q. \\(n = pq\\) et garde p et q secrets.\nA choisit un secret s avec \\(1 \\leq s \\leq n -1\\) et \\(\\gcd(s,n) = 1\\), calcule \\(v = s^2 \\bmod n\\) et distribue v comme clé publique certifiée par T.\n\n(1) A → B: x = r² mod n\nA choisit un r aléatoire et envoie un témoin \\(r^2\\)\n(2) A ← B: e ∈ {0,1}\nB envoie son défi\n(3) A → B: y = r·sᵉ mod n\nA calcule la réponse en utilisant le secret s.\nB rejette la preuve si \\(y = 0\\) (un imposteur pourrait fausser la preuve avec \\(r = 0\\)) et accepte la preuve si \\(y^2 \\equiv x \\cdot v^e \\pmod{n}\\).\nLes étapes (1) à (3) sont répétées jusqu’à atteindre une marge de confiance suffisante.\nVérification des propriétés :\n\nConsistance : Si A connaît s, le protocole accepte la preuve d’identification.\nSignificativité : Dans le cas simple, un imposteur pourrait seulement répondre à \\(e = 0\\). Sinon, il pourrait choisir un r aléatoire et envoyer \\(x = r^2/v\\) dans (1) et répondre au défi \\(e = 1\\) avec une réponse correcte \\(y = r\\). Dans le cas où \\(e = 0\\), il devrait calculer la racine carrée de x mod n (n composite de factorisation inconnue) ce qui est difficile par SQROOTP. La réussite de la preuve nécessite, donc, la possession du secret.\nZéro Knowledge : B ne peut obtenir aucune information sur s car lorsque \\(e = 1\\), il est caché par un nombre aléatoire (blinding factor).\nZéro-Knowledge parfait : Les paires (x,y) obtenues de A peuvent également être simulées par B en choisissant un y aléatoire et un \\(x = y^2\\) ou \\(y^2/v \\bmod n\\). On peut prouver que ces paires ont une distribution probabiliste identique à celles fournies par A (qui les calcule différemment!).\n\nÀ noter que, malgré cette dernière propriété, B est incapable de se faire passer par A auprès de B’ car il ne peut pas prédire les valeurs des défis e.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nSecret : \\(s\\) tel que \\(v = s^2 \\bmod n\\) (clé publique)\nProtocole : Témoin \\(r^2\\), défi \\(e \\in \\{0,1\\}\\), réponse \\(y = r \\cdot s^e\\)\nVérification : \\(y^2 \\equiv x \\cdot v^e \\pmod{n}\\)\nPerfect ZK : Paires (x,y) simulables par B\n\n\n\n\n\n\n\nZKIP - Implantations Pratiques\n\nProtocoles efficaces\nLes implantations pratiques améliorent l’efficacité de Fiat-Shamir.\nFeige-Fiat-Shamir (FSS) :\n\nUtilise des témoins et défis multiples (k valeurs) par itération\nProbabilité de tricher : \\(2^{-nk}\\) pour n itérations\nRéduit le nombre d’échanges nécessaires\n\nGuillou-Quisquater (GQ) :\n\nBasé sur Fiat-Shamir mais avec domaine de défis élargi\nDiminue la probabilité de deviner sans augmenter les échanges\nMeilleur compromis efficacité/sécurité\n\nSchnorr :\n\nBasé sur la difficulté des logarithmes discrets (DLP)\nDomaine très grand de défis possibles\nIdentification en 3 échanges seulement\nSacrifie parfois la propriété perfect zero-knowledge pour l’efficacité\n\nAvantages : Plus efficaces que RSA, implantables sur supports à capacité réduite (cartes à puces).\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nZKIP : Implantations Courantes\nFeige-Fiat-Shamir (FSS) :\n\nBasé sur le protocole de Fiat-Shamir mais en utilisant des témoins et des défis multiples (des ensembles de k valeurs) à chaque itération; ce qui pour n itérations nous donne une probabilité de \\(2^{-nk}\\) de deviner toutes les réponses.\n\nGuillou-Quisquater (GQ) :\n\nÉgalement basé sur Fiat-Shamir mais en augmentant le choix des défis ce qui diminue la probabilité de deviner sans augmenter le nombre d’instances transférées et d’étapes du protocole.\n\nSchnorr :\n\nBasé sur la difficulté de calculer des logarithmes discrets (DLP)\nIl utilise également un domaine très grand de défis possibles ce qui lui permet de réaliser une identification en 3 échanges de messages seulement.\n\nCes protocoles sont nettement plus efficaces que RSA et peuvent être implantés sur des supports à capacité de calcul réduite (smart cards).\nIls satisfont les propriétés de consistance, significativité mais la propriété zero-knowledge est parfois sacrifiée (comme dans le cas de Schnorr) pour augmenter l’efficacité.\nPour une description détaillée de ces protocoles se référer à [Men97] ou à [Sti95].\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nFSS : Témoins/défis multiples → probabilité \\(2^{-nk}\\)\nGQ : Domaine de défis élargi → moins d’échanges\nSchnorr : DLP + grands défis → 3 échanges seulement\nTous : Plus efficaces que RSA, adaptés aux cartes à puces\n\n\n\n\n\n\n\nZKIP - Attaque Mafia et Remarques Finales\n\nVulnérabilités et contre-mesures\nMême les protocoles ZKIP robustes peuvent être vulnérables à certaines attaques sophistiquées.\nAttaque Mafia (1989, Adi Shamir) :\nScénario : C (attaquant) et D (complice) collaborent pour que D se fasse passer pour A auprès de B.\nA ↔ C: Instance ZKIP     D ↔ B: Instance ZKIP\nC relaie les messages de A vers D (complice), qui les utilise pour s’authentifier auprès de B. L’attaque est transparente pour A et B.\nContre-mesures :\n\nChambres blindées (cage de Faraday) empêchant les communications radio\nSynchronisation forte pour éviter les échanges annexes\nDistance bounding protocols limitant le délai de réponse\n\nRecommandations générales :\n\nChoisir une solution prouvée plutôt qu’inventer\nVérifier que les objectifs sont atteints\nAnalyser pratiquement (reflection attacks, redondance, etc.)\nAnalyser formellement (logique BAN, model checking)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nZKIP : Remarques Finales\nLes ZKIP offrent un très bon niveau de sécurité cryptographique. Ils permettent de procéder à des identifications en minimisant les chances d’un imposteur hypothétique et, surtout, en protégeant les informations sécrètes des utilisateurs “honnêtes”.\nEn 1989 (SECURICOM’89) Adi Shamir disait à propos des ZKIP : “I could go to a Mafia owned store a million successive times and they will still not be able to misrepresent themselves as me”…\nEt pourtant : A participe à une ZKIP avec C Mafia; en même temps, D (complice de C) participe à une autre ZKIP où il prétend se faire passer par A auprès de B (un vérificateur “honnête”).\n(1) A → C: t1 (témoin que C fait suivre par liaison radio à D)\n(1') D → B: t1\n(2') D ← B: d1 (B envoie le défi à D; D le fait suivre à C...)\n(2) A ← C: d1 (C reprend le défi dans son dialogue avec A)\n(3) A → C: r1 (la réponse en utilisant son secret, que C envoie à D)\n(3') D → B: r1 (B accepte r1 et ainsi de suite!)\nSolutions :\n\nProcéder à des identifications dans des chambres blindées (cage de Faraday)…\nUtiliser des algorithmes de synchronisation forte pour éviter des échanges annexes.\n\nAuthentification : Récapitulation - Attaques et Protections\n\n\n\n\n\n\n\n\nAttaque\nDescription\nProtection\n\n\n\n\nreplay\nrejouer une instance d’identification précédente\nzero-knowledge, challenge and response, one-time password (attention aux pre-play !)\n\n\nknown/chosen-plaintext\nobtenir des couples plaintext/ciphertext\nzero-knowledge\n\n\nchosen-ciphertext\nfaire décrypter (ou signer) à A des informations soigneusement choisies\nzero-knowledge, ch. & resp. + témoin de connaissance + structure (redondance !)\n\n\nreflection\nrépondre le même nombre qui a été reçu\ninclure l’entité cible dans les messages, asymétrie dans les messages\n\n\ninterleaving\nutiliser des messages appartenant à plusieurs instances de protocoles simultanées\ninclure l’entité cible dans les messages, introduire un chaînage cryptographique entre les messages d’une même instance d’identification\n\n\ncollusion\nconnivence entre les intervenants\ncage de Faraday, synchronisation forte\n\n\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nAttaque Mafia : Relais des messages via complice → authentification frauduleuse transparente\nProtections : Cage Faraday, synchronisation forte, distance bounding\nTableau attaques : replay, chosen-plaintext/ciphertext, reflection, interleaving, collusion"
  },
  {
    "objectID": "exam_notes_fr.html#récapitulation---attaques-et-protections",
    "href": "exam_notes_fr.html#récapitulation---attaques-et-protections",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Récapitulation - Attaques et Protections",
    "text": "Récapitulation - Attaques et Protections\n\n\n\n\n\n\n\n\nAttaque\nDescription\nProtection\n\n\n\n\nreplay\nrejouer une instance d’identification précédente\nzero-knowledge, challenge and response, one-time password (attention aux pre-play !)\n\n\nknown/chosen-plaintext\nobtenir des couples plaintext/ciphertext\nzero-knowledge\n\n\nchosen-ciphertext\nfaire décrypter (ou signer) à A des informations soigneusement choisies\nzero-knowledge, ch. & resp. + témoin de connaissance + structure (redondance !)\n\n\nreflection\nrépondre le même nombre qui a été reçu\ninclure l’entité cible dans les messages, asymétrie dans les messages\n\n\ninterleaving\nutiliser des messages appartenant à plusieurs instances de protocoles simultanées\ninclure l’entité cible dans les messages, introduire un chaînage cryptographique entre les messages d’une même instance d’identification\n\n\ncollusion\nconnivence entre les intervenants\ncage de Faraday, synchronisation forte"
  },
  {
    "objectID": "exam_notes_fr.html#kep-définition-et-propriétés",
    "href": "exam_notes_fr.html#kep-définition-et-propriétés",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "KEP Définition et Propriétés",
    "text": "KEP Définition et Propriétés\n\nDéfinitions et Classification\nProtocole d’établissement de clés (KEP) : Mécanisme permettant aux entités de partager un secret pour leurs échanges cryptographiques.\nDeux types :\n\nKey Transport Protocol (KTP) : Une entité crée et transmet la clé\nKey Agreement Protocol (KAP) : Les entités dérivent conjointement la clé\n\nClassification temporelle :\n\nPré-distribution : Clés déterminées à priori\nDynamic Key Establishment (DKE) : Clés changeant à chaque exécution\n\n\n\n\nKey Establishment Protocols\n\n\n\n\nKey Agreement\n\n\nKey Transport\n\n\n\n\nsymétrique + pré-dist.\n\n\nsymétrique + DKE\n\n\nsymétrique + DKE\n\n\n\n\nasymétrique + pré-dist.\n\n\nasymétrique + DKE\n\n\nasymétrique + DKE\n\n\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUn protocole d’établissement de clés (key establishment protocol ou KEP) est celui qui met à disposition des entités impliquées un secret partagé (une clé) qui servira comme base pour des échanges cryptographiques ultérieurs.\nLes deux variantes des KEP sont les protocoles de transport de clé (key transport protocol ou KTP) et les protocoles de mise en accord (key agreement protocol ou KAP).\n\nUn key transport protocol (KTP) est un mécanisme permettant à une entité de créer une clé secrète et de la transférer à son (ses) correspondant(s).\nUn key agreement protocol (KAP) est un mécanisme permettant à deux (ou plusieurs) entités de dériver une clé à partir d’informations propres à chaque entité.\n\nKey pré-distribution schemes sont ceux où les clés utilisées sont entièrement déterminées à priori (p.ex. à partir des calculs initiaux).\nDynamic key establishment schemes (DKE) sont ceux où les clés changent pour chaque exécution du protocole.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nKEP : Protocoles pour établir un secret partagé.\n\nKTP : transport de clé\nKAP : accord mutuel sur la clé\nPré-distribution vs DKE (dynamique)\n\n\n\n\n\n\n\nPropriétés des KEP\nPropriétés d’authentification :\n\nImplicit key authentication : Assurance que seul le correspondant peut accéder à la clé (sans preuve de possession)\nKey confirmation : Assurance que le correspondant possède effectivement la clé\nExplicit key authentication : Implicit + confirmation\nAuthenticated KEP : KEP fournissant l’authentification de clé\n\nPropriétés de sécurité temporelle :\n\nPerfect Forward Secrecy (PFS) : Compromission des clés long terme ne révèle pas les clés de sessions passées\nFuture Secrecy : Clés futures protégées même si clés long terme compromises (par attaquant passif)\nDeniability/Repudiability : Impossibilité de prouver la participation à un tiers (comme Zero-Knowledge)\n\nTypes d’attaques :\n\nAttaque passive : Enregistrement et analyse des échanges\nAttaque active : Modification ou injection de messages\nKnown-key attack : Exploitation d’une clé de session compromise pour attaquer les clés futures\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nPropriétés des protocoles d’établissement de clés :\n\nImplicit key authentication (ou key authentication) : propriété par laquelle une entité est assurée que seul(s) son (ses) correspondant(s) peut (peuvent) accéder à une clé secrète. Cependant, ceci ne spécifie rien sur le fait de posséder effectivement la clé.\nKey confirmation : propriété permettant à une entité d’être sûre que ses correspondants sont en possession des clés de session générées.\nExplicit key authentication : = implicit key authentication + key confirmation.\nUn authenticated KEP est un KEP capable de fournir key authentication.\n\nAttaques :\n\nUne attaque passive est celle qui essaye de démonter un système cryptographique en se limitant à l’enregistrement et à l’analyse des échanges.\nUne attaque active fait intervenir un adversaire qui modifie ou injecte des messages.\nUn protocole est dit vulnérable à un known-key attack si lorsqu’une clé de session antérieure est compromise, il devient possible : (a) de compromettre par une attaque passive des clés futures et/ou (b) de monter des attaques actives visant l’usurpation d’identité.\n\nPropriétés modernes :\n\nPerfect Forward Secrecy (PFS) est une caractéristique qui garantit la confidentialité des clés de sessions utilisées par le passé même si les clés long terme (par exemple la clé privée du destinataire) est compromise.\nFuture Secrecy : Le protocole garantit la sécurité des échanges ultérieurs (les clés des sessions futures sont protégées) même si les clés long terme sont compromises par un attaquant passif.\nDeniability / Repudiability (répudiabilité) : À l’image des protocoles d’authentification Zéro-Knowledge, permet aux entités de garantir l’authentification des échanges sans apporter des informations qui permettraient de prouver à un tiers leur participation dans l’échange cryptographique.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nAuthentification :\n\nImplicit : seul le correspondant accède à la clé\nKey confirmation : preuve de possession\nExplicit = Implicit + confirmation\n\nSécurité :\n\nPFS : clés passées protégées si compromission\nFuture Secrecy : clés futures protégées\nDeniability : participation non prouvable"
  },
  {
    "objectID": "exam_notes_fr.html#kap",
    "href": "exam_notes_fr.html#kap",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "KAP",
    "text": "KAP\n\nSymétrique\n\navec Pré-distribution\nCas trivial :\nPour \\(n\\) utilisateurs avec un Key Distribution Center (KDC) :\n\nKDC génère \\(\\frac{n(n-1)}{2}\\) clés différentes (une par paire d’utilisateurs)\nKDC distribue \\(n-1\\) clés à chaque utilisateur via canal confidentiel\n\nAvantages :\n\nInconditionnellement sûr contre complots d’utilisateurs (sécurité information-théorique)\n\nInconvénients :\n\nComplexité \\(O(n^2)\\) en stockage pour le KDC\nComplexité \\(O(n)\\) en clés par utilisateur\nNon scalable\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKAP Symétrique avec Pré-distribution - Cas Trivial\nSoit un nombre \\(n\\) d’utilisateurs avec un centre de distribution de clés (key distribution center ou KDC).\nOn peut construire un KAP symétrique avec pré-distribution trivial de la façon suivante :\n\nKDC génère \\(n(n-1)/2\\) clés différentes (une clé différente pour chaque couple d’utilisateurs).\nKDC distribue ensuite par un canal confidentiel et authentique les clés en donnant \\(n-1\\) clés à chaque utilisateur.\n\nSi KDC génère les clés de façon vraiment aléatoire, ce système est inconditionnellement sûr contre des complots d’utilisateurs (même en admettant que \\(n-2\\) utilisateurs complotent, ils ne pourraient pas trouver la clé des deux autres) par construction du protocole.\nProblème de ce protocole :\n\n\\(O(n^2)\\) en stockage de clés par le KDC.\n\\(O(n)\\) en clés secrètes échangées pour chaque entité.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nKAP symétrique trivial :\n\n\\(n(n-1)/2\\) clés pour \\(n\\) utilisateurs\nInconditionnellement sûr\nProblème : \\(O(n^2)\\) en stockage\n\n\n\n\n\n\n\navec Dynamic Key Establishment (DKE)\n\nExemple Simple\nInitialisation : A et B partagent une clé long terme \\(S\\)\nProtocole :\n\n\\(A \\rightarrow B: r_a\\) (nombre aléatoire)\n\\(A \\leftarrow B: r_b\\) (nombre aléatoire)\nClé de session : \\(K := E_S(r_a \\oplus r_b)\\)\n\nPropriétés :\n\n❌ Entity authentication\n✅ Implicit key authentication\n\n❌ Key confirmation\n❌ Perfect Forward Secrecy\n\n\n\nAKEP2 (Authenticated Key Exchange Protocol 2)\nInitialisation : A et B partagent \\(S\\) (pour MAC) et \\(S'\\) (pour clé de session)\nProtocole :\n\n\\(A \\rightarrow B: r_a\\)\n\\(A \\leftarrow B: T = (B,A,r_a,r_b), h_S(T)\\)\n\\(A \\rightarrow B: (A, r_b), h_S(A,r_b)\\)\nClé de session : \\(K := h'_{S'}(r_b)\\)\n\nPropriétés :\n\n✅ Entity authentication (mutuelle)\n✅ Implicit key authentication\n❌ Key confirmation\n❌ Perfect Forward Secrecy\n\nNote : Clé dépend uniquement de \\(B\\) et de la clé long terme \\(S'\\) !\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKAP Symétriques avec Dynamic Key Establishment\nCes méthodes permettent aux entités impliquées de dériver des clés de courte durée (typiquement, des clés de session) à partir de secrets de longue durée qui, pour ces protocoles, sont des clés symétriques.\nExemple intuitif :\n(Initialisation): A et B partagent une clé symétrique long terme \\(S\\)\n\n\\(A \\rightarrow B: r_a\\); A génère un nb. aléatoire et l’envoie à B\n\\(A \\leftarrow B: r_b\\); B fait de même\n\nA et B calculent la clé de session: \\(K := E_S(r_a \\oplus r_b)\\)\nPropriétés : - Entity authentication : NON : par construction du protocole, les \\(r_i\\) peuvent être envoyés par une entité quelconque. - Implicit key authentication : OUI : seules les entités partageant la clé symétrique long terme \\(S\\) peuvent accéder à la clé de session \\(K\\). - Key confirmation : NON : les \\(r_i\\) étant aléatoires, ils peuvent être modifiés par un adversaire et empêcher A et B de se mettre d’accord sur la clé de session \\(K\\). Ceci ne serait pas détecté par le protocole. - Perfect Forward Secrecy : NON : si la clé long terme \\(S\\) est compromise, toutes les clés de session précédentes peuvent être facilement calculées par un adversaire qui aurait enregistré tous les échanges.\nAuthenticated Key Exchange Protocol 2 (AKEP2)\n(Init.) : A et B partagent deux clés symétriques long terme \\(S\\) et \\(S'\\). \\(S\\) est utilisé pour générer des MACs \\(h_S()\\) (afin de garantir l’intégrité et l’authentification d’entités) et \\(S'\\) pour la génération de la clé de session \\(K\\).\n\n\\(A \\rightarrow B: r_a\\); A génère un nb. aléatoire et l’envoie à B\n\\(A \\leftarrow B: T = (B,A,r_a,r_b), h_S(T)\\) ; B idem + identités + MAC de tout\n\\(A \\rightarrow B: (A, r_b), h_S(A,r_b)\\) ; A vérifie les identités et le \\(r_a\\) fournis par B ; ensuite, il envoie identité + \\(r_b\\) + MAC du tout.\n\nLa clé est calculée bilatéralement avec un MAC dédié \\(h'_{S'}()\\) : \\(K := h'_{S'}(r_b)\\).\nPropriétés : - Entity authentication : OUI mutuelle (fournie par les MACs). - Implicit key authentication : OUI. - Key confirmation : NON (pas d’évidence que la clé \\(S'\\) est connue du correspondant). - Perfect forward secrecy : NON (si la clé \\(S'\\) est compromise, les clés de session \\(K\\) précédentes aussi).\nLa clé dépend seulement de B (et de la clé long terme \\(S'\\)) mais le protocole peut être facilement modifié pour que la clé dépende aussi de A et en faire un “vrai” KAP.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nKAP symétrique DKE :\n\nSimple : \\(K := E_S(r_a \\oplus r_b)\\) - pas de PFS\nAKEP2 : utilise MACs pour authentification + clé dérivée \\(K := h'_{S'}(r_b)\\)\nPas de PFS si \\(S'\\) compromise\n\n\n\n\n\n\n\n\n\nAsymétrique avec pré-distribution\n\nDiffie-Hellman\nInitialisation : Premier p et générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) publics\nProtocole :\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\) (A choisit \\(x\\) secret)\n\\(A \\leftarrow B: \\alpha^y \\mod p\\) (B choisit \\(y\\) secret)\nClé partagée : \\(K := \\alpha^{xy} \\mod p\\)\n\n\nA calcule \\(K := (\\alpha^y)^x \\mod p\\)\nB calcule \\(K := (\\alpha^x)^y \\mod p\\)\n\nSécurité :\n\nBasée sur le problème Diffie-Hellman (DHP) : impossible de calculer \\(\\alpha^{xy}\\) à partir de \\(\\alpha^x\\) et \\(\\alpha^y\\).\nRésultat prouvé : DHP \\(\\equiv\\) DLP.\n\nAttaque Man-in-the-Middle (MIM) :\nAdversaire C intercepte et remplace :\n\n\\(\\alpha^x\\) par \\(\\alpha^{x'}\\) vers B\n\\(\\alpha^y\\) par \\(\\alpha^{y'}\\) vers A\nC établit deux clés : \\(\\alpha^{xy'}\\) avec A et \\(\\alpha^{x'y}\\) avec B\n\nPropriétés (DH non authentifié) :\n\n❌ Entity authentication\n❌ Implicit key authentication (vulnérable MIM)\n❌ Key confirmation\n\nGénération de clés symétriques :\nLes clés DH ne sont pas bit secure.\nSolution : appliquer un MDC (SHA, MD5) à toute la clé \\(K\\) :\n\\[K_{sym} := \\text{SHA-256}(K)\\]\nRésultat: KAP avec Dynamic Key Establishment\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKAP Asymétrique avec Pré-Distribution - Diffie-Hellman\nPublié en 1976, il s’agit du précurseur des protocoles asymétriques.\nIl permet à deux entités qui ne se sont jamais rencontrées de construire une clé partagée en échangeant des messages sur un canal non confidentiel.\nProtocole :\nInitialisation : Un nb. premier \\(p\\) est généré et un générateur \\(\\alpha\\) de \\(\\mathbb{Z}_p^*\\), t.q. \\(\\alpha \\in \\mathbb{Z}_{p-1}\\). Les deux nombres sont rendus publiques.\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\) ; A choisit un secret \\(x \\in \\mathbb{Z}_{p-1}\\) et envoie la partie publique\n\\(A \\leftarrow B: \\alpha^y \\mod p\\) ; B choisit un secret \\(y \\in \\mathbb{Z}_{p-1}\\) et envoie la partie publique\n\nA calcule la clé secrète : \\(K := (\\alpha^y)^x \\mod p\\) et B à son tour : \\(K := (\\alpha^x)^y \\mod p\\)\nLa sécurité de ce schéma réside dans l’impossibilité de trouver \\(\\alpha^{xy} \\mod p\\) à partir de \\(\\alpha^x \\mod p\\) et \\(\\alpha^y \\mod p\\). (Diffie-Hellman Problem : DHP).\nRésultat prouvé : DHP \\(\\equiv\\) DLP.\nDiffie-Hellman est sûr (autant que DHP) contre des attaques passives. En d’autres mots, un adversaire qui se limite à voir passer des messages ne peut pas trouver la clé \\(K\\).\nCeci n’est cependant plus vrai pour des attaques actives ; voyons ce que C peut faire en modifiant les messages :\nC échange des clés secrètes avec A et B, respectivement : \\(\\alpha^{xy'} \\mod p\\) et \\(\\alpha^{x'y} \\mod p\\) (C contrôle \\(x'\\) et \\(y'\\)). Si C ré-encrypte chaque paquet qu’il reçoit avec la clé publique correspondante, l’attaque se fera de manière transparente pour A et B.\nCette attaque est appelée Man in the Middle (MIM) et s’applique à tous les protocoles asymétriques.\nElle est due au manque d’authentification des clés publiques, i.e. lorsque A “parle” à B, il doit utiliser la clé publique authentique de B.\nCaractéristiques de Diffie-Hellman (non authentifié) :\n\nEntity Authentication : NON.\nImplicit key authentication : NON (par l’attaque MIM).\nKey confirmation : NON (dû au risque de MIM, A ne peut pas être sûr que B possède la clé secrète partagée).\n\nGénération de clés symétriques à partir d’une clé partagée Diffie-Hellman :\nLes quantités manipulées dans DH (notamment \\(K\\)) sont de taille 512 - 1024 bits (suivant le nb. premier \\(p\\) utilisé).\nUne approche intuitive pour générer des clés symétriques de petite taille (64 - 128 bits) serait de prendre un sous-ensemble de bits de la clé \\(K\\).\nMalheureusement, on peut prouver que les clés DH ne sont pas bit secure ce qui signifie que des sous ensembles de bits (notamment les Least Significant Bits) peuvent être calculés avec un effort non proportionnel à l’effort nécessaire à calculer la clé entière.\nPour générer des clés de manière sûre il est conseillé d’appliquer un MDC (comme SHA ou MD5) à toute la clé (év. enchaîner l’application des MDCs pour obtenir des clés symétriques successives).\nCette méthode permet d’obtenir un KAP avec Dynamic Key Establishment.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nDiffie-Hellman :\n\n\\(K := \\alpha^{xy} \\mod p\\) calculée indépendamment par A et B\nSûr contre attaques passives (DHP \\(\\equiv\\) DLP)\nVulnérable MIM sans authentification\nGénérer clés symétriques : \\(K_{sym} := \\text{SHA}(K)\\)\n\n\n\n\n\n\n\n\nAsymétrique avec DKE\n\nStation to Station Protocol (STS)\nDiffie-Hellman authentifié avec signatures numériques.\nInitialisation : Nombre premier \\(p\\), générateur \\(\\alpha\\) publics. A et B ont copies authentiques des clés publiques.\nProtocole :\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\)\n\\(A \\leftarrow B: \\alpha^y \\mod p, E_k(S_B(\\alpha^x, \\alpha^y))\\)\n\nB calcule \\(k := (\\alpha^x)^y \\mod p\\)\nB signe et encrypte les parties publiques\n\n\\(A \\rightarrow B: E_k(S_A(\\alpha^y, \\alpha^x))\\)\n\nA décrypte, vérifie signature de B\nA signe et encrypte en inversant l’ordre\n\n\nPropriétés :\n\n✅ Entity authentication (mutuelle, par signatures)\n✅ Implicit key authentication (DHP + signatures empêchent MIM)\n✅ Key confirmation (encryption prouve possession de \\(k\\))\n✅ Explicit key authentication (authentication + key confirmation)\n✅ Perfect Forward Secrecy (clé privée signature compromise ne révèle pas clés session passées)\n\nVariante efficace : Remplacer \\(E_k(S_B(...))\\) par \\((sig, h_k(sig))\\) avec MAC au lieu d’encryption symétrique.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKAP Asymétrique avec DKE - Station to Station Protocol\n(Notation) \\(S_A\\) : Signature avec la clé privée de A.\n(Initialisation) : (a) On choisit un nb. premier \\(p\\) et un générateur \\(\\alpha\\) de \\(\\mathbb{Z}_p^*\\), t.q. \\(\\alpha \\in \\mathbb{Z}_{p-1}\\). Les deux nombres sont rendus publiques (et éventuellement associés aux clés publiques des intervenants).\n\nLes intervenants ont accès aux copies authentiques des clés publiques des correspondants. Des certificats peuvent être échangés si besoin dans (2) et (3).\n\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\) ; A génère un secret \\(x\\) et envoie la partie pub.\n\\(A \\leftarrow B: \\alpha^y \\mod p, E_k(S_B(\\alpha^x, \\alpha^y))\\) ; B génère un secret \\(y\\) et calcule la clé : \\(k := (\\alpha^x)^y \\mod p\\) + signe et encrypte les p.pub.\n\\(A \\rightarrow B: E_k(S_A(\\alpha^y, \\alpha^x))\\) ; A décrypte en calculant \\(k := (\\alpha^y)^x \\mod p\\), teste la signature de B et les parties publiques ; si OK, A signe + encrypte en inversant les parties publiques.\n\nB décrypte et teste la signature de A sur les parties publiques. Si OK =&gt; FIN.\nCaractéristiques :\n\nEntity Authentication : OUI mutuelle (fournie par les signatures).\nImplicit key authentication : OUI, les clés sont protégées par DHP. L’attaque MIM est rendue impossible par les signatures.\nKey confirmation : OUI, les deux entités prouvent la possession de la clé en encryptant des quantités avec.\nExplicit key authentication : OUI : implicit key authentication + key confirmation.\nPerfect Forward Secrecy : OUI. La seule clé à long terme est celle utilisée pour signature/vérification. Si cette clé est compromise, les clés de session antérieures sont protégées par le fait qu’elles ne sont pas explicitement échangées mais plutôt calculées par DH.\n\nÉvidemment, dès que la clé de signature est compromise (vol de clé privée), les propriétés énoncées ne sont plus vérifiées pour les échanges ultérieurs.\nLe protocole fournit en plus l’anonymat car l’identité des parties est protégée par \\(k\\).\nVariante : Dans (2), calculer \\(sig := S_B(\\alpha^x, \\alpha^y)\\), et envoyer : \\((sig, h_k(sig))\\) plutôt que \\(E_k(S_B(\\alpha^x, \\alpha^y))\\). Pareil pour (3) en observant les asymétries du protocole.\nSolution plus efficace car elle fait intervenir un MAC plutôt qu’un cryptage symétrique.\nAlgorithme robuste et efficace choisi comme support de base pour la génération de clés dans IPv6.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nStation to Station (STS) :\n\nDH + signatures numériques\n✅ PFS : clés session passées protégées\n✅ Explicit key authentication\nUtilisé dans IPv6\n\n\n\n\n\n\n\nProtocoles OTR et Signal\n\nOff-The-Record (OTR)\nProtocole (2004) pour messagerie instantanée avec répudiabilité.\nTechnique SIGMA (SIGn-and-MAC) :\n\nSignatures DH + authentification éphémère via MAC\nKey Derivation Function (KDF) génère deux clés : \\(K_e\\) (encryption AES-CTR) et \\(K_m\\) (MAC)\nChangement de clés à chaque conversation\nRévélation des clés MAC précédentes pour garantir répudiabilité\n\nProtocole simplifié :\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\)\n\\(A \\leftarrow B: \\alpha^y \\mod p, S_B(\\alpha^x, \\alpha^y), \\text{MAC}_{K_m}(B)\\)\n\nB calcule \\(k := (\\alpha^x)^y \\mod p\\)\n\\((K_m, K_e) := \\text{KDF}(k)\\)\n\n\\(A \\rightarrow B: S_A(\\alpha^y, \\alpha^x), \\text{MAC}_{K_m}(A)\\)\n\nMessages chiffrés avec \\(K_e\\).\n\n\nSignal Protocol\nÉvolution d’OTR pour réseaux sociaux (WhatsApp, Facebook Messenger).\nCaractéristiques :\n\nClés asymétriques et symétriques éphémères\nDH sur courbes elliptiques\n✅ PFS\n✅ Future Secrecy\n✅ Repudiability\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nProtocole Off-The-Record (OTR)\nProtocole conçu en 2004 dans le but d’offrir des services d’authentification et de confidentialité dans les échanges des messages (instant messaging) en préservant le caractère “répudiable” d’une conversation “off the record”.\nLe protocole satisfait également les propriétés de PFS et Future Secrecy en cas de compromis des clés long terme.\nIl reprend les mêmes principes que le protocole Station-to-Station en rajoutant aux signatures des paramètres DH une authentification éphémère via un MAC. Cette technique double est appelée SIGMA (SIGn-and-MAC).\nIl utilise une fonction de dérivation de clés (Key Derivation Function ou KDF) pour générer une clé d’encryption (\\(K_e\\)) préservant la confidentialité des messages avec AES CTR-mode et une clé MAC (\\(K_m\\)) garantissant l’authenticité d’origine de ceux-ci.\nChaque conversation implique un changement de clés (nouvel échange de paramètres DH) avec en plus un échange en clair des clés MAC (\\(K_m\\)) utilisées dans l’échange précédent pour garantir la répudiabilité !\nÉchanges schématiques du protocole OTR :\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\); A génère un secret \\(x\\) et envoie la partie pub.\n\\(A \\leftarrow B: \\alpha^y \\mod p, S_B(\\alpha^x, \\alpha^y), \\text{MAC}_{K_m}(B)\\)\n\nB génère un secret \\(y\\), calcule la clé de session \\(k := (\\alpha^x)^y \\mod p\\) et signe les parties publiques DH. Il génère ensuite les clés \\(K_e\\) et \\(K_m\\) via la KDF : \\((K_m, K_e) := \\text{KDF}(k)\\)\n\n\\(A \\rightarrow B: S_A(\\alpha^y, \\alpha^x), \\text{MAC}_{K_m}(A)\\) : A fait de même\n\nLes messages sont ensuite chiffrés avec la clé \\(K_e\\)\nIl existe de nombreuses évolutions du protocole original OTR ayant permis d’adresser des vulnérabilités et de rendre le protocole plus efficace.\nLe protocole Signal\nLe protocole Signal est une évolution du protocole OTR qui cible la protection des échanges des messages dans les réseaux sociaux. Il utilise également des clés asymétriques et symétriques éphémères pour assurer la PFS, la Future Secrecy et la repudiability avec des calculs DH sur des courbes elliptiques.\nSignal est utilisé pour protéger les plateformes de messagerie telles que Whatsapp et Facebook Messenger entre autres.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nOTR/Signal :\n\nSIGMA : signature + MAC\nKDF : génère \\(K_e\\) (chiffrement) et \\(K_m\\) (MAC)\nRévèle anciennes clés MAC → répudiabilité\n✅ PFS, ✅ Future Secrecy\nUtilisé : WhatsApp, Facebook Messenger\n\n\n\n\n\n\n\n\nSecure Remote Password (SRP)\nProtocole KAP asymétrique basé sur mot de passe, résistant aux attaques dictionnaire.\nInitialisation :\n\n\\(m := 2p+1\\) (safe prime), \\(\\alpha\\) générateur de \\(\\mathbb{Z}_p^*\\)\n\\(P\\) : password de A, \\(x := H(P)\\) avec \\(H\\) une CRHF\nB stocke le vérificateur : \\(v := \\alpha^x \\mod m\\) (pas le password!)\n\nProtocole :\n\n\\(A \\rightarrow B: \\gamma := \\alpha^r \\mod m\\) (A génère \\(r\\) secret)\n\\(A \\leftarrow B: \\delta := (v + \\alpha^t) \\mod m, u\\) (B génère \\(t, u\\) aléatoires)\nA calcule \\(k := (\\delta - v)^{r+ux} \\mod m\\)\nB calcule \\(k := (\\gamma v^u)^t \\mod m\\)\nKey confirmation\n\nPropriétés :\n\n✅ Protège passwords des attaques dictionnaire\n✅ Verifier-based : B ne stocke pas passwords\n✅ Toutes propriétés KEP\nInclus dans SSL/TLS, EAP\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKAP Asymétrique avec DKE - Secure Remote Password protocol\n\nSoit \\(m\\) un safe prime avec \\(m := 2p+1\\) et \\(p\\) premier\nSoit \\(\\alpha\\) un générateur de \\(\\mathbb{Z}_p^*\\), t.q. \\(\\alpha \\in \\mathbb{Z}_{p-1}\\)\nSoit \\(P\\) le password de A et \\(x := H(P)\\) avec \\(H\\) une CRHF.\nB garde dans sa base des mots de passe le vérificateur \\(v := \\alpha^x \\mod m\\).\n\n\n\\(A \\rightarrow B: \\gamma := \\alpha^r \\mod m\\) ; A génère un nombre aléatoire secret \\(r\\)\n\\(A \\leftarrow B: \\delta := (v + \\alpha^t) \\mod m, u\\) ; B génère un nombre aléatoire secret \\(t\\) et un deuxième nombre aléatoire \\(u\\)\n\nA calcule la clé symétrique : \\(k := (\\delta - v)^{r+ux} \\mod m\\)\nB calcule la clé symétrique : \\(k := (\\gamma v^u)^t \\mod m\\)\nA et B prouvent la connaissance de \\(k\\) (key confirmation) lors d’un échange ultérieur.\n\nSRP protège les mots de passe des attaques dictionnaire.\nB ne stocke pas les passwords mais des valeurs de vérification (verifier-based).\nSRP satisfait également toutes les propriétés propres aux KEP et est inclus dans des nombreux standards (SSL/TLS, EAP, etc.).\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nSRP :\n\nKAP basé mot de passe\nB stocke vérificateur \\(v := \\alpha^x\\) (pas password)\nRésiste attaques dictionnaire\n✅ Toutes propriétés KEP\n\n\n\n\n\n\n\n\nAttaques sur DH et PFS\nAttaque Logjam (2015) :\nAttaque active permettant :\n\nDowngrade : Man-in-the-Middle force utilisation de groupe DH 512 bits\nCalcul de logarithmes discrets avec Number Field Sieve :\n\nPré-calcul d’une semaine pour un premier \\(p\\) fixé\nCalcul individuel en ~1 minute après pré-calcul\n\nRéutilisation du pré-calcul : Beaucoup de serveurs utilisent le même \\(p\\)\n\nConséquence :\nActeurs avec ressources étatiques peuvent compromettre PFS sur groupes 1024 bits répandus.\nSolutions :\n\nUtiliser groupes \\(\\geq\\) 2048 bits\nDiversifier les premiers \\(p\\) utilisés\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAttaques Récentes sur Diffie-Hellman et la PFS\nEn 2015 un groupe de chercheurs a publié une série d’attaques sur le protocole TLS/SSL permettant de :\n\nEffectuer un downgrade via une attaque active appelée Logjam moyennant laquelle un man-in-the-middle réussit à diminuer à 512 bits la taille du groupe Diffie-Hellman sur lequel s’effectue l’établissement de la clé secrète partagée.\nCalculer ensuite les logarithmes discrets de \\(\\alpha^x \\mod p\\) et de \\(\\alpha^y \\mod p\\) avec la technique Number Field Sieve.\nÀ partir d’un groupe basé sur un nombre premier \\(p\\) fixé, ils effectuent une phase de pré-calcul d’une durée approximative d’une semaine.\nUne fois cette phase initiale terminée, les calculs des logarithmes individuels ne prennent qu’une minute !\nUne constatation statistique montre qu’un pourcentage significatif des serveurs se basent sur le même groupe (même premier \\(p\\)) ce qui permet d’utiliser la même phase de pré-calcul pour compromettre plusieurs serveurs.\nUne des conclusions de cette recherche est que des acteurs majeurs avec des ressources étatiques seraient capables à ce jour de démonter la PFS lorsque celle-ci est basée sur des groupes (très répandus à ce jour…) de 1024 bits.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nLogjam (2015) :\n\nDowngrade → DH 512 bits\nPré-calcul (1 semaine) + calcul individuel (1 min)\nRéutilisation si même \\(p\\)\n⚠️ États peuvent casser PFS sur 1024 bits"
  },
  {
    "objectID": "exam_notes_fr.html#ktp",
    "href": "exam_notes_fr.html#ktp",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "KTP",
    "text": "KTP\n\nSymétrique\n\nCas Trivial\nInitialisation : A et B partagent clé long terme \\(S\\)\nProtocole :\n\n\\(A \\rightarrow B: E_S(r_a)\\)\nClé de session : \\(K := r_a\\)\n\nPropriétés :\n\n❌ Entity authentication\n✅ Implicit key authentication\n❌ Key confirmation (amélioration : \\(E_S(B, r_a)\\))\n❌ Perfect Forward Secrecy\n\nVariante avec timestamp : \\(A \\rightarrow B: E_S(B, t_a, r_a)\\) (nécessite horloges synchronisées)\n\n\nShamir’s No-key Protocol\nÉquivalent de DH en transport de clé.\nInitialisation : Nombre premier \\(p\\) public, A et B génèrent secrets \\(a, b \\in \\mathbb{Z}_{p-1}\\) avec \\(\\gcd(a,p-1)=1\\) et \\(\\gcd(b,p-1)=1\\)\nProtocole :\n\n\\(A \\rightarrow B: K^a \\mod p\\) (A choisit clé \\(K\\) et cache avec \\(^a\\))\n\\(A \\leftarrow B: (K^a)^b \\mod p\\) (B exponentie avec \\(b\\))\n\\(A \\rightarrow B: (K^{ab})^{a^{-1}} \\mod p = K^b \\mod p\\) (A défait \\(^a\\))\nB calcule \\(K\\) en exponenti ant avec \\(b^{-1} \\mod (p-1)\\)\n\nProblème : Vulnérable Man-in-the-Middle (comme DH)\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKey Transport Protocol Symétrique - Cas trivial\n(Init.) A et B partagent une clé symétrique long terme \\(S\\)\n\n\\(A \\rightarrow B: E_S(r_a)\\) ; A génère un nb. aléatoire et l’encrypte avec \\(k\\)\n\nLa clé de session utilisée par les deux entités est \\(K := r_a\\).\nPropriétés :\n\nEntity Authentication : NON.\nImplicit Key Authentication : OUI (seul A et B ont accès à la clé).\nKey Confirmation : NON. B ne peut pas être sûr que A possède la clé car \\(r_a\\) est un nombre aléatoire. En rajoutant de la redondance (p.ex. l’identité de B), B peut obtenir key confirmation unilatérale (et donc, explicit key authentication) :\n\n(1)’ : \\(A \\rightarrow B: E_s(B, r_a)\\)\n\nPerfect Forward Secrecy : NON.\n\nSi, de plus, B ne peut pas juger l’actualité (freshness) de (1) à partir du seul \\(r_a\\), il peut demander à A d’inclure un timestamp à condition d’avoir des horloges synchronisés :\n(1)’’ : \\(A \\rightarrow B: E_s(B, t_a, r_a)\\)\nKTP Symétrique : Shamir’s No-key Protocol\nRappel Théorie des nombres : Si \\(p\\) premier et \\(r \\equiv t \\mod p-1\\) alors \\(a^r \\equiv a^t \\mod p\\) \\(\\forall a \\in \\mathbb{Z}\\) et donc : \\(r \\cdot r^{-1} \\equiv 1 \\mod p-1\\) implique \\(a^{r \\cdot r^{-1}} \\equiv a \\mod p\\).\n(Init.) (a) Choisir et publier un nb. premier \\(p\\) pour lequel il est difficile (par DLP) de calculer les logarithmes discrets dans \\(\\mathbb{Z}_p\\).\n\nA (resp. B) génère un nombre secret \\(a\\) (resp. \\(b\\)), t.q \\(\\{a,b\\} \\in \\mathbb{Z}_{p-1}\\) et \\(\\gcd(a,p-1) = 1\\) et \\(\\gcd(b,p-1) = 1\\) (pour que les inverses existent).\nPour la suite, A pré-calcule \\(a^{-1} \\mod p-1\\) et B pré-calcule \\(b^{-1} \\mod p-1\\)\n\n\n: \\(A \\rightarrow B: K^a \\mod p\\) ; A choisit une clé \\(K \\in \\mathbb{Z}_p\\) et la cache avec \\(^a\\)\n: \\(A \\leftarrow B: (K^a)^b \\mod p\\) ; B exponentie à son tour avec \\(b\\)\n: \\(A \\rightarrow B: (K^{ab})^{a^{-1}} \\mod p\\) ; A défait l’exponentiation avec \\(a^{-1} \\mod p-1\\) ; mais la clé reste protégée par \\(^b\\)\n\nB n’a plus qu’à calculer \\(K\\) en exponentiant avec \\(b^{-1} \\mod p-1\\).\nCe protocole est l’équivalent de Diffie-Hellman en Key Transport (dans DH la clé n’est pas transportée mais calculée bilatéralement). Il souffre donc des mêmes problèmes (notamment Man in the Middle) que ce dernier.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nKTP symétrique :\n\nTrivial : \\(K := r_a\\) avec \\(E_S(r_a)\\)\nShamir : transport via exponentiations successives\nPas de PFS\n\n\n\n\n\n\n\n\nAsymétrique\n\nNeedham-Schroeder\nInitialisation : A et B ont copies authentiques clés publiques mutuelles\nProtocole :\n\n\\(A \\rightarrow B: E_{pub_B}(k_1, A)\\)\n\\(A \\leftarrow B: E_{pub_A}(k_1, k_2)\\)\n\\(A \\rightarrow B: E_{pub_B}(k_2)\\)\nClé de session : \\(K := H(k_1, k_2)\\)\n\nPropriétés :\n\n✅ Entity authentication + implicit key authentication + key confirmation\n❌ Perfect Forward Secrecy (clés entièrement déterminées par quantités échangées)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKey Transport Protocol Asymétrique - Needham-Schroeder Public Key Protocol\n(Notation) : \\(E_{pub_E}(X)\\) signifie encrypter avec la clé publique de l’entité E.\n(Init) : A et B possèdent une copie authentique (év. un certificat) de la clé publique de l’autre.\n\n\\(A \\rightarrow B: E_{pub_B}(k_1, A)\\) ; A génère un nb. aléatoire \\(k_1\\) + A + Encrypt\n\\(A \\leftarrow B: E_{pub_A}(k_1, k_2)\\) ; B idem pour \\(k_2\\) + concat avec \\(k_1\\) + Encrypt\n\\(A \\rightarrow B: E_{pub_B}(k_2)\\) ; A vérifie si \\(k_1\\) coïncide, si oui, encrypt \\(k_2\\) ; B vérifie si \\(k_2\\) coïncide avec (2)\n\nLa clé est générée à l’aide d’une fonction de hachage cryptographique : \\(K := H(k_1, k_2)\\)\nCaractéristiques :\n\nEntity Authentication + implicit key authentication + key confirmation : OUI.\nPerfect forward secrecy : NON : Les clés sont entièrement déterminées par les quantités échangées.\n\nUn protocole semblable (seul (3) change) peut être utilisé pour l’authentification d’entités.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nNeedham-Schroeder asymétrique :\n\n\\(K := H(k_1, k_2)\\) avec échanges encryptés\n✅ Authentification complète\n❌ Pas de PFS\n\n\n\n\n\n\n\n\nMixte\n\nEncrypted Key Exchange (EKE)\nProtocole mixte (symétrique + asymétrique) résistant aux attaques dictionnaire.\nInitialisation : A et B partagent password \\(p\\)\nProtocole :\n\n\\(A \\rightarrow B: A, E_p(pub_A)\\) (A génère paire clés, envoie publique encryptée)\n\\(A \\leftarrow B: E_p(E_{pub_A}(k))\\) (B génère clé session \\(k\\), double encryption)\n\\(A \\rightarrow B: E_k(r_a)\\) (Key confirmation)\n\\(A \\leftarrow B: E_k(r_a, r_b)\\)\n\\(A \\rightarrow B: E_k(r_b)\\)\n\nAvantages :\n\nRobuste même si password \\(p\\) faible\nEve ne peut pas deviner sans “casser” aussi l’algorithme asymétrique\n\nPropriétés :\n\n✅ Entity authentication + implicit + confirmation\n✅ Perfect Forward Secrecy si \\(pub_A/priv_A\\) régénérée à chaque fois\n❌ Pas de PFS si clés longue durée\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKTP mixte : Encrypted Key Exchange (EKE)\nCe protocole fait intervenir des schémas symétriques et asymétriques afin de minimiser le risque de cryptanalyse par attaque dictionnaire inhérents aux systèmes symétriques.\n(Init.) : A et B partagent un secret symétrique \\(p\\) (password).\n\n\\(A \\rightarrow B: A, E_p(pub_A)\\) ; A génère une paire de clés pub/priv. et envoie la partie publique à B encrypté avec \\(p\\).\n\\(A \\leftarrow B: E_p(E_{pub_A}(k))\\) ; B génère une clé de session \\(k\\) et l’envoie encryptée.\n\\(A \\rightarrow B: E_k(r_a)\\) ; A génère un nb. aléatoire et l’envoie encrypté avec \\(k\\).\n\\(A \\leftarrow B: E_k(r_a, r_b)\\) ; B génère \\(r_b\\) et l’envoie avec \\(r_a\\) crypté avec \\(k\\).\n\\(A \\rightarrow B: E_k(r_b)\\) ; Confirmation de la part de A. Si \\(r_b =\\) OK =&gt; FIN.\net (2) sont responsables du key transport ; (3) à (5) du key confirmation.\n\nCe protocole est robuste même si le password \\(p\\) partagé entre A et B est de mauvaise qualité. En effet, Eve ne peut pas essayer de deviner sans “casser” aussi l’algorithme asymétrique.\nPropriétés :\n\nEntity Authentication + implicit key authentication + key confirmation : OUI.\nPerfect forward secrecy : OUI si la paire \\(pub_A/priv_A\\) est régénérée à chaque instance du protocole. NON si \\(pub_A/priv_A\\) est une clé de longue durée.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nEKE (mixte) :\n\nPassword + crypto asymétrique\nRobuste même si password faible\nPFS si clés régénérées chaque fois\n\n\n\n\n\n\n\n\nSymétrique avec Key Distribution Center (KDC)\n\nNeedham-Schroeder Symétrique\nProtocole avec Key Distribution Center (KDC).\nInitialisation : A partage \\(K_{AT}\\) avec T (KDC), B partage \\(K_{BT}\\) avec T\nProtocole :\n\n\\(A \\rightarrow T: A, B, r_a\\)\n\\(A \\leftarrow T: E_{K_{AT}}(r_a, B, k_{AB}, E_{K_{BT}}(k_{AB}, A))\\)\n\\(A \\rightarrow B: E_{K_{BT}}(k_{AB}, A)\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_b)\\)\n\\(A \\rightarrow B: E_{k_{AB}}(r_b - 1)\\)\n\nPropriétés :\n\n✅ Entity authentication A auprès de B\n❌ Entity authentication B auprès de A (A n’a jamais vu \\(r_b\\))\n✅ Implicit key authentication\n❌ Key Confirmation (seul \\(B\\) sait que \\(A\\) possède la clé)\n❌ Perfect Forward Secrecy\n\nVulnérabilités :\n\nReplay attacks : A peut rejouer (3) sans contrôle de B\nKnown-key attack : Si ancienne clé \\(k\\) compromise, adversaire peut la faire accepter par B\n\nSolutions :\n\nkey confirmation et entity authentication mutuelles :\nRemplacer 3. et 4. par :\n\n\\(A \\rightarrow B: E_{k_{AB}}(r_a'), E_{K_{BT}}(k_{AB}, A)\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_a'-1, r_b)\\)\n\nActualité des échanges\nAjouter timestamp dans 3. : \\(E_{K_{BT}}(k_{AB}, A, t)\\)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKTP symétrique avec Key Distribution Center - Needham-Schroeder Symétrique\n(Notation) : On appelle T, le Key Distribution Center.\n(Init.) : A et T partagent la clé symétrique \\(K_{AT}\\). B et T partagent \\(K_{BT}\\).\n\n\\(A \\rightarrow T: A, B, r_a\\) ; A génère un nb. aléatoire \\(r_a\\) et l’envoie à T avec les ident.\n\\(A \\leftarrow T: E_{K_{AT}}(r_a, B, k_{AB}, E_{K_{BT}}(k_{AB}, A))\\) ; T génère \\(k_{AB}\\) et l’envoie encryptée.\n\\(A \\rightarrow B: E_{K_{BT}}(k_{AB}, A)\\) ; A forwarde le paquet à B.\n\\(A \\leftarrow B: E_{k_{AB}}(r_b)\\) ; confirmation de B en utilisant \\(k_{AB}\\) et un nb. aléatoire \\(r_b\\)\n\\(A \\rightarrow B: E_{k_{AB}}(r_b - 1)\\) ; confirmation de A\n\nPropriétés :\n\nEntity Authentication :\n\nA auprès de B : OUI.\nB auprès de A : NON : A n’a jamais vu \\(r_b\\) (il pourrait s’agir de \\(E_{k'}(r_b')\\)).\n\nImplicit Key Authentication : OUI (les clés sont toujours protégées par \\(K_{AT}\\) et \\(K_{BT}\\)). Cependant, en cas de known-key attack, ceci n’est plus vérifié pour B.\nKey Confirmation : Seul B obtient l’assurance que A possède la clé à cause de la faille décrite dans entity authentication.\nPerfect Forward Secrecy : NON. Si une des deux clés \\(K_{AT}\\) ou \\(K_{BT}\\) est compromise, les clés de session \\(k\\) deviennent immédiatement visibles.\n\nSolution pour obtenir key confirmation et entity authentication mutuelles :\nRemplacer (3) et (4) par :\n(3’) \\(A \\rightarrow B: E_{k_{AB}}(r_a'), E_{K_{BT}}(k_{AB}, A)\\)\n(4’) \\(A \\leftarrow B: E_{k_{AB}}(r_a'-1, r_b)\\)\nPour autant que les \\(r_i\\) soient soigneusement contrôlés par les intervenants.\nCependant : attention aux reflection attacks !\nProblème : A peut rejouer (3) autant de fois qu’il le souhaite, sans aucun contrôle de la part de B. Ce problème s’aggrave si une vieille clé \\(k\\) est compromise :\nVulnérable au known-key attack : Si une clé de session \\(k\\) déjà utilisée est obtenue par un adversaire C, il peut sans difficulté la faire accepter par B en rejouant (3) et en calculant le challenge envoyé par B dans (5). Dans ce cas, les propriétés entity authentication, implicit key authentication et key confirmation de A auprès de B sont aussi compromises.\nSolution : Rajouter un timestamp dans (3) témoignant de l’actualité des échanges :\n(3’’) \\(A \\rightarrow B: E_{K_{BT}}(k_{AB}, A, t)\\) (c’est la solution adoptée par Kerberos)\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nNeedham-Schroeder symétrique :\n\nKDC génère et distribue \\(k_{AB}\\)\nVulnérable replay et known-key attacks\nSolution : ajouter timestamp\nBase de Kerberos\n\n\n\n\n\n\n\nKerberos\nProtocole d’authentification et distribution de clés basé sur Needham-Schroeder avec corrections.\nArchitecture :\n\nAuthentication Server (AS) : Émet tickets pour TGS\nTicket Granting Server (TGS) : Émet tickets pour services\nTickets : Structures encryptées contenant clés de session\n\nProtocole simplifié :\nPhase 1 : Demande TGT (Ticket Granting Ticket)\n\n\\(A \\rightarrow AS: A, TGS, r_a\\)\n\\(A \\leftarrow AS: E_{K_A}(k_{AT}, r_a), Ticket_{AT} := E_{K_T}(A, TGS, t_1, t_2, k_{AT})\\)\n\nPhase 2 : Demande ticket pour service B\n\n\\(A \\rightarrow TGS: Authenticator_{AT} := E_{k_{AT}}(A, t), Ticket_{AT}, B, r_a'\\)\n\\(A \\leftarrow TGS: E_{k_{AT}}(k_{AB}, r_a'), Ticket_{AB} := E_{K_B}(A, B, t_1, t_2, k_{AB})\\)\n\nPhase 3 : Authentification auprès de B\n\n\\(A \\rightarrow B: Authenticator_{AB} := E_{k_{AB}}(A, t), Ticket_{AB}, r_a'', [request]\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_a''), [response]\\)\n\nPropriétés :\n\n✅ Entity authentication (toutes entités)\n✅ Implicit key authentication\n⚠️ Key confirmation partielle (pas entre A et AS)\n❌ Perfect Forward Secrecy\n\nVulnérabilités :\n\nPassword guessing attacks sur \\(E_{K_A}(k_{AT}, r_a)\\) (Solution : pré-authentification)\nReplay attacks si \\(r_a\\) mal contrôlés\nNécessite synchronisation d’horloges\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKTP symétrique avec Key Distribution Center - Kerberos\nKerberos est un protocole permettant l’authentification d’entités et la distribution de clés à l’intérieur dans un réseau d’utilisateurs.\nÀ l’origine, Kerberos était conçu comme solution de remplacement pour remédier aux problèmes d’insécurité (authentification faible, transactions en clair, etc.) propres aux environnements UNIX.\nKerberos fut créé à MIT comme partie intégrante du projet ATHENA.\nIl est basé sur le protocole de Needham-Schroeder symétrique avec notamment la correction de quelques failles du protocole et l’inclusion de timestamps.\nLes trois premières versions étaient instables. La version 4 a eu un succès considérable aussi bien dans les environnements industriel qu’académique et reste prédominante. La version 5, bien qu’étant plus sûre et mieux structurée, est plus complexe et moins performante, ce qui a ralenti son déploiement.\nKerberos définit également un mode de collaboration entre domaines appartenant à des autorités administratives distinctes (les realms). Ceci permet à des utilisateurs d’un domaine d’utiliser des ressources d’un autre domaine “sans sortir” de l’environnement sécurisé de Kerberos.\nPour des transactions inter-realm, la cryptographie symétrique constitue un obstacle significatif car nécessite des canaux confidentiels pour la pré-distribution des clés.\nKerberos Version 5\n(Notation) : - A et B veulent établir une transaction sécurisée ; dans l’environnement Kerberos, il s’agit normalement d’un client et d’un serveur fournissant des services. - Le KDC de Kerberos est subdivisé en deux entités fonctionnelles : l’Authentication Server (AS) et le Ticket Granting Server (TGS). Les deux accèdent à la BdD passwords. - Les \\(r_a^{(n)}\\) sont des nbs. aléatoires, \\(t\\) est un timestamp, \\(t_1\\) et \\(t_2\\) indiquent une fenêtre de validité de temps.\n(Initialisation) : A et B partagent une clé secrète avec AS, soient : \\(K_A\\) et \\(K_B\\) (pour les clients, il s’agit d’une OWF du password). TGS a également une clé secrète \\(K_T\\).\n\n\\(A \\rightarrow AS: A, TGS, r_a\\)\n\\(A \\leftarrow AS: E_{K_A}(k_{AT}, r_a), Ticket_{AT} := E_{K_T}(A, TGS, t_1, t_2, k_{AT})\\) ; AS génère \\(k_{AT}\\)\n\\(A \\rightarrow TGS: Authenticator_{AT} := E_{k_{AT}}(A, t), Ticket_{AT}, B, r_a'\\)\n\\(A \\leftarrow TGS: E_{k_{AT}}(k_{AB}, r_a'), Ticket_{AB} := E_{K_B}(A, B, t_1, t_2, k_{AB})\\) ; TGS génère \\(k_{AB}\\)\n\\(A \\rightarrow B: Authenticator_{AB} := E_{k_{AB}}(A, t), Ticket_{AB}, r_a'', [request]\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_a''), [response]\\) ; [request] et [response] év. cryptés avec \\(k_{AB}\\)\n\n\n: Demande de ticket pour TGS\n\n\n\n\n: Demande de ticket pour B\n\n\n\n\n: Authentification et établissement de clé entre A et B.\n\n\n\nCaractéristiques de Kerberos\nPropriétés :\n\nEntity Authentication : OUI, de toutes les entités impliquées.\nImplicit key authentication : OUI : toutes les clés générées sont protégées par des clés partagées entre le AS et tous les participants.\nKey confirmation :\n\nEntre A et AS : NON : AS n’a pas de preuve que A possède la clé \\(K_A\\).\nEntre A et TGS : OUI pour \\(k_{AT}\\) (des quantités redondantes encryptées avec \\(k_{AT}\\) sont échangées entre A et TGS) ; NON pour \\(k_{AB}\\) (TGS n’a pas de preuve de la part de A)\nEntre A et B : OUI : échange des quantités redondantes encryptées avec \\(k_{AB}\\).\n\nPerfect forward secrecy : NON : Toutes les clés sont explicitement transférées.\n\nProblèmes :\n\nLes clés initiales (comme \\(K_A\\)) dépendent (directement) des passwords choisis par les utilisateurs. Ceci rend le protocole vulnérable à des vols de password ou à des :\n\nPassword guessing attacks : \\(E_{K_A}(k_{AT}, r_a)\\) dans (2) aide à casser le password de A. Solution : Pré-authentification dans (1) : \\(E_{K_A}(t)\\) avec \\(t =\\) timestamp (optionnelle dans v5).\n\nLa fenêtre de validité d’un ticket peut conduire à des replay attacks si les \\(r_a^{(n)}\\) ne sont pas correctement contrôlés par les intervenants.\nLa synchronisation d’horloges est nécessaire ! Ceci n’est pas toujours facile dans des environnements hétérogènes.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nKerberos :\n\nAS émet TGT, TGS émet tickets service\nTickets contiennent clés de session\nAuthentification via authenticators\nVulnérable : password guessing, replay\nSolution : pré-authentification, timestamps"
  },
  {
    "objectID": "exam_notes_fr.html#ssltls",
    "href": "exam_notes_fr.html#ssltls",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "SSL/TLS",
    "text": "SSL/TLS\nSSL/TLS: Secure Socket Layer / Transport Layer Security\nProtocole de sécurisation entre couche transport (TCP) et application.\nServices fournis :\n\nConfidentialité, intégrité, authentification du flot\nIdentification serveur (client optionnelle)\n\nAlgorithmes utilisés :\n\nCryptographie publique (RSA, DH, DSA) : échange clés\nMACs : authentification flot\nCryptographie symétrique (DES, AES, IDEA) : encryption flot\n\nPropriétés :\n\n✅ Entity authentication (serveur + client optionnel via certificats)\n✅ Implicit key authentication\n✅ Key confirmation\n⚠️ Perfect Forward Secrecy : dépend du protocole d’échange (DH → oui, RSA → non)\n\nRemarques\n\nLes clés secrètes TLS sont dérivées par hachage à partir de valeurs aléatoires et du pre_master_secret.\nSSL/TLS est le standard de facto de la sécurité web (HTTPS).\nLa confiance repose sur des certificats racine intégrés dans les navigateurs.\nLes failles majeures proviennent de l’aléa, des implémentations et des fonctions de hachage.\nAttaques notables : renégociation (2009), Heartbleed (2014).\n\n\nArchitecture SSL/TLS\nTrois composants :\n\nSSL Record Protocol : Encapsulation au-dessus de TCP (fragmentation + compression + encryption)\nSSL Handshake Protocol : Authentification + négociation paramètres\nSSL State Machine : Variables d’état session et connexion\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nSecure Socket Layer (SSL) / Transport Level Security (TLS)\nSe situe entre la couche transport (TCP) et les protocoles de la couche application (non seulement HTTP mais également SMTP, FTP, etc. !)\nIl s’agit d’un Meta Protocole d’établissement de clés hautement paramétrable permettant des nombreux modes de fonctionnement et des options de négociation.\nOffre des services de confidentialité, intégrité, authentification du flot de données, et identification du serveur (et accessoirement du client)\nUtilise les familles d’algorithmes suivants :\n\nCryptographie publique (RSA, Diffie-Hellmann, DSA, etc.) pour l’échange de clés symétriques\nMACs pour l’authentification du flot de données\nCryptographie symétrique (DES, IDEA, AES, etc.) pour l’encryption du flot de données\n\nL’intervention des CAs pour certifier l’association entre entités et clés publiques est vivement recommandée… mais pas indispensable !\nPropriétés : - Entity authentication par certificats (serveur et client optionnelle) - Implicit Key Authentication et Key Confirmation sont garanties - La Perfect Forward Secrecy dépend du protocole choisi pour l’échange de clés.\nSSL/TLS Aperçu\nSSL est une “mini-pile” de protocoles avec des fonctionnalités des couches session, présentation et application.\nSSL est constitué de trois blocs fondamentaux :\n\nSSL record protocol permettant l’encapsulation des protocoles de plus haut niveau au-dessus de TCP (fragmentation + compression + encryption)\nSSL handshake protocol chargé de l’authentification des intervenants et de la négociation des paramètres d’encryption\nSSL state machine. Contrairement à HTTP, SSL est un protocole à états (stateful), il nécessite, donc, un ensemble de variables qui déterminent l’état d’une session et d’une connexion\n\n\n\n\n\n\nSSL Handshake Protocol\n\n\n\n\n\n\nNoneDiagram\n\n\n\n\n\nPhase 1 : Hello\n\nClient Hello : Version, random, session ID, algorithmes acceptés\nServer Hello : Version, random, session ID, algorithmes sélectionnés\nServer Certificate (optionnel) : Certificat serveur + chemin CA\nServer Key Exchange (optionnel) : Informations clé publique serveur\nCertificate Request (optionnel) : Demande certificat client\n\nPhase 2 : Authentification client et échange de clé\n\nClient Certificate (optionnel) : Certificat client + chemin CA\nClient Key Exchange : Génère pre_master_secret, envoie encrypté avec clé publique serveur\nCertificate Verify (optionnel) : Vérification explicite certificat client\n\nPhase 3 : Finalisation\n\nFinish (client) : Premier message protégé avec paramètres négociés\nFinish (serveur) : Idem côté serveur\n\nPhase 4 : Application\n\nDonnées protégées avec clés dérivées\n\n\n\n\n\n\nGénération des Clés SSL/TLS\nDérivation en cascade :\n\\[master\\_secret = MD5(pre\\_master\\_secret + SHA('A' + pre\\_master\\_secret + ClientRandom + ServerRandom))\\] \\[+ MD5(pre\\_master\\_secret + SHA('BB' + ...)) + ...\\]\n\\[key\\_block = MD5(master\\_secret + SHA('A' + master\\_secret + ServerRandom + ClientRandom)) + ...\\]\nPartition du key_block :\n\nclient_write_MAC_secret[hash_size]\nserver_write_MAC_secret[hash_size]\nclient_write_key[key_material]\nserver_write_key[key_material]\nclient_write_IV[IV_size]\nserver_write_IV[IV_size]\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nSSL/TLS Handshake Protocol Simplifié\n[Diagramme du handshake avec 4 phases : Hello, Key Exchange, Finish, Application Data]\nSSL/TLS : Generation de clés\nmaster_secret = \n MD5(pre_master_secret + SHA('A' + pre_master_secret +\n ClientHello.random + ServerHello.random)) +\n MD5(pre_master_secret + SHA('BB' + pre_master_secret +\n ClientHello.random + ServerHello.random)) +\n MD5(pre_master_secret + SHA('CCC' + pre_master_secret +\n ClientHello.random + ServerHello.random));\n\nkey_block =\n MD5(master_secret + SHA('A' + master_secret +\n ServerHello.random +\n ClientHello.random)) +\n MD5(master_secret + SHA('BB' + master_secret +\n ServerHello.random +\n ClientHello.random)) +\n MD5(master_secret + SHA('CCC' + master_secret +\n ServerHello.random +\n ClientHello.random)) + [...];\n \n until enough output has been generated. Then the key_block is\n partitioned as follows:\n \n client_write_MAC_secret[CipherSpec.hash_size] \n server_write_MAC_secret[CipherSpec.hash_size]\n client_write_key[CipherSpec.key_material]\n server_write_key[CipherSpec.key_material]\n client_write_IV[CipherSpec.IV_size] /* non-export ciphers */\n server_write_IV[CipherSpec.IV_size] /* non-export ciphers */\nSSL/TLS : Remarques Finales\n\nLes clés secrètes sont le résultat de l’application de fonctions de hachage (MD5, SHA) sur les random numbers des enregistrement Hello et le pre_master_secret\nTLS/SSL est devenu le standard de facto pour la sécurité sur le web (à la base de https)\nLes clients SSL (Explorer, Firefox, Opera, Chrome, etc.) contiennent “hard-coded” des certificats correspondant à quelques entités de certification racine (Verisign, Thawte, Microsoft, RSA, etc.) permettant de vérifier les certificats présentés par certains serveurs mais SSL est conçu pour s’appuyer sur un réseau global de certification pour le moment inexistant.\nLes failles de sécurité les plus courantes de SSL concernent la génération aléatoire des clés ainsi que les défauts d’implantation les plus courants : buffer overflows, sql injection, etc. La faiblesse des fonctions de hachage (MD5, SHA) est aussi un facteur à risque.\nEn Novembre 2009, on a découvert une attaque permettant à un Man in The Middle d’injecter du contenu (chosen plaintext) dans un flot authentique suite à une renégociation des paramètres prévue dans le protocole. Il s’agit d’une faille dans le protocole qui a nécessité un patch dans toutes les implantation.\nLa faille heartbleed basée sur un buffer overflow a sérieusement troublé la communauté Internet lors de sa découverte en Avril 2014.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nSSL/TLS :\n\nMeta-protocole entre TCP et application\nHandshake : négociation + authentification\nClés dérivées : master_secret → key_block\nStandard HTTPS\nFailles : génération aléatoire, heartbleed, renégociation"
  },
  {
    "objectID": "exam_notes_fr.html#remarques-finales-sur-les-kep",
    "href": "exam_notes_fr.html#remarques-finales-sur-les-kep",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Remarques Finales sur les KEP",
    "text": "Remarques Finales sur les KEP\nAvant de choisir un KEP :\n\nDéfinir objectifs : confidentialité, authentification, non-répudiation\nDéfinir niveau de sécurité : key confirmation, PFS, future secrecy\nÉtablir contraintes : utilisateurs, machines, réseau, attaquants\n\nBonnes pratiques :\n\n✅ Choisir solution prouvée et robuste\n❌ Éviter d’inventer “from scratch”\n✅ Vérifier propriétés satisfaites\n\nVérification des protocoles :\nDeux approches complémentaires :\n\nAnalyse pratique : “Sur papier” et “sur machine”\n\nContrôle nombres aléatoires (reflection attacks)\nRedondance quantités encryptées/signées\nPièges classiques\n\nAnalyse formelle : Logiques dédiées (BAN logic, etc.)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nKey Establishment Protocols : Remarques Finales\nLes protocoles d’établissement de clés constituent une pierre angulaire de toute solution de sécurité. Avant de choisir (concevoir) un KEP, il est, donc, indispensable de :\n\nDéfinir les objectifs (confidentialité, authentification d’entités/données, non-répudiation, etc.)\nDéfinir le niveau de sécurité souhaité en fonction des propriétés étudiées (key confirmation, perfect forward secrecy, etc.)\nÉtablir une liste des contraintes liées à l’environnement (utilisateurs, machines, réseau, attaquants potentiels, etc.)\n\nEn fonction de ces critères nous pouvons :\n\nChoisir une solution prouvée et robuste (mieux qu’en inventer une from scratch !).\nVérifier que les objectifs sont atteints et les propriétés satisfaites.\n\nLa vérification des protocoles est un processus complexe et délicat, de plus, les solutions publiées ne sont pas toujours correctes. Deux approches sont possibles (et nécessaires) :\n\nL’analyse pratique. Analyser les failles du protocole “sur papier” et “sur machine” en tenant compte des pièges classiques : contrôle des nbs. aléatoires pour éviter des reflection attacks, redondance des quantités encryptées/signées, etc.\nL’analyse formelle avec des logiques spécialement conçues à cet effet (comme la logique BAN)\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nKEP - Bonnes pratiques :\n\nDéfinir objectifs et contraintes\nChoisir solution prouvée\nVérifier propriétés (pratique + formelle)\nÉviter pièges : reflection, redondance, contrôle aléas"
  },
  {
    "objectID": "exam_notes_fr.html#ttp",
    "href": "exam_notes_fr.html#ttp",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "TTP",
    "text": "TTP\n\nModes de Fonctionnement des TTP\nTrois modes opérationnels :\n\nIn-line : TTP agit comme intermédiaire, relaye tous les échanges en temps réel (ex: Proxies, Secure Gateways)\nOn-line : TTP participe en temps réel mais A et B communiquent directement (ex: KDC)\nOff-line : TTP ne participe pas en temps réel, rend l’information disponible à priori (ex: CA)\n\n\n\n\n\n\ngraph LR\n    A[A] --&gt;|in-line| TTP[TTP]\n    TTP --&gt;|in-line| B[B]\n    \n    A2[A] ---|on-line| TTP2[TTP on-line]\n    A2 &lt;--&gt;|direct| B2[B]\n    \n    A3[A] -.-&gt;|échange préalable| TTP3[TTP off-line]\n    B3[B] -.-&gt;|échange préalable| TTP3\n    A3 &lt;--&gt;|direct| B3\n\n\n\n\n\n\nComparaison :\n\nOff-line : Échanges facilités, pas besoin de disponibilité permanente\nIn-line/On-line : Disponibilité permanente requise\nOff-line : Révocation des privilèges plus complexe\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nTTP: Modes de Fonctionnement\n\nIn-line : Le TTP agit comme intermédiaire pour relayer en temps réel les échanges entre A et B. Exemples : Proxies, Secure Gateways.\nOn-line : Le TTP participe en temps réel aux échanges entre A et B mais A et B communiquent directement (sans passer par le TTP). Exemple : Key Distribution Center.\nOff-line : Le TTP ne participe pas à l’échange en temps réel mais rend l’information disponible à priori. Exemple : Certification Authorities.\n\nComparaison In-line/On-Line/Off-line : Échanges facilités et pas besoin de disponibilité permanente des TTP dans le off-line (contrairement aux deux autres) mais révocation des privilèges (p.ex. : lorsqu’une clé secrète est compromise) plus complexe.\n[Diagrammes montrant les trois modes]\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nModes TTP :\n\nIn-line : intermédiaire relay\nOn-line : participation temps réel\nOff-line : info à priori (ex: CA)\nOff-line : pas de disponibilité requise mais révocation complexe\n\n\n\n\n\n\n\nKey Distribution Centers (KDCs)\nObjectif : Résoudre le problème de distribution \\(n^2\\) clés.\nPrincipe :\n\nSans KDC : \\(\\frac{n(n-1)}{2} \\approx n^2\\) clés pour \\(n\\) entités\nAvec KDC : Seulement \\(n\\) clés (chaque entité partage une clé avec KDC)\nClés de session générées dynamiquement par KDC\n\nAvantages :\n\nScalabilité : une nouvelle entité = une seule nouvelle clé\nÉtablissement canaux sûrs via tickets (à la Kerberos)\n\nInconvénients :\n\nSingle point of security failure : KDC compromis → tout le système vulnérable\nSingle point of operational failure : KDC indisponible (DoS) → système paralysé\nPerformance bottleneck : Opérations coûteuses (encryption, random generation)\n\nSolutions : Mirroring, répartition de charge\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nTTP: Key Distribution Centers (KDCs)\nBut : Résoudre le n² key distribution problem :\n\nDans un environnement symétrique de \\(n\\) entités sans intermédiaire : \\(n(n-1)/2 \\sim n^2\\) clés différentes sont nécessaires pour toutes les paires d’entités partagent une clé différente.\nDe plus, un tel système n’est pas évolutif (scalable) car l’adjonction d’une entité se traduit par la génération de \\(n\\) nouvelles clés.\n\nSi chaque entité partage une clé avec un KDC, seules n clés sont nécessaires pour le fonctionnement du système et une clé suffit pour chaque nouvelle entité. L’établissement de canaux sûrs étant assuré par la génération de clés de session et la présence des tickets à la Kerberos.\nProblèmes :\n\nSingle point of security failure : par construction le KDC peut usurper l’identité de tous les nœuds du réseau. S’il est compromis tout le système devient vulnérable.\nSingle point of operational failure : le mode de fonctionnement habituel d’un KDC est on-line (év. in-line). S’il devient indisponible (p.ex. suite à un denial of service attack), tout le système est paralysé.\nPerformance bottleneck : les opérations des KDC sont souvent coûteuses en temps de calcul (cryptage/décryptage, random generation, etc.). Des solutions classiques (ie. le mirroring) doivent être envisagées pour répartir la charge des KDCs.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nKDC :\n\nRésout problème \\(n^2\\) → \\(n\\) clés\nScalable : +1 entité = +1 clé\nRisques : single point of failure (sécurité + opérationnel), bottleneck\n\n\n\n\n\n\n\nCA\nCertification Authorities (CAs)\nRôle : Authentifier l’association entre une entité et sa clé publique.\nFonctionnement :\n\nCA vérifie identité (passeport, etc.)\nCA crée et signe certificat contenant cette association\nCertificats accessibles aux entités (peuvent être cachés)\n\nVérification : Nécessite copie authentique de la clé publique de la CA.\nAvantages :\n\nMode off-line : Indisponibilité courte acceptable\nSimpler then safer : pas de protocoles complexes\n\nInconvénients :\n\nRévocation asynchrone : Certificat peut devenir invalide (vol clé privée)\nSolution : Certificate Revocation Lists (CRLs) signées\n\nCompromission CA :\nConséquences graves si clé privée de signature compromise.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nTTP: Certification Authorities (CAs)\nLe rôle premier d’une Entité de Certification (Certification Authority ou CA) est d’authentifier l’association entre une entité et sa clé publique (pensez aux attaques Man-In-the-Middle !).\nLa CA va créer et signer des certificats contenant cette association (moyennant une preuve d’identité comme un passeport) et les rendre accessibles aux entités concernées.\nUne fois signées, des copies des certificats (cached certificates) peuvent être gardées dans des endroits non protégés (p.ex. dans l’espace disque de l’utilisateur). Cependant, afin de vérifier la signature des certificats, les entités concernées nécessitent une copie authentique de la clé publique de la CA.\nSimpler then safer : pas besoin d’implanter des protocoles complexes dans une CA.\nLe mode de fonctionnement habituel d’une CA est off-line, ce qui diminue les conséquences des périodes (courtes…) d’indisponibilité.\nProblème associé au mode off-line : la validité des cached certificates peut être remise en question de manière “asynchrone” par un vol de clé privé.\nRemède : les CAs publient également des listes signées des certificats non valides (Certificate Revocation Lists ou CRLs).\nLe compromis d’une CAs a des conséquences moins évidentes mais presque aussi néfastes que celui d’un KDC surtout si la clé privée servant à signer des certificats est aussi compromise.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCA :\n\nAuthentifie association entité ↔︎ clé publique\nSigne certificats (mode off-line)\nCRLs pour révocations\nCompromission = conséquences graves\n\n\n\n\n\n\nProof of Possession (PoP)\nProblème : Vérifier identité ne suffit pas, il faut aussi vérifier possession de la clé privée.\nAttaque sans PoP :\n\nA signe document et l’envoie à B (notaire) : \\(S_{priv_A}(\\text{Invention}), S_{priv_{CA_A}}(Cert_A)\\)\nC intercepte, demande à \\(CA_C\\) (sans PoP) certificat associant C à \\(pub_A\\)\nC envoie à B : \\(S_{priv_A}(\\text{Invention}), S_{priv_{CA_C}}(Cert_C)\\)\nC devient l’inventeur !\n\nProtocole PoP simple :\n\n\\(CA \\rightarrow A: A, r\\) (nombre aléatoire + identité)\n\\(CA \\leftarrow A: S_{priv_A}(A, r)\\)\n\\(CA\\) vérifie signature avec \\(pub_A\\)\n\nConséquences :\n\nIntroduit niveaux de confiance pour CAs\nCritères : PoP, mise à jour CRLs, sécurité clé signature\nProblème aggravé par prolifération non contrôlée des CAs\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nCA: Proof of Possession (PoP)\nLa vérification de l’identité de A pour créer (év. modifier) un certificat associant A à sa clé publique n’est pas un critère suffisant. Il faut également vérifier que A possède vraiment la clé privée correspondante.\nSoient A et sa CA : \\(CA_A\\). Voyons ce qu’un attaquant actif C peut faire en “collaboration” avec une \\(CA_C\\) qui ne vérifierait pas la PoP :\nA signe un document contenant la description d’une invention révolutionnaire et l’envoie à B (le notaire) avec son certificat signé par \\(CA_A\\) :\n\\(A \\rightarrow B: S_{priv_A}(\\text{Invention}), S_{priv_{CA_A}}(Cert_A)\\)\nC intercepte ce paquet, s’adresse à \\(CA_C\\) et lui demande de créer un certificat associant son identité C à la clé publique de A et envoie à B :\n\\(C \\rightarrow B: S_{priv_A}(\\text{Invention}), S_{priv_{CA_C}}(Cert_C)\\)\nC devient ainsi l’inventeur révolutionnaire…\nProtocole simple de vérification de PoP :\n\\(CA \\rightarrow A: A, r\\) ; \\(r\\) : nb. aléatoire, A pour protéger A des chosen message attacks.\n\\(CA \\leftarrow A: S_{priv_A}(A, r)\\) ; CA n’a plus qu’à vérifier la signature avec \\(pub_A\\).\nCe critère et d’autres critères de comportement comme la mise à jour des CRLs ou la sécurité de la clé de signature introduisent des niveaux de confiance pour les CAs et pour les certificats qu’elles signent.\nCe phénomène s’aggrave avec la prolifération non contrôlée des CAs !\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nPoP (Proof of Possession) :\n\nVérifier possession clé privée (pas juste identité)\nSans PoP : attaquant peut usurper identité\nProtocole : CA vérifie signature sur challenge\nIntroduit niveaux de confiance pour CAs\n\n\n\n\n\n\n\nSéparation Certification/Révocation\nProblème : Si même clé signe certificats et CRLs, adversaire possédant clé privée CA peut :\n\nPublier CRL révoquant certificat de victime A\nCréer faux certificat associant A à une clé contrôlée par adversaire\nDécrypter transactions confidentielles pour A\nSe faire passer par A (signatures, authentification)\n\nSolution : Separation of Duties\nSéparation claire des tâches :\n\nCertificats et CRLs signés avec clés différentes\nPar entités fonctionnelles différentes :\n\nCertification Authority (CA)\nRevocation Authority (RA)\n\nRésidant dans machines différentes\nSoumises à security policies indépendantes\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nCA: Certification et Révocation\nProblème : Si la même clé sert à signer les certificats et les CRLs, un adversaire possédant la clé privée de signature d’une CA peut attaquer une “victime” A sous l’autorité de cette CA comme suit :\n\nPublier une CRL contenant le certificat révoqué de A.\nCréer un certificat associant A à une clé publique dont il contrôle la clé privée pour ensuite :\n\njouer le Man-In-the-Middle pour décrypter les transactions confidentielles pour A ;\nse faire passer par A pour des transactions authentifiées ou des documents signés.\n\n\nSolution : Separation of duties : La certification et la révocation deviennent des tâches clairement différenciées :\n\nCertificats et CRLs sont signés avec des clés différentes,\npar des entités fonctionnelles différentes (Certification Authority et Revocation Authority) ;\nsi possible, résidant dans des machines différentes soumises à des critères de sécurité (security policies) indépendants.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nSeparation of Duties :\n\nCertificats ≠ CRLs (clés différentes)\nCA ≠ Revocation Authority\nMachines et policies séparées\nÉvite attaques post-compromission\n\n\n\n\n\n\n\n\nEntités Fonctionnelles Liées à la Certification\nName Server :\n\nGestion espace de noms unique et cohérent\nCombiné avec certification si authentification nécessaire\nExemple : DNSSec (DNS authentifié pour Internet)\n\nRegistration Authority (RA) :\n\nTâches nécessitant contact direct avec entités\nVérification identité, PoP, demandes/modifications certificats\nDétachée de CA pour raisons géographiques\n\nKey Generator :\n\nGénération de paires clés publique/privée\nAvantages : Simplicité utilisateurs, sécurité renforcée\nDésavantage : Clé privée connue d’une autre entité → perte non-répudiation\n\nCertificate Directory :\n\nRépertoire accès lecture seule aux certificats\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nEntités Fonctionnelles Liées à la Certification\n\nName Server : responsable de la gestion d’un espace de noms unique et cohérent. Lorsque l’authentification est nécessaire, la gestion des noms doit être complétée par la certification des clés publiques associées à ces noms.\nExemple d’une solution pilote combinant les deux concepts : DNSsec : environnement de gestion de noms authentifiés pour Internet.\nRegistration Authority : Entité chargée d’accomplir les tâches relatives à la gestion des certificats nécessitant un contact direct avec les entités concernées. Ces tâches comprennent la vérification des paramètres nécessaires à la demande initiale ou à la modification des certificats (vérification d’identité, PoP, etc.). Le fait de détacher cette fonctionnalité de la CA est normalement dû à des considérations géographiques.\nKey Generator : Permet de déléguer le processus de création de paires de clés publique/privée à une entité dédiée :\n\nAvantages : simplicité pour les utilisateurs ; possibilité de renforcer la sécurité des paires choisies.\nDésavantage : Clé privée connue d’une autre entité ! Perte de la non-répudiation.\n\nCertificate Directory : Le répertoire permettant aux utilisateurs d’accéder (en lecture seulement) aux certificats des correspondants.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nEntités certification :\n\nName Server : noms + DNSSec\nRA : contact direct, vérifications\nKey Generator : génération clés (⚠️ perd non-répudiation)\nCertificate Directory : accès lecture certificats\n\n\n\n\n\n\n\nAutres TTPs\nTimestamp Agent (TA) :\n\nCertifie existence document/transaction à un moment précis\nMéthodes :\n\nAssocier timestamp au document (ou \\(h(\\text{doc})\\)) + signer\nUtiliser authentication tree (arbre d’authentification)\n\n\nNotary Agent :\n\nComme TA mais aussi : validité, origine, appartenance\nSupport légal pour non-répudiation\n\nKey Escrow Agent (KEA) :\n\nAccès clés secrètes de session sous conditions (mandat judiciaire)\nNécessite système cryptage dédié\n\nExemple : Clipper/Capstone\n\nClipper chip (1993) : Encryption symétrique avec accès KEA\nPolémique, failles découvertes\nCapstone chip : Successeur (carte PCMCIA Fortezza)\nMilitary level security\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAutres TTPs\n\nTimestamp agent (TA) : Certifie l’existence d’un document ou le déroulement d’une transaction à un moment bien spécifié dans le temps. Pour ce faire le TA peut :\n\nassocier un timestamp au document (ou à \\(h(\\text{doc})\\) avec \\(h\\) une Collision Resistant Hash Fonction) et signer le tout avec sa clé privée et\nutiliser un authentication tree (arbre d’authentification, cf. page 231).\n\nNotary agent : Certifie non seulement l’existence d’un document à un temps donné (comme le TA) mais également sa validité, origine ou appartenance à une entité donnée. Ce service constitue un support (légalement nécessaire ?) pour la non-répudiation.\nKey escrow agent (KEA) : Entité autorisée à accéder aux clés secrètes de session pourvu que certaines conditions (p.ex. un mandat judiciaire) soient remplies. Ceci nécessite un système de cryptage dédié. Exemple, le Clipper key escrow system :\n\nAnnoncé en Avril 1993 par l’administration USA, au milieu d’une grande polémique, comme la solution de cryptage de communications à grande échelle.\nLe Clipper chip est un dispositif de cryptage/décryptage symétrique donnant accès aux clés des session lorsque les clés secrètes de deux KEAs (normalement des agences fédérales) lui sont fournies en entrée.\nLa présence de quelques failles ainsi que le besoin de crypto asymétrique ont donné lieu à son successeur : le Capstone chip pouvant être intégré dans une carte PCMCIA (appelée Fortezza et utilisée pour military level security).\n\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nAutres TTPs :\n\nTA : timestamp existence document\nNotary : TA + validité/origine (non-répudiation)\nKEA : accès clés sous conditions légales\nExemple : Clipper/Fortezza (controversé)"
  },
  {
    "objectID": "exam_notes_fr.html#public-key-authentication",
    "href": "exam_notes_fr.html#public-key-authentication",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Public Key Authentication",
    "text": "Public Key Authentication\n\nCertificats\nDéfinition : Information associant une entité à sa clé publique.\nStructure générique :\n\nSerial Number, Version\nIssuer : Identité CA signataire (globale et unique)\nSignature Algorithm : Algorithme calcul signature (ex: MD5+ElGamal, SHA+RSA)\nSubject : Nom entité certifiée (global et unique)\nSubject Public Key : Clé publique\n\nRSA : \\((n, e)\\)\nDH : \\((p, \\alpha, \\alpha^x \\mod p)\\)\n\nSubject Public Key Algorithm : RSA, DH, etc.\nValidity : Période validité (UTC)\nSignature : Porte sur tous enregistrements précédents, garantit authenticité\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthenticité des clés publiques: Certificats\nUn certificat est une pièce d’information associant une entité à sa clé publique. De manière générique, il est constitué des élément suivants :\n\nSerial Number, Version.\nIssuer : l’identité (global et unique) de la CA signataire.\nSignature Algorithm : l’algorithme permettant de calculer la signature sur le certificat. P.ex. : MD5 + ElGamal ou SHA + RSA.\nSubject : Le nom (global et unique) de l’entité dont la clé publique est certifiée.\nSubject Public Key : La clé publique de l’entité. Par exemple :\n\n\\((n,e)\\) : modulus et exposant publique pour RSA.\n\\((p, \\alpha^x \\mod p)\\) : modulus, générateur et partie publique pour Diffie-Hellman.\n\nSubject Public Key Algorithm : L’algorithme associé à la clé publique. P.ex : RSA ou Diffie-Hellman.\nValidity : La période de validité du certificat, normalement exprimée en UTC.\nSignature : Contient la signature effectuée au moyen du Signature Algorithm et de la clé privée de la CA. Elle porte sur l’ensemble des enregistrements précédents et garantit ainsi l’authenticité des informations qu’ils contiennent.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCertificat :\n\nIssuer (CA) + Subject (entité)\nClé publique + algorithme\nValidity period\nSignature CA sur tout\n\n\n\n\n\n\n\nCertificate Revocation Lists (CRLs)\nDéfinition : Listes de certificats devenus invalides.\nRaisons révocation :\n\nClé privée compromise\nModification algorithme\nChangement fonction (role-based certificate)\nAutres facteurs invalidant informations certificat\n\nStructure CRL :\n\nIssuer, Signature Algorithm\nDate of Issue, Date of Next Issue\nPour chaque certificat révoqué :\n\nSerial Number\nRevocation Date\n\nSignature : Sur toute la liste\n\nExigences :\n\nCAs doivent publier CRLs fréquemment\nCanaux distribution large audience\nMinimiser risque fraudes\n\nProblème : Révocation = talon d’Achille systèmes à clés publiques\nSolutions alternatives :\n\nCertificats validité très courte (quelques minutes)\nRe-confirmation périodique par CAs\n⚠️ Retour au mode on-line → haute disponibilité requise\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nCertificate Revocation Lists (CRLs)\nIl s’agit de listes contenant des certificats devenus non valables suite à une clé privée compromise ou à tout autre facteur mettant en évidence la validité des informations contenues dans un certificat (changement de l’algorithme utilisé, changement de fonction pour un role-based certificate, etc.).\nUne CRL générique a les éléments suivants :\n\nIssuer, Signature Algorithm : comme pour les certificats.\nDate of Issue, Date of Next Issue : date d’émission et date de la prochaine émission.\nPour chaque certificat révoqué, les enregistrements suivants :\n\nSerial Number du certificat révoqué.\nRevocation Date.\n\nSignature : signature portant sur toute la liste.\n\nUne CA se doit de publier des CRLs avec une fréquence très élevée et en utilisant des canaux de distribution de large audience, afin de diminuer le risque de fraudes.\nLa révocation est le talon d’Achille de tout système à clés publiques…\nUne solution : certificats avec des lapses de validité très courts (quelques minutes) exigeant une re-confirmation périodique de la part des CAs…\n…mais ceci nous fait revenir au mode on-line et à imposer, donc, une grande disponibilité de la part des CAs.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCRLs :\n\nListes certificats invalides (compromis, etc.)\nStructure : issuer, dates, serial numbers, signature\nPublication fréquente requise\nTalon d’Achille PKI\nAlternative : certificats courte durée (→ on-line)\n\n\n\n\n\n\n\nArbres d’Authentification\nPrincipe : Alternative à certification pour authentifier informations publiques.\nConstruction : Arbre (binaire) avec hash fonction + authentification racine.\nPour \\(n\\) valeurs \\(Y_1, Y_2, ..., Y_n\\) :\n\nValeurs placées dans feuilles\nArcs depuis feuilles étiquetés \\(h(Y_i)\\)\nNœuds non-terminaux étiquetés \\(h(h_1 || h_2)\\) (|| = concaténation)\nRacine \\(R\\) authentifiée (signature digitale)\n\n\n\n\n\n\ngraph TD\n    R[\"R = h(h2 || h(Y4))\"]\n    h2[\"h2 = h(h1 || h(Y3))\"]\n    h1[\"h1 = h(h(Y1) || h(Y2))\"]\n    Y1[Y1] --&gt; hY1[\"h(Y1)\"]\n    Y2[Y2] --&gt; hY2[\"h(Y2)\"]\n    Y3[Y3] --&gt; hY3[\"h(Y3)\"]\n    Y4[Y4] --&gt; hY4[\"h(Y4)\"]\n    hY1 --&gt; h1\n    hY2 --&gt; h1\n    h1 --&gt; h2\n    hY3 --&gt; h2\n    h2 --&gt; R\n    hY4 --&gt; R\n\n\n\n\n\n\nVérification \\(Y_1\\) : Fournir \\(h(Y_2), h(Y_3), h(Y_4)\\), calculer \\(h(Y_1), h_1, h_2\\) et vérifier \\(h(h_2 || h(Y_4)) = R\\)\nAvantages :\n\nSeul \\(R\\) nécessite protection cryptographique\nArbres équilibrés : données intermédiaires \\(\\sim \\log_2 n\\)\n\nInconvénients :\n\nNœud modifié → recalcul chemin jusqu’à racine\nAjout nœuds → arbres non-équilibrés recommandés\n\nApplication principale : Timestamping\nTA\n\nconstruit arbre\nfournit timestamp signé + chemin vérification\npublie \\(R\\) quotidiennement (journal).\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nArbres d’Authentification\nLes arbres d’authentification sont une alternative à la certification pour authentifier des information publiques.\nIl s’agit d’exploiter les avantages d’une structure d’arbre (normalement binaire) avec l’utilisation de hash fonctions et l’authentification du nœud racine.\nSoit un arbre A avec \\(n\\) feuilles. Soit \\(h\\) une collision resistant hash function (CRHF). L’arbre A peut être utilisé pour l’authentification de \\(n\\) valeurs publiques \\(Y_1, Y_2, ..., Y_n\\) en construisant un arbre d’authentification comme suit :\n\nLes valeurs \\(Y_1, Y_2, ..., Y_n\\) sont placées dans les feuilles de l’arbre.\nChaque arc partant d’une feuille \\(Y_i\\) est étiqueté \\(h(Y_i)\\) (\\(h\\) étant une CRHF).\nChaque nœud non-terminal ayant des arcs sous-jacents étiquetés \\(h_1\\) et \\(h_2\\) est étiqueté \\(h(h_1 || h_2)\\) (|| dénote concaténation).\n\n[Diagramme arbre]\nPour vérifier l’authenticité de \\(Y_1\\), il est nécessaire de fournir les valeurs \\(h(Y_2), h(Y_3), h(Y_4)\\). Après, il suffit de calculer \\(h(Y_1), h_1\\) et \\(h_2\\) (selon la figure) et accepter l’authenticité de \\(Y_1\\) si \\(h(h_2 || h(Y_4)) = R\\). Une modification illicite dans \\(Y_1\\) se traduirait (par les caractéristiques de la CRHF) en une valeur différente pour \\(h(h_2 || h(Y_4)) \\neq R\\).\nÀ noter que seule la valeur \\(R\\) doit être authentifiée (p.ex. à l’aide d’une signature digitale). Les autres valeurs sont protégées par la non-réversibilité de la CRHF.\nAvantage : Seul \\(R\\) nécessite une protection cryptographique pour l’authentification !\nInconvénients :\n\nPour vérifier la valeur \\(Y_1\\), les valeurs \\(h(Y_{2,3,4})\\) et la valeur \\(R\\) sont nécessaires. Pour minimiser cet effet, on peut d’utiliser des arbres équilibrés (des arbres dont les chemins différent d’au plus un arc) afin de réduire le nombre de données intermédiaires à \\(\\sim \\log_2 n\\).\nLorsqu’un nœud est modifié, tout le chemin jusqu’à la racine doit être re-calculé.\nLorsque des nouveaux nœuds sont rajoutés, il convient de construire des arbres non-équilibrés (comme celui de la figure) et de rajouter les nœuds par la racine.\n\nApplication principale : timestamping : le timestamping agent (TA) construit un tel arbre et fournit au requérant le timestamp signé avec sa clé privée ainsi que le chemin de vérification. TA publie \\(R\\) quotidiennement dans un journal ce qui lui empêche de tricher !\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nArbres d’authentification :\n\nAlternative certification via hash + arbre\nSeule racine \\(R\\) signée\nVérification : chemin \\(\\sim \\log_2 n\\) valeurs\nApplication : timestamping\nTA publie \\(R\\) quotidiennement\n\n\n\n\n\n\n\nTopologies de Certification\nProblème : Communication entre utilisateurs de CAs différentes → question de confiance.\nCross-Certification :\n\n\\(CA_A\\) certifie clé publique \\(pub_{CA_B}\\) de \\(CA_B\\)\nCertificat croisé : \\(CA_A\\{CA_B\\}\\)\nChaîne de certification : \\(CA_A\\{CA_B\\} \\rightarrow CA_B\\{B\\}\\)\nA vérifie clé B avec copie authentique \\(pub_{CA_A}\\)\n\nModèle Hiérarchique Strict (PEM/X.509) :\n\n\n\n\n\ngraph TD\n    Root[CA Racine]\n    Root --&gt; CA1[CA Niveau 1]\n    Root --&gt; CA2[CA Niveau 1]\n    CA1 --&gt; CA3[CA Niveau 2]\n    CA1 --&gt; CA4[CA Niveau 2]\n    CA2 --&gt; CA5[CA Niveau 2]\n\n\n\n\n\n\n\nToute chaîne non-locale commence au nœud racine\nClé publique racine supposée connue mondialement\nProblème : Centralisation, point de défaillance unique\n\nModèle Graphe (PGP) :\n\nUtilisateurs agissent comme CAs pour correspondants\nStructure graphe décentralisée\nAdapté groupes fermés\nLimites : Populations non connectées\n\nModèles Hybrides :\n\nHiérarchie + certification croisée bidirectionnelle\n\nRègle d’or : Chaînes courtes (maillon le plus faible !)\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nTopologies de Certification\nLorsque deux utilisateurs appartenant à des CAs différentes souhaitent communiquer, il apparaît un problème de confiance : doit-on faire confiance à un certificat émis par une autre CA ?.\nLe processus de certification croisée (cross-certification) permet à \\(CA_A\\) de certifier la clé publique \\(pub_{CA_B}\\) de \\(CA_B\\). Le certificat résultant s’appelle certificat croisé (cross-certificate), on le note : \\(CA_A\\{CA_B\\}\\).\nSi A désire vérifier l’authenticité de la clé publique de B et il existe un certificat croisé \\(CA_A\\{CA_B\\}\\), A va demander à B de lui fournir son certificat signé par \\(CA_B\\), soit \\(CA_B\\{B\\}\\). La chaîne de certification résultante : \\(CA_A\\{CA_B\\} \\rightarrow CA_B\\{B\\}\\) permet à A de vérifier la clé publique de B en utilisant une copie authentique de \\(pub_{CA_A}\\).\nLa relation de confiance nécessaire à la certification croisée n’est pas toujours facile à établir dans des environnements concurrents, c’est pourquoi des modèles hiérarchiques entre les CAs ont été proposés. Exemple le modèle hiérarchique strict de PEM/X.509 :\n[Diagramme hiérarchie]\nDans l’environnement PEM, toute chaîne de certification non-locale commence au nœud racine, dont la clé publique est supposée connue du monde entier…\nD’autres modèles comme celui proposé par PGP se basent sur une structure de graphe où les nœuds sont les utilisateurs qui agissent comme CAs pour certifier les clés publiques des correspondants. Même si bien adapté pour des groupes fermés d’utilisateurs, ce modèle a ses limites lorsqu’il est appliqué à des populations non connectées.\nD’autres schémas proposés combinent la structure hiérarchique avec la certification croisée bidirectionnelle.\nIl faut garder les chaînes de certification aussi courtes que possible (une chaîne est toujours aussi vulnérable que son maillon le plus faible !).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nTopologies certification :\n\nCross-certification : \\(CA_A\\{CA_B\\} \\rightarrow CA_B\\{B\\}\\)\nHiérarchique (PEM/X.509) : racine universelle\nGraphe (PGP) : utilisateurs = CAs\nHybride : hiérarchie + cross-cert\nRègle : chaînes courtes !"
  },
  {
    "objectID": "exam_notes_fr.html#public-key-infrastructure-pki",
    "href": "exam_notes_fr.html#public-key-infrastructure-pki",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Public Key Infrastructure (PKI)",
    "text": "Public Key Infrastructure (PKI)\nDéfinition : Infrastructure intégrée fournissant services de sécurité basés sur cryptographie à clés publiques.\n\nEntités Fonctionnelles Principales\nCertification Authority (CA) :\n\nCréation et maintenance certificats\n\nCertificate Repository :\n\nRépertoire certificats accessible (X.500, LDAP, WWW, DNS)\n\nCertificate Revocation :\n\nGestion certificats compromis/obsolètes (CRLs)\n\nKey Backup and Recovery :\n\nSauvegarde/rétablissement clés perdues\nDestruction support, oubli password, départ employé\n⚠️ Clé privée décryption (pas signature)\n\nAutomatic Key Update :\n\nMise à jour clés après fin validité\n\nKey and Certificate History :\n\nRécupération clés obsolètes pour décrypter anciens documents\n\nCross-Certification :\n\nValidation certificats d’autres PKIs (clients, fournisseurs, partenaires)\n\nSupport Non-Répudiation :\nDémontre le bon déroulement d’une transaction authentifiée\n\nData origin authentication\nTime-stamped data signature\nSigned receipt of delivery\n\nSecure Time Stamping :\n\nTemps référence accepté par tous\n\nLogiciel Client :\n\nOpérations PKI côté client\nGestion certificats, signatures, décryption\nPériphériques (cartes à puces, biométrie)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nPublic Key Infrastructure (PKI): Définitions\nDéfinition : Une PKI est une infrastructure intégrée permettant de fournir un ensemble de services de sécurité sur la base de la cryptographie à clés publiques.\nEntités Fonctionnelles :\n\nEntité de certification (Certification Authority ou CA) : Entité responsable de la création et maintenance des certificats.\nRépertoire des certificats (Certificate Repository) mettant les certificats à disposition des utilisateurs et des applications. Technologies utilisées : X.500, LDAP, Serveurs WWW, DNS, etc.\nRévocation des certificats (Certificate Revocation) compromis ou devenus obsolètes (notamment gestion des CRLs)\nSauvegarde et rétablissement centralisés des clés (Key Backup and Recovery) : Entité permettant de gérer la perte de clés suite à des événements divers : destruction du support matériel, oubli du mot de passe de déblocage, départ de l’employé, etc. À noter que cette procédure s’applique principalement à la clé privée de décryption (par opposition à la clé privée de signature).\nMise à jour automatique des clés (Automatic Key Update) après la fin de leur validité.\nHistorique des clés et des certificats (Key and Certificate History). Cette entité permet de récupérer des clés devenues obsolètes, ayant servi à encrypter un document dans le passé.\nCertification croisée (Cross-Certification) avec d’autres PKI (clients, fournisseurs, partenaires, etc.). Cette fonctionnalité permet (sous certaines contraintes) de valider les certificats émis par d’autres PKIs\nSupport pour la non-répudiation : Service à valeur ajouté permettant de fournir l’évidence nécessaire à démontrer le déroulement d’une transaction authentifiée (data origin authentication, time-stamped data signature, signed receipt of delivery, etc.)\nSecure Time Stamping : Entité capable de fournir un temps de référence accepté par tous les intervenants d’une PKI. Applications principales : non-répudiation, arbitrage en cas de conflits, etc.\nLogiciel Client : Cette entité fonctionnelle permet de réaliser toutes les opérations propres à la PKI côté client. Exemples : gestion des certificats utilisateurs, signature de documents, décryption d’information, gestion de périphériques spécifiques (lecteurs de cartes à puces, dispositifs biométriques, etc.)\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nPKI - Entités principales :\n\nCA : création/maintenance certificats\nRepository : stockage certificats\nRevocation : CRLs\nBackup/Recovery : clés perdues (décryption)\nCross-cert : validation autres PKIs\nTime stamping : référence temps\nClient : opérations utilisateur\n\n\n\n\n\n\n\nAvantages et Inconvénients\nAvantages :\nSécurité :\n\nEnvironnement intégré sans maillons faibles\n\nTout en un :\n\nIntégration multiples services : authentification forte, signatures, single sign-on, VPNs, B2C/B2B\nÉconomie vs solutions “au cas par cas”\n\nInteropérabilité :\n\nStandards répandus (X.509, PKCS, OCSP)\nApplications et dispositifs compatibles\nInteropérabilité inter-entreprise possible\n\nInconvénients :\nCoût de mise en place :\n\nProduits chers\nCompétences rares\n\nComplexité :\n\nMise en œuvre et gestion complexes\nAlternative : Sous-traitance service PKI\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nPKI: Principaux Avantages et Inconvénients\nAvantages\n\nSécurité : La nature intégrée d’une PKI permet de créer un environnement de sécurité sans maillons faibles.\nTout en un : Une PKI permet l’intégration et la gestion de tous les paramètres de sécurité propres à un grand nombre de services : authentification forte d’entités, signature des documents permettant la non-répudiation, single sign-on, réseaux privés virtuels (VPNs), communications sécurisées avec des clients/partenaires/fournisseurs (B2C, B2B), etc. La PKI constitue une économie notable par rapport aux solutions “au cas par cas”.\nInter-opérabilité intra et inter entreprise : Les principaux produits PKI répondent à des normes de standardisation très répandues (X.509, PKCS, OCSP, etc.). Un grand nombre d’applications et dispositifs matériels sont désormais conformes à ces standards. La compatibilité possible entre différents fournisseurs de PKIs permet également (sous quelques réserves) l’inter-opérabilité inter-entreprise.\n\nInconvénients\n\nCoût de mise en place : produits chers, compétences rares\nComplexité…mais :\n\nla sous-traitance du “service” PKI est une alternative.\n\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nPKI :\n✅ Avantages :\n\nSécurité intégrée\nTout-en-un : multi-services\nInteropérabilité (standards)\n\n❌ Inconvénients :\n\nCoût élevé\nComplexité\nSolution : sous-traitance"
  },
  {
    "objectID": "exam_notes_en.html",
    "href": "exam_notes_en.html",
    "title": "Fundamental Security Services",
    "section": "",
    "text": "Security services are the objectives aimed at protecting a system.\n\nConfidentiality: Protection against unauthorized disclosure.\nIntegrity: Protection against unauthorized modification.\nAvailability: Guarantee of access for legitimate users.\nAuthentication:\n\nEntity authentication: Certifying the identity of an actor.\nData origin authentication: Certifying the source of data.\n\nNon-repudiation: Inability to deny a transaction.\nNon-duplication: Protection against illicit copying.\nAnonymity: Preservation of identity or source.\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nConfidentiality: Protection of information from unauthorized disclosure.\nIntegrity: Protection against unauthorized modification of information.\nAvailability: Ensuring that resources are accessible to legitimate users.\nAuthentication:\n\nEntity authentication (entity authentication): Process allowing one entity to be certain of the identity of a second entity, supported by corroborating evidence (e.g., physical presence, cryptographic, biometric, etc.). The term identification is sometimes also used for this service.\nData origin authentication (data origin authentication): Process allowing one entity to be certain that a second entity is the original source of a set of data. By definition, this service also ensures the integrity of the data.\n\nNon-repudiation: Guarantees that an entity cannot deny being involved in a transaction.\nNon-duplication: Protection against illicit copying.\nAnonymity (entity or data origin): Preserves the identity of an entity, the source of information, or a transaction."
  },
  {
    "objectID": "exam_notes_en.html#threats-and-attacks-summary",
    "href": "exam_notes_en.html#threats-and-attacks-summary",
    "title": "Fundamental Security Services",
    "section": "Threats and Attacks: Summary",
    "text": "Threats and Attacks: Summary\n\n\n\n\n\n\n\n\nServices\nThreats\nAttacks\n\n\n\n\nConfidentiality\nInformation leakage\nUnauthorized eavesdropping, traffic analysis\n\n\nIntegrity\nInformation modification\nIllicit creation, alteration, or destruction\n\n\nAvailability\nDenial of service, illicit use\nViruses, repeated access attempts to disable a system\n\n\nEntity Authentication\nUnauthorized access\nPassword theft, authentication protocol flaw\n\n\nData Authentication\nInformation falsification\nSignature forgery, protocol flaw\n\n\nNon-repudiation\nDenying involvement in a transaction\nClaiming key theft or signature protocol flaw\n\n\nNon-duplication\nDuplication\nFalsification, imitation\n\n\nAnonymity\nIdentification\nTransaction analysis, unauthorized access enabling identification"
  },
  {
    "objectID": "exam_notes_en.html#protection-mechanisms",
    "href": "exam_notes_en.html#protection-mechanisms",
    "title": "Fundamental Security Services",
    "section": "Protection Mechanisms",
    "text": "Protection Mechanisms\n\n\n\n\n\n\n\n\nServices\nClassic Mechanisms\nDigital Mechanisms\n\n\n\n\nConfidentiality\nSeals, safes, padlocks\nEncryption, logical authorization\n\n\nIntegrity\nSpecial ink, holograms\nOne-way functions + encryption\n\n\nAvailability\nPhysical access control, video surveillance\nLogical access control, audit, antivirus\n\n\nEntity Authentication\nPresence, voice, ID card, biometric recognition\nSecret + authentication protocol, network address + userid, smart card + PIN\n\n\nData Authentication\nSeals, signature, fingerprint\nOne-way functions + encryption\n\n\nNon-repudiation\nSeals, signature, notary signature, registered mail\nOne-way functions + encryption + digital signature\n\n\nNon-duplication\nSpecial ink, holograms, tagging\nDigital watermarking, cryptographic locking\n\n\nAnonymity\nVoice scrambler, disguise, cash\nMixers, remailers, e-money, deep web"
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-e-mail",
    "href": "exam_notes_en.html#malware-delivered-via-e-mail",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via E-Mail",
    "text": "Malware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to trigger an action (open attachment or click a link).\nOften personalized using social engineering.\nMain consequences:\n\nMalware installation (ransomware, keyloggers, etc.).\nLoss or theft of personal data.\nSystem hijacking and malware propagation.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nMalware spread by email\nPrompting clicks or opens\nSocial engineering\nData theft, loss, hijacking\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nMalware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to incite the recipient to open an attachment or follow a link containing ads, offensive info, risky programs, etc.\nOften targeted based on victim interests (preliminary social engineering).\nConsequences:\n\nMalware installation (ransomware, keyloggers, etc.) on victim systems (computer, tablet, smartphone, smartwatch, etc.).\nData destruction.\nTheft of personal information or data.\nSystem hijacking for malicious purposes (e.g., illegal bitcoin mining).\nMalware propagation (potentially to other users)."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-e-mail-1",
    "href": "exam_notes_en.html#malware-delivered-via-e-mail-1",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via E-Mail",
    "text": "Malware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to incite the recipient to open an attachment or follow a link containing ads, offensive info, risky programs, etc.\nOften targeted based on victim interests (preliminary social engineering).\nConsequences:\n\nMalware installation (ransomware, keyloggers, etc.) on victim systems (computer, tablet, smartphone, smartwatch, etc.).\nData destruction.\nTheft of personal information or data.\nSystem hijacking for malicious purposes (e.g., illegal bitcoin mining).\nMalware propagation (potentially to other users)."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-web",
    "href": "exam_notes_en.html#malware-delivered-via-web",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via Web",
    "text": "Malware Delivered via Web\n\nMethod called drive-by download: automatic infection when visiting a website.\nSources can be:\n\nA malicious website\nA compromised legitimate site (e.g., cross-site scripting).\n\nUser caution greatly reduces this propagation method.\nImpacts are similar to email-borne infections.\nScript restriction (Java/JavaScript) reduces risk but can affect browsing.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nDrive-by download = infection without user action\nMalicious or compromised sites\nAwareness + restricted scripts = protection\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nMalware Delivered via Web\n\nOften called drive-by download, allows infecting the system (computer, tablet, smartphone, smartwatch, etc.) simply by visiting a website.\nSources may be:\n\nMalicious site containing malware\nLegitimate website previously infected (e.g., cross-site scripting). Infection may only affect certain pages.\n\nUser awareness (avoiding suspicious sites) reduces the effectiveness.\nConsequences are similar to email infections.\nRestricted script execution (Java/JavaScript) in browsers can limit infection but may constrain navigation."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-web-1",
    "href": "exam_notes_en.html#malware-delivered-via-web-1",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via Web",
    "text": "Malware Delivered via Web\n\nOften called drive-by download, allows infecting the system (computer, tablet, smartphone, smartwatch, etc.) simply by visiting a website.\nSources may be:\n\nMalicious site containing malware\nLegitimate website previously infected (e.g., cross-site scripting). Infection may only affect certain pages.\n\nUser awareness (avoiding suspicious sites) reduces the effectiveness.\nConsequences are similar to email infections.\nRestricted script execution (Java/JavaScript) in browsers can limit infection but may constrain navigation."
  },
  {
    "objectID": "exam_notes_en.html#phishing",
    "href": "exam_notes_en.html#phishing",
    "title": "Fundamental Security Services",
    "section": "Phishing",
    "text": "Phishing\n\nTechnique to collect private information through indiscriminate fishing.\nPhishing can be:\n\nGeneral (broad targeting)\nTargeted (spear phishing) for a specific person or organization.\n\nMain vector: forged email address, hard to detect.\nGoal: obtain sensitive data (credentials, passwords, personal or banking info).\nAttacks use credible or threatening pretexts to prompt victim cooperation.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nInformation theft by deception\nForged emails\nSpear phishing = targeted attack\nUrgent or threatening pretexts\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nPhishing\n\nThe word phishing comes from English “password”, “harvesting”, and “fishing”.\nShows the technique’s main goal: collect as much private info via indiscriminate fishing.\nTargeted attacks are called spear phishing (from spear fishing).\nTransmission vector: email with forged sender address requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.\nPretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored."
  },
  {
    "objectID": "exam_notes_en.html#phishing-1",
    "href": "exam_notes_en.html#phishing-1",
    "title": "Fundamental Security Services",
    "section": "Phishing",
    "text": "Phishing\n\nThe word phishing comes from English “password”, “harvesting”, and “fishing”.\nShows the technique’s main goal: collect as much private info via indiscriminate fishing.\nTargeted attacks are called spear phishing (from spear fishing).\nTransmission vector: email with forged sender address requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.\nPretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored."
  },
  {
    "objectID": "exam_notes_en.html#spam",
    "href": "exam_notes_en.html#spam",
    "title": "Fundamental Security Services",
    "section": "Spam",
    "text": "Spam\n\nUnwanted emails, often ads, or unsolicited pop-ups during web browsing.\nRepresent about 60% of global emails.\nMain consequences:\n\nResource consumption and time loss.\nSome can transmit malware.\n\nOften target short addresses or come from sold/exchanged address lists.\nAnti-spam filters incur significant costs for organizations.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nUnwanted emails/ads\nRisks: time/resource loss, malware\nTargeting: short addresses or lists\nFiltering costly for organizations\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nSpam\n\nIncludes all unwanted emails (often ads) received by people and organizations.\nAlso applies to pages/pop-up windows shown without user consent during web browsing.\nAround 60% of global emails belong to this category.\nConsequences: resource consumption and wasted time, but some spam can also transmit malware.\nOften target short email addresses or list-based addresses (sold/exchanged).\nAnti-spam filtering incurs high organizational costs."
  },
  {
    "objectID": "exam_notes_en.html#spam-1",
    "href": "exam_notes_en.html#spam-1",
    "title": "Fundamental Security Services",
    "section": "Spam",
    "text": "Spam\n\nIncludes all unwanted emails (often ads) received by people and organizations.\nAlso applies to pages/pop-up windows shown without user consent during web browsing.\nAround 60% of global emails belong to this category.\nConsequences: resource consumption and wasted time, but some spam can also transmit malware.\nOften target short email addresses or list-based addresses (sold/exchanged).\nAnti-spam filtering incurs high organizational costs."
  },
  {
    "objectID": "exam_notes_en.html#ransomware",
    "href": "exam_notes_en.html#ransomware",
    "title": "Fundamental Security Services",
    "section": "Ransomware",
    "text": "Ransomware\n\nTrojan-type malware that encrypts data to make it inaccessible.\nDemands a ransom (often in bitcoins) to recover files.\nCan remain dormant, triggered by an event or date.\nMain vector: malicious emails.\nOther effects: DoS attacks, extortion.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nData encrypted by Trojan\nRansom to restore access\nPossible programmed dormancy\nInfection via malicious emails\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nRansomware\n\nTrojan malware family.\nTypically encrypts victim’s data to make it completely inaccessible.\nThen displays a message requesting ransom payment (often in bitcoins).\nMay stay in dormant state triggered by event or date.\nInfection vectors vary, but malicious email attachments often responsible.\nVariants exist and continue to evolve.\nOther behaviors: DoS, targeted extortion, threats, etc."
  },
  {
    "objectID": "exam_notes_en.html#ransomware-1",
    "href": "exam_notes_en.html#ransomware-1",
    "title": "Fundamental Security Services",
    "section": "Ransomware",
    "text": "Ransomware\n\nTrojan malware family.\nTypically encrypts victim’s data to make it completely inaccessible.\nThen displays a message requesting ransom payment (often in bitcoins).\nMay stay in dormant state triggered by event or date.\nInfection vectors vary, but malicious email attachments often responsible.\nVariants exist and continue to evolve.\nOther behaviors: DoS, targeted extortion, threats, etc."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-internet-of-things-iot-devices",
    "href": "exam_notes_en.html#attacks-on-internet-of-things-iot-devices",
    "title": "Fundamental Security Services",
    "section": "Attacks on Internet of Things (IoT) Devices",
    "text": "Attacks on Internet of Things (IoT) Devices\n\nTarget connected objects (cameras, TVs, sensors, alarms, etc.).\nDevices are easy to compromise due to:\n\nKnown vulnerabilities\nDefault passwords\nUser unawareness\n\nRemote control enables:\n\nEntry point to the network\nDevice abuse for illicit activities (DDoS, hacking, mining)\n\nA precise inventory of connected devices is essential.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nTargets connected objects\nWeak security (vulnerabilities, default passwords)\nRisk of network access and abuse\nIoT inventory needed\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAttacks on IoT Devices\n\nTarget connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).\nOften easier to hack than traditional systems due to:\n\nMany vulnerabilities known to attackers\nDefault passwords\nUser negligence\n\nRemote takeover allows:\n\nEntry point to home/corporate network\nDevice use for illicit activities (hacking, DDoS, bitcoin mining)\n\nMaintaining a detailed directory of all connected devices is necessary."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-iot-devices",
    "href": "exam_notes_en.html#attacks-on-iot-devices",
    "title": "Fundamental Security Services",
    "section": "Attacks on IoT Devices",
    "text": "Attacks on IoT Devices\n\nTarget connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).\nOften easier to hack than traditional systems due to:\n\nMany vulnerabilities known to attackers\nDefault passwords\nUser negligence\n\nRemote takeover allows:\n\nEntry point to home/corporate network\nDevice use for illicit activities (hacking, DDoS, bitcoin mining)\n\nMaintaining a detailed directory of all connected devices is necessary."
  },
  {
    "objectID": "exam_notes_en.html#information-spoofing-and-website-defacement",
    "href": "exam_notes_en.html#information-spoofing-and-website-defacement",
    "title": "Fundamental Security Services",
    "section": "Information Spoofing and Website Defacement",
    "text": "Information Spoofing and Website Defacement\n\nAttacks aiming to alter information on websites and social media.\nImpact: compromised reputation and economic damage.\nWebsites: secure host system, restrictive configuration, regular audits.\nSocial media: strong passwords, multi-factor authentication, session closure, cookie deletion.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAltered info on websites and social media\nRisks: reputation, economic losses\nWebsites: security + audits\nSocial media: strong passwords, MFA, closed sessions, cookies cleared\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nInformation Spoofing and Website Defacement\n\nTarget integrity of published info on websites and social media.\nAffects reputation and can cause economic damage.\nWebsites: secure host system, as restrictive configuration as possible, recurring security audits recommended.\nSocial media: depends on authentication process:\n\nAvoid simple passwords\nPrefer strong, possibly multi-factor authentication\nClose sessions properly\nClear cookies"
  },
  {
    "objectID": "exam_notes_en.html#information-spoofing-and-website-defacement-1",
    "href": "exam_notes_en.html#information-spoofing-and-website-defacement-1",
    "title": "Fundamental Security Services",
    "section": "Information Spoofing and Website Defacement",
    "text": "Information Spoofing and Website Defacement\n\nTarget integrity of published info on websites and social media.\nAffects reputation and can cause economic damage.\nWebsites: secure host system, as restrictive configuration as possible, recurring security audits recommended.\nSocial media: depends on authentication process:\n\nAvoid simple passwords\nPrefer strong, possibly multi-factor authentication\nClose sessions properly\nClear cookies"
  },
  {
    "objectID": "exam_notes_en.html#denial-of-service-dos-ddos-attacks",
    "href": "exam_notes_en.html#denial-of-service-dos-ddos-attacks",
    "title": "Fundamental Security Services",
    "section": "Denial of Service (DoS / DDoS) Attacks",
    "text": "Denial of Service (DoS / DDoS) Attacks\n\nAim to make IT systems inaccessible, especially for organizations.\nDDoS: distributed attack using thousands of devices, generating massive traffic.\nClassic protections (firewalls, IDS/IPS sensors) often insufficient.\nConsequences:\n\nAffected reputation\nFinancial losses (sometimes ransom)\nHigh risk for critical infrastructure (hospitals, power plants, Internet backbone)\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nDDoS = inaccessible systems via massive attacks\nLimited protections\nRisks: reputation, finances, critical infrastructures\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nDenial of Service (DoS / DDoS) Attacks\n\nAim to render IT systems inaccessible, mainly targeting private or governmental organizations.\nDDoS (Distributed Denial of Service): multiple devices (often tens of thousands) simultaneously target victim system(s).\nTraffic can reach several hundred Gbps.\nTraditional protection (firewalls, intrusion detection/prevention sensors) has limited effectiveness.\nService unavailability can cause:\n\nReputational issues\nSignificant financial losses (ransom demands)\nHigh security risks (even physical) for critical infrastructures (hospitals, power plants, Internet backbone)."
  },
  {
    "objectID": "exam_notes_en.html#denial-of-service-dos-ddos-attacks-1",
    "href": "exam_notes_en.html#denial-of-service-dos-ddos-attacks-1",
    "title": "Fundamental Security Services",
    "section": "Denial of Service (DoS / DDoS) Attacks",
    "text": "Denial of Service (DoS / DDoS) Attacks\n\nAim to render IT systems inaccessible, mainly targeting private or governmental organizations.\nDDoS (Distributed Denial of Service): multiple devices (often tens of thousands) simultaneously target victim system(s).\nTraffic can reach several hundred Gbps.\nTraditional protection (firewalls, intrusion detection/prevention sensors) has limited effectiveness.\nService unavailability can cause:\n\nReputational issues\nSignificant financial losses (ransom demands)\nHigh security risks (even physical) for critical infrastructures (hospitals, power plants, Internet backbone)."
  },
  {
    "objectID": "exam_notes_en.html#cryptographic-hash-functions",
    "href": "exam_notes_en.html#cryptographic-hash-functions",
    "title": "Fundamental Security Services",
    "section": "Cryptographic Hash Functions",
    "text": "Cryptographic Hash Functions\n\nFunctions easy to compute in one direction but virtually impossible to reverse.\nAny modification of the source document radically changes the digest (avalanche effect).\nKey properties:\n\nOne-way: impossible to retrieve the input from the hash.\nCollision-free: impossible to find two inputs with the same hash.\n\nDigest size: 160 to 512 bits.\nAlgorithms (very performant): SHA-1, SHA-256, SHA-3.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nOne-way + collision-free.\nSize: 160-512 bits.\nAlgos: SHA-1/256/3.\nUsage: integrity, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nFunctions easy to compute in one direction but virtually impossible to compute in the reverse direction.\nAny modification (even insignificant) of the source document results in a fundamentally different digest.\nIt is virtually impossible to retrieve the source document using only the digest (one-way).\nIt is virtually impossible to find a second source document producing the same digest (collision-free).\nUsual digest length: 160 to 512 bits.\nOne-way algorithms are very performant.\nExamples: SHA-1, SHA-256, SHA-3, etc."
  },
  {
    "objectID": "exam_notes_en.html#pseudo-random-generators",
    "href": "exam_notes_en.html#pseudo-random-generators",
    "title": "Fundamental Security Services",
    "section": "(Pseudo) Random Generators",
    "text": "(Pseudo) Random Generators\n\nCharacteristics\n\nrandom\nunpredictable\nnon-reproducible\n\nCritical for security (keys, IV, secrets).\nTypes:\n\nTrue random: based on physical phenomena (radioactivity, quantum).\nPseudo-random: deterministic (based on a seed: initial random sequence).\n\nRisk: “Pseudo-security” if the seed is predictable (Pitkin quote).\nApplications: session keys, IV (DES-CBC), signatures (ElGamal).\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nTrue random: physical (quantum).\nPseudo-random: deterministic (seed).\nRisk: predictable seed = vulnerability.\nUses: keys, IV, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nRandom number generation is a very important process that can compromise the security of many encryption systems.\nApplications: session key generation, initialization vectors (DES - CBC mode), secrets for signatures (ElGamal), etc.\nA random generator is a device capable of generating numbers in a random, unpredictable and non-reproducible way. (e.g. based on physical phenomena: radioactive or quantum source).\nPseudo-random generators are deterministic processes developed from an initial random sequence (seed) (e.g. user keystrokes, disk access).\nQuote: R. Pitkin in [Kau95]: “The use of pseudo-random processes to generate secret quantities can result in pseudo-security”"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-cryptography",
    "href": "exam_notes_en.html#symmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Symmetric Cryptography",
    "text": "Symmetric Cryptography\n\nHistory: Used since Julius Caesar (1st century BC).\nPrinciple: A single key for encryption/decryption.\nScheme: Plaintext → Encryption (Key) → Ciphertext → Decryption (Key) → Plaintext.\nCharacteristics:\n\nAlgorithms: AES, DES, IDEA, RC4.\nServices: Confidentiality, Authentication, Integrity.\nLimit: No signatures (shared key).\nProblem: Secure key exchange required.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\n1 key to encrypt/decrypt.\nFast (AES, DES).\nProblem: key exchange.\nUses: personal documents, closed groups.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nAlso called conventional cryptography or secret key cryptography (1st century BC, Julius Caesar).\nIdea: Based on a single secret key, perform a transformation capable of respectively making information unreadable and restoring it.\nScheme: Plaintext \\(\\to\\) Encryption (Key) \\(\\to\\) Ciphertext \\(\\to\\) Decryption (Key) \\(\\to\\) Plaintext.\nCharacteristics:\n\nAlgorithms: AES, DES, IDEA, RC4, RC5, etc. (some are free and openly available)\nServices: Confidentiality, Authentication, Integrity.\nNo direct support for digital signatures (because key known by both).\nRequires a confidential channel to exchange the key.\nIdeal for protection of personal documents or closed groups."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography",
    "href": "exam_notes_en.html#asymmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography",
    "text": "Asymmetric Cryptography\n\nAlso called public cryptography (1976, Diffie & Hellman).\nPrinciple\n\nKey pair (public/private) for encryption and signatures.\n\nTwo main uses:\n\nConfidentiality:\n\nEncryption: recipient’s public key\nDecryption: recipient’s private key\n\nDigital signature:\n\nSignature: sender’s private key\nVerification: sender’s public key\nOptimization: Generally sign the hash of the document\nFundamental properties:\n\nIntegrity: Any modification invalidates the signature\nNon-collision: Impossible to have 2 documents with the same signature\nNon-repudiation: Only the holder of the private key can sign\n\n\n\nTechnical aspects:\n\nAlgorithms: RSA, ElGamal\nServices: Integrity, Authentication, Non-Repudiation\nPerformance: much slower than symmetric (100x slower)\nAdvantage: No need for a confidential channel for key exchange\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\n2 keys: public (encrypt/verify) + private (decrypt/sign)\n2 uses:\n\nConfidentiality: encrypt for a recipient\nSignature: prove authenticity\n\nSignatures:\n\nIntegrity + non-repudiation\n\nAlgorithms: RSA/ElGamal\nAdvantage: No need for secure channel to exchange keys\nDisadvantage: Slow\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography\n\nAlso called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).\nIdea: Use two different keys - one secret and one public - respectively for encryption and decryption operations.\nEach user has a keyring.\n\nConfidentiality: * Sender encrypts with the recipient’s public key. * Recipient decrypts with their private key. * Only the recipient’s key is used!\nDigital Signature: * Sender signs with their private key. * Recipient verifies with the sender’s public key. * Only the sender’s key is used! * Note: Generally sign the digest of the document (hash) for performance reasons.\nSignature characteristics: * The signature changes if the document changes, while the private key remains the same. * If the document or signature is modified, verification fails (integrity guaranteed). * It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function without collisions). * Only the holder of the private key can generate a signature verifiable using the corresponding public key (non-repudiation). * Algorithms: RSA, ElGamal. * Services: Integrity, Authentication, Non-Repudiation. * Slowness: Up to 50 times slower than symmetric cryptography. * Advantage: No need for a confidential channel to exchange keys (unlike symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography",
    "text": "Asymmetric Cryptography\n\nAlso called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).\nIdea: Use two different keys - one secret and one public - respectively for encryption and decryption operations.\nEach user has a keyring.\n\nConfidentiality: * Sender encrypts with the recipient’s public key. * Recipient decrypts with their private key. * Only the recipient’s key is used!\nDigital Signature: * Sender signs with their private key. * Recipient verifies with the sender’s public key. * Only the sender’s key is used! * Note: Generally sign the digest of the document (hash) for performance reasons.\nSignature characteristics: * The signature changes if the document changes, while the private key remains the same. * If the document or signature is modified, verification fails (integrity guaranteed). * It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function without collisions). * Only the holder of the private key can generate a signature verifiable using the corresponding public key (non-repudiation). * Algorithms: RSA, ElGamal. * Services: Integrity, Authentication, Non-Repudiation. * Slowness: Up to 50 times slower than symmetric cryptography. * Advantage: No need for a confidential channel to exchange keys (unlike symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-symmetric-cryptography-hybrid",
    "href": "exam_notes_en.html#asymmetric-symmetric-cryptography-hybrid",
    "title": "Fundamental Security Services",
    "section": "Asymmetric + Symmetric Cryptography (Hybrid)",
    "text": "Asymmetric + Symmetric Cryptography (Hybrid)\n\nPrinciple: Use asymmetric to exchange a symmetric key (session key).\nSteps:\n\nA generates a random symmetric key \\(K_s\\).\nA encrypts \\(K_s\\) with B’s public key.\nA and B then communicate using \\(K_s\\) (symmetric).\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAsymmetric: exchange of symmetric key.\nSymmetric: data encryption.\nAdvantage: combines security + performance.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nIdea: Use public cryptography only to exchange symmetric keys (Session keys).\nA generates a random key \\(K_s\\) and transmits it to B by encrypting it with B’s public key.\nA & B then communicate using \\(K_s\\) (symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-operation-rsa",
    "href": "exam_notes_en.html#asymmetric-cryptography-operation-rsa",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Operation (RSA)",
    "text": "Asymmetric Cryptography: Operation (RSA)\n\nKey Construction\n\nChoice of prime numbers:\n\n\\(p\\) and \\(q\\): two large prime numbers (&gt; 1024 bits)\n\\(n = pq\\): RSA modulus (size = 2048+ bits)\n\nCalculation of Euler’s totient function:\n\n\\(\\phi(n) = (p-1)(q-1)\\)\nProperty: For any \\(a\\) coprime with \\(n\\), \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\n\nSelection of exponents:\n\n\\(e\\): integer coprime with \\(\\phi(n)\\) (public exponent)\n\\(d\\): modular inverse of \\(e\\) (private exponent), such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\n\n\n\nEncryption/decryption process\n\nPublic key: \\((n,e)\\)\nPrivate key: \\((d)\\)\nEncryption: \\(C = P^e \\pmod{n}\\)\nDecryption: \\(P = C^d \\pmod{n}\\)\n\n\n\nMathematical proof\n\nFundamental congruence:\n\n\\(ed = 1 + k\\phi(n)\\) (by definition of \\(d\\))\n\nApplication of Euler’s theorem:\n\n\\(P^{\\phi(n)} \\equiv 1 \\pmod{n}\\) (if \\(P\\) coprime with \\(n\\))\n\nDemonstration:\n\\[\\begin{align*}\n(P^e)^d &\\equiv P^{ed} \\pmod{n} \\\\\n&\\equiv P^{1 + k\\phi(n)} \\pmod{n} \\\\\n&\\equiv P \\cdot (P^{\\phi(n)})^k \\pmod{n} \\\\\n&\\equiv P \\cdot 1^k \\pmod{n} \\\\\n&\\equiv P \\pmod{n}\n\\end{align*}\\]\n\n\n\nSystem security\n\nHard problem: Factorization of \\(n\\) into \\(p\\) and \\(q\\)\nRecommended size:\n\n\\(n\\): 2048 bits (minimum for current security)\n\\(p\\) and \\(q\\): 1024+ bits each\n\nKnown vulnerabilities:\n\nSide-channel attacks (timing, power analysis)\nInappropriate parameter choices (\\(e\\) too small, \\(p\\) and \\(q\\) too close)\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nKeys:\n\nPublic: \\((n,e)\\) where \\(n = pq\\)\nPrivate: \\((d)\\) with \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\nOperations:\n\nEncryption: \\(P^e \\mod n\\)\nDecryption: \\(C^d \\mod n\\)\n\nSecurity: Factorization of \\(n\\) difficult\nSize: 2048+ bits for \\(n\\)\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography: Operation (RSA)\n\nLet \\(n := pq\\) with \\(p\\) and \\(q\\) two large prime numbers (&gt; 1024 bits).\nLet \\(\\phi(n) = (p-1)(q-1)\\).\nLet \\(e\\) and \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nBy definition of congruences: \\(ed = 1 + k\\phi(n)\\)\nEuler’s theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption: \\(C = P^e \\pmod n\\). Public key: \\((n,e)\\).\nDecryption: \\(P = C^d \\pmod n\\). Private key: \\((d)\\).\nProof: \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-operation-rsa-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-operation-rsa-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Operation (RSA)",
    "text": "Asymmetric Cryptography: Operation (RSA)\n\nLet \\(n := pq\\) with \\(p\\) and \\(q\\) two large prime numbers (&gt; 1024 bits).\nLet \\(\\phi(n) = (p-1)(q-1)\\).\nLet \\(e\\) and \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nBy definition of congruences: \\(ed = 1 + k\\phi(n)\\)\nEuler’s theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption: \\(C = P^e \\pmod n\\). Public key: \\((n,e)\\).\nDecryption: \\(P = C^d \\pmod n\\). Private key: \\((d)\\).\nProof: \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-conclusions",
    "href": "exam_notes_en.html#asymmetric-cryptography-conclusions",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Conclusions",
    "text": "Asymmetric Cryptography: Conclusions\n\nDominant algorithms: RSA (most used), Rabin, ElGamal\nComplete services:\n\nConfidentiality\nAuthentication\nIntegrity\nDigital signature & Non-repudiation\nNon-duplication\n\nPerformance:\n\n50x slower than symmetric\nOptimal solution: Combination of asymmetric (key exchange) + symmetric (encryption)\n\nKey management:\n\nAdvantage: Public key exchange without confidential channel\nRisk: Need to verify authenticity of public keys\n\nAuthenticated acquisition channel or\nCertification by trusted third party\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAlgos: RSA (dominant), Rabin, ElGamal\nServices: Confidentiality + Authentication + Integrity + Signatures\nSlowness: 50x vs symmetric → hybrid recommended\nKeys: Simple public exchange but authentication crucial\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography: Conclusions\n\nThere are a few asymmetric encryption systems (Rabin, ElGamal, etc.) but the most used is RSA.\nSupported services: Confidentiality, Authentication, Integrity, Digital Signature & Non-Repudiation, (Non-Duplication).\nOperations related to asymmetric cryptography are up to 50 times (!) slower than those of symmetric cryptography. A combination of the two methods is often desirable.\nKey distribution is simplified by the fact that only public keys need to be exchanged between participants (no need for an alternative confidential channel) but…\n… it is necessary to verify that the public key actually belongs to the recipient:\n\nEither the acquisition channel of the public key is protected against any modification (authenticated)\nOr the key is certified accurate by a third party"
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-conclusions-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-conclusions-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Conclusions",
    "text": "Asymmetric Cryptography: Conclusions\n\nThere are a few asymmetric encryption systems (Rabin, ElGamal, etc.) but the most used is RSA.\nSupported services: Confidentiality, Authentication, Integrity, Digital Signature & Non-Repudiation, (Non-Duplication).\nOperations related to asymmetric cryptography are up to 50 times (!) slower than those of symmetric cryptography. A combination of the two methods is often desirable.\nKey distribution is simplified by the fact that only public keys need to be exchanged between participants (no need for an alternative confidential channel) but…\n… it is necessary to verify that the public key actually belongs to the recipient:\n\nEither the acquisition channel of the public key is protected against any modification (authenticated)\nOr the key is certified accurate by a third party"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs-asymmetric-comparison",
    "href": "exam_notes_en.html#symmetric-vs-asymmetric-comparison",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs Asymmetric Comparison",
    "text": "Symmetric vs Asymmetric Comparison\n\nComparative advantages\n\nSymmetric:\n\nPerformance: 100x faster\nImplementation: Easy in hardware\nKeys: Short (128 bits = 16 memorable characters)\n\nAsymmetric:\n\nKey exchange: Authenticated channel sufficient (no need for confidentiality)\nManagement: 1 key pair for n correspondents (vs n keys in symmetric)\n\n\n\n\nCommon issues\n\nWeak link: Key management by users\nSecurity basis: Empirical rather than theoretical\nLegal constraints: Usage and export restrictions\n\n\n\nUsage recommendations\n\n\n\n\n\n\n\n\nUse case\nRecommended solution\nJustification\n\n\n\n\nPersonal documents\nSymmetric\nSpeed + memorable keys\n\n\nGroups of close users\nSymmetric\nSpeed + easy confidential exchange\n\n\nDistant/unknown users\nAsymmetric\nNo need for confidential channel\n\n\nRemote transactions\nHybrid (Asymmetric + Symmetric)\nAsymmetric for key exchange, symmetric for data\n\n\nSoftware protection (distribution)\nHybrid\nUnique symmetric key per version, encrypted with asymmetric\n\n\nNetwork segments\nSymmetric\nSpeed + controlled environment (easy key exchange between administrators)\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nSymmetric:\n✅ Fast (100x)\n✅ Short keys (128 bits)\n❌ Confidential key exchange required\nAsymmetric:\n✅ Simplified key exchange\n✅ 1 key pair for n correspondents\n❌ Slow (50x)\n❌ Long keys (1024+ bits)\nHybrid: Best of both worlds Common problems: Key management, empirical basis, legal restrictions\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nSymmetric vs. Asymmetric Cryptography\n\nThere are hundreds of symmetric and asymmetric algorithms capable of providing a sufficient level of confidentiality.\nSymmetric solutions offer the following advantages:\n\nSpeed (up to 100 times faster than asymmetric solutions)\nEase of hardware implementation\nReduced key length: 128 bits (= 16 characters ⇒ memorable!) instead of 1024 bits for asymmetric equivalents.\n\nAsymmetric solutions have as main arguments:\n\nSimplified key exchange: keys must be exchanged through an authenticated but non-confidential channel\nSimplified key management: a single public/private key pair is sufficient for a user to receive confidential messages from n users (instead of n different keys in the symmetric case).\n\nProblems common to both techniques:\n\nKey management by the user remains the weakest link\nSecurity (normally) based on empirical arguments rather than theoretical ones\nLegal restrictions on usage and export\n\n\n\n\nSymmetric vs. Asymmetric Cryptography (II)\n\n\n\n\n\n\n\n\nActivity\nRecommendation\nRemarks\n\n\n\n\nProtection of personal documents\nSymmetric crypto\nSpeed, easily memorable keys\n\n\nProtection of documents in a group of close users\nSymmetric crypto\nSpeed, ease of exchanging confidential keys\n\n\nEstablishment of confidential channels between distant users (unknown)\nAsymmetric crypto\nNo need to have a confidential channel: authenticity suffices\n\n\nTransactions between two distant users, Software protection (multicast distribution)\nAsymmetric crypto for symmetric key protection + Symmetric crypto for data protection\nSpeed, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public\n\n\nProtection of network segments\nSymmetric crypto\nSpeed, Stable environment → easy confidential key exchange between sysadmins"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography",
    "href": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs. Asymmetric Cryptography",
    "text": "Symmetric vs. Asymmetric Cryptography\n\nThere are hundreds of symmetric and asymmetric algorithms capable of providing a sufficient level of confidentiality.\nSymmetric solutions offer the following advantages:\n\nSpeed (up to 100 times faster than asymmetric solutions)\nEase of hardware implementation\nReduced key length: 128 bits (= 16 characters ⇒ memorable!) instead of 1024 bits for asymmetric equivalents.\n\nAsymmetric solutions have as main arguments:\n\nSimplified key exchange: keys must be exchanged through an authenticated but non-confidential channel\nSimplified key management: a single public/private key pair is sufficient for a user to receive confidential messages from n users (instead of n different keys in the symmetric case).\n\nProblems common to both techniques:\n\nKey management by the user remains the weakest link\nSecurity (normally) based on empirical arguments rather than theoretical ones\nLegal restrictions on usage and export"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography-ii",
    "href": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography-ii",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs. Asymmetric Cryptography (II)",
    "text": "Symmetric vs. Asymmetric Cryptography (II)\n\n\n\n\n\n\n\n\nActivity\nRecommendation\nRemarks\n\n\n\n\nProtection of personal documents\nSymmetric crypto\nSpeed, easily memorable keys\n\n\nProtection of documents in a group of close users\nSymmetric crypto\nSpeed, ease of exchanging confidential keys\n\n\nEstablishment of confidential channels between distant users (unknown)\nAsymmetric crypto\nNo need to have a confidential channel: authenticity suffices\n\n\nTransactions between two distant users, Software protection (multicast distribution)\nAsymmetric crypto for symmetric key protection + Symmetric crypto for data protection\nSpeed, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public\n\n\nProtection of network segments\nSymmetric crypto\nSpeed, Stable environment → easy confidential key exchange between sysadmins"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-attack-lifecycle",
    "href": "exam_notes_en.html#ransomware-attack-lifecycle",
    "title": "Fundamental Security Services",
    "section": "Ransomware Attack Lifecycle",
    "text": "Ransomware Attack Lifecycle\n\nPrevention and Response\n\n\n\n\n\n\n\nPhase\nMeasures\n\n\n\n\nPrevention\n- Regular patching- Detection solutions (Firewalls, WAFs, IDS/IPS)- Anti-malware scans (emails, files)\n\n\nProtection\n- Offline backups (essential!)- Strict security policies- User training\n\n\nResponse\n- Do not pay (official recommendation)- Forensic analysis- Restoration from backups\n\n\n\n\n\nTechnical Dissection\n\nInfection:\n\nVectors: Phishing, exploits, vulnerable RDP\nPropagation: Lateral (network) or vertical (system)\n\nExecution:\n\nEncryption of targeted files\nDeletion of shadow copies\nPersistence (registry, scheduled tasks)\n\nExtortion:\n\nDisplay of ransom demand\nPayment in cryptocurrencies (Bitcoin, Monero)\nPayment deadlines with penalties\n\nObfuscation:\n\nCode obfuscation\nCommunication via TOR/Deep Web\nLog erasure\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nAttack cycle:\n\nInfection (phishing/exploits)\nExecution (encryption + persistence)\nExtortion (ransom in crypto)\nObfuscation (TOR + trace erasure)\n\nCountermeasures:\n✅ Offline backups\n✅ Patching + detection\n✅ Training\n❌ Do not pay"
  },
  {
    "objectID": "exam_notes_en.html#cryptolocker-technical-analysis",
    "href": "exam_notes_en.html#cryptolocker-technical-analysis",
    "title": "Fundamental Security Services",
    "section": "Cryptolocker: Technical Analysis",
    "text": "Cryptolocker: Technical Analysis\n\nAttack Scheme\n\n\n\n\n\ngraph TD\n    A[Initial infection] --&gt; B[File encryption]\n    B --&gt; C[Private key storage on C2 servers]\n    C --&gt; D[Ransom demand]\n    D --&gt; E{Payment ?}\n    E --&gt;|Yes| F[Decryption key sent via TOR]\n    E --&gt;|No| G[Permanent data loss]\n\n\n\n\n\n\n\n\nPreferred Targets\n\nCritical extensions (extract):\n\nDocuments: .docx, .xlsx, .pdf, .pptx\nDatabases: .mdb, .sql, .sqlite\nMedia: .jpg, .png, .mp4, .avi\nDevelopment: .java, .cpp, .py, .php\nFinancial: .qbw, .qbb, .wallet\n\nBehavior:\n\nSelective encryption (recent/modified files)\nDouble extortion: Encryption + threat of leakage\nRaaS (Ransomware-as-a-Service): Economic model\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nMechanism: - Private key stored on C2 servers - Payment → key via TOR - Targets: 100+ extensions (docs, DB, media)\nRecent evolutions: - Double extortion (encryption + leakage) - RaaS (ransomware rental)\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nRansomware: Complete View\n(Source: 2017 State of Cybersecurity, F-Secure Inc.)\n\n\nRansomware: Complete View\n\nPrevention, Remediation and Response\n\nPatching\nActive and passive detection (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)\nOffline backups !\nSecurity Policy - Rules for proper email usage\nTraining !\nTo pay or not to pay…\n\n\n\nTechnical Dissection of the Attack\n\nInfection and propagation\nExecution\nPayment (Crypto-currencies / Bitcoin)\nObfuscation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nGeneric Scheme of a Cryptolocker Ransomware\n\nDecryption private keys are stored on the attacker’s servers\nThey are sent to the victim after bitcoin payment\nThe trace is shredded using TOR networks\n\n\n\n\nRansomware Cryptolocker: Targets\nTargeted file extensions: .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource: Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-complete-view",
    "href": "exam_notes_en.html#ransomware-complete-view",
    "title": "Fundamental Security Services",
    "section": "Ransomware: Complete View",
    "text": "Ransomware: Complete View\n(Source: 2017 State of Cybersecurity, F-Secure Inc.)"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-complete-view-1",
    "href": "exam_notes_en.html#ransomware-complete-view-1",
    "title": "Fundamental Security Services",
    "section": "Ransomware: Complete View",
    "text": "Ransomware: Complete View\n\nPrevention, Remediation and Response\n\nPatching\nActive and passive detection (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)\nOffline backups !\nSecurity Policy - Rules for proper email usage\nTraining !\nTo pay or not to pay…\n\n\n\nTechnical Dissection of the Attack\n\nInfection and propagation\nExecution\nPayment (Crypto-currencies / Bitcoin)\nObfuscation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nGeneric Scheme of a Cryptolocker Ransomware\n\nDecryption private keys are stored on the attacker’s servers\nThey are sent to the victim after bitcoin payment\nThe trace is shredded using TOR networks"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-cryptolocker-targets",
    "href": "exam_notes_en.html#ransomware-cryptolocker-targets",
    "title": "Fundamental Security Services",
    "section": "Ransomware Cryptolocker: Targets",
    "text": "Ransomware Cryptolocker: Targets\nTargeted file extensions: .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource: Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_en.html#kerckhoffs-principle",
    "href": "exam_notes_en.html#kerckhoffs-principle",
    "title": "Fundamental Security Services",
    "section": "Kerckhoffs’ Principle",
    "text": "Kerckhoffs’ Principle\n\nFundamental principle: security relies solely on the key, not on the secrecy of the algorithm.\nThe system must remain secure even if the algorithm is public.\nThe key must be easily modifiable and the system simple to use.\nExplicit rejection of security through obscurity.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nSecurity based on the key\nPublic algorithm\nNo security through obscurity\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nKerckhoffs’ Principle\nAuguste Kerckhoffs published in 1883 two articles defining six principles for military ciphers:\n\nThe system must be practically, if not mathematically, undecipherable.\nIt must not require confidentiality and remain secure even if it falls into enemy hands.\nThe key must be able to be memorized, transmitted and modified easily, without written notes.\nThe system must be compatible with telegraphic communications.\nIt must be portable and usable by a single person.\nIt must be simple to use, without complex procedures or excessive constraints.\n\nKerckhoffs stated as early as the 19th century that security must be mathematically demonstrable and that there is no security through obscurity."
  },
  {
    "objectID": "exam_notes_en.html#kerckhoffs-principle-1",
    "href": "exam_notes_en.html#kerckhoffs-principle-1",
    "title": "Fundamental Security Services",
    "section": "Kerckhoffs’ Principle",
    "text": "Kerckhoffs’ Principle\nAuguste Kerckhoffs published in 1883 two articles defining six principles for military ciphers:\n\nThe system must be practically, if not mathematically, undecipherable.\nIt must not require confidentiality and remain secure even if it falls into enemy hands.\nThe key must be able to be memorized, transmitted and modified easily, without written notes.\nThe system must be compatible with telegraphic communications.\nIt must be portable and usable by a single person.\nIt must be simple to use, without complex procedures or excessive constraints.\n\nKerckhoffs stated as early as the 19th century that security must be mathematically demonstrable and that there is no security through obscurity."
  },
  {
    "objectID": "exam_notes_en.html#classification-of-encryption-systems",
    "href": "exam_notes_en.html#classification-of-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "Classification of Encryption Systems",
    "text": "Classification of Encryption Systems\n\nUnconditional Security\n(unconditional security / perfect secrecy)\n\nSecurity independent of computing power.\nCiphertext provides no information about the plaintext.\nConditions: key ≥ message, never reused.\nMostly theoretical use.\nExample: one-time pad.\n\n\n\nAs hard as / equivalent / provable security\n\nCryptanalysis as difficult as a hard mathematical problem.\nRSA and Rabin proven equivalent to factorization.\n\nDemonstrated by reduction (reduction proof).\n\nCentral but controversial concept.\n\n\n\nComputational Security\n(computational security / practical security)\n\nSecurity based on unrealistic cost of attacks.\nMost used category in practice.\nExamples: AES, DES, IDEA, RC4.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nUnconditional: perfect, theoretical (one-time pad).\nProvable security: equivalence to hard mathematical problem.\nComputational: secure in practice.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nUnconditional security (unconditional security also called perfect secrecy):\n\nThe security of the encryption system is not compromised by the computing power intended for cryptanalysis.\nThis category relies on information theory published by Shannon in 1949.\nMore precisely, an encryption system is unconditionally secure if the probability of encountering a plaintext x after observing the corresponding ciphertext y is identical to the a priori probability of encountering plaintext x.\nIn other words, having plaintext/ciphertext pairs (x,y) provides no help for cryptanalysis.\nA necessary condition for a system to be unconditionally secure is that the key be at least the same size as the message and, above all, that it not be reused to encrypt different messages.\nThis condition makes these systems poorly suited to usual cryptographic needs and reduces their domain of interest to a theoretical framework.\nThe classic example is the one-time pad invented in 1917 by J. Mauborgne and G. Vernam.\nTheoretical foundations of unconditionally secure systems + other examples in [Sti06].\n\nAs hard as / equivalent / provable security\n\nWhen it can be proven that cryptanalyzing the algorithm is as difficult as solving a reputedly hard mathematical problem.\nFor example factorization of large numbers, calculation of square roots modulo a composite, calculation of discrete logarithms in a finite group, etc.\nThe Rabin and RSA algorithms (generic case^1) are “proven” equivalent to factorization.\nSuch a proof is called a “reduction” (reduction proof).\nThe notion of provable security is at the origin of an important controversy in the cryptographic world.\n\nComputational security (computational security also called practical security)\n\nAn encryption system is in this category if the computational effort needed to “break” it using the best possible techniques is beyond (with a reasonable margin) the computing resources of a hypothetical adversary.\nThe vast majority of symmetric encryption systems (AES, DES, IDEA, RC4, etc.) are in this category."
  },
  {
    "objectID": "exam_notes_en.html#entropy",
    "href": "exam_notes_en.html#entropy",
    "title": "Fundamental Security Services",
    "section": "Entropy",
    "text": "Entropy\n\nEntropy (Shannon, 1948) measures the effective amount of information contained in a message.\nConditional entropy measures the uncertainty that remains about the plaintext after observing the ciphertext.\n\n\nProperties\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0\\) → no uncertainty\n\\(H(X) = \\log n\\) → all outcomes equally probable\n\n\n\nInterpretation\n\nApproximates the number of bits needed to encode \\(X\\).\nRedundancy = difference between effective encoding and entropy.\n\n\n\nConditional Entropy\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\)\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\nMeasures the remaining uncertainty about the plaintext after observing the ciphertext.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nEntropy: amount of information in a message.\nConditional entropy: uncertainty about plaintext after ciphertext.\nRedundancy: difference between effective encoding and entropy.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nAn essential definition in cryptography is the effective amount of information contained in a message.\nFor example, days of the week (Monday, …, Sunday) can intuitively be encoded as character strings of length (\\(\\le \\text{len}(\\text{``Wednesday''})\\)), i.e., \\((8 \\times 8 = 64)\\) bits. However, the effective amount of information of the variable day of the week can be optimally encoded on 3 bits (since \\((2^3 = 8)\\) is sufficient to represent the 7 possible variations).\nEntropy (Shannon, 1948) is the mathematical formalization of this definition.\n\n\nFormal Definition\nLet \\(X\\) be a random variable with a finite set of possible values \\({x_1, x_2, \\dots, x_n}\\), such that \\(P(X=x_i) = p_i\\), with \\(0 \\le p_i \\le 1\\) and \\(\\sum p_i = 1\\). The entropy of \\(X\\), denoted \\(H(X)\\), is defined by\n\\(H(X) = - \\sum_{i=1}^{n} p_i \\log p_i = \\sum_{i=1}^{n} p_i \\log \\left(\\frac{1}{p_i}\\right)\\)\nBy convention: \\(p_i \\log p_i = 0\\) if \\(p_i = 0\\). All logarithms are in base 2.\n\n\nInterpretation\n\nApproximation of the number of bits needed to encode the elements of \\(X\\).\nRedundancy is the difference between the effective encoding and entropy.\n\n\n\nProperties\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0 \\iff \\exists i : p_i = 1, p_j = 0 \\ \\forall j \\ne i\\)\n\\(H(X) = \\log n \\iff p_i = 1/n \\ \\forall i\\)\n\n\n\nConditional Entropy\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\),\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\n\nMeasures the uncertainty about \\(X\\) (plaintext) after having observed \\(Y\\) (ciphertext)."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-encryption-systems",
    "href": "exam_notes_en.html#attacks-on-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "Attacks on Encryption Systems",
    "text": "Attacks on Encryption Systems\n\nCiphertext-only: Adversary has only the ciphertext.\nKnown-plaintext: Adversary has plaintext/ciphertext pairs.\nChosen-plaintext: Adversary chooses the plaintext and see the ciphertext (and tries to find the plaintext for other messages).\nAdaptive chosen-plaintext: depends on the received ciphertexts.\nChosen-ciphertext: Adversary chooses the ciphertext and obtains the plaintext (aims to find the key).\nAdaptive Chosen-ciphertext: Chosen-ciphertext depends on the received plaintexts."
  },
  {
    "objectID": "exam_notes_en.html#oracles-and-security-models",
    "href": "exam_notes_en.html#oracles-and-security-models",
    "title": "Fundamental Security Services",
    "section": "Oracles and Security Models",
    "text": "Oracles and Security Models\n\nRandom Oracles and Security Models\n\nRandom Oracle: A theoretical “perfect” function that returns a uniform and random value for each new input, but remains deterministic for an input already seen.\nROM (Random Oracle Model): Mathematical proof framework using this ideal oracle as a substitute for hash functions.\nStandard Model: Framework where security relies solely on the adversary’s computing power against real algorithms.\nLimit: A security proof in ROM does not guarantee absolute security in the real world (with SHA-256, etc.).\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nA random oracle is an abstract entity accessible to legitimate parties and adversaries.\n\nBehavior: It responds to input queries \\(x\\) with perfectly random responses \\(Orc(x)\\).\nDeterminism: The only exception lies in previously processed inputs (\\(x_1, x_2, \\dots, x_n\\)). If \\(x_1' = x_1\\), then \\(Orc(x_1') = Orc(x_1)\\).\nModeling: It is modeled by a function \\(Orc : X \\to Y\\) where \\(\\forall x \\in X, \\Pr(Orc(x) = y) = \\frac{1}{|Y|}\\).\nUtility: It behaves like an “ideal” cryptographic hash function, a valuable tool for proving security in the Random Oracle Model.\nComparison: The standard model limits adversaries by computational factors. A protocol secure in the random oracle model can become vulnerable if used with a “real” hash function (SHA-1, SHA-256).\n\n\n\n\n\n\n\nEncryption, Decryption and Signature Oracles\n\nFunction: Entities that perform operations (encrypt/sign) for the adversary using secret keys without ever revealing them.\nSymmetric cryptography: The oracle provides \\(E_k(x)\\) or \\(D_k(y)\\).\nAsymmetric cryptography: The oracle is crucial for private operations (decryption/signature), as public operations are already freely accessible.\n\n\n\n\n\n\n\nNoneOriginal version: Operational Oracles\n\n\n\n\n\nAn encryption/decryption/signature oracle is an abstract entity offering an “on-demand” service.\n\nKey access: It uses the same keys as the legitimate owners (symmetric and asymmetric systems) without disclosing them.\nSymmetric primitives: For a primitive \\(E\\) and a key \\(k\\), it returns \\(y = E_k(x)\\) or the corresponding plaintext \\(x\\).\nPublic key systems: The oracle is only needed for operations with the private key (\\(priv_k\\)).\n\nDecryption: returns \\(x\\) such that \\(E'_{pubk}(x) = y\\).\nSignature: For a system \\(S\\), it returns \\(y = S_{privk}(x)\\).\n\nAttacks: The attack models using chosen plaintext (CPA) and chosen ciphertext (CCA) rely on making these oracles available to the adversary.\n\n\n\n\n\n\n\nIndistinguishability and Semantic Security (IND-CPA)\n\nProperty: An adversary must not be able to distinguish the ciphertexts of two different plaintext messages.\nIND-CPA (Indistinguishability under Chosen Plaintext Attack): If the adversary guesses the correct message only with a probability of \\(1/2 + \\epsilon\\), the system is considered secure.\nSemantic Security: Equivalent to IND-CPA, it ensures that no useful information leaks from the ciphertext.\n\n\n\n\n\n\n\nNoneOriginal version: Semantic Security\n\n\n\n\n\nCiphertext indistinguishability guarantees the inability to distinguish the ciphertexts of given plaintexts.\n\nExperiment (IND-CPA Security Game):\n\nThe adversary chooses two messages \\(M_0\\) and \\(M_1\\).\nThe oracle chooses a random index \\(i \\in \\{0,1\\}\\) and returns \\(c_i = E_k(M_i)\\).\nThe adversary can perform other calculations or oracle calls.\n\nIND-CPA Definition: The system is secure if the adversary’s advantage is negligible (\\(Prob = 1/2 + \\epsilon\\) with \\(\\epsilon\\) small).\nNote: In public key, the encryption oracle is useless because the adversary already possesses the public key. IND-CPA provides semantic security.\n\n\n\n\n\n\n\nProbabilistic Encryption and OAEP\n\nProblem: Deterministic encryption allows dictionary attacks (comparison of known ciphertexts).\nSolution: Add randomness to the message before encryption so that \\(E(M)\\) is different each time.\nOAEP (Optimal Asymmetric Encryption Padding): Standard used with RSA. It combines the message \\(P\\) with a random number \\(R\\) via hash functions \\(h\\) and XOR operations (\\(\\oplus\\)).\n\n\n\n\n\n\n\nNoneOriginal version: Determinism vs. Probabilism\n\n\n\n\n\nDeterministic behavior (same inputs = same outputs) creates vulnerabilities.\n\nExample: If Alice sends “Yes” or “No”, the adversary can compute \\(C_{yes} = E_{pub}(``Yes\")\\) and compare. They can create a codebook (dictionary) to identify messages without breaking the key.\nProbabilistic encryption: Adds randomness. The goal is semantic security for the public key.\nOAEP: Used in RSA-PKCS1. The text \\(P\\) is combined with randomness \\(R\\):\n\n\\(M_1 := P \\oplus h(R)\\)\n\\(M_2 := R \\oplus h(M_1)\\)\nEncryption applies to \\(M_1\\) and \\(M_2\\). During decryption, we recover \\(R = M_2 \\oplus h(M_1)\\), then \\(P = h(R) \\oplus M_1\\).\n\n\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nRandom Oracle: “Ideal” hash function (theoretical model).\nCPA/CCA Oracles: Simulate access to the secret key to test resistance.\nIND-CPA: Inability to distinguish two ciphertexts (Semantic Security).\nProbabilistic Encryption: Essential to counter codebooks (dictionary attacks).\nOAEP: Padding method adding the necessary randomness to RSA."
  },
  {
    "objectID": "exam_notes_en.html#history-of-cryptography-and-unconditional-security",
    "href": "exam_notes_en.html#history-of-cryptography-and-unconditional-security",
    "title": "Fundamental Security Services",
    "section": "History of Cryptography and Unconditional Security",
    "text": "History of Cryptography and Unconditional Security\n\nHistorical Encryption Systems\nCryptography was for a long time limited to the sole pursuit of confidentiality. Historical systems are based on two fundamental principles: substitution and transposition.\n\nCaesar Cipher (mono-alphabetic substitution): Fixed letter shift. Very vulnerable to frequency analysis.\nVigenère Cipher (polyalphabetic substitution): Uses a key to vary the shift. More complex, but breakable by identifying the key length.\nTransposition Cipher: Reorganization of the original text characters according to a permutation defined by a key.\n\n\n\n\n\n\n\nNoneOriginal version: Historical Cryptography\n\n\n\n\n\nFor centuries confidentiality was the only application of cryptography…\n\n1st century BC, Caesar Cipher: Mono-alphabetic substitution encryption \\(e_k(x) = (x + k) \\pmod{26}\\), \\(d_k(y) = (y - k) \\pmod{26}\\) where \\(x, y, k \\in \\mathbb{Z}_{26}\\).\n\nExample: \\(E_1(\\text{'hello'}) = \\text{'ifmmp'}\\).\nCryptanalysis: easy, based on character frequency.\n\n16th century, Vigenère: Polyalphabetic substitution encryption \\(e_k(x_1, \\dots, x_n) = (x_1 + k_1, \\dots, x_m + k_m, x_{m+1} + k_1, \\dots) \\pmod{26}\\).\n\nCryptanalysis: find the key length \\(m\\) by identifying repeated ciphertext portions and analyzing separate blocks as in the Caesar Cipher.\n\nTransposition Ciphers (Porta, 1563): The key defines a permutation on the plaintext.\nThese techniques are still the basis of modern encryption systems (ex: Enigma, qualified by W. Churchill as the secret weapon that won the war).\n\n\n\n\n\n\nThe One-Time Pad (OTP)\nThe One-Time Pad (OTP), or Vernam cipher, is the only system proven to be unconditionally secure (perfect secrecy).\n\nPrinciple: The message is combined with a key of the same length via the XOR operation (\\(\\oplus\\)).\nUnconditional Security: Observation of the encrypted message provides no information about the plaintext message. Even an adversary with infinite computing power cannot break it.\nShannon’s Constraints: The key must be as long as the message, purely random, and used only once.\nKey Reuse: If a key is reused for two messages, an attacker can eliminate the key by XOR (\\(y_a \\oplus y_b = x_a \\oplus x_b\\)) and recover the plaintext messages.\n\n\n\n\n\n\n\nNoneOriginal version: The One-Time Pad\n\n\n\n\n\nLet \\(n \\ge 1\\) and the spaces \\(P, C, K\\) such that \\(P, C, K = (\\mathbb{Z}_2)^n\\). The encryption and decryption operations of a one-time pad (Vernam Cipher) are: \\(E_k(x_i) = x_i \\oplus k_i\\) and \\(D_k(y_i) = y_i \\oplus k_i\\) for \\(1 \\le i \\le n\\).\n\nUnconditional security: If \\(k_i\\) are random and independent, observation of ciphertexts does not help cryptanalysis. The entropy of \\(X\\) does not decrease: \\(H(X|C) = H(X)\\).\nShannon’s Theorem: Necessary condition: \\(H(K) \\ge H(X)\\). The length of the random key must be at least as large as that of the plaintext.\nKey reuse: \\(y_a \\oplus y_b = x_a \\oplus x_b\\). With low-entropy messages, the plaintexts and the key (\\(k = y_a \\oplus x_a\\)) can be recovered.\nVulnerable to the Known Plaintext attack (if the key is reused).\nMajor problem: The distribution and management of large keys. Revived by quantum cryptography proposing confidential channels for unlimited-length key distribution.\n\n\n\n\n\n\nSteganography\nIn contrast to cryptography, which makes the message unreadable, steganography conceals the very existence of the message.\n\nMethod: Use a “subliminal channel” (an innocent medium like an image or a banal text).\nModern technique: Insertion of data into the least significant bits (LSB) of multimedia files, allowing the hiding of large volumes of data without visible alteration.\n\n\n\n\n\n\n\nNoneOriginal version: Steganography\n\n\n\n\n\nSteganography hides a message inside another. Constituent elements:\n\nA different physical or logical channel (subliminal channel).\nA secret mechanism to identify this channel.\n\n\nClassic examples: First letters of words in a text, invisible ink.\nModern example: Use the least significant bits of the frames of a Photo CD.\nFor a 2048x3072 image (RGB 24 bits), hiding a message using 1 bit allows storing 2.3 Mb without deteriorating quality.\n\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nHistory: Substitution (Caesar/Vigenère) and Transposition (permutation).\nOne-Time Pad: Absolute security if the key is random, unique, and as long as the message (\\(H(K) \\ge H(X)\\)).\nSteganography: Hiding the existence of the message (ex: LSB technique in images)."
  },
  {
    "objectID": "exam_notes_en.html#stream-ciphers-stream-encryption",
    "href": "exam_notes_en.html#stream-ciphers-stream-encryption",
    "title": "Fundamental Security Services",
    "section": "Stream Ciphers (Stream Encryption)",
    "text": "Stream Ciphers (Stream Encryption)\n\nIntroduction to Stream Ciphers\n\nDefinition and Principle\nStream ciphers are a family of encryption systems characterized by:\n\nUnit block size: each encrypted block = 1 bit\nTwo-phase architecture:\n\nKeystream generation: production of the key sequence\nSubstitution: operation on plaintext bits based on the keystream\n\n\nClassic example: the one-time pad\n\nGeneration: (pseudo-)random generator\nSubstitution: XOR operation (\\(\\oplus\\)) with the keystream\n\n\n\nGeneral Characteristics\nAdvantages:\n\nSpeed: encryption at register level, ideal for real-time streaming (video)\nLightweight: work on systems with limited CPU resources\nLow memory: little or no buffering needed\nNon-propagated errors: retransmission of defective packets is sufficient (suitable for wireless transmissions - WiFi)\n\nDisadvantages:\n\nDependency on keystream quality: randomness determines robustness\nDangerous reuse: keystream reuse allows easy cryptanalysis\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nStream Ciphers\n\nStream ciphers constitute a family of encryption systems where the size of the encrypted block is equal to 1 bit.\nStream ciphers are generally composed of two phases:\n\nA generation phase of the sequence of elements forming the key (the keystream).\nA substitution phase where the plaintext bits undergo a specific operation dependent on the keystream.\n\nAn obvious example of a stream cipher is the one-time pad with:\n\nA keystream generation phase performed by a (pseudo-)random generator.\nA substitution phase consisting of performing a xor (\\(\\oplus\\)) with the keystream.\n\n\n\n\nStream Ciphers: Characteristics\n\nSpeed: Encryption is done directly at the register level. Ideal for applications requiring “on the fly” encryption like video streaming.\nEase: Operations can be performed by systems with limited CPU resources.\nNo (or little…) need for memory/buffering.\nLimited or absent error propagation: retransmission of faulty packets is normally sufficient (suitable for applications where packet loss is frequent like wireless transmissions (WiFi)).\nDisadvantages:\n\nThe quality in terms of randomness of the generated keystream determines the system’s robustness.\nKeystream reuse allows easy cryptanalysis (cf. the one-time pad).\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nStream Ciphers = encryption bit by bit in 2 phases (keystream generation + substitution).\nAdvantages: fast, lightweight, no error propagation.\nDisadvantages: keystream quality critical, reuse = vulnerability.\n\n\n\n\n\n\n\nSynchronous Stream Ciphers\n\nOperating Principle\nIn a synchronous stream cipher, the keystream depends only on the key, independent of the plaintext and ciphertext.\nProcess equations:\n\\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nWhere:\n\n\\(\\sigma_i\\): state at time \\(i\\) (initial state \\(\\sigma_0\\) may depend on \\(k\\))\n\\(k\\): secret key\n\\(f\\): state transition function\n\\(g\\): keystream production function producing \\(z_i\\)\n\\(h\\): output function producing ciphertext \\(c_i\\) from plaintext \\(m_i\\)\n\n\n\n\n\n\ngraph LR\n    A[Key k] --&gt; B[State σi]\n    B --&gt; C[Function f]\n    C --&gt; D[State σi+1]\n    B --&gt; E[Function g]\n    E --&gt; F[Keystream zi]\n    F --&gt; G[Function h]\n    H[Plaintext mi] --&gt; G\n    G --&gt; I[Ciphertext ci]\n    D -.-&gt;|loop| B\n\n\n\n\n\n\n\n\nCharacteristics\nSynchronization requirement:\n\nTransmitter and receiver must share the same key \\(k\\) AND the same state \\(\\sigma_i\\)\nLoss of synchronization = need for external mechanisms (markers, redundancy analysis)\n\nProperties:\n\nNo error propagation: modification of ciphertext does not affect subsequent sequences\nAttention: deletion of a ciphertext = receiver desynchronization\n\nVulnerabilities to active attacks:\n\n✓ Detection: insertion, elimination, replay of fragments\n✗ Bit modification: adversary can modify bits and analyze impact on plaintext\nSolution: additional authentication mechanisms necessary\n\n\n\nSpecial case: Additive Stream Cipher\nThe most frequent case where:\n\nFunctions \\(f\\) and \\(g\\) replaced by a random generator\nFunction \\(h\\) = modulo 2 addition (XOR: \\(\\oplus\\))\n\nFormula: \\(c_i = z_i \\oplus m_i\\)\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nSynchronous Stream Ciphers\n\nThe generated keystream depends only on the key and not on the plaintext nor the ciphertext.\nThe encryption process of a synchronous stream cipher is described by the following equations: \\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] with \\(\\sigma_i\\) the initial state which may depend on the key \\(k\\), \\(f\\) the function determining the next state, \\(g\\) the function producing the keystream \\(z_i\\) and \\(h\\) the output function producing the ciphertext \\(c_i\\) from the plaintext \\(m_i\\).\n\n\n\nSynchronous Stream Ciphers: Characteristics\n\nRequire synchronization of the transmitter and receiver: In addition to using the same key \\(k\\), both must be in the same state for the process to work. If synchronization is lost, external mechanisms are needed to recover it (special markers, plaintext redundancy analysis, etc.)\nNo error propagation. Modification of the ciphertext during transmission does not cause disturbances in subsequent ciphertext sequences (however, the deletion of a ciphertext would cause desynchronization of the receiver).\nActive attacks: Insertion, elimination or replay of parts of ciphertext are detected by the receiver. However, an adversary could modify certain bits of the ciphertext and analyze the impact on the corresponding plaintext. Additional origin authentication mechanisms are necessary to detect these attacks.\nMost frequent case of Synchronous Stream Ciphers: the additive stream cipher (cf. the one-time pad) where the functions \\(f\\) and \\(g\\) generating the keystream are replaced by a random generator and the function \\(h\\) is a modulo 2 addition (xor).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nSynchronous: keystream = \\(f\\)(key only). Equations: \\(\\sigma_{i+1} = f(\\sigma_i, k)\\), \\(z_i = g(\\sigma_i, k)\\), \\(c_i = h(z_i, m_i)\\).\nRequires synchronization transmitter/receiver. No error propagation but vulnerable to bit modifications.\nFrequent case: additive cipher with XOR.\n\n\n\n\n\n\n\nAsynchronous Stream Ciphers\n\nOperating Principle\nAlso called self-synchronizing ciphers.\nThe keystream depends on the key AND a fixed number of previous ciphertexts.\nProcess equations:\n\\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nWhere \\(\\sigma_i\\) represents a buffer of the last \\(t\\) ciphertexts.\n\n\n\n\n\ngraph LR\n    A[Key k] --&gt; B[Function g]\n    C[Buffer: ci-t...ci-1] --&gt; B\n    B --&gt; D[Keystream zi]\n    D --&gt; E[Function h]\n    F[Plaintext mi] --&gt; E\n    E --&gt; G[Ciphertext ci]\n    G -.-&gt;|feedback| C\n\n\n\n\n\n\n\n\nCharacteristics\nSelf-synchronization:\n\nIn case of insertion/elimination of ciphertexts, the receiver automatically re-synchronizes\nMechanism: memorization (buffer) of the last ciphertexts\n\nLimited error propagation:\n\nError propagates only over the buffer size (\\(t\\) bits)\nAfter buffer exhaustion, correct decryption resumes\n\nSecurity against active attacks:\n\nBetter detection: modifications detected thanks to error propagation\nAttention: self-synchronization allows receiver to continue even after insertions/deletions\nSolution: verification of integrity and authenticity of entire stream necessary\n\nDiffusion of plaintext statistics:\n\nEach plaintext bit influences all subsequent ciphertexts\nResult: better dispersion of statistics vs. synchronous case\nApplication: use for low entropy or highly redundant plaintexts\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nAsynchronous Stream Ciphers\n\nAlso called self-synchronizing ciphers.\nThe generated keystream depends on the key as well as a fixed number of previous ciphertexts.\nThe encryption process of an asynchronous stream cipher is described by the following equations: \\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] with \\(\\sigma_i\\), \\(g\\) and \\(h\\) as for the synchronous case.\n\n\n\nAsynchronous Stream Ciphers: Characteristics\n\nSelf-synchronization: In case of elimination or insertion of ciphertexts along the way, the receiver is capable of re-synchronizing with the transmitter thanks to the memorization (buffer) of a number of previous ciphertexts.\nLimited error propagation: Error propagation extends only to the number of ciphertext bits memorized (buffer size). Afterwards, decryption proceeds correctly again.\nActive attacks: Modification of ciphertext fragments will be more easily detected than in the synchronous case because of error propagation. However, since the receiver is capable of self-synchronizing with the transmitter, even if ciphertexts are eliminated or inserted along the way, it is necessary to verify the integrity and authenticity of the entire stream.\nDiffusion of plaintext statistics: The fact that each plaintext bit will influence all subsequent ciphertexts results in a greater dispersion of statistics compared to the synchronous case…\n… It is therefore advisable to use asynchronous stream ciphers when the entropy of plaintexts is limited and could allow targeted attacks on highly redundant plaintexts.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nAsynchronous (self-synchronizing): keystream = \\(f\\)(key + last ciphertexts). State \\(\\sigma_i\\) = buffer of \\(t\\) previous ciphertexts.\nAutomatic self-synchronization. Limited error propagation to buffer.\nBetter diffusion of statistics → ideal for redundant/low entropy plaintexts.\n\n\n\n\n\n\n\nKeystream Generators: LSFR\n\nContext and Necessity\nProblem: generate a keystream of length \\(m\\) from a secret key of length \\(l\\) with \\(l \\ll m\\).\nSolution: Linear Feedback Shift Register (LSFR or LFSR)\n\n\nLSFR Characteristics\nAdvantages:\n\nOptimal hardware implementation: very efficient circuits\nLong periods: sequences of great length\nGood random quality: notable randomness\nMathematical basis: algebraic properties of linear combinations\n\nGeneric structure: LSFR of length \\(L\\)\n\n\n\n\n\ngraph LR\n    A[bit L-1] --&gt; B[bit L-2]\n    B --&gt; C[...]\n    C --&gt; D[bit 1]\n    D --&gt; E[bit 0]\n    E --&gt; F[Output]\n    A -.-&gt;|feedback| G[⊕]\n    D -.-&gt;|coeff| G\n    C -.-&gt;|coeff| G\n    G --&gt; A\n\n\n\n\n\n\n\n\nImportant Remarks on LSFR\nHistory and Usage:\n\nVery widespread construction in cryptography and coding theory\nMany military stream ciphers based on LSFR\n\nSecurity Limits:\n\nInsufficient security level compared to modern block ciphers\nVulnerability: the Berlekamp-Massey algorithm allows to:\n\nDetermine the linear complexity of an LSFR\nCalculate an arbitrary number of generated sequences\n\n\nMetric: Linear complexity (linear complexity)\nImprovement Solution:\nReplace the linear combination with a non-linear function \\(f\\)\n→ Non Linear Feedback Shift Registers (NLFSR)\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nStream Ciphers: Keystream Generators\n\nWhen it is necessary to generate a keystream of length \\(m\\) from a secret key of length \\(l\\) with \\(l \\ll m\\), we call upon keystream generators.\nThe most common of these generators is the Linear Feedback Shift Register (LSFR).\nAn LSFR has the following characteristics:\n\nAdapts very well to hardware implementations.\nProduces sequences of long periods and with notable random quality (quite strong randomness)\nBased on the algebraic properties of linear combinations.\n\n\n\n\nLSFRs: Some Remarks\n\nLSFRs are very widespread constructions in cryptography and coding theory.\nA large number of stream ciphers based on LSFRs (especially in the military sphere) were developed in the past.\nUnfortunately, the security level offered by these systems is deemed insufficient nowadays (compared to that of block ciphers…)\nThe metric allowing analysis of an LFSR is its linear complexity. The Berlekamp-Massey algorithm allows determining the linear complexity of an LSFR and thus calculating an arbitrarily large number of sequences generated by an LSFR.\nA solution to increase complexity is to substitute the linear combination of ciphertext bits with a non-linear function \\(f\\). These are the Non Linear Feedback Shift Registers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nLSFR: long keystream generator (\\(m\\)) from short key (\\(l\\)). Base = linear combinations.\nAdvantages: efficient hardware, long periods.\nProblem: insufficient security, vulnerable to Berlekamp-Massey (linear complexity calculation).\nSolution: NLFSR (non-linear function).\n\n\n\n\n\n\n\nRC4: Software Stream Cipher\n\nGeneral Presentation\nRC4™ (Rivest Cipher 4) developed in 1987 by Ron Rivest for RSA Security.\nMain characteristics:\n\nVariable key: flexible length\nExtremely fast: 10× faster than DES\nSynchronous mode: keystream independent of plaintext/ciphertext\n\nHistory:\n\n1987-1994: patented, details confidential (NDA contract required)\n1994: unofficial publication in a newsgroup\nSince then: intensive analysis by cryptographic community\n\n\n\nArchitecture\nKey components:\n\nS-box: 8×8 substitution box (256 entries)\n\nContent: permutation of numbers 0 to 255\nDepends on the main key of variable length: \\(0 &lt; len(k) \\leq 255\\)\n\nCombinations: linear and non-linear\nFinal encryption: XOR between keystream and plaintext\n\n\n\nApplications and Security\nCommercial uses (numerous):\n\nLotus Notes\nOracle SQL\nMicrosoft Windows\nSSL/TLS\nAnd many more…\n\nAnalyses and Vulnerabilities:\n\nExhaustive work on key scheduling and PRGA\nMajor flaw: implementation in WEP (WiFi Wired Equivalent Privacy)\n\nWEP protocol completely compromised\nProblem: faulty usage mode, not the RC4 algorithm itself\n\n\n\n\nOperation\nRC4 decomposes into two steps:\n\nKey Scheduling Algorithm (KSA)\n\nResponsible for initial permutation of the S-box\nFunction of the variable length key \\(len(k) = l\\)\n\nPseudo Random Generator Algorithm (PRGA)\n\nGenerates keystream of arbitrary size\nRelies on S-box permuted by KSA\n\n\n\n\n\n\n\ngraph TB\n    A[Variable length key k] --&gt; B[KSA: Key Scheduling]\n    B --&gt; C[Permuted S-box]\n    C --&gt; D[PRGA: Generation]\n    D --&gt; E[Keystream zi]\n    E --&gt; F[XOR]\n    G[Plaintext mi] --&gt; F\n    F --&gt; H[Ciphertext ci]\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nSoftware Cipher Streams: RC4\n\nThe major disadvantage of stream ciphers based on registers is that they are very slow in programmed version on a generic machine. RC4™ is a variable key stream cipher developed in 1987 by Ron Rivest for RSA security. It is very fast (10 times faster than DES !)\nFor 7 years, this algorithm was patented and its internal operational details were disclosed only after signing a confidentiality contract. Since its (unofficial) publication in a newsgroup in 1994, it has been widely discussed and analyzed by the entire cryptographic community.\nThe algorithm works in synchronous mode (the keystream is independent of the ciphertext and plaintext).\nIt is composed of linear and non-linear combinations. The key element is an 8×8 substitution box (S-box) whose entries are a permutation of the numbers 0 to 255. The permutation is a function of the main key of variable size with \\(0 &lt; len(k) \\leq 255\\). The final encryption is obtained by a xor between the keystream and the plaintext.\nRC4 is used in a large number of commercial applications: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. It is the subject of a large number of analytical and exhaustive works that have managed to compromise the security of the key scheduling and the PRGA.\nIn particular the application of RC4 to the Wired Equivalent Privacy (WiFi WEP) protocol has been “broken” due to a flaw in the protocol’s usage mode.\n\n\n\nRC4: Operation\n\nThe algorithm consists of two steps:\n\nThe Key Scheduling Algorithm (KSA): Responsible for the initial permutation that will fill the S-box depending on the variable length key \\(len(k) = l\\).\nThe Pseudo Random Generator Algorithm (PRGA): Generates the keystream of arbitrary size relying on the S-box.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nRC4: software stream cipher, variable key, 10× faster than DES.\nArchitecture: 8×8 S-box (permutation 0-255) + XOR.\n2 steps: KSA (S-box permutation) + PRGA (keystream generation). Synchronous mode.\nVulnerability: WEP broken (usage flaw). Used in SSL, Windows, Oracle…"
  },
  {
    "objectID": "exam_notes_en.html#block-ciphers-block-encryption",
    "href": "exam_notes_en.html#block-ciphers-block-encryption",
    "title": "Fundamental Security Services",
    "section": "Block Ciphers (Block Encryption)",
    "text": "Block Ciphers (Block Encryption)\n\n1. Introduction to Block Ciphers\n\nDefinition and Principle\nA block cipher is a cryptographic function that:\n\nTransforms fixed-size blocks: maps a block of \\(n\\) bits to another block of the same size\nIs parameterized by a key: the key \\(K\\) of \\(k\\) bits defines the transformation\nMust be bijective: to allow unique decryption\nEach key = different bijection: guarantees variability\n\nNominal size: input block size on which encryption is applied\n\n\nQuality Criteria\n1. Key size/Entropy\n\nKeys ideally equiprobable with entropy = \\(k\\) bits\nStrong entropy protects against brute-force attacks\nMinimum required: 128 bits for modern block ciphers\n\n2. Performance\n\nExecution speed\nSoftware/hardware efficiency\n\n3. Block size\n\nToo small block = vulnerability to plaintext/ciphertext dictionaries\nModern standard: blocks ≥ 128 bits\n\n4. Cryptographic resistance\n\nResistance to known techniques:\n\nLinear cryptanalysis\nDifferential cryptanalysis\nMeet in the middle\n\nCryptanalysis effort equivalent to brute force\n\n\n\n\n\n\ngraph LR\n    A[Plaintext n bits] --&gt; B[Block Cipher]\n    C[Key K k bits] --&gt; B\n    B --&gt; D[Ciphertext n bits]\n    \n    style B fill:#e1f5ff\n    style C fill:#fff4e1\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\nBlock Ciphers\n\nSymmetric block ciphers constitute the cornerstone of cryptography. Their main functionality is confidentiality but they are also the basis for authentication, hashing functions, random generation, etc.\nDefinition: A block cipher is a function that maps a block of \\(n\\) bits to another block of the same size. The function is parameterized by a key \\(K\\) of \\(k\\) bits. To allow unique decryption, the function must be bijective. Each key defines a different bijection. The input block size on which encryption is applied is also called nominal algorithm size.\nCriteria to evaluate the quality of a block cipher:\n\nKey size/Entropy: Ideally, keys are equiprobable and the key space has an entropy equal to \\(k\\). A strong key entropy protects against brute-force attacks from chosen/known plaintexts. Modern block ciphers must have keys of at least 128 bits.\nPerformance\nBlock size: A too small block would allow attacks where plaintext/ciphertext “dictionaries” could be built. Nowadays, blocks of size ≥ 128 bits are becoming common.\nCryptographic resistance: The block cipher must show resistance to known cryptanalysis techniques: linear or differential cryptanalysis, meet in the middle, etc. The inherent effort of these attacks (complexity, storage, parallelization, etc.) must be equivalent to that of a brute force attack.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nBlock cipher: bijective function transforming blocks of \\(n\\) bits with key \\(K\\) of \\(k\\) bits. Criteria: key entropy ≥ 128 bits, block size ≥ 128 bits, cryptanalysis resistance = brute force effort. Usage: confidentiality, authentication, hashing, random generation.\n\n\n\n\n\n\n\n2. Block Cipher Modes of Operation\n\n2.1 Electronic Codebook (ECB)\nPrinciple: each plaintext block is encrypted independently with the same key.\n\\[c_i = E_K(m_i)\\] \\[m_i = D_K(c_i)\\]\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        P1[Plaintext Block 1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext Block 1]\n        \n        P2[Plaintext Block 2] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext Block 2]\n    end\n    \n    style E1 fill:#ffcccc\n    style E2 fill:#ffcccc\n    style K1 fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\nCharacteristics:\n\n✗ Identical plaintexts → identical ciphertexts (predictable)\n✓ No error propagation: error on \\(c_j\\) affects only \\(m_j\\)\n✗ Visible patterns: plaintext structure transparent in ciphertext\n✓ Parallelizable: each block processed independently\n\n⚠️ Major vulnerability: Should NOT be used for redundant data\n\n\n\n2.2 Cipher Block Chaining (CBC)\nPrinciple: each plaintext block is XORed with the previous ciphertext before encryption.\n\\[c_i = E_K(m_i \\oplus c_{i-1})\\] \\[m_i = D_K(c_i) \\oplus c_{i-1}\\]\nWith \\(c_0 = IV\\) (Initialization Vector)\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        IV[IV] --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext c1]\n        \n        C1 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ccffcc\n    style E2 fill:#ccffcc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ Patterns erased: chaining masks the structure\n✓ Limited error propagation: error on \\(c_j\\) affects \\(m_j\\) and \\(m_{j+1}\\) only\n✗ Not parallelizable in encryption (sequential)\n✓ Parallelizable in decryption\n\nIV (Initialization Vector):\n\nMust be random or pseudo-random\nCan be transmitted in clear\nMust be different for each message with the same key\n\n\n\n\n2.3 Cipher Feedback Mode (CFB)\nPrinciple: works like a stream cipher where the keystream is generated by the block cipher. The keystream depends on previous ciphertexts (asynchronous mode).\n\\[c_i = m_i \\oplus E_K(c_{i-1})\\] \\[m_i = c_i \\oplus E_K(c_{i-1})\\]\nWith \\(c_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph CFB_Encryption\n        IV[IV / ci-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        C1 -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#ffccff\n    style X1 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ Chaining: dependencies between ciphertexts\n⚠️ Error propagation: error on \\(c_j\\) affects \\(\\frac{n}{r}\\) following blocks\n\n\\(n\\) = nominal size of block cipher\n\\(r\\) = size of plaintexts\n\n✗ Not parallelizable\n⚠️ IV non-confidential but must be transmitted\n\nUsage: suitable for transmissions with frequent packet loss\n\n\n\n2.4 Output Feedback Mode (OFB)\nPrinciple: works like a synchronous stream cipher. The keystream is entirely determined by the key and IV, independent of plaintext and ciphertext.\n\\[z_i = E_K(z_{i-1})\\] \\[c_i = m_i \\oplus z_i\\] \\[m_i = c_i \\oplus z_i\\]\nWith \\(z_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph OFB_Mode\n        IV[IV / zi-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; Z[zi keystream]\n        Z --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        Z -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#cce5ff\n    style X1 fill:#ffffcc\n    style Z fill:#e1ffe1\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ No error propagation: error on \\(c_j\\) affects only \\(m_j\\)\n✓ Pre-computable keystream: efficient\n⚠️ CRITICAL: NEVER reuse the same IV with the same key (otherwise identical keystream)\n✓ Parallelizable if keystream pre-computed\n\n⚠️ Reuse warning: Change IV for each new message!\n\n\n\n\n\n\nNote📄 Original text (CFB and OFB Modes)\n\n\n\n\n\nCFB and OFB Modes: Characteristics\nThe CFB and OFB modes work as a stream cipher with a keystream generated by the encryption block. In CFB, the keystream depends on previous ciphertexts (asynchronous) whereas in OFB, the keystream is entirely determined by the key and the IV (synchronous).\nParticularities of CFB:\n\nAs in CBC mode, identical plaintexts are translated into different ciphertexts if the IV changes. The IV is not necessarily confidential and can be exchanged in clear between parties.\nChaining also introduces dependencies between current ciphertexts and previous ciphertexts. In particular, if \\(n\\) is the nominal algorithm size and \\(r\\) is the plaintext size, the current ciphertext will depend on the \\(\\frac{n}{r}\\) previous ciphertexts (each iteration will shift the faulty input by \\(r\\) positions, after \\(\\frac{n}{r}\\) iterations the faulty ciphertext will be completely “expelled”).\nError propagation follows the same principle: an error in a ciphertext will result in incorrect decryption of the \\(\\frac{n}{r}\\) following ciphertexts.\n\nParticularities of OFB:\n\nOFB has identical behavior to CBC and CFB modes for encryption of identical plaintexts.\nNo error propagation on adjacent ciphertexts.\nModify the IV if the key does not change to avoid keystream reuse !!!\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (CFB/OFB)\n\n\n\n\n\nCFB (asynchronous): keystream = \\(f\\)(previous ciphertexts). Limited error propagation (\\(\\frac{n}{r}\\) blocks).\nOFB (synchronous): keystream = \\(f\\)(key + IV only). No error propagation.\nCRITICAL: NEVER reuse same IV with same key. IV transmissible in clear.\n\n\n\n\n\n\n2.5 Counter Mode (CTR)\nPrinciple: the keystream is generated by encryption of a counter incremented at each block.\n\\[c_i = m_i \\oplus E_K(counter + i)\\] \\[m_i = c_i \\oplus E_K(counter + i)\\]\n\n\n\n\n\ngraph TB\n    subgraph CTR_Mode\n        CTR1[Counter + 0] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; C1[Ciphertext c1]\n        \n        CTR2[Counter + 1] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ffe6cc\n    style E2 fill:#ffe6cc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Synchronous mode: keystream = \\(f\\)(counter)\n✓ Parallelizable: keystream pre-computable for encryption AND decryption\n✓ Random access: each block decryptable independently\n✓ No error propagation\n✓ Benefits from SIMD architectures: no dependencies between blocks\n⚠️ Counter: must be of size \\(2^b\\) (\\(b\\) = block size)\n⚠️ CRITICAL: NEVER reuse the same counter with the same key\n\nCounter management:\n\nIncrement modulo \\(2^b\\) after each iteration\nSolution: always increment for each encrypted stream\nFirst block of stream \\(i+1\\) &gt; last block of stream \\(i\\)\n\nApplications:\n\nATM (Asynchronous Transfer Mode)\nIPsec (IP security)\nHigh-speed lines: selective transmission of blocks\nLarge volume transfers: video\n\n\n\n\n\n\n\nNote📄 Original text (Counter Mode)\n\n\n\n\n\n\nCounter Mode (CTR Mode)\nFrequently used as encryption support in data transfer protocols like ATM (Asynchronous Transfer Mode) and IPsec (IP security).\n\n\nCounter Mode (II)\n\nThe keystream is generated by the encryption of a random counter of size \\(2^b\\) (with \\(b\\) the block size) and necessary for decryption. This counter is incremented modulo \\(2^b\\) after each iteration.\nWorks in synchronous mode. Reuse of the same counter results in an identical keystream !\nSolution: Always increment the counter for each encrypted stream such that the counter of the first block of a stream is larger than the last block of the previous stream.\nEasily parallelizable: The keystream can be pre-calculated both for encryption and decryption. Fully benefits from SIMD architectures because unlike other chaining modes there are no dependencies between operations of different blocks.\nRandom access to encryption/decryption of each block: Unlike other chaining modes where the \\(i\\)-th operation depends on the \\((i-1)\\)-th operation.\nIf we add absence of error propagation, the counter mode facilitates selective (re)transmission of ciphertext blocks, making it very attractive for securing high-speed lines as well as for encrypted transfers of large volumes of information (e.g. video).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (Counter Mode)\n\n\n\n\n\nCTR: keystream = \\(E_K\\)(counter + \\(i\\)).\nAdvantages: parallelizable (encryption + decryption), random access, no error propagation, SIMD-friendly.\nCRITICAL: never reuse counter.\nUsage: ATM, IPsec, high speed, video.\n\n\n\n\n\n\n\n3. Product Ciphers and Feistel Ciphers\n\nProduct Ciphers\nDefinition: encryption scheme combining a series of successive transformations to strengthen resistance to cryptanalysis.\nCommon transformations:\n\nTranspositions (permutations)\nSubstitutions (S-boxes)\nXORs\nLinear combinations\nModular multiplications\n\n\n\nFeistel Ciphers\nDefinition: iterative product cipher with specific structure.\nOperating principle:\n\nInput: plaintext of \\(2t\\) bits = \\((L_0, R_0)\\) (two sub-blocks of \\(t\\) bits)\nOutput: ciphertext of \\(2t\\) bits = \\((R_r, L_r)\\) after \\(r\\) steps (rounds)\nEach step: invertible bijection (for unique decryption)\n\nEquations of step \\(i\\) (\\(1 \\leq i \\leq r\\)):\n\\[(L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\]\nWith:\n\n\\(L_i = R_{i-1}\\)\n\\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph Feistel_Round\n        L0[Li-1] --&gt; R1[Ri = Li-1 ⊕ f]\n        R0[Ri-1] --&gt; L1[Li = Ri-1]\n        R0 --&gt; F[Function f]\n        K[Key Ki] --&gt; F\n        F --&gt; XOR[⊕]\n        L0 --&gt; XOR\n        XOR --&gt; R1\n    end\n    \n    style F fill:#ffcccc\n    style XOR fill:#ffffcc\n    style K fill:#fff4e1\n\n\n\n\n\n\nCharacteristics:\n\n\\(K_i\\): subkeys generated from the main key \\(K\\)\nNumber of steps \\(r\\): generally even and \\(\\geq 3\\)\n\nExample: DES has 16 steps\n\nFinal permutation: \\((L_r, R_r) \\rightarrow (R_r, L_r)\\)\nDecryption: identical to encryption but subkeys applied in reverse order (from \\(K_r\\) to \\(K_1\\))\n\nFrequent operations:\n\nPermutations\nSubstitutions (S-boxes)\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\nProduct Ciphers and Feistel Ciphers\n\nA product cipher is an encryption scheme combining a series of successive transformations to strengthen resistance to cryptanalysis. Common transformations for a product cipher are: transpositions, substitutions, XORs, linear combinations, modular multiplications, etc.\nA Feistel cipher is an iterative product cipher capable of transforming a plaintext of \\(2t\\) bits of the form \\((L_0, R_0)\\) composed of two sub-blocks \\(L_0\\) and \\(R_0\\) of \\(t\\) bits into a ciphertext of size \\(2t\\) of the form \\((R_r, L_r)\\) after \\(r\\) successive steps (rounds) with \\(r \\geq 1\\). Each step defines a bijection (inversible !) to allow unique decryption.\nPermutations and substitutions are the most frequent operations.\nThe steps \\(1 \\leq i \\leq r\\) are written: \\((L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\) with \\(L_i = R_{i-1}\\) and \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\). The \\(K_i\\) are sub-keys, different for each step, generated from the main key \\(K\\) of the encryption scheme.\nThe number of steps proper to a Feistel cipher is normally even and \\(\\geq 3\\) (e.g. DES has 16 steps)\nAfter execution of all steps, a Feistel cipher performs a permutation of the two parts \\((L_r, R_r)\\) into \\((R_r, L_r)\\).\nThe decryption of a Feistel Cipher is identical to encryption except that the sub-keys \\(K_i\\) are applied in reverse order (From \\(K_r\\) to \\(K_1\\)).\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nProduct cipher: combination of successive transformations (transpositions, substitutions, XOR).\nFeistel cipher:\n\niterative product cipher\nplaintext \\(2t\\) bits = \\((L_0, R_0)\\)\n\\(r\\) rounds with \\(L_i = R_{i-1}\\) and \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\).\nDecryption = encryption with reversed sub-keys.\nExample: DES (16 rounds).\n\n\n\n\n\n\n\n\n4. Data Encryption Standard (DES)\n\nGeneral Presentation\nDES (Data Encryption Standard): most important cryptographic algorithm until the advent of AES in 2001.\nMain characteristics:\n\nType: Feistel Cipher\nBlock size: 64 bits (nominal size)\nKey size: 56 effective bits (64 total bits with 8 parity bits)\nNumber of steps: 16 rounds\nSubkeys: 16 subkeys of 48 bits (one per step)\nUsage modes: ECB, CBC, CFB, OFB\n\n\n\n\n\n\ngraph TB\n    subgraph DES_Overview\n        P[Plaintext 64 bits] --&gt; DES[DES Encryption]\n        K[Key 56 bits] --&gt; DES\n        DES --&gt; C[Ciphertext 64 bits]\n        \n        C --&gt; DES_INV[DES Decryption]\n        K2[Key 56 bits] --&gt; DES_INV\n        DES_INV --&gt; P2[Plaintext 64 bits]\n    end\n    \n    style DES fill:#ffcccc\n    style DES_INV fill:#ccffcc\n    style K fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\n\n\nDES Structure\nMain components:\n\nInitial permutation (IP): permutation of the 64 input bits\n16 Feistel rounds: iterative transformation\nFinal permutation (IP⁻¹): inverse of IP\n\nEach round applies:\n\nDivision into two halves: \\(L_{i-1}\\) and \\(R_{i-1}\\) (32 bits each)\nFunction \\(f\\) on \\(R_{i-1}\\) with subkey \\(K_i\\)\nXOR with \\(L_{i-1}\\)\nExchange of halves\n\n\n\n\n\n\ngraph TB\n    Plain[Plaintext 64 bits] --&gt; IP[Initial Permutation IP]\n    IP --&gt; Split[Split L0, R0]\n    \n    Split --&gt; Round1[Round 1]\n    K1[K1] --&gt; Round1\n    Round1 --&gt; Round2[Round 2]\n    K2[K2] --&gt; Round2\n    Round2 --&gt; Dots[...]\n    Dots --&gt; Round16[Round 16]\n    K16[K16] --&gt; Round16\n    \n    Round16 --&gt; Swap[Swap R16, L16]\n    Swap --&gt; IP_inv[Final Permutation IP⁻¹]\n    IP_inv --&gt; Cipher[Ciphertext 64 bits]\n    \n    style IP fill:#e1f5ff\n    style IP_inv fill:#e1f5ff\n    style Round1 fill:#ffcccc\n    style Round2 fill:#ffcccc\n    style Round16 fill:#ffcccc\n\n\n\n\n\n\n\n\nDES Cipher Function\nThe function \\(f\\) for each round:\n\nExpansion E: 32 bits → 48 bits (table E)\nKey Addition: XOR with subkey \\(K_i\\) (48 bits)\nS-boxes: 8 S-boxes transform 48 bits → 32 bits\n\nEach S-box: 6 bits input → 4 bits output\n\nPermutation P: permutation of the resulting 32 bits\n\n\n\n\n\n\ngraph TB\n    R[Ri-1 32 bits] --&gt; E[Expansion E]\n    E --&gt; E_out[48 bits]\n    E_out --&gt; XOR1[⊕]\n    K[Ki 48 bits] --&gt; XOR1\n    XOR1 --&gt; S[8 S-boxes]\n    S --&gt; S_out[32 bits]\n    S_out --&gt; P[Permutation P]\n    P --&gt; F_out[f output 32 bits]\n    \n    style E fill:#cce5ff\n    style S fill:#ffcccc\n    style P fill:#e1ffe1\n    style XOR1 fill:#ffffcc\n\n\n\n\n\n\nS-box operation:\nInput: \\(a_1a_2a_3a_4a_5a_6\\) (6 bits)\n\nRow: \\(a_1 + 2a_6\\) (external bits)\nColumn: \\(a_2 + 2a_3 + 4a_4 + 8a_5\\) (internal bits)\nOutput: value of the corresponding cell (4 bits)\n\n\n\nSubkey Generation\nProcess:\n\nMain key: 64 bits (56 effective + 8 parity)\nPermuted Choice 1 (PC-1): selection of 56 bits\nDivision into two halves: \\(C_0\\) and \\(D_0\\) (28 bits each)\nFor each round \\(i\\):\n\nLeft circular rotation of \\(C_{i-1}\\) and \\(D_{i-1}\\)\nPermuted Choice 2 (PC-2): selection of 48 bits for \\(K_i\\)\n\n\nRotations:\n\nRounds 1, 2, 9, 16: 1 position\nOther rounds: 2 positions\n\n\n\n\n\n\n\nNote📄 Original text (DES Operation)\n\n\n\n\n\nDES: Operation\nCipher Function\n\nExpansion E: The 32 bits of the input are transformed into a vector of 48 bits using the table E. The first line of this table indicates how the first sub-block of 6 bits will be generated: first take the 32nd bit then bits 1,2,3,4,5. The second sub-block starts with the 4th bit then bits 5,6,7,8,9 and so on…\nKey addition: XOR of the 48-bit vector with the key.\nS-boxes: Apply 8 S-boxes on the resulting 48-bit vector. Each of these S-boxes takes a 6-bit sub-block and transforms it into a 4-bit sub-block. The operation is performed as follows: If we denote the 6 input bits of the S-box as: \\(a_1a_2a_3a_4a_5a_6\\). The output is given by the content of the cell located in the row \\(a_1 + 2a_6\\) and the column \\(a_2 + 2a_3 + 4a_4 + 8a_5\\).\nPermutation P: Permutation P works as follows: The first bit is sent to the 16th position, the second to the 7th position and so on.\n\nPermutations IP and IP⁻¹\n\nAct respectively at the beginning and at the end of the block processing and on the entirety of the 64 bits.\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (DES)\n\n\n\n\n\nDES: Feistel cipher, 64-bit blocks, 56-bit effective key, 16 rounds.\nFunction \\(f\\): Expansion E (32→48 bits) → XOR \\(K_i\\) → 8 S-boxes (48→32 bits) → Permutation P.\nS-box: 6 bits input → 4 bits output via table (row = external bits, column = internal bits).\nPermutations: IP (initial) and IP⁻¹ (final) on 64 bits.\n\n\n\n\n\n\n\n5. Triple-DES and DES Security\n\nDES Vulnerabilities\nMain problem: key space size \\(\\{0,1\\}^{56}\\) insufficient.\nBrute force attack:\n\n1999: key found in 24 hours\nTechnique: massively parallel brute force (100,000 PCs on Internet)\nKnown plaintext attack\n\n\n\nTriple-DES (3DES)\nSolution: increase key space to \\(\\{0,1\\}^{112}\\).\nScheme:\n\\[C = E_{K_1}(D_{K_2}(E_{K_1}(P)))\\]\nWith:\n\n\\(E\\): DES encryption\n\\(D\\): DES decryption\n\\(K_1, K_2\\): two 56-bit keys\n\n\n\n\n\n\ngraph LR\n    P[Plaintext 64 bits] --&gt; E1[DES Encrypt K1]\n    E1 --&gt; D[DES Decrypt K2]\n    D --&gt; E2[DES Encrypt K1]\n    E2 --&gt; C[Ciphertext 64 bits]\n    \n    K1a[Key K1 56 bits] --&gt; E1\n    K2[Key K2 56 bits] --&gt; D\n    K1b[Key K1 56 bits] --&gt; E2\n    \n    style E1 fill:#ffcccc\n    style D fill:#ccffcc\n    style E2 fill:#ffcccc\n\n\n\n\n\n\nAdvantages:\n\n✓ Satisfactory security: key space \\(2^{112}\\)\n✓ Compatibility: reuse of existing DES hardware/software\n✓ Gradual migration: while waiting for AES\n\nDisadvantage:\n\n✗ Performance: 3× slower (3 successive DES executions)\n\n\n\nDES Properties\n1. DES is not a group\nDES is NOT a group under composition:\n\\[\\nexists K_3 \\text{ such that } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)\\]\nConsequence: composite encryption (Triple-DES) considerably increases security.\nIf DES were a group: exhaustive search on \\(\\{0,1\\}^{56}\\) would break the algorithm regardless of the number of consecutive executions.\n2. Weak and semi-weak keys\n\nWeak key: \\(E_K(E_K(x)) = x\\)\nPair of semi-weak keys: \\(E_{K_1}(E_{K_2}(x)) = x\\)\n\nCharacteristic: weak keys generate identical subkeys in pairs:\n\n\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)\nFacilitates cryptanalysis\n\nDES has 4 weak keys:\n\n\n\nWeak key (hexadecimal)\n\n\n\n\n0101 0101 0101 0101\n\n\n0101 0101 FEFE FEFE\n\n\nFEFE FEFE FEFE FEFE\n\n\nFEFE FEFE 0101 0101\n\n\n\nAnd 6 pairs of semi-weak keys\n\n\n\n\n\n\nNote📄 Original text (DES and 3DES)\n\n\n\n\n\n\nDES and Triple-DES\n\nThe size of the key set (\\(\\{0,1\\}^{56}\\)) constitutes the greatest threat weighing on DES with current computing resources. In 1999 it took only 24 hours to find the key from a known plaintext using a massively parallel brute force technique (100,000 PCs connected to the Internet).\nTriple DES protects us from these brute force attacks by increasing the possible key space to \\(\\{0,1\\}^{112}\\).\nThis alternative allows continuing to use DES “boxes” (hardware and software) while waiting for migration to AES.\nThe security level obtained by this solution is very satisfactory.\nThe performance impact of three successive DES executions remains a disadvantage for some applications.\n\n\n\nDES: properties\n\nDES is not a group (in the algebraic sense) under composition: In other words, DES being a permutation: \\(\\{0,1\\}^{64} \\rightarrow \\{0,1\\}^{64}\\), if DES were a group under composition, this would mean that: \\(\\exists K_3\\) such that \\(E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)\\)\nThis property ensures that composite encryption (like Triple-DES) considerably increases the security of DES. If DES were a group, exhaustive search on the possible key set (\\(\\{0,1\\}^{56}\\)) would allow “breaking” the algorithm regardless of the number of consecutive executions of DES.\nWeak and semi-weak keys (weak and semi-weak keys):\n\nA key \\(K\\) is said to be weak if \\(E_K(E_K(x)) = x\\).\nA pair of keys \\((K_1, K_2)\\) is said to be semi-weak if \\(E_{K_1}(E_{K_2}(x)) = x\\).\n\nWeak keys have the particularity of generating identical subkeys in pairs (\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)), which facilitates cryptanalysis.\nDES has 4 weak keys (and 6 pairs of semi-weak keys).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (3DES and security)\n\n\n\n\n\nDES vulnerability: key space \\(2^{56}\\) breakable in 24h (1999). Triple-DES: \\(E_{K_1}(D_{K_2}(E_{K_1}(P)))\\), space \\(2^{112}\\), reuses DES hardware, 3× slower. DES ≠ group → composite encryption strengthens security. 4 weak keys generating identical subkeys in pairs → facilitates cryptanalysis.\n\n\n\n\n\n\n\n6. Advanced Encryption Standard (AES)\n\nGeneral Presentation\nAES (Advanced Encryption Standard): standard adopted in November 2001.\nDesign: Johan Daemen and Vincent Rijmen (original name: Rijndael)\nMain characteristics:\n\nType: iterative block cipher (but NOT a Feistel Cipher)\nBlock size: 128 bits\nVariable key size: 128, 192 or 256 bits\nNumber of rounds: depends on key size\n\n10 rounds for 128-bit key\n12 rounds for 192-bit key\n14 rounds for 256-bit key\n\nUsage modes: ECB, CBC, CFB, OFB, CTR\n\nAdvantages over DES:\n\n✓ Open process: consultation and analysis by worldwide experts\n✓ ~2× more performant in software\n✓ ~10²² times more secure (theoretically)\n✓ Scalable: key size can be increased if necessary\n\n\n\nAES Structure\nBasic unit: State matrix of 4 rows × 4 columns (for 128-bit key)\n\nEach element = 1 byte\nTotal: 16 bytes = 128 bits\n\nOperations on field \\(GF(2^8)\\):\n\nByte = element of \\(GF(2^8)\\)\nFinite field of polynomials of degree ≤ 7 with coefficients in \\(GF(2)\\)\nAdditions, multiplications defined in \\(GF(2^8)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph State_Matrix\n        S00[s0,0] --- S01[s0,1]\n        S01 --- S02[s0,2]\n        S02 --- S03[s0,3]\n        \n        S10[s1,0] --- S11[s1,1]\n        S11 --- S12[s1,2]\n        S12 --- S13[s1,3]\n        \n        S20[s2,0] --- S21[s2,1]\n        S21 --- S22[s2,2]\n        S22 --- S23[s2,3]\n        \n        S30[s3,0] --- S31[s3,1]\n        S31 --- S32[s3,2]\n        S32 --- S33[s3,3]\n    end\n    \n    style S00 fill:#ffe6cc\n    style S11 fill:#ffe6cc\n    style S22 fill:#ffe6cc\n    style S33 fill:#ffe6cc\n\n\n\n\n\n\n\n\nAES Round Detail\nFour operations per round:\n1. SubBytes (ByteSub)\n\nNon-linear substitution via S-box\nEach byte transformed independently\nResistance to linear and differential cryptanalysis\n\n2. ShiftRows\n\nPermutation of bytes with variable shifts per row\nRow 0: no shift\nRow 1: left shift 1 position\nRow 2: left shift 2 positions\nRow 3: left shift 3 positions\n\n3. MixColumns\n\nEach column = linear combination of other columns\nMatrix multiplication in \\(GF(2^8)\\)\nMaximum diffusion\n\n4. AddRoundKey\n\nXOR of the State matrix with the round subkey\nSubkey = result of Key Schedule\n\n\n\n\n\n\ngraph TB\n    Input[State Input] --&gt; SB[SubBytes]\n    SB --&gt; SR[ShiftRows]\n    SR --&gt; MC[MixColumns]\n    MC --&gt; ARK[AddRoundKey]\n    K[Round Key] --&gt; ARK\n    ARK --&gt; Output[State Output]\n    \n    style SB fill:#ffcccc\n    style SR fill:#ccffcc\n    style MC fill:#cce5ff\n    style ARK fill:#ffffcc\n\n\n\n\n\n\nFinal round: identical EXCEPT no MixColumns\n\n\nKey Schedule (Subkey Generation)\nProcess:\n\nKey Expansion: generation of an extended matrix\n\nKey 128 bits → matrix 4 × 4 × (\\(N_e\\) + 1) bytes\n\\(N_e\\) = number of rounds\n\nKey Selection: extraction of subkeys\n\nFirst subkey: first 4 columns\nSecond subkey: next 4 columns\nEtc.\n\n\nOperations:\n\nByte rotations\nSubstitutions via S-box\nXOR with constants (Rcon)\n\n\n\nAES Pseudo-code\nRijndael(State, CipherKey) {\n    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule\n    \n    AddRoundKey(State, ExpandedKey[0..3]); // Initial XOR\n    \n    for(i = 1; i &lt; Ne; i++) {\n        Round(State, ExpandedKey[4*i...(4*i)+3]);\n    }\n    \n    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Without MixColumns\n}\n\n\nAES Decryption\nPrinciple: apply the inverse operations in each round.\nInverse operations:\n\nInvSubBytes: inverse substitution via S-box⁻¹\nInvShiftRows: right shifts (instead of left)\nInvMixColumns: inverse matrix multiplication\nAddRoundKey: self-inverse (XOR)\n\nOrder: inverse of encryption with subkeys in reverse order\n\n\n\n\n\n\nNote📄 Original text (AES)\n\n\n\n\n\nAdvanced Encryption Standard (AES)\n\nAdopted as standard in November 2001, designed by Johan Daemen and Vincent Rijmen (hence its original name Rijndael).\nIt is also an iterative block cipher (like DES) but not a Feistel Cipher.\nPlaintext/Ciphertext Blocks: 128 bits.\nVariable key length: 128, 192, or 256 bits.\nUnlike DES, AES comes from an open consultation and analysis process involving worldwide experts.\nTechniques similar to DES (substitutions, permutations, XOR…) complemented by simple and very performant algebraic operations.\nAll operations are performed in the field \\(GF(2^8)\\): the finite field of polynomials of degree ≤ 7 with coefficients in \\(GF(2)\\).\nIn particular, a byte for AES is an element in \\(GF(2^8)\\) and the operations on bytes (additions, multiplications,…) are defined as in \\(GF(2^8)\\).\n~2 times more performant (in software) and ~10²² times (in theory…) more secure than DES…\nScalable: The key size can be increased if necessary.\n\n\nDetail of an AES Step (round)\nThe basic unit on which calculations are applied is a matrix of 4 rows and 4 columns (in the case of a 128-bit key) whose elements are bytes:\n\nByteSub: Non-linear operation (S-box) designed to resist linear and differential cryptanalysis.\nShiftRow: Permutation of bytes introducing variable shifts on the rows.\nMixColumn: Each column is replaced by linear combinations of the other columns (matrix multiplication !)\nAddRoundKey: XOR of the current matrix with the subkey corresponding to the current step.\n\n\n\nAES: Global Operation\n\nThe number of steps of AES varies depending on the key size. For a 128-bit key, 10 steps must be performed. Each increase of 32 bits in the key size entails an additional step (14 steps for 256-bit keys).\nDecryption consists of applying the inverse operations in each of the steps (InvSubBytes, InvShiftRows, InvMixColumns). AddRoundKey (because of XOR) is its own inverse.\nThe Key Schedule consists of:\n\nAn operation of key expansion of the main key. If \\(N_e\\) is the number of steps (depending on the key), a matrix of 4 rows and 4 × (\\(N_e\\) + 1) columns is generated.\nAn operation of step key selection: The first subkey will be constituted by the first 4 columns of the matrix generated during expansion and so on.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (AES)\n\n\n\n\n\nAES (Rijndael 2001): iterative block cipher (NOT Feistel), 128-bit blocks, keys 128/192/256 bits → 10/12/14 rounds.\nState: 4×4 byte matrix in \\(GF(2^8)\\).\n4 operations/round:\n\nSubBytes (non-linear S-box)\nShiftRows (row shifts)\nMixColumns (linear combinations)\nAddRoundKey (XOR subkey).\n\n2× faster than DES, 10²² times more secure.\n\n\n\n\n\n\n\n7. Attacks and AES Security\n\nAES Strengths\nSimplicity and performance:\n\n✓ Simple and efficient algorithm\n✓ Works on limited platforms (8-bit smart cards)\n✓ Hardware and software optimizations\n\n\n\nPublished Attacks\n1. Algebraic attacks (2002)\nXSL technique (N. Courtois and P. Pieprzyk):\n\nRepresents AES as system of 8000 quadratic equations with 1600 binary unknowns\nEstimated effort: \\(2^{100}\\) operations (still a conjecture)\nCharacteristic: requires few known plaintexts\nDistinction: different from linear/differential attacks\n\nCritique: based on the “highly algebraic” character of AES (largely contested)\n2. Related Key Attacks (2009-2011)\nPrinciple: attacks based on similar keys\n\nInteresting results on reduced versions of AES\nDo not compromise full AES\n\n3. Side Channel Attacks\nPrinciple: attacks on implementation (not the algorithm)\nTechniques:\n\nCache timing attacks: cache access analysis\nPower analysis: power consumption\nElectromagnetic analysis: electromagnetic emissions\n\nExample (2005): Osvik, Shamir, Tromer\n\nExtraction of 128-bit key with 6-7 plaintext/ciphertext pairs\nBased on cache access analysis\n\n4. Meet in the Middle on biclique structures (2011-2015)\nResult:\n\nReduces effort for AES-128 to \\(2^{126}\\) (factor 4 vs brute force)\nRemains well above current capabilities\n\n\n\nPractical Security\nFundamental assumption: key of maximum entropy\nRecent attacks (WPA2, etc.):\n\nExploit weakness of passwords/passphrases\nNo flaw in AES itself\nProblem: key generation from weak passwords\n\n⚠️ Critical reminder: key quality = system security\n\n\n\n\n\n\nNote📄 Original text (AES Attacks)\n\n\n\n\n\n\nAES: Final Remarks and Attacks (I)\n\nThe greatest strength of AES lies in its simplicity and its performance, including on reduced computing capacity platforms (e.g. smart cards with 8-bit processors).\nSince its official publication, many cryptanalysis works have been published with very interesting results. In particular, N. Courtois and P.Pieprzyk presented a technique called XSL allowing to represent AES as a system of 8000 quadratic equations with 1600 binary unknowns. The effort needed to break this system is estimated (it is still a conjecture…) to be \\(2^{100}\\).\nThese attacks are based on the highly algebraic character (and largely contested…) of AES. Moreover, only a few known plaintexts are needed to set them up, which distinguishes them from linear and differential attacks.\nIn recent years (2009-2011) attacks based on similar keys (related key attacks) have obtained interesting results on reduced versions of AES.\nAnother family of attacks called side channel attacks acting directly on the algorithm implementation allows extracting cryptographically relevant information during encryption execution.\n\n\n\nAES: Final remarks and Attacks (II)\n\nIn 2015 a Meet in the Middle type attack based on biclique structures showed that it was possible to reduce the effort needed to find an AES-128 key to \\(2^{126}\\), i.e., a factor of 4 compared to brute force. This nevertheless remains well above current computing capabilities.\nAnother family of attacks called side channel attacks acting directly on the algorithm implementation allows extracting cryptographically relevant information during encryption execution. In particular, the authors manage to extract the 128-bit key with only 6-7 plaintext/ciphertext pairs based on cache accesses.\nThe security of AES (as for any other encryption algorithm) is always based on the assumption of a key of maximum entropy. The attacks published recently on protocols based on AES (like WPA2) exploit the weakness of passwords/passphrases that are the origin of the keys used.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (AES Security)\n\n\n\n\n\nStrengths: simplicity, performance (even 8-bit cards). Attacks: XSL (\\(2^{100}\\), algebraic), related keys (reduced versions), side channel (implementation, cache), Meet-in-Middle biclique (\\(2^{126}\\)). Security: assumption of max entropy key. Practical attacks = weak passwords, not AES flaw.\n\n\n\n\n\n\n\n8. Block Cipher Cryptanalysis Techniques\n\n8.1 Differential Cryptanalysis\nPrinciple: chosen plaintext attack analyzing the propagation of differences between two plaintexts through the rounds.\nMethod:\n\nChoose two plaintexts with known difference: \\(x_a\\) and \\(x_b\\)\nObserve propagation: \\(\\Delta x = x_a \\oplus x_b\\)\nAnalyze ciphertexts: \\(\\Delta y = y_a \\oplus y_b\\)\nAssign probabilities to keys according to observed changes\nMost probable key = correct key (after many trials)\n\nCharacteristics:\n\nRequires \\(2^{47}\\) chosen plaintext pairs for DES\nProbabilities: depend on S-boxes and structure\nThe more pairs increase, the more success probability increases\n\nSensitivity: very sensitive to number of rounds\n\nChances of success increase exponentially when rounds decrease\n\n\n\n8.2 Linear Cryptanalysis\nPrinciple: known plaintext attack creating a linear simulator of the block cipher.\nMethod:\n\nCreate linear approximations of the algorithm\nAnalyze a large number of plaintext/ciphertext pairs\nThe bits of the simulator key tend to coincide with those of the real key (probabilistic calculation)\n\nComplexity for DES:\n\n\\(2^{38}\\) known plaintexts → 10% probability of guessing correctly\n\\(2^{43}\\) known plaintexts → 85% success probability\n\nCharacteristics:\n\nMost powerful analytical attack to date on block ciphers\nAlso sensitive to number of rounds\n\n\n\n8.3 Differential vs Linear Comparison\nCommon difficulties:\n\n✗ Parallelization: less efficient than parallel brute force\n⚠️ Sensitivity to rounds: efficiency decreases exponentially with number of rounds\n\nDES and these attacks:\n\nWidespread conjecture: DES designers knew these attacks (1970s, unpublished at the time)\nS-box design: very high resistance to both techniques\n\n\n\n8.4 Meet-in-the-Middle Attack\nPrinciple: exploits composite constructions of type \\(y = E_{K_2}(E_{K_1}(x))\\).\nMethod:\n\nBuild list \\(L_1\\): \\(L_1 = \\{E_{K_1}(x) \\mid K_1 \\in \\text{KeySpace}\\}\\)\nBuild list \\(L_2\\): \\(L_2 = \\{D_{K_2}(y) \\mid K_2 \\in \\text{KeySpace}\\}\\)\nIdentify repeated elements in \\(L_1\\) and \\(L_2\\)\nVerify hypothesis with second known plaintext\nThe associated keys \\(K_1\\) and \\(K_2\\) are probably the sought keys\n\nExample for DES:\nIntuitive key space for \\(E_{K_2}(E_{K_1}(x))\\): \\(\\{0,1\\}^{112}\\)\nActual effort:\n\n\\(2^{57}\\) operations to establish the two lists\n\\(2^{56}\\) blocks of 64 bits storage\nSignificantly lower than the intuitive \\(2^{112}\\)\n\nApplications:\n\nAttacks on composite constructions\nInternal cryptanalysis of block ciphers\n\n\n\n\n\n\ngraph TB\n    subgraph Meet_in_Middle\n        X[Known Plaintext x] --&gt; E1[Encrypt K1]\n        E1 --&gt; M[Middle Value m]\n        M --&gt; E2[Encrypt K2]\n        E2 --&gt; Y[Known Ciphertext y]\n        \n        X2[x] --&gt; L1[List L1: EK1 for all K1]\n        Y2[y] --&gt; L2[List L2: DK2 for all K2]\n        \n        L1 -.match.-&gt; Match[Find common m]\n        L2 -.match.-&gt; Match\n    end\n    \n    style M fill:#ffffcc\n    style Match fill:#ccffcc\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text (Cryptanalysis)\n\n\n\n\n\n\nBlock Cipher Cryptanalysis Techniques\nDifferential Cryptanalysis\n\nThis is a chosen plaintext attack that focuses on the propagation of differences in two plaintexts as they evolve through the different steps of the algorithm.\nIt assigns probabilities to keys it “guesses” based on the changes they induce on the ciphertexts. The most probable key has a good chance of being the correct key after a large number of plaintext/ciphertext pairs.\nRequires \\(2^{47}\\) chosen plaintext pairs (for DES) to obtain correct results.\n\nLinear Cryptanalysis\n\nThis is a known plaintext attack that creates a block simulator from linear approximations. By analyzing a large number of plaintext/ciphertext pairs, the bits of the simulator key tend to coincide with those of the analyzed block cipher (probabilistic calculation)\nFor DES an attack based on this technique requires \\(2^{38}\\) known plaintexts to obtain a probability of 10% of guessing correctly and \\(2^{43}\\) for 85% !\nIt is the most powerful analytical attack to date on block ciphers.\n\n\n\nBlock Cipher Cryptanalysis Techniques (II)\n\nThe practical implementation of differential and linear attacks presents difficulties in parallelizing calculations compared to an exhaustive key search.\nThese two attacks are very sensitive to the number of steps of the block cipher: chances of success increase exponentially as the number of algorithm steps decreases.\nA widespread conjecture among cryptographers is that these attacks, at the time unpublished, were known to the designers of DES. In particular, the design of the S-boxes offers a very high resistance to both techniques.\n\nMeet-in-the-Middle Attack\n\nApplies to constructions of the type \\(y := E_{K_2}(E_{K_1}(x))\\). For DES, the key space for this solution would be \\(\\{0,1\\}^{112}\\). First build two lists \\(L_1\\) and \\(L_2\\) of \\(2^{56}\\) messages of the form: \\(L_1 = E_{K_1}(x)\\) and \\(L_2 = D_{K_2}(y)\\) with \\(E\\) and \\(D\\) the encryption and decryption operations respectively. Then identify elements that repeat in both lists and verify our hypothesis with a second known plaintext. The \\(K_1\\) and \\(K_2\\) associated with this pair of known plaintexts will (in all likelihood) be the sought keys !\nEffort required to carry out the attacks (for DES): \\(2^{57}\\) operations to establish the two lists + \\(2^{56}\\) blocks of 64 bits of storage to memorize intermediate results… significantly lower than the intuitive \\(2^{112}\\)…\nThese meet-in-the-middle techniques are also applied to the internal cryptanalysis of block ciphers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (Cryptanalysis)\n\n\n\n\n\nDifferential: chosen plaintext, difference propagation, probabilities on keys, \\(2^{47}\\) pairs (DES).\nLinear: known plaintext, linear approximations, \\(2^{38}\\)-\\(2^{43}\\) plaintexts (DES), most powerful attack.\nMeet-in-Middle: composite constructions, 2 lists \\(2^{56}\\), effort \\(2^{57}\\) &lt;&lt; \\(2^{112}\\).\nSensitivity: very dependent on number of rounds."
  },
  {
    "objectID": "exam_notes_en.html#mathematical-foundations",
    "href": "exam_notes_en.html#mathematical-foundations",
    "title": "Fundamental Security Services",
    "section": "Mathematical Foundations",
    "text": "Mathematical Foundations\n\nFundamental Theorem of Arithmetic and Euler’s Totient Function\nAsymmetric cryptography relies on solid mathematical foundations from number theory. Two concepts are essential:\nFundamental Theorem of Arithmetic: Every positive integer greater than 1 can be written uniquely (up to order) as a product of prime powers:\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nEuler’s Totient Function \\(\\phi(n)\\): Number of positive integers smaller than \\(n\\) that are coprime with \\(n\\).\nTo compute \\(\\phi(n)\\):\n\\[\\phi(n) = \\prod_{i=1}^{m} p_i^{e_i} \\cdot \\left(1 - \\frac{1}{p_i}\\right)\\]\nImportant special case: If \\(n = p \\cdot q\\) with \\(p\\) and \\(q\\) prime, then:\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMathematical Foundations\nFundamental Theorem of Arithmetic: Every positive integer \\(n\\) can be written uniquely (up to order) as a product of powers of distinct prime numbers \\(p_i\\):\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nEuler’s Totient Function: Let \\(n \\in \\mathbb{Z}^+\\), the Euler’s totient function \\(\\phi(n)\\) is equal to the number of positive integers smaller than \\(n\\) that are relatively prime to \\(n\\).\nCalculation of Euler’s totient function: According to the fundamental theorem of arithmetic, every integer \\(n &gt; 1\\) can be written as:\n\\[n = \\prod_{i=1}^{m} p_i^{e_i}\\]\nthen \\(\\phi(n)\\) is calculated as:\n\\[\\phi(n) = \\prod_{i=1}^{m} \\left(p_i^{e_i} - p_i^{e_i-1}\\right)\\]\nIn particular, if \\(n = p \\cdot q\\) with \\(p\\) and \\(q\\) prime, then:\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nUnique decomposition: every integer = product of prime numbers\n\\(\\phi(n)\\): counts integers \\(&lt; n\\) coprime with \\(n\\)\nKey for RSA: if \\(n = pq\\) (primes) then \\(\\phi(n) = (p-1)(q-1)\\)\n\n\n\n\n\n\n\nEuler’s Theorem and Fermat’s Little Theorem\nThese theorems are at the heart of RSA and other asymmetric algorithms.\nEuler’s Theorem: If \\(n \\in \\mathbb{Z}^+\\) and \\(a \\in \\mathbb{Z}\\) with \\(\\text{gcd}(a,n) = 1\\), then:\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nFermat’s Little Theorem (special case if \\(n = p\\) prime): If \\(a \\in \\mathbb{Z}\\) and \\(p\\) prime does not divide \\(a\\):\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nImportant applications:\n\nExponent reduction: If \\(n\\) is a product of distinct primes and \\(r \\equiv s \\pmod{\\phi(n)}\\), then: \\[a^r \\equiv a^s \\pmod{n}\\]\nCalculation of inverses: \\(a^{\\phi(n)-1}\\) is the inverse of \\(a\\) modulo \\(n\\). In particular, if \\(p\\) is prime, \\(a^{p-2}\\) is the inverse of \\(a\\) modulo \\(p\\).\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMathematical Foundations (II)\nEuler’s Theorem: Let \\(n \\in \\mathbb{Z}^+\\) and \\(a \\in \\mathbb{Z}\\) with \\(\\text{gcd}(a,n) = 1\\), then we have:\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nFermat’s Little Theorem (special case of Euler’s theorem if \\(n\\) is prime): Let \\(a \\in \\mathbb{Z}\\) and \\(p\\) a prime number such that \\(p\\) does not divide \\(a\\), then we have:\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nNote that since \\(p\\) is prime, we have \\(\\phi(p) = p-1\\).\nExponent reduction \\(\\bmod \\phi(n)\\): If \\(n\\) is the product of distinct primes and \\(r, s \\in \\mathbb{Z}\\) such that \\(r \\equiv s \\pmod{\\phi(n)}\\) then \\(\\forall a \\in \\mathbb{Z}\\):\n\\[a^r \\equiv a^s \\pmod{n}\\]\nApplication of Euler’s Theorem to inverse calculation: From Euler’s theorem, we have that:\n\\[a \\cdot a^{\\phi(n)-1} \\equiv 1 \\pmod{n}\\]\nwhich means that \\(a^{\\phi(n)-1}\\) is the inverse of \\(a\\) modulo \\(n\\). In particular, \\(a^{p-2}\\) is the inverse of \\(a\\) modulo \\(n\\) if \\(p\\) is prime.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nEuler’s Theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\nFermat: special case if \\(p\\) prime: \\(a^{p-1} \\equiv 1 \\pmod{p}\\)\nModular inverse: \\(a^{-1} \\equiv a^{\\phi(n)-1} \\pmod{n}\\)\nBase of RSA: enables encryption/decryption with exponents\n\n\n\n\n\n\n\nMultiplicative Groups and Generators\nMultiplicative group \\(\\mathbb{Z}_n^*\\): Set of elements of \\(\\mathbb{Z}_n\\) coprime with \\(n\\):\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{gcd}(a,n) = 1\\}\\]\nIf \\(n\\) is prime: \\(\\mathbb{Z}_n^* = \\{1, 2, \\ldots, n-1\\}\\)\nOrder of an element: Smallest positive integer \\(t\\) such that \\(a^t \\equiv 1 \\pmod{n}\\)\nGenerator: An element \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) if its order is \\(\\phi(n)\\). Then \\(\\mathbb{Z}_n^*\\) is said to be cyclic.\nProperties of generators:\n\n\\(\\mathbb{Z}_n^*\\) has a generator iff \\(n = 2, 4, p^k\\) or \\(2p^k\\) (with \\(p\\) prime, \\(p \\neq 2\\) and \\(k \\geq 1\\))\nIf \\(p\\) is prime, \\(\\mathbb{Z}_p^*\\) always has a generator\nIf \\(\\alpha\\) is a generator, all elements can be written as: \\(\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i &lt; \\phi(n)\\}\\)\nThe number of generators is \\(\\phi(\\phi(n))\\)\n\nGenerator test\n\n\\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) iff for every prime \\(p\\) dividing \\(\\phi(n)\\), \\(\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\)\nif \\(n = 2p+1\\) is a “safe prime” with \\(p\\) prime: \\(\\alpha\\) is a generator iff \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) and \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMathematical Foundations (III)\nDefinition: The multiplicative group of \\(\\mathbb{Z}_n\\), denoted \\(\\mathbb{Z}_n^*\\) is:\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{gcd}(a,n) = 1\\}\\]\nIn particular, if \\(n\\) is prime: \\(\\mathbb{Z}_n^* = \\{a \\mid 1 \\leq a \\leq n-1\\}\\)\nThe number of elements or order of the multiplicative group \\(\\mathbb{Z}_n^*\\) is \\(\\phi(n)\\) (by definition of \\(\\phi\\)).\nDefinition: Let \\(a \\in \\mathbb{Z}_n\\), the order of \\(a\\) is the smallest positive integer \\(t\\) for which:\n\\[a^t \\equiv 1 \\pmod{n}\\]\nDefinition: Let \\(\\alpha \\in \\mathbb{Z}_n^*\\), if the order of \\(\\alpha\\) is \\(\\phi(n)\\), then \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\). When a group \\(\\mathbb{Z}_n^*\\) has a generator, it is said to be cyclic.\nProperties of generators:\n\n\\(\\mathbb{Z}_n^*\\) has a generator iff \\(n = 2, 4, p^k\\) or \\(2p^k\\), with \\(p\\) prime, \\(p \\neq 2\\) and \\(k \\geq 1\\). In particular, if \\(p\\) is prime, \\(\\mathbb{Z}_p^*\\) has a generator.\nIf \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\), then all elements of \\(\\mathbb{Z}_n^*\\) can be written as: \\[\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i \\leq \\phi(n)-1\\}\\]\nThe number of generators of \\(\\mathbb{Z}_n^*\\) is \\(\\phi(\\phi(n))\\).\n\\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) iff for every prime \\(p\\) dividing \\(\\phi(n)\\), we have: \\[\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\]\n\nIn particular if \\(n\\) is a prime of the form \\(n = 2p+1\\) with \\(p\\) prime (such \\(n\\) is called a safe prime), \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) iff \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) and \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\n\\(\\mathbb{Z}_n^*\\): elements coprime with \\(n\\), cardinality = \\(\\phi(n)\\)\nGenerator: element of order \\(\\phi(n)\\) (generates the entire group)\nCrucial for DH and ElGamal: security based on discrete logarithm in cyclic group\nSafe prime: \\(n = 2p+1\\) with \\(p\\) and \\(n\\) prime\n\n\n\n\n\n\n\nFast Exponentiation\nEfficient computation of \\(a^k \\bmod n\\) in polynomial time, essential for all asymmetric algorithms.\nPrinciple: Use the binary representation of the exponent \\(k\\).\nExample: Computation of \\(2^{644} \\bmod 645\\)\n\nBinary representation: \\((644)_{10} = (1010000100)_2\\)\nCompute successive powers of 2 modulo 645:\n\n\\(2^1 \\bmod 645\\)\n\\(2^2 \\bmod 645\\)\n\\(2^4 \\bmod 645\\)\n\\(2^8 \\bmod 645\\)\n…\n\\(2^{512} \\bmod 645\\)\n\nCombine according to bits set to 1: \\(2^{644} = 2^{512} \\cdot 2^{128} \\cdot 2^4\\)\n\nComplexity: \\(O(\\log^3 n)\\) - very efficient!\nApplication: Computation of the inverse using Euler’s theorem in polynomial time.\nAlternative: Extended Euclidean algorithm to find \\(x\\) such that \\(ax \\equiv 1 \\pmod{n}\\) by solving \\(ax - kn = 1 = \\text{gcd}(a,n)\\). Complexity also \\(O(\\log^3 n)\\).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nFast Exponentiation\nFast exponentiation: Using the binary representation of a number, we can compute powers very efficiently.\nExample: computation of \\(2^{644} \\bmod 645\\)\n\\((644)_{10} = (1010000100)_2\\)\nNow, we compute the exponents corresponding to the powers of 2, namely:\n\\[2^1 \\bmod 645, \\quad 2^2 \\bmod 645, \\quad 2^4 \\bmod 645, \\quad \\ldots, \\quad 2^{512} \\bmod 645\\]\nFrom the binary representation, we compute:\n\\[2^{644} = 2^{512+128+4} = 2^{512} \\cdot 2^{128} \\cdot 2^4 = 160 \\cdot 153 \\cdot 6 \\bmod 645\\]\nThe complexity of this algorithm fast exponentiation is \\(O(\\log^3 n)\\).\nBy relying on Euler’s theorem, the computation of the inverse of a number in such a group is therefore performed in polynomial time.\nThe extended Euclidean algorithm can also be used to find an \\(x\\) such that:\n\\[ax \\equiv 1 \\pmod{n}\\]\nsince this congruence can be written as: \\(ax - 1 = kn\\) and therefore:\n\\[ax - kn = 1 = \\text{gcd}(a,n)\\]\nThe complexity of this algorithm is also \\(O(\\log^3 n)\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nIdea: binary representation of the exponent\nComplexity: \\(O(\\log^3 n)\\) - polynomial!\nEssential: makes RSA, ElGamal, DH practical\nAlternative: extended Euclidean algorithm for inverses\n\n\n\n\n\n\n\nChinese Remainder Theorem (CRT)\nThe CRT allows solving systems of simultaneous congruences, with important applications in cryptography.\nTheorem: Let \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) pairwise coprime (gcd\\((n_i, n_j) = 1\\) if \\(i \\neq j\\)) and \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Then the system:\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\nhas a unique solution \\(x \\bmod N\\) with \\(N := n_1 \\cdot n_2 \\cdots n_t\\).\nGauss’s algorithm (1801) to compute \\(x\\):\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\nwith:\n\n\\(N_i = N/n_i\\)\n\\(M_i = N_i^{-1} \\bmod n_i\\) (modular inverse)\n\nComplexity: \\(O(\\log^3 n)\\) - polynomial!\nCryptographic applications:\n\nAcceleration of RSA computations (use \\(p\\) and \\(q\\) separately)\nSecret sharing (secret sharing schemes)\nCertain attacks on RSA (if small exponent and multiple messages)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nChinese Remainder Theorem\nThe Chinese Remainder Theorem (3rd century!) allows solving linear systems of simultaneous congruences. It solves problems raised in ancient Chinese puzzles. It was, for example, about finding a number that produces a remainder of 1 when divided by 3, of 2 when divided by 5 and of 3 when divided by 7… It was also used to calculate the exact moment of alignment of several celestial bodies having different orbits (and therefore periods).\nChinese Remainder Theorem: Let \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) be pairwise coprime (i.e., gcd\\((n_i, n_j) = 1\\), \\(\\forall i \\neq j\\)) and \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Then, the system of congruences:\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\nhas a unique solution \\(x \\bmod N := n_1 n_2 \\cdots n_t\\)\nGauss’s algorithm (1801) for the computation of \\(x\\):\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\nwith \\(N_i = N/n_i\\) and \\(M_i = N_i^{-1} \\bmod n_i\\).\nThe complexity of this algorithm is \\(O(\\log^3 n)\\).\nIt is therefore possible in polynomial time to go from congruences mod \\(n_i\\) to congruences mod \\(N\\)!\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSolves: systems of congruences with pairwise coprime moduli\nUnique solution: modulo product of moduli\nComplexity: \\(O(\\log^3 n)\\) (polynomial)\nCrypto usage: RSA optimization, attacks if small exponent"
  },
  {
    "objectID": "exam_notes_en.html#basic-problems-and-complexity",
    "href": "exam_notes_en.html#basic-problems-and-complexity",
    "title": "Fundamental Security Services",
    "section": "Basic Problems and Complexity",
    "text": "Basic Problems and Complexity\n\nClassification of Hard Problems\nThe security of asymmetric cryptography relies on mathematical problems reputed to be hard:\nGeneric problems:\n\nFactorization (FACTP): Given \\(n\\), find its factorization into prime numbers\n\nBase of RSA and Rabin\n\nDiscrete Logarithms (DLP): Given prime \\(p\\), a generator \\(\\alpha \\in \\mathbb{Z}_p^*\\) and \\(\\beta \\in \\mathbb{Z}_p^*\\), find \\(x\\) such that: \\[\\alpha^x \\equiv \\beta \\pmod{p}\\]\n\nBase of ElGamal and Diffie-Hellman\n\nSquare Root modulo composite (SQROOTP): Given composite \\(n\\) and a quadratic residue \\(a\\), find \\(\\sqrt{a} \\bmod n\\)\n\nBase of Rabin\n\n\nSpecific problems:\n\nRSA Problem (RSAP): Given \\(n = pq\\), \\(e\\) with gcd\\((e, \\phi(n)) = 1\\) and \\(c\\), find \\(m\\) such that \\(m^e \\equiv c \\pmod{n}\\)\nDiffie-Hellman Problem (DHP): Given prime \\(p\\), generator \\(\\alpha\\), \\(\\alpha^a \\bmod p\\) and \\(\\alpha^b \\bmod p\\), find \\(\\alpha^{ab} \\bmod p\\)\n\nProven equivalences:\n\nDHP ⟺ DLP (equivalent under certain conditions)\nRSAP ⟺ FACTP (proven equivalent for the generic case)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nBasic Problems\nMain generic problems:\n\nFactorization (FACTP): Given a positive integer \\(n\\), find its factorization into prime numbers.\nDiscrete Logarithms (DLP): Given a prime number \\(p\\), a generator \\(\\alpha \\in \\mathbb{Z}_p^*\\) and an element \\(\\beta \\in \\mathbb{Z}_p^*\\), find the integer \\(x\\), \\(0 \\leq x \\leq p-2\\), such that: \\(\\alpha^x \\equiv \\beta \\pmod{p}\\).\nSquare Root in \\(\\mathbb{Z}_n\\) if \\(n\\) is composite (SQROOTP): Given a composite integer \\(n\\) and a quadratic residue \\(a\\), find the square root of \\(a\\) mod \\(n\\).\n\nSpecific problems (proper to an encryption system):\n\nRSA (RSAP): Given a positive integer \\(n = pq\\), a positive integer \\(e\\) with gcd\\((e, (p-1)(q-1)) = 1\\) and an integer \\(c\\), find an integer \\(m\\) with \\(m^e \\equiv c \\pmod{n}\\).\nDiffie-Hellman (DHP): Given a prime number \\(p\\), a generator \\(\\alpha \\in \\mathbb{Z}_p^*\\) and the elements \\(\\alpha^a \\bmod p\\) and \\(\\alpha^b \\bmod p\\), find \\(\\alpha^{ab} \\bmod p\\).\n\nProven results:\n\nDHP ⟺ DLP (Equivalent under certain conditions)\nRSAP ⟺ FACTP (Proven equivalent for the generic problem)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nFACTP: factor \\(n\\) → base of RSA/Rabin\nDLP: find discrete logarithm → base ElGamal/DH\nSQROOTP: square root mod composite → Rabin\nEquivalences: breaking = solving the base problem\n\n\n\n\n\n\n\nFactorization Techniques\nThe security of RSA depends on the difficulty of factoring large numbers.\nExponential time methods: \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division (successive division)\nSieve of Eratosthenes (2nd century BC)\nFermat’s Method (~1650)\nPollard’s \\(\\rho\\) Method (1975)\nPollard’s \\(p-1\\) Method (1974)\n\nSub-exponential time methods: \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981) - very effective in practice\nNumber Field Sieve - NFS (1990) - currently the fastest\nGeneral Number Field Sieve - GNFS (2006)\n\nPolynomial time methods:\n\nShor’s Algorithm (1994): \\(O(\\log^c n)\\) on quantum computer\n\nCurrent records (2020):\n\nLargest number factored: RSA-829 (250 digits, 829 bits)\nComputation time: 2700 core-years (Intel Xeon Gold 6130 CPUs)\nMethod: General Number Field Sieve\n\nImplications:\n\nRSA keys &lt; 1024 bits: vulnerable\nRSA keys 1024 bits: limits (states with significant resources)\nRecommendation: 2048 bits minimum (3072-4096 for long term)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nClassical Factoring Techniques and New Developments\nExponential time: \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division\nEratosthenes’ Sieve (II B.C.)\nFermat’s Difference of Squares Method (~1650)\nSquare Form Factorization (1971)\nPollard’s p-1 method (1974)\nPollard’s Rho Method (1975)\n\nSub-exponential time: \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981)\nNumber Field Sieve - NFS (1990)\nGeneral Number Field Sieve - GNFS (2006)\n\nPolynomial time:\n\nShor’s Algorithm in a Quantum Computer (1994): \\(O(\\log^c n)\\)\n\nRecent developments:\n\nBernstein’s specific NFS computer to factor a 1536-bit number would take the same time as a 512-bit computation on a conventional machine\nLargest factorization to date (2020): RSA-829 (250-digit number) using NFS\nTotal computation time: 2700 core-years (Intel Xeon Gold 6130 CPUs at 2.1GHz)\n\nFactorization on quantum computer:\n\nSignificant problems (errors, dispersion, etc.)\n2001: 7-qubit computer (IBM Almaden)\nFeasibility of a computer with millions of qubits… ?\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSub-exponential: NFS currently the fastest\nRecord 2020: RSA-829 (829 bits) in 2700 core-years\nRecommendation: keys ≥ 2048 bits for RSA\nFuture threat: quantum computers (Shor)"
  },
  {
    "objectID": "exam_notes_en.html#the-rsa-algorithm",
    "href": "exam_notes_en.html#the-rsa-algorithm",
    "title": "Fundamental Security Services",
    "section": "The RSA Algorithm",
    "text": "The RSA Algorithm\n\nRSA Operation (Encryption/Decryption)\nRSA (Rivest-Shamir-Adleman, 1978) is the most used asymmetric algorithm.\nKey generation:\n\nChoose two large prime numbers \\(p\\) and \\(q\\) (≥ 1024 bits each)\nCompute \\(n := p \\cdot q\\) and \\(\\phi(n) = (p-1)(q-1)\\)\nChoose encryption exponent \\(e\\) with:\n\n\\(1 &lt; e &lt; \\phi(n)\\)\ngcd\\((e, \\phi(n)) = 1\\)\n\nCompute decryption exponent \\(d\\) such that: \\[e \\cdot d \\equiv 1 \\pmod{\\phi(n)}\\] (using extended Euclidean algorithm or fast exponentiation)\n\nResulting keys:\n\nPublic key: \\((n, e)\\)\nPrivate key: \\(d\\) (keep \\(p\\) and \\(q\\) secret too!)\n\nEncryption (by Bob, to Alice):\n\nObtain authentic public key \\((n, e)\\) of Alice\nTransform plaintext into integers \\(m_i \\in [0, n-1]\\)\nCompute ciphertexts: \\(c_i := m_i^e \\bmod n\\)\nSend the \\(c_i\\) to Alice\n\nDecryption (by Alice):\n\nUse private key \\(d\\) to compute: \\[m_i = c_i^d \\bmod n\\]\n\nProof of operation:\n\\[c^d \\equiv (m^e)^d \\equiv m^{ed} \\pmod{n}\\]\nSince \\(ed \\equiv 1 \\pmod{\\phi(n)}\\), there exists \\(k\\) such that \\(ed = 1 + k\\phi(n)\\), therefore:\n\\[c^d \\equiv m^{1+k\\phi(n)} \\equiv m \\cdot (m^{\\phi(n)})^k \\equiv m \\cdot 1^k \\equiv m \\pmod{n}\\]\n(by Euler’s theorem)\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRSA Encryption/Decryption Procedure and Proof\nKey generation:\n\nEach entity (A) creates a key pair (public and private) as follows:\n\nA chooses the size of the modulus \\(n\\) (e.g., size\\((n) = 1024\\) or size\\((n) = 2048\\)).\nA generates two prime numbers \\(p\\) and \\(q\\) of large size \\((n/2)\\).\nA computes \\(n := pq\\) and \\(\\phi(n) = (p-1)(q-1)\\).\nA generates the encryption exponent \\(e\\), with \\(1 &lt; e &lt; \\phi(n)\\) such that gcd\\((e, \\phi(n)) = 1\\).\nA computes the decryption exponent \\(d\\), such that: \\(ed \\equiv 1 \\pmod{\\phi(n)}\\) using the extended Euclidean algorithm or fast exponentiation.\n\nThe pair \\((n,e)\\) is A’s public key; \\(d\\) is A’s private key.\n\nEncryption:\n\nEntity B obtains \\((n,e)\\), the authentic public key of A.\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, n-1]\\) \\(\\forall i\\).\nB computes the ciphertext \\(c_i := m_i^e \\bmod n\\), \\(\\forall i\\) using fast exponentiation.\nB sends to A all the ciphertexts \\(c_i\\).\n\nDecryption:\n\nA uses its private key to compute the plaintexts \\(m_i = c_i^d \\bmod n\\).\n\nProof: Let \\(m\\) be the plaintext and \\(c\\) the ciphertext with \\(c := m^e \\bmod n\\), we need to prove: \\(m \\stackrel{!}{=} c^d \\bmod n\\)\nSubstituting \\(c\\) by its value we obtain: \\[c^d \\bmod n = m^{ed} \\bmod n \\quad (*)\\]\nbut, we know that: \\[ed \\equiv 1 \\pmod{\\phi(n)}\\]\nand therefore by definition of congruences, there exists an integer \\(k\\) with: \\[ed - 1 = k\\phi(n)\\]\nsubstituting in (*): \\[c^d \\equiv m^{k\\phi(n)+1} \\equiv m^{k\\phi(n)} \\cdot m \\pmod{n}\\]\nIf gcd\\((m,n) = 1\\), we have by Euler’s theorem: \\[m^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\ntherefore: \\[c^d \\equiv (m^{\\phi(n)})^k \\cdot m \\equiv m \\pmod{n}\\] Q.E.D. !\nIf gcd\\((m,n) \\neq 1\\), \\(m\\) is necessarily a multiple of \\(p\\) or \\(q\\) (very unlikely case…), we can show by doing the calculations mod \\(p\\) and mod \\(q\\) that the congruence remains true.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nPublic key: \\((n, e)\\) with \\(n = pq\\)\nPrivate key: \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\nEncryption: \\(c = m^e \\bmod n\\)\nDecryption: \\(m = c^d \\bmod n\\)\nSecurity: based on difficulty of factoring \\(n\\)\n\n\n\n\n\n\n\n\n\ngraph LR\n    A[Plaintext m] --&gt;|Encryption: m^e mod n| B[Ciphertext c]\n    B --&gt;|Decryption: c^d mod n| C[Plaintext m]\n    D[Public key: n, e] -.-&gt;|used for| A\n    E[Private key: d] -.-&gt;|used for| B\n    F[p, q secret primes] --&gt;|n = pq| D\n    F --&gt;|φn = p-1q-1| E\n\n\n\n\n\n\n\n\n\nRSA Security\nEquivalence RSA problem ⟺ Factorization:\n\nFinding \\(d\\) ⟺ factoring \\(n\\) (proven equivalent)\nDecrypting without \\(d\\) is not proven as hard as factoring, but…\nNo method faster than factoring is known\n\nFactorization complexity:\n\nFastest methods: \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\) (sub-exponential)\nComputationally impossible for \\(n \\geq 1024\\) bits\nCurrent recommendation: 2048 bits minimum (3072-4096 for long-term security)\n\nChoice of exponents:\n\nEncryption exponent \\(e\\):\n\nOften small for speed: \\(e = 3, 17, 65537\\) (common)\nCaution: if \\(e\\) too small AND \\(m &lt; n^{1/e}\\), attack possible (\\(e\\)-th root in \\(\\mathbb{Z}\\))\nSolution: randomization (padding) of the message\n\nDecryption exponent \\(d\\):\n\nMust be large: at least half the size of \\(n\\)\nIf \\(d\\) small: vulnerable to Wiener’s attack\n\n\nPerformance consequence:\n\nFast encryption (\\(e\\) small)\nSlow decryption (\\(d\\) large)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRSA: Security\nThe RSAP problem of finding \\(m\\) from \\(c\\) is not proven to be as hard as factorization but…:\n\nWe can prove that if we find \\(d\\) we can easily compute \\(p\\) and \\(q\\). This is equivalent to saying that factoring \\(n\\) and finding \\(d\\) require equivalent computational effort.\nWe know that the fastest methods for factoring have a sub-exponential complexity \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\). The problem therefore remains computationally impossible for modulus \\(\\geq 1048\\) bits (2048 bits is a frequent choice for long-term security…).\nTo improve encryption speed, we tend to choose relatively small exponents \\(e\\) (typically: \\(e := 3\\), \\(e := 17\\) and \\(e := 19\\)). However, it has been proven that computing an \\(i\\)-th root (with small \\(i\\)) modulo a composite \\(n\\) can be significantly easier than factoring \\(n\\). On the other hand, in 2008 it was proven that the generic RSA problem is equivalent to factorization.\nThe decryption exponent \\(d\\) must imperatively be large (at least half the size of \\(n\\)) to guarantee the system’s security.\nConsequently, encryption is normally significantly faster than decryption since the exponents used are much smaller!\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSecurity: based on difficulty of FACTP (factorization)\nRecommended size: \\(n \\geq 2048\\) bits\nSmall \\(e\\): fast encryption (3, 17, 65537)\nLarge \\(d\\): at least \\(\\text{size}(n)/2\\)\nSeparate keys: encryption ≠ signature\n\n\n\n\n\n\n\nAttacks on RSA\n\nAttack on small exponent with same message\nIf the same message \\(m\\) is sent to 3 recipients with \\(e = 3\\):\n\n\\(c_1 \\equiv m^3 \\pmod{n_1}\\)\n\\(c_2 \\equiv m^3 \\pmod{n_2}\\)\n\\(c_3 \\equiv m^3 \\pmod{n_3}\\)\n\nThe Chinese Remainder Theorem gives a unique solution \\(x \\bmod n_1n_2n_3\\) such that: \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nIf \\(m^3 &lt; n_1n_2n_3\\) (often true), then \\(x = m^3\\) in \\(\\mathbb{Z}\\) and we can compute \\(m\\) by simply taking the integer cube root!\nProtection: always randomize the message before encryption (OAEP padding)\n\n\nAttack if message small\nIf \\(m &lt; n^{1/e}\\), then \\(m^e &lt; n\\), so \\(c = m^e\\) (in \\(\\mathbb{Z}\\), not modulo). We can directly compute the \\(e\\)-th root!\nProtection: padding mandatory\n\n\nMultiplicative property\n\\[E(m_1) \\cdot E(m_2) \\equiv (m_1 \\cdot m_2)^e \\equiv E(m_1 \\cdot m_2) \\pmod{n}\\]\nAllows chosen-ciphertext attacks and blind signatures.\n\n\nGeneral attack\nThe most effective method remains factoring \\(n\\) (if parameters well chosen and implementation correct).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRSA: Attacks\nWhen we want to encrypt the same message for a group of correspondents, it is advisable to introduce variations (randomization) before encryption to avoid the following attack:\nAssume we compute ciphertexts \\(c_1, c_2, c_3\\) from the same plaintext \\(m\\) and the same exponent \\(e := 3\\) addressed to three entities with modulus: \\(n_1, n_2, n_3\\).\nThe Chinese Remainder Theorem tells us that there exists a solution \\(x \\bmod n_1n_2n_3\\), such that: \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nBut if \\(m\\) does not change for the three encryptions, we have that \\(x = m^3 \\bmod n_1n_2n_3\\) and, moreover: \\(m^3 &lt; n_1n_2n_3\\). We can, therefore, find \\(m\\) by computing the integer cube root of \\(m^3\\), knowing that for this calculation there exist efficient algorithms!\nMore generally, if \\(m &lt; n^{1/e}\\), we can apply fast algorithms (in \\(\\mathbb{Z}\\)) to compute the \\(e\\)-th roots of \\(m^e\\). It is therefore advisable to perform “randomization” of \\(m\\) before encrypting!\nThe multiplicative property of RSA: \\((m_1 m_2)^e \\equiv m_1^e \\cdot m_2^e \\equiv c_1 \\cdot c_2 \\pmod{n}\\)\ngives rise to dangerous vulnerabilities (see blind signatures).\nAssuming parameters are correctly chosen and the implementation has no flaws, the most effective method to “break” the generic RSA algorithm remains factoring \\(n\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSame message, small \\(e\\): CRT allows extracting \\(m\\)!\nMessage too small: \\(m &lt; n^{1/e}\\) → direct root\nMultiplicative property: \\(E(m_1) \\cdot E(m_2) = E(m_1 m_2)\\)\nProtection: always padding/randomization (OAEP)"
  },
  {
    "objectID": "exam_notes_en.html#the-elgamal-algorithm",
    "href": "exam_notes_en.html#the-elgamal-algorithm",
    "title": "Fundamental Security Services",
    "section": "The ElGamal Algorithm",
    "text": "The ElGamal Algorithm\nAsymmetric system (1985) based on the discrete logarithm problem (DLP).\nKeys:\n\nChoose prime \\(p\\), generator \\(\\alpha \\in \\mathbb{Z}_p^*\\), secret \\(a\\)\nCompute \\(y = \\alpha^a \\bmod p\\)\nPublic: \\((p, \\alpha, y)\\) | Private: \\(a\\)\n\nEncryption: For message \\(m\\), choose unique random \\(k\\)\n\n\\(\\gamma = \\alpha^k \\bmod p\\)\n\\(\\delta = m \\cdot y^k \\bmod p\\)\nSend \\((\\gamma, \\delta)\\)\n\nDecryption: \\(m = \\delta \\cdot \\gamma^{-a} \\bmod p\\)\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nElGamal Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates a prime number \\(p\\) (len(\\(p\\)) ≥ 1024 bits) and a generator \\(\\alpha\\) of the multiplicative group \\(\\mathbb{Z}_p^*\\)\nA generates a random number \\(a\\), such that \\(1 \\leq a \\leq p-2\\) and computes \\(y := \\alpha^a \\bmod p\\)\nThe public key of A is \\((p, \\alpha, y)\\), the private key of A is \\(a\\)\n\nEncryption\n\nEntity B obtains \\((p, \\alpha, \\alpha^a \\bmod p)\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nFor each message \\(m_i\\):\n\nB generates a unique random number \\(k\\), such that \\(1 \\leq k \\leq p-2\\)\nB computes \\(\\gamma := \\alpha^k \\bmod p\\) and \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) and sends the ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA uses its private key \\(a\\) to compute \\(\\gamma^{p-1-a} \\bmod p\\) (note that: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrieves the plaintext by computing: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBase: DLP in \\(\\mathbb{Z}_p^*\\)\nCiphertext: \\((\\alpha^k, m \\cdot y^k)\\)\nSecurity: \\(k\\) must be unique and large\nDisadvantage: doubles message size\n\n\n\n\nEssential Remarks\n\nProof: \\(\\delta \\cdot \\gamma^{-a} = m \\cdot (\\alpha^a)^k \\cdot (\\alpha^k)^{-a} = m \\bmod p\\)\nSecurity: based on DLP (complexity sub-exponential close to factorization)\nExponents: \\(k\\) and \\(a\\) must be large (otherwise vulnerable to baby-step giant-step)\nReuse prohibited: if \\(k\\) repeated, \\(\\delta_1/\\delta_2 = m_1/m_2\\) reveals the messages\nMajor disadvantage: ×2 expansion of ciphertext size\nGeneralization: works on \\(GF(2^n)\\) or elliptic curves\n\n\n\n\n\n\n\nNoteOriginal Text - Remarks\n\n\n\n\n\nProof that the scheme works: If \\(s \\equiv k^{-1}(m_h - ar) \\bmod (p-1)\\), we have that: \\(m_h \\equiv (ar + ks) \\bmod (p-1)\\) and \\(v_2 = \\alpha^{H(m)} \\bmod p\\). If, as we wish to show \\(m_h = H(m)\\), by reducing exponents mod \\((p-1)\\), we can rewrite \\(v_2\\): \\(v_2 \\equiv \\alpha^{ar+ks} \\bmod p\\). On the other hand: \\(v_1 = y^r\\alpha^{rs} \\equiv \\alpha^{ar}\\alpha^{ks} \\equiv \\alpha^{ar+ks} \\bmod p\\).\nThe ElGamal procedure is based on the difficulty of computing discrete logarithms modulo a prime number (DLP problem) even though it has not been proven to be strictly equivalent to this problem.\nThe most efficient algorithms known have a sub-exponential complexity very close to that of factorization (we often use the same algorithms).\nThe chosen exponents (\\(k\\), \\(a\\)) must be large because there exist efficient algorithms to compute discrete logarithms modulo a prime number when the exponent is small (baby-step giant-step algorithm).\nA disadvantage of ElGamal is that it multiplies the ciphertext length by 2.\nIt is essential for the security of the procedure that the random number \\(k\\) is not repeated, otherwise: let \\((\\gamma_1, \\delta_1)\\) and \\((\\gamma_2, \\delta_2)\\) be the two generated ciphertexts, we have that \\(\\delta_1/\\delta_2 = m_1/m_2\\) and consequently, it is trivial to recover one plaintext from the other.\nThe ElGamal procedure can be generalized to other groups like \\(GF(2^n)\\) or elliptic curves.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Remarks\n\n\n\n\n\nEquivalence: based on DLP (not proven equivalent)\n\\(k\\) unique: CRITICAL - otherwise \\(m_1/m_2\\) revealed\nKey size: large exponents necessary\nExtensions: \\(GF(2^n)\\), elliptic curves"
  },
  {
    "objectID": "exam_notes_en.html#elgamal-encryptiondecryption-procedure",
    "href": "exam_notes_en.html#elgamal-encryptiondecryption-procedure",
    "title": "Fundamental Security Services",
    "section": "ElGamal Encryption/Decryption Procedure",
    "text": "ElGamal Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates a prime number \\(p\\) (len(\\(p\\)) ≥ 1024 bits) and a generator \\(\\alpha\\) of the multiplicative group \\(\\mathbb{Z}_p^*\\)\nA generates a random number \\(a\\), such that \\(1 \\leq a \\leq p-2\\) and computes \\(y := \\alpha^a \\bmod p\\)\nThe public key of A is \\((p, \\alpha, y)\\), the private key of A is \\(a\\)\n\nEncryption\n\nEntity B obtains \\((p, \\alpha, \\alpha^a \\bmod p)\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nFor each message \\(m_i\\):\n\nB generates a unique random number \\(k\\), such that \\(1 \\leq k \\leq p-2\\)\nB computes \\(\\gamma := \\alpha^k \\bmod p\\) and \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) and sends the ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA uses its private key \\(a\\) to compute \\(\\gamma^{p-1-a} \\bmod p\\) (note that: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrieves the plaintext by computing: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)"
  },
  {
    "objectID": "exam_notes_en.html#rabin-algorithm",
    "href": "exam_notes_en.html#rabin-algorithm",
    "title": "Fundamental Security Services",
    "section": "Rabin Algorithm",
    "text": "Rabin Algorithm\nAsymmetric system equivalent to factorization (provably secure).\nKeys:\n\nGenerate two primes \\(p\\), \\(q\\) (≥1024 bits total), compute \\(n = pq\\)\n\nPublic: \\(n\\)\nPrivate: \\((p, q)\\)\n\n\nEncryption: \\(c = m^2 \\bmod n\\)\nDecryption:\n\nCompute the 4 square roots of \\(c \\bmod n\\) (via roots mod \\(p\\) and mod \\(q\\))\nIdentify the correct message by redundancy\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRabin Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates two random prime numbers \\(p\\) and \\(q\\) of large size (len(\\(pq\\)) ≥ 1024)\nA computes \\(n := pq\\)\nThe public key of A is \\(n\\), the private key of A is \\((p, q)\\)\n\nEncryption\n\nEntity B obtains \\(n\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB computes \\(c_i = m_i^2 \\bmod n\\) for each message \\(m_i\\)\nB sends all the ciphertexts \\(c_i\\) to A\n\nDecryption\n\nA uses its private key \\((p, q)\\) to retrieve the 4 solutions of the equation: \\(c_i = x^2 \\bmod n\\) using efficient algorithms to compute square roots \\(\\bmod p\\) and \\(\\bmod q\\)\nA determines either by an additional indication from B, or by redundancy analysis which of the 4 messages \\(m_1, m_2, m_3, m_4\\) is the original plaintext\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBase: SQROOTP (square root mod composite)\nAdvantage: proven equivalent to factorization\nProblem: 4 possible solutions, requires redundancy\nVulnerability: chosen-ciphertext attack reveals factors\n\n\n\n\nEssential Remarks\n\nProven security: SQROOTP ⟺ FACTP (only algorithm with proven equivalence)\nChosen-ciphertext attack: if A decrypts \\(c = m^2 \\bmod n\\) chosen by adversary M\n\nM receives a root \\(m_x\\) among 4 possible\nIf \\(m \\neq m_x \\bmod n\\) (prob. 0.5), then \\(\\gcd(m - m_x, n)\\) gives a factor of \\(n\\)\n\nSolution: require sufficient redundancy to identify unique solution without ambiguity\n\n\n\n\n\n\n\nNoteOriginal Text - Remarks\n\n\n\n\n\nThe Rabin procedure is based on the impossibility of finding square roots modulo a composite of unknown factorization (SQROOTP problem).\nThe main interest of this algorithm lies in the fact that it has been proven to be equivalent to factorization (SQROOTP ⟺ FACTP). This algorithm therefore belongs to the provably secure category for any passive attack.\nActive attacks can, in some cases, compromise the algorithm’s security. More precisely, if we mount the following chosen ciphertext attack:\n\nThe attacker M generates an \\(m\\) and sends to A the ciphertext \\(c = m^2 \\bmod n\\).\nA responds with a root \\(m_x\\) among the 4 possible \\(m_1, m_2, m_3, m_4\\).\nIf \\(m \\neq m_x \\bmod n\\) (probability 0.5), M repeats with a new \\(m\\).\nOtherwise, A computes \\(\\gcd(m - m_x, n)\\) and thus obtains one of the two factors of \\(n\\).\n\nThis attack could be avoided if the procedure required sufficient redundancy in the plaintexts allowing A to identify without ambiguity which of the possible solutions is the original plaintext. In this case, A would always respond with \\(m\\) and discard the other solutions that do not have the predefined level of redundancy.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Remarks\n\n\n\n\n\nUnique: only algorithm proven equivalent to FACTP\nAttack: chosen-ciphertext gives factors (prob. 0.5)\nCountermeasure: mandatory redundancy in messages"
  },
  {
    "objectID": "exam_notes_en.html#rabin-encryptiondecryption-procedure",
    "href": "exam_notes_en.html#rabin-encryptiondecryption-procedure",
    "title": "Fundamental Security Services",
    "section": "Rabin Encryption/Decryption Procedure",
    "text": "Rabin Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates two random prime numbers \\(p\\) and \\(q\\) of large size (len(\\(pq\\)) ≥ 1024)\nA computes \\(n := pq\\)\nThe public key of A is \\(n\\), the private key of A is \\((p, q)\\)\n\nEncryption\n\nEntity B obtains \\(n\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB computes \\(c_i = m_i^2 \\bmod n\\) for each message \\(m_i\\)\nB sends all the ciphertexts \\(c_i\\) to A\n\nDecryption\n\nA uses its private key \\((p, q)\\) to retrieve the 4 solutions of the equation: \\(c_i = x^2 \\bmod n\\) using efficient algorithms to compute square roots \\(\\bmod p\\) and \\(\\bmod q\\)\nA determines either by an additional indication from B, or by redundancy analysis which of the 4 messages \\(m_1, m_2, m_3, m_4\\) is the original plaintext"
  },
  {
    "objectID": "exam_notes_en.html#comparison-rsa---elgamal---rabin",
    "href": "exam_notes_en.html#comparison-rsa---elgamal---rabin",
    "title": "Fundamental Security Services",
    "section": "Comparison RSA - ElGamal - Rabin",
    "text": "Comparison RSA - ElGamal - Rabin\n\n\n\n\n\n\n\n\n\nCriterion\nRSA\nElGamal\nRabin\n\n\n\n\nProblem\nRSAP\nDLP\nSQROOTP\n\n\nSecurity\nEquiv. factorization (generic case)\nBased on DLP\nProven ⟺ factorization\n\n\nExpansion\n1:1\n1:2\n1:1\n\n\nDecryption\nDeterministic\nDeterministic\n4 solutions\n\n\nSignature\nYes\nYes\nYes (with precautions)"
  },
  {
    "objectID": "exam_notes_en.html#elliptic-curves-basic-idea",
    "href": "exam_notes_en.html#elliptic-curves-basic-idea",
    "title": "Fundamental Security Services",
    "section": "Elliptic Curves (Basic Idea)",
    "text": "Elliptic Curves (Basic Idea)\n\nFundamental Concept\nAn elliptic curve \\(E\\) is defined by: \\(y^2 = x^3 + ax + b\\) (with discriminant \\(4a^3 + 27b^2 \\neq 0\\)).\nKey operation: Point addition\n\nGeometrically: draw a line between two points \\(P\\) and \\(Q\\), find the 3rd intersection point, then take its symmetric\nForms a commutative group with point at infinity \\(\\mathcal{O}\\) as identity\nScalar multiplication: \\(kP = P + P + ... + P\\) (\\(k\\) times)\n\nCryptographic advantage:\n\nThe ECDLP problem: finding \\(k\\) such that \\(Q = kP\\) is very difficult (exponential effort)\nShorter keys for same security as in \\(\\mathbb{Z}_p^*\\)\n\n\n\n\n\n\n\nNoteOriginal Text - Definition\n\n\n\n\n\nAn elliptic curve is a set of points \\(E\\) defined by the equation: \\(y^2 = x^3 + ax + b\\), with \\(x, y, a\\) and \\(b\\) rational numbers, integers or integers modulo \\(m\\) (\\(m &gt; 1\\)). The set \\(E\\) also contains a “point at infinity” denoted \\(\\mathcal{O}\\). The point \\(\\mathcal{O}\\) is not on the curve but it is the identity element of \\(E\\).\nWe will choose for our calculations elliptic curves that do not have multiple roots or, in other words, curves where the discriminant \\(4a^3 + 27b^2 \\neq 0\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Concept\n\n\n\n\n\nEquation: \\(y^2 = x^3 + ax + b\\)\nStructure: group with \\(\\mathcal{O}\\)\nOperation: geometric addition\nHard problem: ECDLP\n\n\n\n\n\nAddition on Elliptic Curves\nLet \\(P := (x, y) \\in E\\), we define \\(-P := (x, -y)\\) (symmetric with respect to the x-axis). We have \\(P + (-P) = \\mathcal{O}\\).\nFor two points \\(P, Q \\in E\\) with \\(Q \\neq -P\\), we define \\(P + Q := R\\) where \\(-R\\) is the 3rd intersection point between the curve and the line passing through \\(P\\) and \\(Q\\).\nFor doubling: \\(2P = R\\) where \\(-R\\) is the intersection point of the curve with the tangent to the curve at point \\(P\\).\n\n\n\n\n\n\nNoteOriginal Text - Addition\n\n\n\n\n\nLet \\(P := (x, y) \\in E\\), we define \\(-P\\) as \\(-P := (x, -y)\\). Graphically, \\(-P\\) is the symmetric point of \\(P\\) with respect to the x-axis. Note that \\(P + (-P) = \\mathcal{O}\\).\nLet two points \\(P, Q \\in E\\), such that \\(Q \\neq -P\\), we define the addition \\(P + Q := R\\) where \\(R \\in E\\) such that \\(-R\\) is the 3rd intersection point between the curve and the line passing through \\(P\\) and \\(Q\\).\nThe set \\(E\\) with \\(\\oplus\\) defines a commutative group for addition.\nLet \\(P \\in E\\), the point \\(2P = R\\), such that \\(-R\\) is the intersection point of the curve with the line tangent to the curve at point \\(P\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Addition\n\n\n\n\n\nInverse: \\(-P = (x, -y)\\)\nAddition: 3rd intersection point + symmetry\nDoubling: tangent + symmetry\nProperty: commutative group\n\n\n\n\n\nECDLP and Cryptographic Advantages\nWhen the elliptic curve is defined over the field \\(\\mathbb{Z}_p\\) with \\(p\\) a large prime (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), the computation of \\(k \\in \\mathbb{Z}_p\\) such that \\(Q = kP\\) with \\((P, Q)\\) known is very difficult (exponential effort). This problem is the Elliptic Curve Discrete Logarithm Problem (ECDLP).\nMain advantage: key sizes much smaller for equivalent security.\n\n\n\n\n\n\nNoteOriginal Text - ECDLP and Advantages\n\n\n\n\n\nWhen the elliptic curve is defined over the field \\(\\mathbb{Z}_p\\) with \\(p\\) a large prime number (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), the computation of \\(k \\in \\mathbb{Z}_p\\) such that \\(Q = kP\\) with \\((P, Q)\\) known, is very difficult (requires exponential effort). This problem is known as: Elliptic Curve Discrete Logarithm Problem (ECDLP).\nThe main advantage of public cryptography based on elliptic curves is that the size of the numbers used (and therefore, keys) is smaller.\nThis is due to the increased complexity of computations on \\(E_p\\) (elliptic curve defined over field \\(\\mathbb{Z}_p\\)) compared to usual fields such as \\(\\mathbb{Z}_p\\) or \\(GF(2^m)\\).\nThe representation of a plaintext as points of the curve remains a complex operation.\nIn October 2003, the US National Security Agency (NSA) purchased a patent from Certicom for the use of elliptic curve cryptography.\nIn September 2013 Claus Diem showed that under certain conditions the ECDLP problem could be solved in sub-exponential time.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - ECDLP\n\n\n\n\n\nProblem: finding \\(k\\) in \\(Q = kP\\) (exponential)\nGain: keys ~6-10× shorter\nLimit: representing messages as points difficult\nNSA: adopted in 2003\n\n\n\n\n\nKey Size Comparison Table\n\n\n\nAES (symmetric)\nRSA/DH\nElliptic Curves\nRatio\n\n\n\n\n56 bits\n512 bits\n112 bits\n1:4.6\n\n\n80 bits\n1024 bits\n160 bits\n1:6.4\n\n\n112 bits\n2048 bits\n224 bits\n1:9.1\n\n\n128 bits\n3072 bits\n256 bits\n1:12\n\n\n256 bits\n15360 bits\n512 bits\n1:30\n\n\n\n\n\n\n\n\n\nNoteOriginal Text - Table\n\n\n\n\n\nThis table shows the key size ratios compared to RSA for equivalent security.\n(Table extracted from original document)"
  },
  {
    "objectID": "exam_notes_en.html#elgamal-on-elliptic-curves",
    "href": "exam_notes_en.html#elgamal-on-elliptic-curves",
    "title": "Fundamental Security Services",
    "section": "ElGamal on Elliptic Curves",
    "text": "ElGamal on Elliptic Curves\n\nDirect Adaptation\nReplace operations in \\(\\mathbb{Z}_p^*\\) with operations on \\(E_p\\)\nKeys:\n\nChoose curve \\(E_p\\) and point \\(P_0 \\in E_p\\) of large order\nSecret \\(x\\), compute \\(P_a = xP_0\\)\nPublic: \\((E_p, P_0, P_a)\\) | Private: \\(x\\)\n\nEncryption: For message \\(m_i \\in E_p\\)\n\nChoose random \\(k\\)\n\\(\\gamma = kP_0\\), \\(\\delta = kP_a + m_i\\)\nSend \\((\\gamma, \\delta)\\)\n\nDecryption: \\(m_i = \\delta - x\\gamma\\)\n\n\n\n\n\n\nNoteOriginal Text - ElGamal EC\n\n\n\n\n\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA chooses an elliptic curve \\(E_p\\) with \\(p\\), a large prime number (len(\\(p\\)) bits) and a point \\(P_0 \\in E_p\\).\nA generates a random number \\(x\\), such that \\(1 \\leq x \\leq p\\) and computes \\(P_a = xP_0\\) (multiplication by a scalar on \\(E_p\\), for which efficient algorithms exist).\nThe public key of A is \\((E_p, P_0, P_a)\\), the private key of A is \\(x\\).\n\nEncryption\nEntity B obtains \\((E_p, P_0, P_a)\\), the authentic public key of A.\n\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in E_p\\) for all \\(i\\).\nFor each message \\(m_i\\):\n\nB generates a unique random number \\(k\\), such that \\(1 \\leq k \\leq p\\).\nB computes \\(\\gamma := kP_0\\) and \\(\\delta := kP_a + m_i\\) and sends the ciphertext \\(c := (\\gamma, \\delta)\\).\n\n\nDecryption\n\nA uses its private key \\(x\\) to compute: \\(x\\gamma = xkP_0 = kP_a\\).\nA retrieves the plaintext by computing: \\(\\delta - kP_a = kP_a + m_i - kP_a = m_i\\).\n\nThe security of the scheme relies on ECDLP!\nIt is also necessary to authenticate the exchanged public parts to avoid the previously described man-in-the-middle attacks.\nThe properties of the protocol are identical to the \\(\\mathbb{Z}_p^*\\) case.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - ElGamal EC\n\n\n\n\n\nPrinciple: same as ElGamal on \\(E_p\\)\nOperations: + and scalar multiplication on points\nSecurity: ECDLP\nAuthentication: necessary against MitM\nAdvantage: short keys"
  },
  {
    "objectID": "exam_notes_en.html#one-way-functions-owf",
    "href": "exam_notes_en.html#one-way-functions-owf",
    "title": "Fundamental Security Services",
    "section": "One-Way Functions (OWF)",
    "text": "One-Way Functions (OWF)\nA function \\(f\\) is one-way if \\(f(x) = y\\) is easy to compute, but finding \\(x\\) from \\(y\\) is computationally impossible for the majority of values.\nExamples:\n\nSquares modulo composite: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\)\nDES construction: \\(y = E_k(x) \\oplus x\\) with \\(k\\) fixed and known\n\nNote: OWF ≠ OWHF (hash functions impose compression and 2nd-preimage resistance).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA function f is called one-way (one-way function or OWF) if for \\(x \\in X\\) we can easily compute \\(f(x) = y\\) but for the vast majority of \\(y \\in Y\\) it is computationally impossible to find an \\(x\\) such that \\(f(x) = y\\).\nExamples:\n\ncomputing squares modulo a composite: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\) (p and q unknown) is a one-way function because the inverse is difficult (see the basic problem SQROOTP).\nwe can construct a one-way function based on DES or any other block encryption system \\(E\\) as follows: \\(y = f(x) = E_k(x) \\oplus x\\), \\(\\forall x\\), with \\(k\\) a fixed and known key. We can consider that \\(E_k(x) \\oplus x\\) has (pseudo)random behavior by construction of \\(E\\). Computing the inverse amounts to finding an \\(x\\) such that: \\(x = E_k^{-1}(x \\oplus y)\\), which is considered difficult given the properties of \\(E\\). Note that \\(f(x) = E_k(x)\\) would not be sufficient to make an OWF because, with the key known, DES is reversible.\n\nOWF ≠ OWHF: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.\nExample: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\) (p and q unknown) is not an OWHF because given \\(x\\), \\(-x\\) is a trivial collision.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nOWF: easy in one direction (\\(f(x) \\to y\\)), impossible in the other (\\(y \\to x\\)).\nExamples: modular squares, \\(E_k(x) \\oplus x\\).\nOWF ≠ OWHF (hash functions = more constraints)."
  },
  {
    "objectID": "exam_notes_en.html#hash-functions-definitions",
    "href": "exam_notes_en.html#hash-functions-definitions",
    "title": "Fundamental Security Services",
    "section": "Hash Functions: Definitions",
    "text": "Hash Functions: Definitions\nA hash function \\(h\\) has two essential properties:\n\nCompression: transforms data of arbitrary length into fixed-length output\nEase of computation: \\(h(x)\\) is fast to compute\n\nClassification:\n\nUnkeyed (no key): MDC (Manipulation Detection Code)\nKeyed (with key): MAC (Message Authentication Code)\n\nSecurity properties:\n\nPreimage resistance: given \\(y\\), impossible to find \\(x\\) such that \\(h(x) = y\\)\n2nd-preimage resistance (weak collision): given \\(x\\), impossible to find \\(x' \\neq x\\) such that \\(h(x) = h(x')\\)\nCollision resistance (strong collision): impossible to find any \\(x \\neq x'\\) with \\(h(x) = h(x')\\)\n\nTerminology:\n\nOWHF (weak one-way): satisfies (1) and (2)\nCRHF (strong one-way): satisfies (2) and (3)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA hash function is a function \\(h\\) having the following properties:\n\ncompression: the function \\(h\\) maps a set \\(X\\) composed of bit strings of finite but arbitrary length to a set \\(Y\\) composed of bit strings of finite and fixed length (and normally smaller than the size of \\(X\\)) with \\(h(x) = y\\), and \\(x \\in X\\), \\(y \\in Y\\).\neasy to compute: given \\(h\\) and \\(x \\in X\\), \\(h(x)\\) is easy to compute.\n\nA hash function is called “keyed” (keyed hash function) if a key is involved in the computation of the function (\\(h_k(x) = y\\)); otherwise it is called “unkeyed” (unkeyed hash function).\nHash functions have many computer applications including structured archiving facilitating search. On the security side we will study two main categories:\n\nmanipulation detection codes (MDC) or message integrity codes (MIC): these are unkeyed functions allowing to provide an integrity service under certain conditions. The result of such a function is called MDC-value or simply digest.\nmessage authentication codes (MAC) which are keyed functions allowing to authenticate the source of the message and ensure its integrity without using additional (encryption) mechanisms.\n\nSome basic properties of hash functions:\n\n1) preimage resistance: given a \\(y \\in Y\\), it is computationally impossible to find a preimage \\(x \\in X\\) satisfying \\(h(x) = y\\).\n2) 2nd-preimage resistance: given an \\(x \\in X\\) and its image \\(y \\in Y\\), with \\(h(x) = y\\), it is computationally impossible to find an \\(x' \\neq x\\) such that \\(h(x) = h(x')\\). Also called weak collision resistance.\n3) collision resistance: it is computationally impossible to find two distinct preimages \\(x, x' \\in X\\) for which \\(h(x) = h(x')\\) (no restriction on the choice of values). Also called strong collision resistance.\n\nA one-way hash function (OWHF) is an MDC satisfying 1) and 2). Also called: weak one-way hash function.\nA collision resistant hash function (CRHF) is an MDC satisfying properties 2) and 3). (Note that 3) ⇒ 2)). Also called: strong one-way hash function.\nOWF ≠ OWHF: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.\nExample: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\) (p and q unknown) is not an OWHF because given \\(x\\), \\(-x\\) is a trivial collision.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nHash function: compression + easy computation\nMDC (unkeyed) for integrity\nMAC (keyed) for authentication\nProperties\n\npreimage resistance\n2nd-preimage resistance\ncollision resistance\n\nOWHF = (1)+(2)\nCRHF = (2)+(3)."
  },
  {
    "objectID": "exam_notes_en.html#message-authentication-codes-macs",
    "href": "exam_notes_en.html#message-authentication-codes-macs",
    "title": "Fundamental Security Services",
    "section": "Message Authentication Codes (MACs)",
    "text": "Message Authentication Codes (MACs)\nA MAC is a family of functions \\(h_k\\) parameterized by a secret key \\(k\\):\nProperties:\n\nCompression: arbitrary input → fixed output\nEasy to compute: with known \\(k\\), \\(h_k(x)\\) is fast\nComputation-resistance: without \\(k\\), impossible to compute valid pairs \\((x, h_k(x))\\)\n\nImplications:\n\nKey non-recovery: impossible to recover \\(k\\) from pairs \\((x_i, h_k(x_i))\\)\nPreimage and collision resistance for anyone not possessing \\(k\\)\n\nUsage: Source authentication + message integrity without directly revealing secrets.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA Message Authentication Code (MAC) is a family of functions \\(h_k\\) parameterized by a secret key \\(k\\) having the following properties:\n\n1) compression: as for generic hash functions but applied to \\(h_k\\).\n2) easy to compute: from a function \\(h_k\\), and a known key \\(k\\), we can easily compute \\(h_k(x)\\). The result is called a MAC-value or simply a MAC.\n3) computational resistance (computation-resistance): without knowledge of the symmetric key \\(k\\), it is (computationally) impossible to compute pairs \\((x, h_k(x))\\) from 0 or several known pairs \\((x_i, h_k(x_i))\\) for any \\(x \\neq x_i\\).\n\nProperty 3) implies that the pairs \\((x_i, h_k(x_i))\\) cannot be used to compute the key \\(k\\) (key non-recovery). However the key non-recovery property does not imply computation-resistance because chosen/known-plaintext attacks could lead to forged pairs \\((x, h_k(x))\\).\nThe impossibility of computing pairs \\((x, h_k(x))\\) also translates to preimage and collision resistance (cf. previous slide) for any entity not possessing the key \\(k\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nMAC = hash with key \\(k\\)\nWithout \\(k\\): impossible to forge \\((x, h_k(x))\\) or recover \\(k\\)\nGuarantees source authentication + integrity."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-mdcs",
    "href": "exam_notes_en.html#attacks-on-mdcs",
    "title": "Fundamental Security Services",
    "section": "Attacks on MDCs",
    "text": "Attacks on MDCs\n\n2nd-Preimage Resistance Attack\nProblem: Given \\(h(x) = y\\), find \\(x'\\) such that \\(h(x') = h(x)\\).\nProbabilistic analysis:\nFor an \\(m\\)-bit digest (\\(n = 2^m\\) possible outputs), the probability of having at least one collision after \\(k\\) attempts is:\n\\[P(\\text{collision}) \\approx 1 - (1-1/n)^k \\approx k/n\\]\nFor \\(P = 0.5\\): \\(k = n/2 = 2^{m-1}\\)\nConclusion: For an \\(m\\)-bit digest, approximately \\(2^{m-1}\\) attempts are needed to find a 2nd-preimage with probability 0.5.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nProblem: given \\(h(x) = y\\), find \\(x'\\) such that \\(h(x')=h(x)\\).\nPractical example: we have a text with an associated digest bearing a digital signature; we want to create a fake text bearing the same signature (without control over the original text). What are our chances from a probabilistic point of view?\nLet a hash function \\(h\\) with \\(n\\) possible outputs and a given value \\(h(x)\\). If \\(h\\) is applied to \\(k\\) random values, what must be the value of \\(k\\) so that the probability of having at least one \\(y\\) such that \\(h(x) = h(y)\\) is 0.5?\nFor the first value of \\(y\\), the probability that \\(h(x) = h(y)\\) is \\(1/n\\). Conversely, the probability that \\(h(x) \\neq h(y)\\) is \\(1-1/n\\). For \\(k\\) values, the probability of having no collision is: \\((1-1/n)^k\\), i.e.:\n\\[\\left(1 - \\frac{1}{n}\\right)^k = 1 - \\frac{k}{n} + \\frac{1}{2!}\\left(\\frac{k}{n}\\right)^2 - \\frac{1}{3!}\\left(\\frac{k}{n}\\right)^3 + \\ldots\\]\nwhich for very large \\(n\\) can be approximated by \\(1 - k/n\\). Therefore, the complementary probability of having at least one collision is about \\(k/n\\); which gives us \\(k = n/2\\) for a probability of 0.5.\nConclusion: for an \\(m\\)-bit digest, the number of attempts needed to find a \\(y\\) such that \\(h(x) = h(y)\\) with a probability of 0.5 is \\(2^{m-1}\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nTo break 2nd-preimage resistance with \\(m\\)-bit digest: \\(2^{m-1}\\) attempts (prob 0.5).\n\n\n\n\n\nCollision Resistance Attack: Birthday Paradox\nProblem: Find two distinct values \\(x, x'\\) such that \\(h(x) = h(x')\\).\nBirthday paradox: In a group of 23 people, probability &gt; 0.5 of having two people with the same birthday.\nMathematical result:\nFor \\(n\\) possible outputs, the probability of collision after \\(k\\) computations:\n\\[P(\\text{at least 1 collision}) = 1 - e^{-k(k-1)/(2n)}\\]\nFor \\(P \\geq 0.5\\): \\(k \\approx 1.17\\sqrt{n}\\)\nCryptographic consequence: For an \\(m\\)-bit digest (\\(n = 2^m\\) outputs), approximately \\(2^{m/2}\\) computations are needed to find a collision with probability &gt; 0.5.\nPractical example: Modification of a contract into 237 variations to find a fraudulent version having the same digest as the legitimate version.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nProblem: find two values \\(x, x'\\) distinct such that \\(h(x) = h(x')\\).\nPractical example: We have to have someone sign a text and we want to apply this signature to a falsified text (we control the original text). What are our chances of finding two original texts satisfying this criterion?\nThe birthday paradox is a classic probabilistic problem that shows that in a gathering of only 23 people, there is already a 50% chance of having two people with the same birthday.\nLet \\(y_1, y_2,..., y_n\\) all the possible outputs of a hash function. How many \\(h(x_i)\\): \\(h(x_1), h(x_2),...,h(x_k)\\) must we compute to have a probability of collision equal to or greater than 0.5?\nThe first choice for \\(h(x_1)\\) is arbitrary (prob = 1), the second \\(h(x_2) \\neq h(x_1)\\) has a probability of \\(1 - 1/n\\), the third of \\(1 - 2/n\\), etc. This gives us a probability of having no collisions equal to:\n\\[P_{\\text{no collision}} = \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right)\\]\nWe easily prove (series expansion of \\(e^{-x}\\)) that for \\(0 \\leq x \\leq 1\\): \\(1-x \\leq e^{-x}\\) and therefore:\n\\[P_{\\text{no coll}} \\leq \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right) \\leq \\prod_{i=1}^{k-1} e^{-i/n} = e^{-k(k-1)/(2n)}\\]\nThe probability of having at least one collision is \\(P_{\\text{at least1}} = 1 - P_{\\text{no-coll}}\\). To know the value of \\(k\\) for which \\(P_{\\text{at least1}}\\) is greater than 0.5, it suffices to calculate:\n\\[\\frac{1}{2} \\leq 1 - e^{-k(k-1)/(2n)}\\]\nIf \\(k\\) is large, we replace \\(k(k-1)\\) by \\(k^2\\) and we obtain after simple calculations:\n\\[k \\geq \\sqrt{2\\ln(2) \\cdot n} \\approx 1.17\\sqrt{n}\\]\nTaking \\(n = 365\\) for the birthday, we get \\(k = 22.3\\), which confirms the statement of the problem.\nConsequence for hash functions: Let a hash function with \\(2^m\\) possible outputs. If \\(h\\) is applied to \\(k = 2^{m/2}\\) inputs we have a probability greater than 0.5 of obtaining \\(h(x_i) = h(x_j)\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBirthday paradox: to break collision resistance with \\(m\\)-bit digest: \\(2^{m/2}\\) attempts (prob &gt; 0.5).\nExample: 23 people suffice for identical birthdays."
  },
  {
    "objectID": "exam_notes_en.html#computational-resistance-recap",
    "href": "exam_notes_en.html#computational-resistance-recap",
    "title": "Fundamental Security Services",
    "section": "Computational Resistance: Recap",
    "text": "Computational Resistance: Recap\nFor a hash function with \\(n\\)-bit digest and MAC key of \\(t\\) bits:\n\n\n\nType\nProperty\nDifficulty\nRecommended Size\n\n\n\n\nOWHF\nPreimage\n\\(2^n\\)\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage\n\\(2^{n-1}\\)\n\n\n\nCRHF\nCollision\n\\(2^{n/2}\\)\n\\(n \\geq 256\\) bits\n\n\nMAC\nKey recovery\n\\(2^t\\)\n\\(t \\geq 256\\) bits\n\n\n\nComputation\n\\(\\min(2^t, 2^n)\\)\n\\(n \\geq 128\\) bits\n\n\n\nPractical implications:\n\nFor integrity only (OWHF): 128 bits sufficient\nFor collision resistance (CRHF): minimum 256 bits\nMACs: 256-bit key, 128-bit digest minimum\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\n\\(n\\): size of the MDC-value or MAC-value resulting from the application of the hash function\n\\(t\\): size of the MAC key\n\n\n\n\n\n\n\n\n\n\nHash Fct. Type\nCharacteristic\nComputational Difficulty\nAttack Goal\nRecommended digest/key size\n\n\n\n\nOWHF\npreimage resistance\n\\(2^n\\)\nfind a preimage\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage resistance\n\\(2^{n-1}\\)\nfind \\(x'\\) with \\(h(x') = h(x)\\)\n\n\n\nCRHF\ncollision resistance\n\\(2^{n/2}\\)\nfind a collision\n\\(n \\geq 256\\) bits\n\n\nMAC\nkey non-recovery\n\\(2^t\\)\nfind the key\n\\(n \\geq 128\\)\n\n\n\ncomputation resistance\n\\(\\min(2^t,2^n)\\)\nproduce a \\((x, h_k(x))\\)\n\\(t \\geq 256\\)\n\n\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nEfforts: preimage \\(2^n\\), 2nd-preimage \\(2^{n-1}\\), collision \\(2^{n/2}\\).\nSizes: OWHF ≥128 bits, CRHF ≥256 bits, MAC key ≥256 bits."
  },
  {
    "objectID": "exam_notes_en.html#mdcs-based-on-encryption-systems",
    "href": "exam_notes_en.html#mdcs-based-on-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "MDCs Based on Encryption Systems",
    "text": "MDCs Based on Encryption Systems\nPrinciple: Use a symmetric encryption algorithm (DES, AES) to construct an MDC.\nChallenges to solve:\n\nBreak the reversibility of symmetric algorithms\nIncrease the nominal width (DES = 64 bits insufficient for CRHF)\n\nOperation:\n\nSequential processing of blocks\nChaining operations with XOR\nCombination of \\(n\\) boxes for digests of size \\(n \\times\\) nominal width\n\nClassical models:\n\nMatyas-Meyer-Oseas: \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1}\\)\nDavies-Meyer: \\(H_i = E_{m_i}(H_{i-1}) \\oplus m_i\\)\nMiyaguchi-Preneel: \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1} \\oplus m_i\\)\n\nPractical examples:\n\nMDC-2: uses 2 DES boxes → 128-bit digest\nMDC-4: uses 4 DES boxes → 128-bit digest\n\nLimitation: Security strongly dependent on the underlying algorithm.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nIdea: use a known symmetric encryption system to construct an MDC.\nProblems to solve:\n\nwe must “break” the reversibility of symmetric algorithms to make them OWHF or CRHF.\nThe “nominal width” of some encryption systems (eg. DES) is 64 bits, which is not sufficient to build CRHF.\n\nOperating principle:\n\nthe text blocks are sequentially processed by the encryption “box”.\ncompression is based on chaining operations with the blocks resulting from previous iterations and logical functions (fundamentally XOR). This also makes the process irreversible.\nIf necessary, \\(n\\) encryption boxes will be combined to obtain digest lengths \\(n\\) times greater than the nominal width of the boxes used.\n\nAttention: the security of these algorithms is strongly dependent on the properties of the underlying encryption boxes.\nExamples:\n\nThe models of Matyas-Meyer-Oseas, Davies-Meyer and Miyaguchi-Preneel.\nMDC-2 and MDC-4 using respectively 2 and 4 DES boxes. Digest = 128 bits.\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nMDCs from symmetric crypto: break reversibility + chaining XOR.\nModels: Matyas-Meyer-Oseas, Davies-Meyer, Miyaguchi-Preneel.\nMDC-2/4 with DES → 128 bits."
  },
  {
    "objectID": "exam_notes_en.html#customized-mdcs",
    "href": "exam_notes_en.html#customized-mdcs",
    "title": "Fundamental Security Services",
    "section": "Customized MDCs",
    "text": "Customized MDCs\nFunctions specifically designed for digest generation, optimized for speed and security.\nConstruction elements:\n\nPadding + adding the message length\nPredefined constants to increase dispersion\nSuccessive rounds with logical operations and rotations\nChaining of outputs between rounds\nEvery bit of the digest depends on every input bit\n\nMain algorithms:\n\n\n\nAlgorithm\nYear\nDigest\nStatus\n\n\n\n\nMD5\n1992\n128 bits\n❌ Broken\n\n\nSHA-0\n1993\n160 bits\n❌ Collisions in \\(2^{39}\\)\n\n\nSHA-1\n1995\n160 bits\n⚠️ Collisions in \\(2^{63}\\)\n\n\nSHA-2\n-\n224-512 bits\n✓ Currently secure\n\n\nSHA-3 (Keccak)\n2012\n224-512 bits\n✓ Current standard\n\n\n\nAttack evolution:\n\n2004: Full collisions on MD5 (X. Wang)\n2005: SHA-1 theoretically broken (\\(2^{63}\\) operations)\n2008: Creation of fraudulent CA certificates via MD5\n2012: SHA-3 adopted as new standard\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nThese are functions designed exclusively to generate integrity codes (digests) with a main concern for speed and security.\nTheir operation is based on the following elements:\n\ninitialization operations (padding + adding the length).\na set of predefined constants chosen specifically to increase dispersion.\na set of “steps” (rounds) that will sequentially apply to all the original data blocks. These rounds will perform a combination of logical operations and rotations on the data and constants.\nchaining operations involving the outputs of previous rounds.\n\nIn these functions, every bit of the digest is a function of every bit of the inputs.\nThe most famous are:\n\nMD5: R. Rivest, 1992; RFC 1321. Digest = 128 bits. Broken!\nSHA-0: NIST, 1993. Digest = 160 bits. Collisions in \\(2^{39}\\) operations instead of \\(2^{80}\\)\nSHA-1: NIST, 1995. Digest = 160 bits. Revision of SHA-0 with additional bit rotation. Collisions in \\(2^{63}\\) operations (instead of \\(2^{80}\\)).\nSHA-2: NIST (FIPS 190-3). Includes: SHA-224, SHA-256, SHA-384 and SHA-512. Digest sizes range from 224 to 512 bits.\nSHA-3: Keccak Algorithm (digest size variable from 224 to 512 bits)\n\nLatest Developments:\n\nX.Wang et al. culminated in 2004 a long work aiming to find collisions in the MD5 algorithm. They publish two pairs of collisions for 1024-bit messages.\nIn 2005, X.Wang et al. prove at the CRYPTO’05 conference that the number of operations needed to find collisions on SHA-1 (current standard for secure hash functions) is only \\(2^{63}\\).\nThese attacks target the search for arbitrary collisions but during CRYPTO’06 researchers from the University of Graz in Austria propose a method to partially control the content of collisions.\nIn December 2008 it is shown that controlled collisions on MD5 can be generated and thus create an illicit Certification Authority allowing to forge certificates accepted by any browser.\nThese results rely on analytical approaches (as opposed to brute force!)\nThe selection process for SHA-1’s successor is similar to the one that designated AES as a block encryption standard. NIST decided (October 2012) that Keccak would be the base algorithm for SHA-3.\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nCustomized MDCs\n\nMD5 (broken)\nSHA-0 (broken)\nSHA-1 (weak)\nSHA-2 (secure)\nSHA-3/Keccak (current standard).\n\nConstruction: padding + constants + rounds + chaining."
  },
  {
    "objectID": "exam_notes_en.html#macs-based-on-encryption-systems",
    "href": "exam_notes_en.html#macs-based-on-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "MACs Based on Encryption Systems",
    "text": "MACs Based on Encryption Systems\nCBC-MAC: Uses a block cipher algorithm in CBC mode.\nOperation:\n\nCBC mode with IV = 0\nElimination of intermediate ciphertexts\nOnly the last encrypted block is kept as MAC\n\nWith DES:\n\nKey length: 56 bits (112 in optional Triple-DES)\nMAC length: 64 bits\n\nAdvantages:\n\nReuse of existing encryption infrastructure\nAcceptable performance\n\nLimitations:\n\nSecurity limited by block size (64 bits for DES)\nVulnerable if used incorrectly (ex: without variable IV)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nCBC-MAC algorithm based on DES-CBC with IV = 0 and elimination of intermediate ciphertexts\n\nkey length = 56 bits (112 in case of using the optional part)\nMAC-value length = 64 bits\n\nThe diagram shows the sequential processing of message blocks \\(M_1, M_2, M_3\\) with the encryption algorithm \\(E\\) and the key \\(k\\). The intermediate ciphertexts \\(C_1, C_2\\) are eliminated. Only the last block \\(C_3\\) constitutes the MAC.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nCBC-MAC: CBC mode + IV=0, only last block kept. DES: key 56/112 bits, MAC 64 bits."
  },
  {
    "objectID": "exam_notes_en.html#nested-macs-and-hmacs",
    "href": "exam_notes_en.html#nested-macs-and-hmacs",
    "title": "Fundamental Security Services",
    "section": "Nested MACs and HMACs",
    "text": "Nested MACs and HMACs\nNested MAC (NMAC): Composition of two MAC families \\(G\\) and \\(H\\):\n\\[\\text{NMAC}_{k,l}(x) = g_k(h_l(x))\\]\nSecurity: Depends on two criteria:\n\n\\(G\\) resistant to collisions\n\\(H\\) resistant to specific MAC attacks\n\nHMAC (FIPS 198 standard, 2002): Nested MAC using unkeyed MDCs (SHA-1, SHA-256).\nConstruction:\n\nConstants: ipad = 0x363636...36 and opad = 0x5C5C5C...5C (512 bits)\nKey \\(k\\) of 512 bits\n\n\\[\\text{HMAC-256}_k(x) = \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nAdvantages:\n\nMost widely used MACs in practice\nAttacks on SHA more difficult with secret key\nExcellent performance\nStandardized and widely supported\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA Nested MAC or NMAC is a composition of 2 families of MAC functions \\(G\\) and \\(H\\) parameterized by keys \\(k\\) and \\(l\\) such that:\n\\[G \\circ H = \\{ g \\circ h \\text{ with } g \\in G \\text{ and } h \\in H \\} \\text{ with } g \\circ h_{(k,l)}(x) = g_k(h_l(x))\\]\nThe security of an NMAC depends on two criteria:\n\nThe family of functions \\(G\\) is collision resistant.\nThe family of functions \\(H\\) is resistant to specific attacks for MACs, i.e.: It is impossible to find a pair \\((x,y)\\) and a fixed but unknown key \\(m\\), such that: \\(\\text{MAC}_m(x) = y\\).\n\nAn HMAC (FIPS 198, 2002) is a Nested MAC using at its base dedicated unkeyed MDCs like SHA-1 or SHA-256.\nAn HMAC uses two 512-bit constants called ipad and opad such that:\n\nopad := 363636 ... 36\nipad := 5C5C5C ... 5C\n\nand a key \\(k\\) of 512 bits.\nThe operating scheme of HMAC-256 (based on SHA-256) is as follows:\n\\[\\text{HMAC-256}_k(x) := \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nHMACs are the most used MACs. The attacks mentioned on the functions of the SHA family are more difficult to carry out on an HMAC because of the key \\(k\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nHMAC: double hash with derived keys (ipad/opad). \\(\\text{HMAC}_k(x) = H((k \\oplus \\text{opad}) \\parallel H((k \\oplus \\text{ipad}) \\parallel x))\\). Standard, secure, performant."
  },
  {
    "objectID": "exam_notes_en.html#hash-functions-applications",
    "href": "exam_notes_en.html#hash-functions-applications",
    "title": "Fundamental Security Services",
    "section": "Hash Functions Applications",
    "text": "Hash Functions Applications\n\nData Integrity\nThree main approaches:\n\nMAC only:\n\n\\(A \\to B: X, \\text{MAC}_k(X)\\)\nAuthentication + integrity guaranteed\nRequires shared key\n\nMDC + Encryption:\n\n\\(A \\to B: E_k(X, \\text{MDC}(X))\\)\nConfidentiality + integrity\nShared symmetric key\n\nMDC + Authentic channel:\n\n\\(A \\to B: X\\) (normal channel)\n\\(A \\to B: \\text{MDC}(X)\\) (authentic channel)\nChannel separation\n\n\nLimitations: These simple protocols offer no protection against replay attacks.\nSolution: add timestamps or sequence numbers.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMAC Only: \\[A \\to B: X, \\text{MAC}_k(X)\\] If \\(B\\) computes on its side \\(\\text{MAC}_k(X)\\) and obtains the same value ⇒ the message comes from \\(A\\).\nMDC + symmetric encryption (key \\(k\\) known to \\(A\\) and \\(B\\)) \\[A \\to B: X, E_k(\\text{MDC}(X))\\] \\(B\\) computes \\(\\text{MDC}(X)\\) and then \\(E_k(\\text{MDC}(X))\\). If equal ⇒ message comes from \\(A\\).\nAs 2) with confidentiality of \\(X\\) added: \\[A \\to B: E_k(X,\\text{MDC}(X))\\]\nMDC + digital signature: \\[A \\to B: X, \\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\] \\(B\\) computes \\(\\text{MDC}(X)\\) and verifies \\(\\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\) with an authentic copy of pub-A. If equality ⇒ \\(A\\) is the origin of the message. This solution additionally offers origin non-repudiation.\nThese simple protocols offer no support for uniqueness nor for the timeliness of received messages and are exposed to replay attacks! They require mechanisms taking into account time or the transaction context (cf. entity authentication).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nIntegrity: MAC only, MDC+crypto, MDC+signature.\n⚠️ Vulnerable to replay without timestamps/nonces.\n\n\n\n\n\nBlockchains and Proof of Work\nBitcoin and blockchains: Use of hash functions to chain transaction blocks.\nCharacteristics:\n\nPublic and visible transactions\nBlocks chained via cryptographic hash functions\nMining = solving a cryptographic puzzle (proof of work)\n\nProof of Work:\n\nFind a nonce such that \\(\\text{hash}(\\text{block} \\parallel \\text{nonce}) &lt; \\text{target}\\)\nComputationally expensive puzzle, rapid validation\nFirst miner to solve receives bitcoin reward\n\nSecurity:\n\nBlockchain = public, decentralized, immutable ledger\nFalsification would require effort &gt; all honest miners\nProtection based on CRHF properties\n\nBitcoin statistics (October 2025):\n\nDifficulty: 150.84 T\nTarget: \\(\\approx 2^{177}\\) (pseudo-collision on 79 bits)\nHashrate: ~1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hash/sec)\nAverage block generation time: 10 minutes\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nBitcoin transactions are published and visible by all participants. They are encapsulated in blocks chained using cryptographic hash functions.\nMining consists of iteratively adding new blocks containing current transactions.\nGenerating a valid block requires solving a cryptographic puzzle (proof of work) very costly in computation time (finding pseudo-collisions in cryptographic hash functions). Validation remains very efficient.\nThe first miner able to generate a valid block will receive a monetary reward (in bitcoins). The mining process is open to all miners but only the first is rewarded.\nThe resulting chain of blocks (blockchain) then becomes a public ledger, decentralized and immutable protecting all past transactions. Falsification/modification of data protected by the blockchain would require computational effort greater than that performed by all honest miners.\nBitcoin Statistics 13/10/2025:\n\nDifficulty: 150.84 T\nTarget: \\(2^{224} / \\text{Difficulty} = \\approx 2^{177}\\). The valid digest to generate a block must be less than \\(2^{177}\\), which means a pseudo-collision on the 79 most significant bits. The variation on the inputs depends on the nonce.\nHashrate: ~ 1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hashes /sec)\nHash functions executed to obtain a block: ~ \\(660 \\times 10^{21}\\)\nAverage block generation time: 10 min\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBlockchain: chaining of blocks via hash.\nProof of Work: find nonce for hash &lt; target.\nSecurity = effort &gt; all miners.\nBitcoin: ~10 min/block, \\(10^{21}\\) hash/sec.\n\n\n\n\n\nOther Applications\n1. Authentication:\n\nData origin authentication (DOA)\nTransaction authentication (DOA + temporal parameters)\n\n2. Virus checking:\n\nCreator publishes \\(\\text{digest} = h(\\text{software})\\) via secure channel\nUsers verify integrity by recalculating the digest\n\n3. Public key distribution:\n\nPublish \\(h(\\text{public key})\\) instead of the complete key\nSimplified authenticity verification\n\n4. Document timestamping:\n\nTimestamp applied to digest rather than complete document\nReduction of data to sign\n\n5. One-time password (S-Key):\n\nHash chain: \\(x_1 = h(x_0), x_2 = h(x_1), \\ldots, x_n = h(x_{n-1})\\)\nSystem stores \\(x_n\\), user provides \\(x_{n-1}\\)\nVerification: \\(h(x_{n-1}) = x_n\\)\nAfter validation, system stores \\(x_{n-1}\\) for next time\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAuthentication:\n\ndata origin authentication (DOA)\ntransaction authentication (= DOA + time-variant parameters)\n\nVirus checking:\n\nThe creator of software creates a digest = \\(h(x)\\) with \\(x\\) being the original and distributes it via a secure channel (eg. CD-ROM).\n\nDistribution of public keys:\n\nAllows controlling the authenticity of a public key.\n\nTimestamp on a document:\n\nThe document on which we want to perform the timestamp is first submitted to a hash function. The timestamp (with the signature of the corresponding entity) then applies only to the digest.\n\nOne-time password (S-Key) (identification mechanism):\n\nFrom a secret seed \\(x_0\\), we create a chain of hash-values: \\(x_1 = h(x_0)\\), \\(x_2 = h(x_1)\\), … \\(x_n = h(x_{n-1})\\).\nThe system stores \\(x_n\\) and the user enters \\(x_{n-1}\\). If \\(h(x_{n-1}) == x_n\\) ⇒ OK.\nThe system then stores \\(x_{n-1}\\) and so on.\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nApplications\n\nauthentication\nvirus checking\npublic key distribution\ntimestamping\none-time passwords (hash chain)"
  },
  {
    "objectID": "exam_notes_en.html#randomized-hash-functions-unix-example",
    "href": "exam_notes_en.html#randomized-hash-functions-unix-example",
    "title": "Fundamental Security Services",
    "section": "Randomized Hash Functions: UNIX Example",
    "text": "Randomized Hash Functions: UNIX Example\nProblem: Deterministic hash functions always produce the same result for the same password.\nRisks:\n\nDetection of identical passwords\nOffline dictionary attacks (pre-computed codebooks)\nRainbow tables\n\nUNIX solution: Salt\n\nAddition of a 12-bit pseudo-random element (salt) before hashing\nDifferent salt for each user\n4096 possibilities (\\(2^{12}\\)) for each password\n\nAdvantages:\n\nPrevents detection of duplicates\nPre-computed codebooks become ineffective\nEach password requires 4096 dictionary entries\n\nUNIX implementation:\n\nFile /etc/passwd globally accessible\nFormat: username:hash(salt+password):uid:gid:...\nHash based on modified DES (25 iterations)\nSalt stored in clear (first 2 characters of hash)\n\nExample:\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nLimitations:\n\nEffective protection against pre-computed dictionaries\nOnline attacks limited by the system (number of attempts)\nOffline attacks possible if file compromised\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nUNIX keeps its passwords in a globally accessible file (or possibly distributed by NIS). The stored information corresponds to the result produced by a hash function.\nExample (fictional):\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nProblems:\n\nthe hash function being deterministic, it produces the same result for identical passwords.\none could create “books” (codebooks) containing the result of applying the hash function to given inputs (eg. a dictionary) and easily compare them (off-line) with the strings stored by UNIX (brute force dictionary attack).\n\nSolution:\n\nAdd a (pseudo) random element of 12 bits different for each password (called salt) before computing the hash function and during verification.\nThis element allows adding a random factor of 4096 possibilities for each password and prevents detection of duplicates.\n\nThe operating scheme uses DES with 25 iterations, the password as key, and the salt to modify the E-boxes. The final 64-bit result is converted to 11 ASCII characters.\nUser awareness (not visiting dubious sites) decreases the effectiveness of this technique in malware transmission.\nDictionary attacks are normally less effective online because operating systems limit the number of unsuccessful authentication attempts.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nUNIX salt: 12 random bits added to password before hash.\n4096 possible variations.\nPrevents pre-computed codebooks and duplicate detection."
  },
  {
    "objectID": "exam_notes_en.html#introduction-and-definitions",
    "href": "exam_notes_en.html#introduction-and-definitions",
    "title": "Fundamental Security Services",
    "section": "Introduction and Definitions",
    "text": "Introduction and Definitions\nA digital signature is a string of data associating a message with an originating entity, the digital equivalent of a handwritten signature.\nClassification:\n\nWith appendix: requires the original message for verification (ElGamal, DSS)\nWith message recovery: allows reconstruction of the message (RSA, Rabin)\n\nSignatures primarily use asymmetric cryptography to explicitly identify an entity.\narbitrated digital signatures: symmetric technology + Trusted Third Parties (TTP)\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nDigital signature: string of data allowing to associate a message (in digital form) with an originating entity.\nDigital signature scheme: generation algorithm + verification algorithm.\nSignature process: message formatting + signature generation algorithm.\nVerification process: verification algorithm + (message reconstruction).\nClassification of digital signatures:\n\nDigital signatures with appendix which require the presence of the original message to verify the validity of the signature. These are the most commonly used. Examples: ElGamal, DSS.\nDigital signatures with message recovery which offer, in addition, the possibility to reconstruct the message from the signature. Examples: RSA, Rabin.\n\nDigital signatures are mostly based on asymmetric crypto because the concept of a shared key is not suitable for the need to identify an entity explicitly.\nCommitments similar to those obtained with a public key signature (such as origin non-repudiation) can however be obtained with symmetric technology and trusted third parties (TTP). These methods are called: arbitrated digital signatures.\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nDigital signature = string associating message + entity\nTwo types\n\nwith appendix (requires original message)\nwith recovery (reconstructs the message)\n\nBased on asymmetric crypto"
  },
  {
    "objectID": "exam_notes_en.html#formal-framework-signatures-with-appendix",
    "href": "exam_notes_en.html#formal-framework-signatures-with-appendix",
    "title": "Fundamental Security Services",
    "section": "Formal Framework: Signatures with Appendix",
    "text": "Formal Framework: Signatures with Appendix\nWorking spaces:\n\n\\(M\\): message space\n\\(M_h\\): hashed messages where \\(m_h = H(m)\\) with \\(H\\) a hash function\n\\(S\\): space of possible signatures\n\nOperation:\nEach entity A defines:\n\n\\(S_A : M_h \\rightarrow S\\) (signature function, uses private key)\n\\(V_A : M_h \\times S \\rightarrow \\{\\text{true}, \\text{false}\\}\\) (verification, uses public key)\n\nWith \\(V_A(m_h, s) = \\text{true}\\) if and only if \\(S_A(m_h) = s\\)\nEssential properties:\n\n\\(S_A\\) and \\(V_A\\) easy to compute with the correct keys\nImpossible to find a valid \\((m', s')\\) without A’s private key\n\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nWe assume that each entity has a private key to sign messages and an authentic copy of the public keys of correspondents.\nNotation: - M: Message space - \\(M_h\\): \\(m_h = H(m)\\) with \\(m \\in M\\), \\(m_h \\in M_h\\) and \\(H\\) a hash function - S: Space of values that can be obtained by a signature process\nDescription:\nEach entity defines an injective function \\(S_A : M_h \\rightarrow S\\) (i.e., the signature)\nThe function \\(S_A\\) gives rise to a function \\(V_A\\): \\(V_A : M_h \\times S \\rightarrow \\{\\text{true}, \\text{false}\\}\\) (i.e., the verification)\nsuch that \\(\\forall m_h \\in M_h\\), \\(s \\in S\\), we have: \\(V_A(m_h, s) = \\text{true}\\) if \\(S_A(m_h) = s\\) and \\(V_A(m_h, s) = \\text{false}\\) otherwise\nThe operations \\(S_A\\) require the private key of A while the operations \\(V_A\\) use the public key of A.\nSome simple properties:\n\nThe operations \\(S_A\\) and \\(V_A\\) must be easy to compute (having the corresponding keys)\nIt is impossible (computationally) for an entity not having the private key of A to find an \\(m'\\) and an \\(s'\\) with \\(m' \\in M\\) and \\(s' \\in S\\) such that \\(V_A(m'_h, s') = \\text{true}\\) with \\(m'_h = H(m')\\).\n\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nSignature: \\(S_A(m_h) = s\\) (private key).\nVerification: \\(V_A(m_h, s)\\) (public key).\nImpossible to forge without private key."
  },
  {
    "objectID": "exam_notes_en.html#formal-framework-signatures-with-recovery",
    "href": "exam_notes_en.html#formal-framework-signatures-with-recovery",
    "title": "Fundamental Security Services",
    "section": "Formal Framework: Signatures with Recovery",
    "text": "Formal Framework: Signatures with Recovery\nAdditional spaces:\n\n\\(M_S\\): space on which the signature is applied\n\\(R : M \\rightarrow M_S\\): redundancy function (injective, invertible, public)\n\\(M_R = \\text{Im}(R)\\): image of \\(R\\)\n\nOperation:\n\nSignature: \\(S_A : M_S \\rightarrow S\\) (injective)\nVerification: \\(V_A : S \\rightarrow M_S\\) with \\(V_A \\circ S_A = \\text{Identity}\\)\n\nGeneration:\n\nCompute \\(m_R = R(m)\\) and \\(s = S_A(m_R)\\)\nPublish \\(s\\) as A’s signature on \\(m\\)\n\nVerification:\n\nCompute \\(m_R = V_A(s)\\) with public key\nVerify \\(m_R \\in M_R\\) (reject otherwise)\nReconstruct \\(m = R^{-1}(m_R)\\)\n\nRedundancy function:\nEssential for security. If \\(M_R = M_S\\), it becomes trivial to forge signatures.\nExample: \\(R(m) = m \\parallel m\\) (concatenation). Forgery probability: \\((1/2)^n\\) for an \\(n\\)-bit message.\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nNotation: in addition to the previous definitions, we have:\n\\(M_S\\): The space of elements on which a signature can be applied.\n\\(R\\): An injective function: \\(M \\rightarrow M_S\\), called the redundancy function. It must be invertible and public.\n\\(M_R = \\text{Im}(R)\\)\nDescription:\nEach entity defines an injective function \\(S_A : M_S \\rightarrow S\\) (i.e., the signature)\nThe function \\(S_A\\) gives rise to a function \\(V_A : S \\rightarrow M_S\\) (i.e., the verification) such that \\(V_A \\circ S_A = \\text{Identity}\\) on \\(M_S\\)\nNote that verification is performed without the private key of A\nSignature generation: 1. Compute \\(m_R = R(m)\\) and \\(s = S_A(m_R)\\) 2. Make \\(s\\) public as A’s signature on \\(m\\). This allows other entities to verify the signature and reconstruct \\(m\\).\nVerification: 1. Compute \\(m_R = V_A(s)\\) (with A’s public key) 2. Verify that \\(m_R \\in M_R\\) (otherwise reject the signature) 3. Reconstruct \\(m\\) by computing: \\(R^{-1}(m_R)\\)\nProperties:\n\nThe operations \\(S_A\\) and \\(V_A\\) must be easy to compute (having the corresponding keys)\nIt is impossible (computationally) for an entity not having the private key of A to find an \\(s' \\in S\\) such that \\(V_A(s') \\in M_R\\)\n\nRemarks on the redundancy function:\n\nThe choice of a redundancy function is essential for the security of the system.\nIf \\(M_R = M_S\\) and \\(R\\) and \\(S_A\\) are bijections respectively from \\(M\\) to \\(M_R\\) and from \\(M_S\\) to \\(S\\), then \\(M\\) and \\(S\\) have identical size and, consequently, it is trivial to forge messages bearing A’s signature.\n\nExample of redundancy function: let \\(M = \\{m : m \\in \\{0,1\\}^n\\}\\) (n message size) and \\(M_S = \\{t : t \\in \\{0,1\\}^{2n}\\}\\). Let \\(R : M \\rightarrow M_S\\) such that \\(R(m) = m \\parallel m\\) (\\(\\parallel\\) being the concatenation of 2 messages). The probability of falling on such a message when trying to forge a message from a signature is: \\(|M_R| / |M_S| = (1/2)^n\\), which is negligible for large messages.\nAttention!: A redundancy function suitable for one digital signature scheme may cause vulnerabilities in another different one!\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nWith recovery: Redundancy function \\(R(m) = m_R\\).\nSignature \\(s = S_A(m_R)\\).\nVerification: \\(m_R = V_A(s)\\), reconstruct \\(m = R^{-1}(m_R)\\).\nRedundancy crucial for security."
  },
  {
    "objectID": "exam_notes_en.html#rsa-signature",
    "href": "exam_notes_en.html#rsa-signature",
    "title": "Fundamental Security Services",
    "section": "RSA Signature",
    "text": "RSA Signature\nKey generation:\n\nChoose two large prime numbers \\(p\\) and \\(q\\)\nCompute \\(n = pq\\) and \\(\\phi(n) = (p-1)(q-1)\\)\nChoose \\(e\\) with \\(\\text{gcd}(e, \\phi(n)) = 1\\)\nCompute \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\nPublic key: \\((n, e)\\); Private key: \\(d\\)\n\nSignature:\n\nCompute \\(m_R = R(m)\\) (redundancy function)\nCompute \\(s = m_R^d \\bmod n\\)\nSend \\(s\\)\n\nVerification:\n\nCompute \\(m'_R = s^e \\bmod n\\)\nVerify \\(m'_R \\in M_R\\) (reject otherwise)\nReconstruct \\(m = R^{-1}(m'_R)\\)\n\nVariant with appendix:\n\nSignature: \\(m_h = H(m)\\), then \\(s = m_h^d \\bmod n\\)\nVerification: \\(m'_h = s^e \\bmod n\\), accept if \\(m'_h = H(m)\\)\n\nCharacteristics:\n\nSignature slower than verification (\\(d\\) large, \\(e\\) small)\nDifferentiate signature/encryption keys\nVulnerable to the same attacks as RSA encryption\n\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nKey generation:\n\nEach entity (A) creates a key pair (public and private) as follows:\nA chooses the size of the modulus \\(n\\) (e.g., size\\((n) = 1024\\) or size\\((n) = 2048\\)).\nA generates two prime numbers \\(p\\) and \\(q\\) of large size \\((n/2)\\).\nA computes \\(n := pq\\) and \\(\\phi(n) = (p-1)(q-1)\\).\nA generates the verification exponent \\(e\\), with \\(1 &lt; e &lt; \\phi(n)\\) such that \\(\\text{gcd}(e, \\phi(n)) = 1\\).\nA computes the signature exponent \\(d\\), such that: \\(ed \\equiv 1 \\pmod{\\phi(n)}\\) using the extended Euclidean algorithm or fast exponentiation.\nThe pair \\((n,e)\\) is A’s public key; \\(d\\) is A’s private key.\n\nSignature:\n\nA computes the redundancy function of the message \\(m\\): \\(m_R := R(m)\\).\nA computes the signature: \\(s := m_R^d \\bmod n\\) and sends \\(s\\) to B.\n\nVerification:\n\nEntity B obtains \\((n,e)\\), the authentic public key of A.\nB computes \\(m'_R = s^e \\bmod n\\), verifies \\(m'_R \\in M_R\\) and rejects the signature if \\(m'_R \\notin M_R\\)\nB retrieves the correctly signed message by A by computing: \\(m = R^{-1}(m'_R)\\).\n\nRemarks:\nThe proof of operation is identical to that of the encryption process. The order of exponentiation has no influence since: \\[ed \\equiv de \\equiv 1 \\pmod{\\phi(n)}\\]\nThe process can also be used to produce signatures with appendix with the following modifications:\nSignature: - A uses a hash function \\(H\\) and computes \\(m_h := H(m)\\). - A computes the signature of \\(m_h\\): \\(s := m_h^d \\bmod n\\) and sends the pair \\((m,s)\\) to B.\nVerification: - B computes \\(m'_h = s^e \\bmod n\\) and \\(H(m)\\) and verifies the equality \\(m'_h = H(m)\\). - If the equality is verified, B accepts the signature \\(s\\) of A on the message M.\nThe signature computation is slower than verification because of the difference in size between the exponent \\(d\\) (size\\((d) \\approx\\) size\\((\\phi(n))\\)) and \\(e\\).\nThe risks and attacks mentioned in the encryption process also apply to the signature.\nIt is advisable to differentiate the key pairs for encryption and signature since they require distinct storage, backup and update policies.\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nRSA signature: \\(s = m_R^d \\bmod n\\) (private).\nVerify: \\(m'_R = s^e \\bmod n\\) (public).\nWith appendix: \\(s = H(m)^d \\bmod n\\).\nSignature slow, verification fast."
  },
  {
    "objectID": "exam_notes_en.html#blind-signatures",
    "href": "exam_notes_en.html#blind-signatures",
    "title": "Fundamental Security Services",
    "section": "Blind Signatures",
    "text": "Blind Signatures\nPrinciple: A sends information to B for signature. From the response, A can compute B’s signature on a different message that B has never seen.\nExploitation of the multiplicative property of RSA:\n\\[(m_1 m_2)^e \\equiv m_1^e m_2^e \\equiv c_1 c_2 \\pmod{n}\\]\nBlinding functions:\nLet \\(k\\) be an integer with \\(\\text{gcd}(n,k) = 1\\):\n\nBlinding: \\(f(m) = m \\cdot k^e \\bmod n\\)\nUnblinding: \\(g(m) = k^{-1} \\cdot m \\bmod n\\)\n\nResult: \\(g(S_B(f(m))) = g(S_B(mk^e \\bmod n)) = g(m^dk \\bmod n) = m^d \\bmod n = S_B(m)\\)\nProtocol:\n\nA → B: \\(m' = f(m)\\) (blinded message)\nA ← B: \\(s' = S_B(m')\\) (signature of blinded message)\nA computes \\(g(s')\\) and obtains \\(S_B(m)\\) (signature of original message)\n\nApplications: Anonymous electronic cash, electronic voting systems.\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nScheme invented by Chaum.\nIdea: A sends information to B for signature. B returns to A the signed information. From this signature, A can compute B’s signature on another message chosen beforehand by A. This allows A to have a signature of B on a message that B has never seen (hence the name blind signature…).\nIn fact it is a vulnerability based on the multiplicative property of RSA: \\((m_1m_2)^e \\equiv m_1^e m_2^e \\equiv c_1 c_2 \\pmod{n}\\) which was exploited to make a new signature scheme.\nAlgorithm: Let \\(S_B\\) be the RSA signature of B with \\((n,e)\\) and \\(d\\), respectively the public and private keys of B. Let \\(k\\) be a fixed integer with \\(\\text{gcd}(n,k) = 1\\):\n\\(f : \\mathbb{Z}_n \\rightarrow \\mathbb{Z}_n\\) with \\(f(m) = m \\cdot k^e \\bmod n\\) (blinding function)\n\\(g : \\mathbb{Z}_n \\rightarrow \\mathbb{Z}_n\\) with \\(g(m) = k^{-1} \\cdot m \\bmod n\\) (unblinding function)\nwhich gives:\n\\[g(S_B(f(m))) = g(S_B(mk^e \\bmod n)) = g(m^dk \\bmod n) = m^d \\bmod n = S_B(m)\\]\nProtocol:\n\nA → B: \\(m' = f(m)\\)\nA ← B: \\(s' = S_B(m')\\)\nA computes \\(g(s')\\) and obtains the desired signature using (*).\n\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nBlind signature: Exploits RSA multiplicativity.\nBlinding \\(f(m) = m \\cdot k^e\\)\nUnblinding \\(g(m) = k^{-1} \\cdot m\\).\nB signs \\(f(m)\\), A obtains \\(S_B(m)\\) without B seeing \\(m\\)."
  },
  {
    "objectID": "exam_notes_en.html#rabin-signature",
    "href": "exam_notes_en.html#rabin-signature",
    "title": "Fundamental Security Services",
    "section": "Rabin Signature",
    "text": "Rabin Signature\nKey generation:\n\nGenerate two large prime numbers \\(p\\) and \\(q\\)\nCompute \\(n = pq\\)\nPublic key: \\(n\\); Private key: \\((p, q)\\)\n\nSignature:\n\nCompute \\(m_R = R(m)\\) (redundancy function)\nCompute \\(s = \\sqrt{m_R} \\bmod n\\) (square root mod \\(n\\))\nSend \\(s\\) (one of the 4 square roots)\n\nVerification:\n\nCompute \\(m'_R = s^2 \\bmod n\\)\nVerify \\(m'_R \\in M_R\\) (reject otherwise)\nReconstruct \\(m = R^{-1}(m'_R)\\)\n\nCharacteristics:\n\nBased on the SQROOTP problem (square roots mod composite)\nProvably secure: equivalent to factorization\nVulnerable to active chosen-ciphertext attacks\n\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nKey generation:\n\nEach entity (A) creates a key pair (public and private) as follows:\nA generates two random prime numbers \\(p\\) and \\(q\\) of large size (len\\((pq) \\geq 1024\\)).\nA computes \\(n := pq\\).\nThe public key of A is \\(n\\), the private key of A is \\((p,q)\\).\n\nSignature:\n\nA computes the redundancy function of the message \\(m\\): \\(m_R := R(m)\\).\nA uses its private key to compute the signature: \\(s := m_R^{1/2} \\bmod n\\) using efficient algorithms to compute square roots mod \\(p\\) and mod \\(q\\).\nA sends \\(s\\) to B (\\(s\\) is one of the 4 obtained square roots).\n\nVerification:\n\nEntity B obtains \\(n\\), the authentic public key of A.\nB computes \\(m'_R = s^2 \\bmod n\\), verifies \\(m'_R \\in M_R\\) and rejects the signature if \\(m'_R \\notin M_R\\)\nB retrieves the correctly signed message by A by computing: \\(m = R^{-1}(m'_R)\\).\n\nRemarks:\nThe Rabin procedure is based on the impossibility of finding square roots modulo a composite of unknown factorization (SQROOTP problem).\nThe main interest of this algorithm lies in the fact that it has been proven to be equivalent to factorization (SQROOTP ⇔ FACTP). This algorithm therefore belongs to the provably secure category for any passive attack.\nActive attacks can, in some cases, compromise the security of the algorithm. More precisely, if we mount the following chosen ciphertext attack (we ask A to decrypt a chosen ciphertext):\n\nThe attacker M generates an \\(m\\) and sends to A the ciphertext \\(c = m^2 \\bmod n\\).\nA responds with a root \\(m_x\\) among the 4 possible \\(m_1, m_2, m_3, m_4\\).\nIf \\(m \\not\\equiv m_x \\pmod{n}\\) (probability 0.5), M repeats with a new \\(m\\).\nOtherwise, A computes \\(\\text{gcd}(m - m_x, n)\\) and thus obtains one of the two factors of \\(n\\)…\n\nThis attack could be avoided if the procedure required sufficient redundancy in the plaintexts allowing A to identify without ambiguity which of the possible solutions is the original plaintext. In this case, A would always respond with \\(m\\) and discard the other solutions that do not have the predefined level of redundancy.\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nRabin: \\(s = \\sqrt{m_R} \\bmod n\\).\nVerify: \\(m'_R = s^2 \\bmod n\\).\nProvably secure (equivalent to factorization).\nVulnerable to active chosen-ciphertext attacks."
  },
  {
    "objectID": "exam_notes_en.html#elgamal-signature",
    "href": "exam_notes_en.html#elgamal-signature",
    "title": "Fundamental Security Services",
    "section": "ElGamal Signature",
    "text": "ElGamal Signature\nKey generation:\n\nGenerate prime \\(p\\) and generator \\(\\alpha \\in \\mathbb{Z}_p^*\\)\nGenerate random secret \\(a\\), compute \\(y = \\alpha^a \\bmod p\\)\nPublic key: \\((p, \\alpha, y)\\); Private key: \\(a\\)\n\nSignature:\n\nCompute \\(m_h = H(m)\\)\nGenerate random \\(k\\) with \\(\\text{gcd}(k, p-1) = 1\\)\nCompute \\(r = \\alpha^k \\bmod p\\)\nCompute \\(s = k^{-1}(m_h - ar) \\bmod (p-1)\\)\nSignature: \\((r, s)\\)\n\nVerification:\n\nVerify \\(1 \\leq r \\leq p-2\\) (reject otherwise)\nCompute \\(v_1 = y^r r^s \\bmod p\\)\nCompute \\(v_2 = \\alpha^{H(m)} \\bmod p\\)\nAccept if \\(v_1 = v_2\\)\n\nProof: If \\(s \\equiv k^{-1}(m_h - ar) \\pmod{p-1}\\), then \\(m_h \\equiv ar + ks \\pmod{p-1}\\)\nSo \\(v_2 = \\alpha^{m_h} \\equiv \\alpha^{ar+ks} \\equiv (\\alpha^a)^r (\\alpha^k)^s \\equiv y^r r^s = v_1 \\pmod{p}\\)\nCharacteristics:\n\nWorks only with appendix (hash)\nBase of DSA (Digital Signature Algorithm)\n\\(k\\) must be unique for each signature\n\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nKey generation:\n\nEach entity (A) creates a key pair (public and private) as follows:\nA generates a prime number \\(p\\) (len\\((p) \\geq 1024\\) bits) and a generator \\(\\alpha\\) of \\(\\mathbb{Z}_p^*\\).\nA generates a random number \\(a\\), such that \\(1 \\leq a \\leq p-2\\) and computes \\(y := \\alpha^a \\bmod p\\).\nThe public key of A is \\((p, \\alpha, y)\\), the private key of A is \\(a\\).\n\nSignature:\n\nA uses a hash function \\(H\\) and computes \\(m_h := H(m)\\).\nA generates a random number \\(k\\) (\\(1 \\leq k \\leq p-2\\) and \\(\\text{gcd}(k,p-1) = 1\\)) and computes \\(k^{-1} \\bmod (p-1)\\)\nA computes \\(r := \\alpha^k \\bmod p\\) and then \\(s := k^{-1}(m_h - ar) \\bmod (p-1)\\)\nThe signature of A on the message \\(m\\) is the pair \\((r,s)\\).\n\nVerification:\n\nEntity B obtains \\((p, \\alpha, \\alpha^a \\bmod p)\\), the authentic public key of A.\nB verifies that \\(1 \\leq r \\leq p-2\\), otherwise rejects the signature.\nB computes \\(v_1 := y^r r^s \\bmod p\\).\nB computes \\(H(m)\\) and \\(v_2 := \\alpha^{H(m)} \\bmod p\\)\nB accepts the signature iff \\(v_1 = v_2\\).\n\nRemarks:\nProof that the scheme works: If \\(s \\equiv k^{-1}(m_h - ar) \\pmod{p-1}\\), we have: \\[m_h \\equiv (ar + ks) \\pmod{p-1}\\] and \\[v_2 = \\alpha^{H(m)} \\bmod p\\]\nif, as we wish to show \\(m_h = H(m)\\), by reducing exponents mod \\((p-1)\\), we can rewrite \\(v_2\\): \\[v_2 \\equiv \\alpha^{ar+ks} \\pmod{p}\\]\nOn the other hand: \\[v_1 = y^r r^s \\equiv \\alpha^{ar} \\alpha^{ks} \\equiv \\alpha^{ar+ks} \\pmod{p}\\] Q.E.D.\nBy construction, the ElGamal scheme works only with appendix (result of applying a hash function). The Nyberg-Rueppel scheme introduces a variation allowing message recovery.\nThe Digital Signature Algorithm (DSA), approved by the US National Institute of Standards and Technology has become the most commonly used signature standard. It is built on the basis of a direct derivative of the ElGamal scheme with the SHA-1 hash function.\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nElGamal: \\((r,s)\\) with \\(r = \\alpha^k \\bmod p\\), \\(s = k^{-1}(m_h - ar) \\bmod (p-1)\\).\nVerify: \\(y^r r^s \\stackrel{?}{=} \\alpha^{H(m)} \\bmod p\\).\nBase of DSA.\n\\(k\\) unique crucial."
  },
  {
    "objectID": "exam_notes_en.html#signatures-and-cryptocurrencies",
    "href": "exam_notes_en.html#signatures-and-cryptocurrencies",
    "title": "Fundamental Security Services",
    "section": "Signatures and Cryptocurrencies",
    "text": "Signatures and Cryptocurrencies\nCryptocurrencies massively use digital signatures to authenticate transactions.\nBitcoin and Ethereum:\n\nUse ECDSA (Elliptic Curve Digital Signature Algorithm)\nDerivative of ElGamal on elliptic curves\nSecurity based on ECDLP\n\nTransaction process:\nEach spending/transmission requires:\n\nSignature with the current holder’s private key\nThe holder was the recipient of the previous transaction\nEach transaction forms an authentication chain\n\nECDSA advantages:\n\nShorter keys for equivalent security\nMore efficient computations\nSuitable for blockchain constraints\n\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nMost cryptocurrencies are based on asymmetric cryptography. Bitcoin e.g. uses digital signatures to authenticate its transactions.\nThe spending or transmission of bitcoins requires the signature with the private key of the holder (who was in turn the recipient of the previous transaction).\nBitcoin and Ethereum use the ECDSA (Elliptic Curve Digital Signature Algorithm) algorithm derived from the ElGamal signature algorithm on elliptic curves whose security relies on ECDLP.\n[Image: Diagram showing the Bitcoin transaction chain with signatures]\nSource Image: Bitcoin: A Peer-to-Peer Electronic Cash System. Satoshi Nakamoto\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nCryptocurrencies: Bitcoin/Ethereum use ECDSA (ElGamal on elliptic curves).\nEach transaction signed with holder’s private key.\nSecurity based on ECDLP."
  },
  {
    "objectID": "exam_notes_en.html#summary-table-of-schemes",
    "href": "exam_notes_en.html#summary-table-of-schemes",
    "title": "Fundamental Security Services",
    "section": "Summary Table of Schemes",
    "text": "Summary Table of Schemes\n\n\n\nClass\nScheme\nMessage Recovery\nBase Problem\n\n\n\n\nClassical Signatures\nRSA\nYes\nRSAP\n\n\n\nRabin\nYes\nSQROOTP\n\n\n\nElGamal\nNo\nDLP\n\n\n\nDSS\nNo\nDLP\n\n\nOne-time Signatures\nLamport\nNo\ndepends on OWF\n\n\n\nBos-Chaum\nNo\ndepends on OWF\n\n\nUndeniable Signatures\nChaum-van Antwerpen\nNo\nDLP\n\n\nFail-Stop Signatures\nvan Heyst-Pedersen\nNo\nDLP\n\n\nBlind Signatures\nChaum\nYes\nRSAP\n\n\n\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\n[Complete table with all above information]\nThe operation of One-time, Undeniable and Fail-Stop signature schemes can be consulted in [Men97].\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nClassical signatures:\n\nRSA/Rabin (recovery)\nElGamal/DSS (appendix)\n\nSpecialized:\n\nOne-time\nUndeniable\nFail-stop\nBlind\n\nBase problems: RSAP, SQROOTP, DLP, depends on OWF."
  },
  {
    "objectID": "exam_notes_en.html#types-of-attacks",
    "href": "exam_notes_en.html#types-of-attacks",
    "title": "Fundamental Security Services",
    "section": "Types of Attacks",
    "text": "Types of Attacks\nCriteria for “breaking” a scheme:\n\nTotal Break: Compute the private key or efficient generation algorithm\nSelective forgery: Generate signature for fixed message/class\nExistential forgery: Forge at least one signature (without message control)\n\nBasic attacks:\n\nKey-only: Only the public key is known\nKnown-messages: Access to signatures of known messages\nChosen-messages: Attacker chooses messages to be signed\nAdaptive chosen-messages: Choice depends on previous responses\n\nThese attacks are equivalent to attacks on encryption systems (known/chosen-plaintext/ciphertext) but applied to messages.\n\n\n\n\n\n\nNoneOriginal Text\n\n\n\n\n\nCriteria for “breaking” a digital signature scheme:\n\nTotal Break: Compute the signer’s private key or an efficient (polynomial) algorithm to generate signatures.\nSelective forgery: The adversary is able to generate a valid signature for a fixed message (or class of messages).\nExistential forgery: The adversary is able to forge a signature for (at least) one message (which they do not control).\n\nBasic attacks:\n\nKey-only attacks: The adversary only has knowledge of the signer’s public key.\nMessage-based attacks: The adversary has access to signatures corresponding to:\n\nknown-messages\nchosen-messages\nadaptive chosen-messages\n\n\nEquivalent to x-ciphertext attacks but with messages!\n\n\n\n\n\n\n\n\n\nNoneQuick Revision\n\n\n\n\n\nBreaking signature:\n\nTotal break (private key)\nselective forgery (fixed message)\nexistential (one message)\n\nAttacks:\n\nkey-only\nknown/chosen/adaptive-chosen-messages.\n\n\n\n\nHere is the exact English translation of your document, preserving all content, structure, formatting, and technical terminology:"
  },
  {
    "objectID": "exam_notes_en.html#authentication-of-data-origin-and-entities",
    "href": "exam_notes_en.html#authentication-of-data-origin-and-entities",
    "title": "Fundamental Security Services",
    "section": "Authentication of Data Origin and Entities",
    "text": "Authentication of Data Origin and Entities\n\nAuthentication Methods\nAuthentication of origin ensures that a message genuinely comes from the claimed sender.\nSymmetric Methods:\n\nMAC alone: A → B: X, MACk(X) – B verifies using the shared key k\nMDC + encryption: A → B: X, Ek(MDC(X)) or A → B: Ek(X, MDC(X))\n\nAsymmetric Method:\n\nMDC + signature: A → B: X, Sigpriv-A(MDC(X)) – Also provides non-repudiation\n\nLimitations: These simple protocols do not protect against replay attacks or ensure message freshness. Time- or context-aware mechanisms are required.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAuthentication of Data Origin\n1) MAC with a symmetric key k known to A and B: A → B: X, MACk(X) If B computes MACk(X) independently and obtains the same value ⇒ the message originates from A.\n2) MDC + symmetric encryption (key k known to A and B): A → B: X, Ek(MDC(X)) B computes MDC(X) then Ek(MDC(X)). If equal ⇒ message comes from A.\n3) As 2) with confidentiality of X: A → B: Ek(X, MDC(X))\n4) MDC + digital signature: A → B: X, Sigpriv-A(MDC(X)) B computes MDC(X) and verifies Sigpriv-A(MDC(X)) using an authentic copy of pub-A. If equal ⇒ A is the originator. This solution also provides non-repudiation of origin.\nThese simple protocols offer no support for uniqueness or freshness (timeliness) of received messages and are vulnerable to replay attacks. They require mechanisms accounting for time or transaction context.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\n4 Methods\n\nMAC alone\nMDC + encryption\nMDC + confidential encryption\nMDC + signature\n\nWarning: Vulnerable to replay attacks without temporal mechanisms\n\n\n\n\n\n\n\n\ngraph LR\n    A[Sender A] --&gt;|X, MAC/Signature| B[Receiver B]\n    B --&gt;|Verifies| C{Authentic?}\n    C --&gt;|Yes| D[Accept]\n    C --&gt;|No| E[Reject]\n\n    style A fill:#e1f5ff\n    style B fill:#e1f5ff\n    style D fill:#d4edda\n    style E fill:#f8d7da\n\n\n\n\n\n\n\n\n\nEntity Authentication – Introduction\n\nObjectives of a Robust Protocol\nEntity authentication (or identification) aims to prove an entity’s identity in real time.\nRequired Properties:\n\nIf A and B are honest and A authenticates, B must accept A’s identity.\nB cannot reuse A’s information to impersonate A to C.\nNegligible probability that entity C successfully impersonates A.\nProperty 3 holds even if C has observed or participated in prior protocol instances.\n\nBasic Elements:\n\nSomething known: passwords, PINs, keys\nSomething possessed: smart cards, password generators\nSomething inherent: biometrics (fingerprints, retina, DNA)\n\nClassification:\n\nWeak authentication: Reveals the secret (userid/password)\nStrong authentication: Proves possession of the secret without revealing it\nZero-knowledge: Strong authentication without revealing any information about the secret\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nEntity Authentication (Entity Identification)\nObjectives of a Robust Identification Protocol:\n\nIf A and B are “honest”: if A can authenticate to B, B must accept A’s identity.\nB cannot reuse information provided by A to identify as A to C.\nThe probability that a third party C successfully impersonates A to B is negligible.\nPoint 3) remains true even if:\n\nC has observed a large (polynomial) number of identification protocol instances between A and B\nC has participated (possibly impersonating someone else) in prior protocol executions with A or B\nMultiple protocol instances (possibly initiated by C) may run simultaneously without compromising the identification process\n\n\nTerminology: The user (A) is called the claimant (the one claiming to be A), and the system (B) is the verifier.\nBasic Authentication Elements:\n\nSomething known: passwords, PINs, private or secret keys, etc.\nSomething possessed: passport, smart card, password generators, etc.\nSomething inherent to the individual: biometric properties like fingerprints, retina, DNA, etc.\n\nWeak Authentication: The user presents a pair (userid, password) to the system. The userid is the claimed identity, and the password is the corroborating evidence.\nStrong Authentication: The secret used to corroborate identity is not explicitly revealed. The user provides proof of possession of the secret.\nZero-Knowledge Authentication: Strong authentication protocols that additionally prove identity without revealing any information (not even a hint) about the secret itself. This involves proving an assertion without disclosing any details.\nWeak authentication protocols satisfy points 1) and 3). Strong authentication protocols satisfy (at least partially) points 2) and 4) as well.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\n3 Levels: Weak (reveals secret) &lt; Strong (proof of possession) &lt; Zero-knowledge (no info revealed)\n4 Objectives\n\nAcceptance if honest\nNon-reusability\nImpersonation resistance\nObservation resistance"
  },
  {
    "objectID": "exam_notes_en.html#attacks-and-countermeasures",
    "href": "exam_notes_en.html#attacks-and-countermeasures",
    "title": "Fundamental Security Services",
    "section": "Attacks and Countermeasures",
    "text": "Attacks and Countermeasures\n\nDictionary Attacks\n\nPrinciple and Countermeasures\nA dictionary attack systematically tests probable passwords against a cryptographic system.\nAttack Methods:\n\nOffline: The attacker obtains the hashed password database or captures exchanges\nOnline: Direct attempts against the system (typically rate-limited)\n\nVulnerability Example:\n\nA → B: A\nA ← B: R (random challenge)\nA → B: Ep(R)\n\nThe pair (R, Ep(R)) enables an offline dictionary attack.\nCountermeasures:\n\nLimit online attempts\nSalting (adding a random element)\nUse slow key derivation functions\nStrong authentication avoiding password transmission\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nDictionary Attacks\nA dictionary attack uses a database containing dictionary words from one or more languages (including variants) as input to an encryption or hashing system to obtain secret keys or passwords.\nThis attack is highly effective for obtaining poor-quality passwords, even today, with large databases containing word variations and complex mnemonic rules to “crack” higher-entropy passwords.\nA dictionary attack can be mounted:\n\nBy obtaining the system’s password database (encrypted or hashed)\nFrom one or more authentication exchange instances following a passive attack (network packet observation). For example:\n\nA → B: A (A sends its identity)\nA ← B: R (R = random number, challenge)\nA → B: Ep(R) (A encrypts R with its password)\n\n\nThe pair (R, Ep(R)) enables an offline dictionary attack.\nDictionary attacks are typically less effective online because operating systems limit the number of failed authentication attempts.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nOffline (via DB or capture) &gt; Online (system-limited)\nProtection: Salting, attempt limiting, strong authentication\n\n\n\n\n\n\n\nPlaintext Equivalence\n\nConcept and Risks\nA string is plaintext-equivalent to a password if it grants the same access as the password itself.\nVulnerability Example:\nIf the system stores H(p) and the protocol is: A → B: H(p)\nThen H(p) is plaintext-equivalent to p because the attacker can use it directly.\nCounterexample (Classic UNIX):\nThe system stores H(p) but the protocol transmits p. The stored hash is thus not plaintext-equivalent.\nSecurity Principle: Server-stored information must be neither plaintext-equivalent to passwords nor exposed to offline dictionary attacks.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nPlaintext Equivalence\nA data string is plaintext-equivalent to a password if it can be used to obtain the same access level as the password.\nExample: If system B stores a list of all hashed passwords in the following authentication process: A → B: H(p) (A sends B the hash of the password)\nThe string H(p) is plaintext-equivalent to the password p.\nThis is equivalent to saying that applying a hash function for password storage provides no additional security for the system.\nCounterexample: In the classic UNIX authentication system, the password hash stored in /etc/passwd is not plaintext-equivalent to the password because it is p (not H(p)) that is exchanged between client and server.\nThis property is essential because password databases are typically protected by logical mechanisms that are often compromised by server OS vulnerabilities.\nIf these central databases contain passwords in cleartext or plaintext-equivalent information, the consequences of an attack are devastating.\nThe ideal case is that server-stored information is neither plaintext-equivalent to passwords nor exposed to offline dictionary attacks.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nPlaintext-equivalent: Data usable like the original password\nDanger: If the system transmits H(p) and stores H(p) → H(p) is plaintext-equivalent\nGood Design: System transmits p, stores H(p) → not plaintext-equivalent"
  },
  {
    "objectID": "exam_notes_en.html#weak-authentication",
    "href": "exam_notes_en.html#weak-authentication",
    "title": "Fundamental Security Services",
    "section": "Weak Authentication",
    "text": "Weak Authentication\n\nFixed Passwords\n\nStorage and Protection\nFixed-password systems exhibit significant vulnerabilities.\nStorage Techniques:\n\nCleartext: Protected by OS access control (vulnerable to OS flaws, backups)\nEncrypted or hashed: Vulnerable to offline attacks (guessing, dictionary, collisions)\n\nMajor Problem: The password can be replayed after observation on an unprotected network.\nProtection Techniques:\n\nStrict creation rules (minimum entropy)\nRate-limiting and attempt restrictions\nSalting: Adding a random element before hashing\nRestrict password file dissemination\n\nTypical Password Entropy: Low (~40 bits for an 8-character random password, much less for common words).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nWeak Authentication – Fixed Password\nWeak authentication systems are divided into two main categories:\n\nFixed password: The password does not depend on time or the number of protocol executions. This includes systems where the password is changed by user decision or system security measures.\nVariable password: Password modification based on time and/or execution count is part of the identification protocol.\n\nStorage Techniques for Fixed-Password Systems:\n\nCleartext password storage in a file protected by the OS’s access control mechanisms.\n\nProblems: OS vulnerabilities, “super-user” privileges, backups, etc.\n\nEncrypted or hashed password storage (possibly making the file publicly accessible, cf. UNIX example).\n\nProblems: offline attacks, i.e., guessing attacks, brute-force dictionary attacks, collision identification, etc.\n\n\nMost serious fixed-password problem: It can be replayed after eavesdropping on an unprotected network.\nFixed-Password System Protection Techniques:\n\nStrict rules for password creation, maintenance, and updates, considering the low entropy of user-chosen passwords\nSlowing the identification process and limiting failed attempts to counter “online brute-force attacks”\nSalting (cf. UNIX example)\nRestrict or avoid dissemination of password files, even when encrypted\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\n2 Types: Fixed password (static) vs. Variable password (changes per instance)\nStorage: Cleartext (highly vulnerable) vs. Encrypted/Hashed (offline attacks)\nProtections: Strict rules, attempt limiting, salting, non-dissemination\n\n\n\n\n\n\n\nVariable Passwords\n\nOne-Time Passwords and Generators\nVariable passwords change with each authentication, reducing replay risk.\nLamport Scheme (S/Key):\nInitialization:\n  A generates secret w, chooses t\n  A → B: wt = Ht(w)\n  B stores: wstored := wt, n := t-1\n\nIdentification (t-n)th:\n  A → B: A, n, wn = Hn(w)\n  B tests: H(wn) == wstored\n  If OK: n := n-1, wstored := wn\nAttacks if B is not authenticated:\n\nPre-play attack: C obtains wn before A and replays it\nSmall n attack: C requests an n &lt; current n\n\nHardware Generators (SecureID):\n\nCard generates a code every 30–60 seconds\nBased on a secret key shared with the system\nVulnerable to pre-play but with limited time window\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nWeak Authentication: Variable Password\nThe two best-known variable-password identification techniques are one-time passwords and hardware random number generators.\nOne-Time Passwords – Lamport Scheme (S/Key):\nInitialization:\n\nA generates a secret w\nA constant t (~1000, number of identifications) and a OWF H are chosen\nA → B: wt = Ht(w) (H applied t times to w)\nB stores: wstored := wt, n := t-1\n\nMessages for the (t-n)th identification:\n\nA → B: A (A’s identity)\nA → B: n (current iteration for A)\nA → B: wn = Hn(w)\nB tests: H(wn) == wstored. If OK ⇒ n := n - 1 and wstored := wn\n\nEnd: When n == 0, A chooses a new w and restarts…\nAttacks: B must be authenticated! Otherwise, C impersonates B and:\n\nobtains the current password wn and can replay it (pre-play attack)\nprovides an n &lt; current n and can thus generate all Hm&gt;n(wn) (small n attack)\n\nHardware Random Number Generators:\n\nThese are smart cards that periodically (~every 30 or 60 seconds) generate different numbers used to identify (along with a PIN and user identity information) the cardholder.\nGeneration is based on a secret key present on the card and known to the system.\nThe best-known is SecureID by RSA Security.\nIt has been adopted by many banks for Internet tele-banking authentication.\nIt is also vulnerable to pre-play attacks, but the replay window is limited to the change frequency (30 or 60 seconds).\n\nConclusions on Weak Authentication:\n\nFixed passwords offer very low security.\nVariable passwords are a significant step toward strong authentication but require additional precautions.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nLamport: wn+1 = H(wn), authentication via hash chain verification\nHardware: Synchronized generator (30–60s), limited pre-play window\nWarning: Requires B’s authentication to prevent pre-play and small-n attacks"
  },
  {
    "objectID": "exam_notes_en.html#strong-authentication",
    "href": "exam_notes_en.html#strong-authentication",
    "title": "Fundamental Security Services",
    "section": "Strong Authentication",
    "text": "Strong Authentication\n\nSymmetric\n\nBasic Protocols\n\nChallenge-Response\nStrong authentication uses cryptography to prove secret possession without revealing it.\nBasic Unilateral Authentication:\nA → B: A\nA ← B: R (random challenge)\nA → B: Ek-AB(R)\nB verifies by decrypting\nSession key: K := R\nImprovements:\n\nAdd B’s identity: Es(B, ra) for key confirmation\nAdd timestamp: Es(B, ta, ra) for freshness (requires synchronized clocks)\nUse MAC instead of encryption: Hk-AB(R) (faster)\n\nVulnerabilities:\n\nMan-in-the-Middle if no mutual authentication\nChosen-plaintext attacks possible\nReplay if challenges are poorly managed\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nStrong Authentication: Symmetric Solutions\nStrong authentication protocols use symmetric or asymmetric cryptographic techniques.\nUnilateral Authentication with Shared Symmetric Key:\nA → B: A (A sends its identity)\nA ← B: R (R = random number, challenge)\nA → B: Ek-AB(R) (A encrypts R with the shared key)\nB decrypts Ek-AB(R) and identifies A if it finds R.\nRemarks:\n\nB must ensure the challenge R is random and not repeated.\nThis protocol is a significant improvement over password authentication because varying challenges prevent Eve from replaying protocol parts.\nEve can attempt an offline known-plaintext attack from a (typically small) number of pairs (R, Ek-AB(R)), but most encryption systems are secure in this regard (DES is vulnerable only after 2^47 pairs).\nC can impersonate B and choose challenges R to mount a chosen-plaintext attack (DES vulnerability is also 2^47, but other systems are more sensitive to such attacks).\nC could mount an Active Man-in-the-Middle attack by impersonating B since B is not authenticated, but must convince A to start the protocol.\nA MDC: H(k-AB,R) or a MAC: Hk-AB(R) can replace Ek-AB(R) to speed up identification.\nAfter initial identification, a secure (at least authenticated) channel must be established using cryptographic protection to prevent C from injecting packets while impersonating A.\n\nProtocols of this type, where one entity must respond based on a challenge from the other, are called challenge-and-response protocols and are the most common form of strong authentication.\nUnilateral Authentication with Shared Symmetric Key, 2nd Variant:\nA → B: A, Ek-AB(timestamp)\nRequires synchronized clocks between A and B.\nAdvantage: One fewer message and stateless protocol\nBut:\n\nClock synchronization is difficult to achieve in practice, and “drifts” can be exploited by an adversary.\nMoreover, if B’s clock is “advanced,” some past identification instances may become valid again.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nChallenge-Response: B sends challenge R, A responds with E_k(R)\nAlternative: MAC instead of encryption (faster)\nWith Timestamp: One fewer message but requires clock synchronization\n\n\n\n\n\n\n\nMutual Authentication\n\nRobust Protocols and Reflection Attacks\nBilateral authentication requires precautions against reflection attacks.\nVulnerable (Naive) Protocol:\nA → B: A, R2\nA ← B: R1, Ek-AB(R2)\nA → B: Ek-AB(R1)\nReflection Attack: C can start two instances and use B’s response to its own request to complete authentication.\nRobust Protocol:\n(1) A → B: A, R2\n(2) A ← B: Ek-AB(R1, R2, A)\n(3) A → B: Ek-AB(R2, R1)\nProtections:\n\nInclusion of A’s identity in (2) to prevent reflection attacks\nAsymmetry in challenge order (R1,R2) vs. (R2,R1)\nInclusion of challenges in the encrypted message\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nStrong Authentication: Symmetric Solutions (Mutual Authentication)\nBilateral Authentication with Shared Symmetric Key (Intuitive Solution):\nA → B: A, R2\nA ← B: R1, Ek-AB(R2)\nA → B: Ek-AB(R1)\nAt first glance, the protocol seems robust, but observe what an adversary C can do by starting two identification processes:\nC → B: A, R2 (C pretends to be A)\nC ← B: R1, Ek-AB(R2) (B responds)\nAt this point, C starts a second instance:\nC → B: A, R1\nC ← B: R3, Ek-AB(R1) (C cannot proceed further but...)\nSuccessfully completes the first identification instance with:\nC → B: Ek-AB(R1) (and it’s done!)\nBecause C returns to B the same R it received from B, such attacks are called reflection attacks.\nSince the key is shared, C could have achieved the same result (even more discreetly) by executing the second instance with A (pretending to be B).\nBilateral Authentication with Shared Symmetric Key (Robust Solution):\n(1) A → B: A, R2\n(2) A ← B: Ek-AB(R1, R2, A)\n(3) A → B: Ek-AB(R2, R1)\nThe presence of A in (2) adds extra security in case obvious reflection attacks are not detected by the protocol. Otherwise, if A initiates authentication with what it believes to be B but is actually C:\nA → C: A, R2 (*)\nThen C starts a new authentication instance with A using the same R2:\nC → A: B, R2\nIf A does not see R2 as an obvious reflection, it responds:\nC ← A: Ek-AB(R1, R2) (As in (2) but without the 'A')\nWhich C uses to complete its protocol (*). However, if A responds with B inside the packet as recommended in the protocol:\nA → C: Ek-AB(R1, R2, B)\nThis can no longer be used by C to continue (*) because it would require A instead of B.\nNote also that including R1 in the encrypted part protects against chosen plaintext attack risks from the previous solution.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nReflection Attack: Use one session’s response to authenticate another\nProtection: Include identities + asymmetry in challenges (R1,R2) vs. (R2,R1)\n\n\n\n\n\n\n\n\nAsymmetric\n\nPublic-Key Protocols\nAsymmetry avoids secret sharing but requires precautions against chosen-ciphertext attacks.\nVulnerable Protocol:\nA → B: A\nA ← B: Epub-A(R)\nA → B: R\nProblem: B can make A decrypt anything.\nRobust Protocol:\nA → B: A\nA ← B: H(R), B, Epub-A(B, R)\nA → B: R (after verifying H(R) and B)\nProtection: Structure the encrypted text and prove plaintext knowledge via H(R).\nMutual Authentication (Needham-Schroeder):\n(1) A → B: Epub-B(r1, A)\n(2) A ← B: Epub-A(r1, r2)\n(3) A → B: Epub-B(r2)\nThe presence of A in (1) prevents chosen-ciphertext attacks.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nStrong Authentication: Asymmetric Solutions\nUnilateral Authentication with Asymmetric Key (Intuitive Solution…):\nA → B: A\nA ← B: Epub-A(R) (B encrypts with A’s public key)\nA → B: R (A returns R after decryption)\nRemarks:\n\nB must know A’s authentic key to avoid man-in-the-middle attacks.\nBut especially: B can mount chosen-ciphertext attacks (i.e., B can make A decrypt anything!).\n\nUnilateral Authentication with Asymmetric Key (Robust Solution):\nIdea: Structure the text encrypted with pub-A and show that B knows the plaintext:\nA → B: A\nA ← B: H(R), B, Epub-A(B, R) (H(R) proves B knows R)\nA decrypts Epub-A(B, R) and obtains B’ and R’. A aborts the protocol if h(R') ≠ h(R) or B' ≠ B, otherwise:\nA → B: R\nB identifies A if it matches the initial R.\nA dual protocol can be imagined using A’s signature with priv-A (instead of encryption with pub-A), but the same structural precautions apply to prevent A from signing a “malicious” message generated by B.\nBilateral Authentication with Asymmetric Key. Robust Solution by Needham and Schroeder:\n(1) A → B: Epub-B(r1, A)\n(2) A ← B: Epub-A(r1, r2)\n(3) A → B: Epub-B(r2)\nNote that the presence of A in (1) thwarts chosen-ciphertext attacks.\nThe protocol can be strengthened by adding a “witness” H(r1) in (1).\nFinal Remarks on Classical Authentication:\n\nEntity authentication is a highly complex process full of unexpected pitfalls.\nSome protocols, like the one proposed by ISO in 1988 for authentication in distributed directories, have flaws very similar to those highlighted here.\nWhen identification occurs within a session, it is imperative that all session packets be authenticated (e.g., by establishing a secure channel with session key establishment).\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nVulnerability: Chosen-ciphertext attacks if no structure\nProtection: Include H(R), B’s identity in the encrypted message; A verifies before revealing R\nNeedham-Schroeder: 3 messages with identity inclusion to prevent chosen-ciphertext"
  },
  {
    "objectID": "exam_notes_en.html#zero-knowledge-proofs",
    "href": "exam_notes_en.html#zero-knowledge-proofs",
    "title": "Fundamental Security Services",
    "section": "Zero-Knowledge Proofs",
    "text": "Zero-Knowledge Proofs\n\nConcepts\n\nDefinitions and Principles\nZero-knowledge proofs allow proving possession of a secret without revealing any information about it.\nRequired Properties:\n\nCompleteness: If A and B are honest, B accepts A’s proof\nSoundness: If C succeeds in deceiving B, then C holds A’s secret (or equivalent)\nZero-knowledge: B learns nothing about A’s secret\n\nGeneric Structure:\n(1) A → B: witness\n(2) A ← B: challenge\n(3) A → B: response\nZKIP Types:\n\nComputational ZKIP: A polynomial-time observer cannot distinguish a real proof from a simulation\nPerfect ZKIP: No probabilistic difference between real proof and simulation (guaranteed by information theory)\n\nPrinciple:\n\nA commits to a class of questions (1)\nB chooses a question from this class (2)\nA answers using its secret (3)\nRepeat to reduce guessing probability.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nZero-Knowledge Proofs: Definitions\nProblem with “classical” authentication methods: B (or even an observer) can obtain information about A’s secret:\n\nIn weak authentication methods (password-based), the secret is fully revealed.\nIn classical challenge-and-response methods, B can obtain [plaintext/ciphertext] pairs useful for cryptanalysis.\n\nDefinition: An interactive protocol is a proof of knowledge if it has the following two characteristics:\n\nCompleteness: If A and B are “honest,” B accepts the proof provided by A.\nSoundness: If a “dishonest” entity C can “deceive” B, then C holds A’s secret (or polynomially equivalent information). This is equivalent to requiring secret possession for proof success.\n\nA proof of knowledge is called a zero-knowledge interactive proof (ZKIP) if it additionally has the property that A can convince B of a fact without revealing any information about its secret.\nA protocol is a computational ZKIP if an observer capable of probabilistic polynomial-time tests cannot distinguish a genuine proof (where A responds) from a simulated proof (e.g., by a random generator).\nA protocol is a perfect ZKIP if there is no probabilistic difference between the real proof and the simulated proof. The absence of information in the proof is guaranteed by Shannon’s information theory, not computational criteria.\nGeneric ZKIP Structure:\n(1) A → B: witness\n(2) A ← B: challenge\n(3) A → B: response\n\n(1) A chooses a random secret number and sends B proof of possession of this secret. This constitutes a commitment from A and defines a class of questions to which A claims to know the answers.\n(2) The challenge sent by B randomly selects a question from this class.\n(3) A responds (using its secret).\n\nIf necessary, the protocol is repeated to minimize the probability of an “impostor” guessing the correct answers by chance.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\n3 Properties: Completeness (accepts if honest), Soundness (requires secret), Zero-knowledge (no info revealed)\nStructure: Witness → Challenge → Response (repeat n times)\nPerfect ZK: Indistinguishable from simulation even with infinite resources\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant A as Prover A\n    participant B as Verifier B\n\n    Note over A: Generates witness&lt;br/&gt;with secret s\n    A-&gt;&gt;B: (1) Witness\n    Note over B: Chooses random&lt;br/&gt;challenge\n    B-&gt;&gt;A: (2) Challenge\n    Note over A: Computes response&lt;br/&gt;with secret s\n    A-&gt;&gt;B: (3) Response\n    Note over B: Verifies&lt;br/&gt;Accepts/Rejects\n\n    Note over A,B: Repeat n times for&lt;br/&gt;security 1/2^n\n\n\n\n\n\n\n\n\n\n\nZKIP – Intuitive Example (Ali Baba’s Cave)\n\nConcept Illustration\nThis example intuitively illustrates the zero-knowledge principle.\nScenario:\n\nA knows the secret passage between y and z in a cave\nB wants to verify this knowledge without learning how to traverse\n\nProtocol:\n\nB stands at entrance E\nA chooses to go to y or z (witness)\nB enters and stops at point x\nB asks A to return from the right or left (challenge)\nA uses the secret to comply (if needed)\n\nRepetition: n times. If A does not know the secret: success probability = \\(2^{-n}\\)\nProperties:\n\nB confirms A can traverse but learns nothing about how\nB cannot convince a third party B’ (A and B could have agreed on sequences)\nInspired by the “cut-and-choose” technique\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nZKIP: Intuitive Example\nThis example is described in [Qui89] (Quisquater et al., “How to Explain Zero-Knowledge Protocols to Your Children”, Crypto’89). Suppose A knows a passage between y and z (the secret).\n    E\n    |\n    x\n   / \\\n  y   z\n(1) B stands at the cave entrance at point E.\n(2) A chooses a direction and goes to points y or z (witness choice).\n(3) Once A is inside the cave, B enters and stops at point x.\n(4) B asks A to return to point x from the right or left (the challenge).\n(5) Using the secret to move from y to z (or vice versa) if necessary, A complies with B’s instructions.\nRepeat steps 1 to 5 n times. If A does not know the secret, it has a \\(2^{-n}\\) probability of successfully deceiving B (guessing “correctly”).\nIn this example, B sees that A can traverse the yz passage at will but obtains no information on how to do so, even if the protocol is executed millions of times.\nMoreover, B cannot convince B’ that A knows the secret (as would be the case if A encrypted information using a private key, for example). B’ might suspect A and B of agreeing on the sequences (right/left).\nSuch protocols are inspired by the “cut-and-choose” technique, where A and B fairly share a pie as follows: - A cuts the pie. - B chooses a piece. - A takes the remaining piece.\nThe first ZKIP was published in 1985 by S. Goldwasser [Gol85]. The application of the cut-and-choose paradigm to cryptographic protocols is due to Rabin [Rab78].\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nCave: A enters randomly (y or z), B asks for exit (left/right)\nCheating Probability: \\(2^{-n}\\) after n repetitions\nZK: B verifies knowledge but learns no secret, cannot convince third party\n\n\n\n\n\n\n\nZKIP – Graph Isomorphism\n\n\n\n\n\n\nNoneZKIP – Graph Isomorphism\n\n\n\n\n\nFormal Protocol\nZero-knowledge proofs can be constructed on hard mathematical problems.\nContext: Two graphs \\(G_1\\) and \\(G_2\\) are isomorphic if there exists a permutation \\(\\pi\\) such that for every edge \\(\\{u,v\\} \\in E_1\\), \\(\\{\\pi(u), \\pi(v)\\} \\in E_2\\).\nProperty: Finding the permutation \\(\\pi\\) between two ~1000-node graphs is computationally hard (no known polynomial algorithm).\nProtocol:\nInit: A chooses G1 and creates G2 = π(G1) with π secret\n(1) A → B: H (A creates H = φ(G2) randomly)\n(2) A ← B: i ∈ {1,2}\n(3) A → B: ψ such that H = ψ(Gi)\n    If i=2: ψ := φ\n    If i=1: ψ := φ ∘ π\n(4) B verifies H = ψ(Gi)\n(5) Repeat n times\nPerfect Zero-Knowledge Verification: Protocol transcripts are indistinguishable (probabilistic distribution) from those produced by a simulator.\n\n\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nZKIP: Graph Isomorphism\nTwo graphs \\(G_1 = (V_1,E_1)\\) and \\(G_2=(V_2,E_2)\\) are isomorphic if there exists a permutation \\(\\pi\\) such that \\(\\{u,v\\} \\in E_1\\) if and only if \\(\\{\\pi(u), \\pi(v)\\} \\in E_2\\).\nExample: \\(G_1 = (V, E_1)\\) and \\(G_2=(V, E_2)\\) with \\(V = \\{1,2,3,4\\}\\), \\(E_1= \\{12,13,23,24\\}\\), and \\(E_2 = \\{12,13,14,34\\}\\) are isomorphic with the permutation \\(G_1 \\to G_2 : \\{4,1,3,2\\}\\):\nG1:  1---2    G2:  4---1\n     |\\ /|         |\\ /|\n     | X |         | X |\n     |/ \\|         |/ \\|\n     3---4         3---2\nFrom a graph \\(G_1\\), one can easily (in polynomial time) find a permutation \\(\\pi\\) such that \\(G_2 = \\pi(G_1)\\).\nHowever, no polynomial-time algorithm is known to determine if two sufficiently large graphs (~1000 nodes) are isomorphic (i.e., find the permutation \\(\\pi\\) from \\(G_1\\) and \\(G_2\\)).\nZKIP Based on Graph Isomorphism:\n(Initialization) A chooses a sufficiently large graph \\(G_1\\) and invents a permutation \\(\\pi\\) (the secret) to compute a second graph \\(G_2 = \\pi(G_1)\\). \\(G_1\\) and \\(G_2\\) are made public.\n(1) A → B: H\nA chooses a random permutation \\(\\phi\\) such that \\(H = \\phi(G_2)\\) and sends H to B (the witness).\n(2) A ← B: i\nB chooses an integer \\(i \\in \\{1,2\\}\\) and sends it to A (the challenge).\n(3) A → B: ψ\nA computes \\(\\psi\\) such that \\(H = \\psi(G_i)\\): - If \\(i = 2\\): \\(\\psi := \\phi\\) - If \\(i = 1\\): \\(\\psi := \\phi \\circ \\pi\\)\n(4) B checks if \\(H = \\psi(G_i)\\) and accepts the step as correct.\n(5) Repeat (1) to (4) enough times to minimize “guessing” risks.\nProperty Verification:\n\nCompleteness: The protocol is accepted if A knows the secret (i.e., the permutation \\(\\pi\\) between the two graphs).\nSoundness: If C tries to impersonate A without knowing \\(\\pi\\), it can fix a j and provide a correct permutation \\(\\psi(G_j)\\) but cannot find a correct permutation for both graphs. It must guess the challenge provided by B.\nZero-Knowledge: A succeeds in convincing B that the two graphs are isomorphic but learns nothing about \\(\\pi\\). B only sees a random graph H isomorphic to \\(G_1\\) and \\(G_2\\) and a permutation between H and \\(G_1\\) or between H and \\(G_2\\).\nPerfect Zero-Knowledge: This means B could generate such information alone (using a random generator and polynomial computations). It can be proven that the transcripts provided by the protocol are indistinguishable (from a probabilistic distribution perspective) from those produced by a simulator.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nProblem: Finding permutation between two isomorphic graphs = hard\nProtocol: A creates random H, B asks for permutation to G1 or G2, A responds\nPerfect ZK: Transcripts indistinguishable from a simulator\n\n\n\n\n\n\nZKIP – Fiat-Shamir Algorithm\n\nPractical Protocol\nFiat-Shamir is an efficient and practical ZKIP based on the square root modulo composite problem.\nInitialization:\n\nTrusted third party T chooses \\(n = pq\\) (keeps p,q secret)\nA chooses secret \\(s\\) with \\(\\gcd(s,n) = 1\\)\nA computes \\(v = s^2 \\bmod n\\) and distributes v (certified public key)\n\nProtocol:\n(1) A → B: x = r² mod n\n    (A chooses random r, witness)\n\n(2) A ← B: e ∈ {0,1}\n    (B sends challenge)\n\n(3) A → B: y = r·sᵉ mod n\n    (A computes response with secret s)\n\nB rejects if y = 0\nB accepts if y² ≡ x·vᵉ (mod n)\nRepetition: Multiple times for security \\(2^{-nk}\\)\nProperties:\n\nSoundness: An impostor can easily answer e=0, but for e=1, it must compute \\(\\sqrt{x} \\bmod n\\) (hard by SQROOTP)\nPerfect Zero-Knowledge: The pairs (x,y) can be simulated by B by choosing y randomly and computing \\(x = y^2\\) or \\(y^2/v\\)\nB cannot impersonate A because it cannot predict challenges\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nZKIP: Fiat-Shamir Algorithm\nGoal: Allow A to identify itself by proving knowledge of a secret s (associated with A via authentic public information) to B without revealing any information about s.\nThis is a protocol serving as the basis for real and efficient implementations.\nAlgorithm:\n(Initialization):\n\nA trusted third party T chooses and publishes an n such that \\(n = pq\\) and keeps p and q secret.\nA chooses a secret s with \\(1 \\leq s \\leq n -1\\) and \\(\\gcd(s,n) = 1\\), computes \\(v = s^2 \\bmod n\\), and distributes v as a public key certified by T.\n\n(1) A → B: x = r² mod n\nA chooses a random r and sends a witness \\(r^2\\).\n(2) A ← B: e ∈ {0,1}\nB sends its challenge.\n(3) A → B: y = r·sᵉ mod n\nA computes the response using the secret s.\nB rejects the proof if \\(y = 0\\) (an impostor could falsify the proof with \\(r = 0\\)) and accepts the proof if \\(y^2 \\equiv x \\cdot v^e \\pmod{n}\\).\nSteps (1) to (3) are repeated until a sufficient confidence margin is reached.\nProperty Verification:\n\nCompleteness: If A knows s, the protocol accepts the identification proof.\nSoundness: In the simple case, an impostor could only answer \\(e = 0\\). Otherwise, it could choose a random r and send \\(x = r^2/v\\) in (1) and respond to the challenge \\(e = 1\\) with a correct answer \\(y = r\\). For \\(e = 0\\), it would need to compute the square root of x mod n (n composite with unknown factorization), which is hard by SQROOTP. Proof success thus requires secret possession.\nZero-Knowledge: B cannot obtain any information about s because when \\(e = 1\\), it is hidden by a random number (blinding factor).\nPerfect Zero-Knowledge: The pairs (x,y) obtained from A can also be simulated by B by choosing a random y and computing \\(x = y^2\\) or \\(y^2/v \\bmod n\\). It can be proven that these pairs have an identical probabilistic distribution to those provided by A (who computes them differently!).\n\nNote that, despite this last property, B is unable to impersonate A to B’ because it cannot predict the challenge values e.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nSecret: \\(s\\) such that \\(v = s^2 \\bmod n\\) (public key)\nProtocol: Witness \\(r^2\\), challenge \\(e \\in \\{0,1\\}\\), response \\(y = r \\cdot s^e\\)\nVerification: \\(y^2 \\equiv x \\cdot v^e \\pmod{n}\\)\nPerfect ZK: Pairs (x,y) simulatable by B\n\n\n\n\n\n\n\nZKIP – Practical Implementations\n\nEfficient Protocols\nPractical implementations improve Fiat-Shamir’s efficiency.\nFeige-Fiat-Shamir (FSS):\n\nUses multiple witnesses and challenges (k values) per iteration\nCheating probability: \\(2^{-nk}\\) for n iterations\nReduces required exchanges\n\nGuillou-Quisquater (GQ):\n\nBased on Fiat-Shamir but with expanded challenge domain\nReduces guessing probability without increasing exchanges\nBetter efficiency/security trade-off\n\nSchnorr:\n\nBased on discrete logarithm difficulty (DLP)\nVery large challenge domain\nIdentification in just 3 exchanges\nSometimes sacrifices perfect zero-knowledge for efficiency\n\nAdvantages: More efficient than RSA, implementable on low-capacity devices (smart cards).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nZKIP: Common Implementations\nFeige-Fiat-Shamir (FSS):\n\nBased on the Fiat-Shamir protocol but using multiple witnesses and challenges (sets of k values) per iteration; for n iterations, this gives a probability of \\(2^{-nk}\\) of guessing all responses.\n\nGuillou-Quisquater (GQ):\n\nAlso based on Fiat-Shamir but increasing the challenge choice, which reduces the guessing probability without increasing the number of transferred instances and protocol steps.\n\nSchnorr:\n\nBased on the difficulty of computing discrete logarithms (DLP)\nIt also uses a very large challenge domain, allowing identification in just 3 message exchanges.\n\nThese protocols are significantly more efficient than RSA and can be implemented on low-computing-capacity devices (smart cards).\nThey satisfy completeness and soundness properties, but the zero-knowledge property is sometimes sacrificed (as in Schnorr’s case) to increase efficiency.\nFor a detailed description of these protocols, refer to [Men97] or [Sti95].\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nFSS: Multiple witnesses/challenges → probability \\(2^{-nk}\\)\nGQ: Expanded challenge domain → fewer exchanges\nSchnorr: DLP + large challenges → 3 exchanges only\nAll: More efficient than RSA, suitable for smart cards\n\n\n\n\n\n\n\nZKIP – Mafia Attack and Final Remarks\n\nVulnerabilities and Countermeasures\nEven robust ZKIP protocols can be vulnerable to sophisticated attacks.\nMafia Attack (1989, Adi Shamir):\nScenario: C (attacker) and D (accomplice) collaborate so D impersonates A to B.\nA ↔ C: ZKIP Instance     D ↔ B: ZKIP Instance\nC relays A’s messages to D (accomplice), who uses them to authenticate to B. The attack is transparent to A and B.\nCountermeasures:\n\nFaraday cages (blocking radio communications)\nStrong synchronization to prevent side exchanges\nDistance bounding protocols limiting response delay\n\nGeneral Recommendations:\n\nChoose proven solutions over inventing new ones\nVerify objectives are met\nAnalyze practically (reflection attacks, redundancy, etc.)\nAnalyze formally (BAN logic, model checking)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nZKIP: Final Remarks\nZKIPs offer a very high level of cryptographic security. They allow identifications while minimizing the chances of a hypothetical impostor and, most importantly, protecting the secret information of “honest” users.\nIn 1989 (SECURICOM’89), Adi Shamir said about ZKIPs: “I could go to a Mafia-owned store a million times in a row, and they still wouldn’t be able to impersonate me”…\nAnd yet: A participates in a ZKIP with C (Mafia); simultaneously, D (C’s accomplice) participates in another ZKIP pretending to be A to B (an “honest” verifier).\n(1) A → C: t1 (witness that C forwards via radio to D)\n(1') D → B: t1\n(2') D ← B: d1 (B sends the challenge to D; D forwards it to C...)\n(2) A ← C: d1 (C resumes the challenge in its dialogue with A)\n(3) A → C: r1 (the response using its secret, which C sends to D)\n(3') D → B: r1 (B accepts r1 and so on!)\nSolutions:\n\nConduct identifications in Faraday cages…\nUse strong synchronization algorithms to prevent side exchanges.\n\nAuthentication: Summary – Attacks and Protections\n\n\n\n\n\n\n\n\nAttack\nDescription\nProtection\n\n\n\n\nreplay\nreplay a previous identification instance\nzero-knowledge, challenge-and-response, one-time password (beware of pre-play!)\n\n\nknown/chosen-plaintext\nobtain plaintext/ciphertext pairs\nzero-knowledge\n\n\nchosen-ciphertext\nmake A decrypt (or sign) carefully chosen information\nzero-knowledge, ch. & resp. + knowledge witness + structure (redundancy!)\n\n\nreflection\nreturn the same number received\ninclude target entity in messages, asymmetry in messages\n\n\ninterleaving\nuse messages from multiple simultaneous protocol instances\ninclude target entity in messages, introduce cryptographic chaining between messages of the same identification instance\n\n\ncollusion\ncollusion between participants\nFaraday cage, strong synchronization\n\n\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nMafia Attack: Relay messages via accomplice → transparent fraudulent authentication\nProtections: Faraday cage, strong synchronization, distance bounding\nAttack Table: replay, chosen-plaintext/ciphertext, reflection, interleaving, collusion"
  },
  {
    "objectID": "exam_notes_en.html#summary-attacks-and-protections",
    "href": "exam_notes_en.html#summary-attacks-and-protections",
    "title": "Fundamental Security Services",
    "section": "Summary – Attacks and Protections",
    "text": "Summary – Attacks and Protections\n\n\n\n\n\n\n\n\nAttack\nDescription\nProtection\n\n\n\n\nreplay\nreplay a previous identification instance\nzero-knowledge, challenge-and-response, one-time password (beware of pre-play!)\n\n\nknown/chosen-plaintext\nobtain plaintext/ciphertext pairs\nzero-knowledge\n\n\nchosen-ciphertext\nmake A decrypt (or sign) carefully chosen information\nzero-knowledge, ch. & resp. + knowledge witness + structure (redundancy!)\n\n\nreflection\nreturn the same number received\ninclude target entity in messages, asymmetry in messages\n\n\ninterleaving\nuse messages from multiple simultaneous protocol instances\ninclude target entity in messages, introduce cryptographic chaining between messages of the same identification instance\n\n\ncollusion\ncollusion between participants\nFaraday cage, strong synchronization\n\n\n\nHere is the exact English translation of your Key Establishment Protocols (KEP) document, preserving all content, structure, technical terms, and formatting:"
  },
  {
    "objectID": "exam_notes_en.html#kep-definition-and-properties",
    "href": "exam_notes_en.html#kep-definition-and-properties",
    "title": "Fundamental Security Services",
    "section": "KEP Definition and Properties",
    "text": "KEP Definition and Properties\n\nDefinitions and Classification\nKey Establishment Protocol (KEP): A mechanism enabling entities to share a secret for their cryptographic exchanges.\nTwo Types:\n\nKey Transport Protocol (KTP): One entity creates and transmits the key.\nKey Agreement Protocol (KAP): Entities jointly derive the key.\n\nTemporal Classification:\n\nPre-distribution: Keys determined in advance.\nDynamic Key Establishment (DKE): Keys change with each execution.\n\n\n\n\nKey Establishment Protocols\n\n\n\n\nKey Agreement\n\n\nKey Transport\n\n\n\n\nSymmetric + pre-dist.\n\n\nSymmetric + DKE\n\n\nSymmetric + DKE\n\n\n\n\nAsymmetric + pre-dist.\n\n\nAsymmetric + DKE\n\n\nAsymmetric + DKE\n\n\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA key establishment protocol (KEP) is one that provides the involved entities with a shared secret (a key) to serve as the basis for subsequent cryptographic exchanges.\nThe two variants of KEPs are key transport protocols (KTP) and key agreement protocols (KAP).\n\nA key transport protocol (KTP) is a mechanism allowing one entity to create a secret key and transfer it to its correspondent(s).\nA key agreement protocol (KAP) is a mechanism allowing two (or more) entities to derive a key from information specific to each entity.\n\nKey pre-distribution schemes are those where the keys used are entirely determined a priori (e.g., from initial calculations).\nDynamic key establishment schemes (DKE) are those where the keys change for each protocol execution.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nKEP: Protocols to establish a shared secret.\n\nKTP: Key transport\nKAP: Mutual key agreement\nPre-distribution vs. DKE (dynamic)\n\n\n\n\n\n\n\nKEP Properties\nAuthentication Properties:\n\nImplicit key authentication: Assurance that only the correspondent can access the key (without proof of possession).\nKey confirmation: Assurance that the correspondent effectively possesses the key.\nExplicit key authentication: Implicit + confirmation.\nAuthenticated KEP: A KEP providing key authentication.\n\nTemporal Security Properties:\n\nPerfect Forward Secrecy (PFS): Compromise of long-term keys does not reveal past session keys.\nFuture Secrecy: Future keys are protected even if long-term keys are compromised (by a passive attacker).\nDeniability/Repudiability: Inability to prove participation to a third party (like Zero-Knowledge).\n\nTypes of Attacks:\n\nPassive attack: Recording and analyzing exchanges.\nActive attack: Modifying or injecting messages.\nKnown-key attack: Exploiting a compromised session key to attack future keys.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nKey Establishment Protocol Properties:\n\nImplicit key authentication (or key authentication): A property by which an entity is assured that only its correspondent(s) can access a secret key. However, this does not specify anything about actually possessing the key.\nKey confirmation: A property allowing an entity to be sure that its correspondents are in possession of the generated session keys.\nExplicit key authentication: = implicit key authentication + key confirmation.\nAn authenticated KEP is a KEP capable of providing key authentication.\n\nAttacks:\n\nA passive attack attempts to break a cryptographic system by recording and analyzing exchanges.\nAn active attack involves an adversary who modifies or injects messages.\nA protocol is said to be vulnerable to a known-key attack if, when a previous session key is compromised, it becomes possible to: (a) compromise future keys via a passive attack and/or (b) mount active attacks aiming at identity impersonation.\n\nModern Properties:\n\nPerfect Forward Secrecy (PFS) is a characteristic that guarantees the confidentiality of past session keys even if long-term keys (e.g., the recipient’s private key) are compromised.\nFuture Secrecy: The protocol guarantees the security of future exchanges (future session keys are protected) even if long-term keys are compromised by a passive attacker.\nDeniability / Repudiability: Similar to Zero-Knowledge authentication protocols, this allows entities to ensure exchange authentication without providing information that would allow proving their participation in the cryptographic exchange to a third party.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nAuthentication:\n\nImplicit: Only the correspondent can access the key\nKey confirmation: Proof of possession\nExplicit: Implicit + confirmation\n\nSecurity:\n\nPFS: Past keys protected if compromise occurs\nFuture Secrecy: Future keys protected\nDeniability: Participation not provable"
  },
  {
    "objectID": "exam_notes_en.html#kap",
    "href": "exam_notes_en.html#kap",
    "title": "Fundamental Security Services",
    "section": "KAP",
    "text": "KAP\n\nSymmetric\n\nwith Pre-distribution\nTrivial Case:\nFor \\(n\\) users with a Key Distribution Center (KDC):\n\nKDC generates \\(\\frac{n(n-1)}{2}\\) different keys (one per user pair).\nKDC distributes \\(n-1\\) keys to each user via a confidential channel.\n\nAdvantages:\n\nInformation-theoretically secure against user collusion.\n\nDisadvantages:\n\n\\(O(n^2)\\) storage complexity for the KDC.\n\\(O(n)\\) keys per user.\nNot scalable.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nSymmetric KAP with Pre-distribution – Trivial Case\nGiven \\(n\\) users with a Key Distribution Center (KDC).\nA trivial symmetric KAP with pre-distribution can be constructed as follows:\n\nThe KDC generates \\(n(n-1)/2\\) different keys (one different key for each user pair).\nThe KDC then distributes the keys via a confidential and authentic channel, giving \\(n-1\\) keys to each user.\n\nIf the KDC generates the keys in a truly random manner, this system is information-theoretically secure against user collusion (even if \\(n-2\\) users collude, they cannot find the key of the other two) by protocol construction.\nProblem with this protocol:\n\n\\(O(n^2)\\) key storage for the KDC.\n\\(O(n)\\) secret keys exchanged for each entity.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nTrivial symmetric KAP:\n\n\\(n(n-1)/2\\) keys for \\(n\\) users\nInformation-theoretically secure\nProblem: \\(O(n^2)\\) storage\n\n\n\n\n\n\n\nwith Dynamic Key Establishment (DKE)\n\nSimple Example\nInitialization: A and B share a long-term key \\(S\\).\nProtocol:\n\n\\(A \\rightarrow B: r_a\\) (random number)\n\\(A \\leftarrow B: r_b\\) (random number)\nSession key: \\(K := E_S(r_a \\oplus r_b)\\)\n\nProperties:\n\n❌ Entity authentication\n✅ Implicit key authentication\n❌ Key confirmation\n❌ Perfect Forward Secrecy\n\n\n\nAKEP2 (Authenticated Key Exchange Protocol 2)\nInitialization: A and B share \\(S\\) (for MAC) and \\(S'\\) (for session key).\nProtocol:\n\n\\(A \\rightarrow B: r_a\\)\n\\(A \\leftarrow B: T = (B,A,r_a,r_b), h_S(T)\\)\n\\(A \\rightarrow B: (A, r_b), h_S(A,r_b)\\)\nSession key: \\(K := h'_{S'}(r_b)\\)\n\nProperties:\n\n✅ Mutual entity authentication\n✅ Implicit key authentication\n❌ Key confirmation\n❌ Perfect Forward Secrecy\n\nNote: The key depends only on \\(B\\) and the long-term key \\(S'\\)!\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nSymmetric KAP with Dynamic Key Establishment\nThese methods allow the involved entities to derive short-term keys (typically session keys) from long-term secrets, which, for these protocols, are symmetric keys.\nIntuitive Example:\n(Initialization): A and B share a long-term symmetric key \\(S\\).\n\n\\(A \\rightarrow B: r_a\\); A generates a random number and sends it to B.\n\\(A \\leftarrow B: r_b\\); B does the same.\n\nA and B compute the session key: \\(K := E_S(r_a \\oplus r_b)\\).\nProperties: - Entity authentication: NO: By protocol construction, the \\(r_i\\) can be sent by any entity. - Implicit key authentication: YES: Only entities sharing the long-term symmetric key \\(S\\) can access the session key \\(K\\). - Key confirmation: NO: Since the \\(r_i\\) are random, they can be modified by an adversary, preventing A and B from agreeing on the session key \\(K\\). This would not be detected by the protocol. - Perfect Forward Secrecy: NO: If the long-term key \\(S\\) is compromised, all previous session keys can be easily computed by an adversary who recorded all exchanges.\nAuthenticated Key Exchange Protocol 2 (AKEP2)\n(Init.): A and B share two long-term symmetric keys \\(S\\) and \\(S'\\). \\(S\\) is used to generate MACs \\(h_S()\\) (to ensure integrity and entity authentication), and \\(S'\\) is used for session key \\(K\\) generation.\n\n\\(A \\rightarrow B: r_a\\); A generates a random number and sends it to B.\n\\(A \\leftarrow B: T = (B,A,r_a,r_b), h_S(T)\\); B does the same + identities + MAC of everything.\n\\(A \\rightarrow B: (A, r_b), h_S(A,r_b)\\); A verifies the identities and the \\(r_a\\) provided by B; then sends identity + \\(r_b\\) + MAC of everything.\n\nThe key is bilaterally computed using a dedicated MAC \\(h'_{S'}()\\): \\(K := h'_{S'}(r_b)\\).\nProperties: - Entity authentication: YES (mutual, provided by MACs). - Implicit key authentication: YES. - Key confirmation: NO (no evidence that the key \\(S'\\) is known to the correspondent). - Perfect Forward Secrecy: NO (if the key \\(S'\\) is compromised, previous session keys \\(K\\) are also compromised).\nThe key depends only on B (and the long-term key \\(S'\\)), but the protocol can be easily modified so that the key also depends on A, making it a “true” KAP.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nSymmetric KAP with DKE:\n\nSimple: \\(K := E_S(r_a \\oplus r_b)\\) – no PFS\nAKEP2: Uses MACs for authentication + key derived as \\(K := h'_{S'}(r_b)\\)\nNo PFS if \\(S'\\) is compromised\n\n\n\n\n\n\n\n\n\nAsymmetric with Pre-distribution\n\nDiffie-Hellman\nInitialization: Public prime \\(p\\) and generator \\(\\alpha \\in \\mathbb{Z}_p^*\\).\nProtocol:\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\) (A chooses secret \\(x\\))\n\\(A \\leftarrow B: \\alpha^y \\mod p\\) (B chooses secret \\(y\\))\nShared key: \\(K := \\alpha^{xy} \\mod p\\)\n\n\nA computes \\(K := (\\alpha^y)^x \\mod p\\)\nB computes \\(K := (\\alpha^x)^y \\mod p\\)\n\nSecurity:\n\nBased on the Diffie-Hellman Problem (DHP): Impossible to compute \\(\\alpha^{xy}\\) from \\(\\alpha^x\\) and \\(\\alpha^y\\).\nProven result: DHP \\(\\equiv\\) DLP.\n\nMan-in-the-Middle (MIM) Attack:\nAdversary C intercepts and replaces:\n\n\\(\\alpha^x\\) with \\(\\alpha^{x'}\\) to B\n\\(\\alpha^y\\) with \\(\\alpha^{y'}\\) to A\nC establishes two keys: \\(\\alpha^{xy'}\\) with A and \\(\\alpha^{x'y}\\) with B\n\nProperties (Unauthenticated DH):\n\n❌ Entity authentication\n❌ Implicit key authentication (vulnerable to MIM)\n❌ Key confirmation\n\nSymmetric Key Generation:\nDH keys are not bit secure.\nSolution: Apply a MDC (SHA, MD5) to the entire key \\(K\\):\n\\[K_{sym} := \\text{SHA-256}(K)\\]\nResult: KAP with Dynamic Key Establishment.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAsymmetric KAP with Pre-Distribution – Diffie-Hellman\nPublished in 1976, this is the precursor of asymmetric protocols.\nIt allows two entities that have never met to construct a shared key by exchanging messages over a non-confidential channel.\nProtocol:\nInitialization: A prime number \\(p\\) is generated, and a generator \\(\\alpha\\) of \\(\\mathbb{Z}_p^*\\), such that \\(\\alpha \\in \\mathbb{Z}_{p-1}\\). Both numbers are made public.\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\); A chooses a secret \\(x \\in \\mathbb{Z}_{p-1}\\) and sends the public part.\n\\(A \\leftarrow B: \\alpha^y \\mod p\\); B chooses a secret \\(y \\in \\mathbb{Z}_{p-1}\\) and sends the public part.\n\nA computes the secret key: \\(K := (\\alpha^y)^x \\mod p\\), and B does the same: \\(K := (\\alpha^x)^y \\mod p\\).\nThe security of this scheme lies in the impossibility of finding \\(\\alpha^{xy} \\mod p\\) from \\(\\alpha^x \\mod p\\) and \\(\\alpha^y \\mod p\\) (Diffie-Hellman Problem: DHP).\nProven result: DHP \\(\\equiv\\) DLP.\nDiffie-Hellman is secure (as much as DHP) against passive attacks. In other words, an adversary limited to observing messages cannot find the key \\(K\\).\nThis is no longer true for active attacks; let’s see what C can do by modifying messages:\nC exchanges secret keys with A and B, respectively: \\(\\alpha^{xy'} \\mod p\\) and \\(\\alpha^{x'y} \\mod p\\) (C controls \\(x'\\) and \\(y'\\)). If C re-encrypts each packet it receives with the corresponding public key, the attack will be transparent to A and B.\nThis attack is called Man-in-the-Middle (MIM) and applies to all asymmetric protocols.\nIt is due to the lack of authentication of public keys, i.e., when A “talks” to B, it must use the authentic public key of B.\nCharacteristics of Diffie-Hellman (unauthenticated):\n\nEntity Authentication: NO.\nImplicit key authentication: NO (due to the MIM attack).\nKey confirmation: NO (due to the MIM risk, A cannot be sure that B possesses the shared secret key).\n\nGenerating Symmetric Keys from a Diffie-Hellman Shared Key:\nThe quantities manipulated in DH (notably \\(K\\)) are 512–1024 bits in size (depending on the prime \\(p\\) used).\nAn intuitive approach to generate smaller symmetric keys (64–128 bits) would be to take a subset of bits from the key \\(K\\).\nUnfortunately, it can be proven that DH keys are not bit secure, meaning that subsets of bits (especially the Least Significant Bits) can be computed with an effort not proportional to that required to compute the entire key.\nTo generate keys securely, it is recommended to apply a MDC (like SHA or MD5) to the entire key (possibly chaining MDC applications to obtain successive symmetric keys).\nThis method yields a KAP with Dynamic Key Establishment.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nDiffie-Hellman:\n\n\\(K := \\alpha^{xy} \\mod p\\) computed independently by A and B\nSecure against passive attacks (DHP \\(\\equiv\\) DLP)\nVulnerable to MIM without authentication\nGenerate symmetric keys: \\(K_{sym} := \\text{SHA}(K)\\)\n\n\n\n\n\n\n\n\nAsymmetric with DKE\n\nStation to Station Protocol (STS)\nAuthenticated Diffie-Hellman with digital signatures.\nInitialization: Public prime \\(p\\) and generator \\(\\alpha\\). A and B have authentic copies of each other’s public keys.\nProtocol:\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\)\n\\(A \\leftarrow B: \\alpha^y \\mod p, E_k(S_B(\\alpha^x, \\alpha^y))\\)\n\nB computes \\(k := (\\alpha^x)^y \\mod p\\)\nB signs and encrypts the public parts\n\n\\(A \\rightarrow B: E_k(S_A(\\alpha^y, \\alpha^x))\\)\n\nA decrypts, verifies B’s signature\nA signs and encrypts in reverse order\n\n\nProperties:\n\n✅ Mutual entity authentication (via signatures)\n✅ Implicit key authentication (DHP + signatures prevent MIM)\n✅ Key confirmation (encryption proves possession of \\(k\\))\n✅ Explicit key authentication (authentication + key confirmation)\n✅ Perfect Forward Secrecy (compromise of signature private key does not reveal past session keys)\n\nEfficient Variant: Replace \\(E_k(S_B(...))\\) with \\((sig, h_k(sig))\\) using MAC instead of symmetric encryption.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAsymmetric KAP with DKE – Station to Station Protocol\n(Notation) \\(S_A\\): Signature with A’s private key.\n(Initialization): (a) Choose a prime \\(p\\) and a generator \\(\\alpha\\) of \\(\\mathbb{Z}_p^*\\), such that \\(\\alpha \\in \\mathbb{Z}_{p-1}\\). Both numbers are made public (and optionally associated with the participants’ public keys).\n\nParticipants have access to authentic copies of the correspondents’ public keys. Certificates may be exchanged if needed in (2) and (3).\n\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\); A generates a secret \\(x\\) and sends the public part.\n\\(A \\leftarrow B: \\alpha^y \\mod p, E_k(S_B(\\alpha^x, \\alpha^y))\\); B generates a secret \\(y\\) and computes the key: \\(k := (\\alpha^x)^y \\mod p\\) + signs and encrypts the public parts.\n\\(A \\rightarrow B: E_k(S_A(\\alpha^y, \\alpha^x))\\); A decrypts by computing \\(k := (\\alpha^y)^x \\mod p\\), verifies B’s signature and the public parts; if OK, A signs + encrypts in reverse order.\n\nB decrypts and verifies A’s signature on the public parts. If OK =&gt; END.\nCharacteristics:\n\nEntity Authentication: YES (mutual, provided by signatures).\nImplicit key authentication: YES, keys are protected by DHP. The MIM attack is made impossible by signatures.\nKey confirmation: YES, both entities prove possession of the key by encrypting quantities with it.\nExplicit key authentication: YES: implicit key authentication + key confirmation.\nPerfect Forward Secrecy: YES. The only long-term key is the one used for signing/verification. If this key is compromised, past session keys are protected because they are not explicitly exchanged but rather computed via DH.\n\nObviously, once the signature key is compromised (private key theft), the stated properties no longer hold for future exchanges.\nThe protocol additionally provides anonymity since the parties’ identities are protected by \\(k\\).\nVariant: In (2), compute \\(sig := S_B(\\alpha^x, \\alpha^y)\\), and send \\((sig, h_k(sig))\\) instead of \\(E_k(S_B(\\alpha^x, \\alpha^y))\\). Same for (3), observing the protocol’s asymmetries.\nMore efficient solution as it uses a MAC rather than symmetric encryption.\nRobust and efficient algorithm chosen as the base for key generation in IPv6.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nStation to Station (STS):\n\nDH + digital signatures\n✅ PFS: Past session keys protected\n✅ Explicit key authentication\nUsed in IPv6\n\n\n\n\n\n\n\nOff-The-Record (OTR) and Signal Protocols\n\nOff-The-Record (OTR)\nProtocol (2004) for instant messaging with repudiability.\nSIGMA Technique (SIGn-and-MAC):\n\nDH signatures + ephemeral authentication via MAC\nKey Derivation Function (KDF) generates two keys: \\(K_e\\) (AES-CTR encryption) and \\(K_m\\) (MAC)\nKey change per conversation\nRevelation of previous MAC keys to ensure repudiability\n\nSimplified Protocol:\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\)\n\\(A \\leftarrow B: \\alpha^y \\mod p, S_B(\\alpha^x, \\alpha^y), \\text{MAC}_{K_m}(B)\\)\n\nB computes \\(k := (\\alpha^x)^y \\mod p\\)\n\\((K_m, K_e) := \\text{KDF}(k)\\)\n\n\\(A \\rightarrow B: S_A(\\alpha^y, \\alpha^x), \\text{MAC}_{K_m}(A)\\)\n\nMessages encrypted with \\(K_e\\).\n\n\nSignal Protocol\nEvolution of OTR for social networks (WhatsApp, Facebook Messenger).\nCharacteristics:\n\nEphemeral asymmetric and symmetric keys\nDH on elliptic curves\n✅ PFS\n✅ Future Secrecy\n✅ Repudiability\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nOff-The-Record (OTR) Protocol\nProtocol designed in 2004 to provide authentication and confidentiality services in instant messaging exchanges while preserving the “repudiable” nature of an “off-the-record” conversation.\nThe protocol also satisfies PFS and Future Secrecy properties in case of long-term key compromise.\nIt follows the same principles as the Station-to-Station protocol, adding ephemeral authentication via a MAC to the DH parameter signatures. This dual technique is called SIGMA (SIGn-and-MAC).\nIt uses a Key Derivation Function (KDF) to generate an encryption key (\\(K_e\\)) preserving message confidentiality with AES CTR-mode and a MAC key (\\(K_m\\)) ensuring message origin authenticity.\nEach conversation involves a key change (new DH parameter exchange) with an additional plaintext exchange of the MAC keys (\\(K_m\\)) used in the previous exchange to ensure repudiability!\nSchematic OTR Protocol Exchanges:\n\n\\(A \\rightarrow B: \\alpha^x \\mod p\\); A generates a secret \\(x\\) and sends the public part.\n\\(A \\leftarrow B: \\alpha^y \\mod p, S_B(\\alpha^x, \\alpha^y), \\text{MAC}_{K_m}(B)\\)\n\nB generates a secret \\(y\\), computes the session key \\(k := (\\alpha^x)^y \\mod p\\), and signs the DH public parts. It then generates keys \\(K_e\\) and \\(K_m\\) via the KDF: \\((K_m, K_e) := \\text{KDF}(k)\\).\n\n\\(A \\rightarrow B: S_A(\\alpha^y, \\alpha^x), \\text{MAC}_{K_m}(A)\\); A does the same.\n\nMessages are then encrypted with key \\(K_e\\).\nNumerous evolutions of the original OTR protocol have addressed vulnerabilities and improved efficiency.\nThe Signal Protocol\nThe Signal protocol is an evolution of the OTR protocol targeting message exchange protection in social networks. It also uses ephemeral asymmetric and symmetric keys to ensure PFS, Future Secrecy, and repudiability with DH computations on elliptic curves.\nSignal is used to protect messaging platforms such as WhatsApp and Facebook Messenger, among others.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nOTR/Signal:\n\nSIGMA: signature + MAC\nKDF: generates \\(K_e\\) (encryption) and \\(K_m\\) (MAC)\nReveals old MAC keys → repudiability\n✅ PFS, ✅ Future Secrecy\nUsed in: WhatsApp, Facebook Messenger\n\n\n\n\n\n\n\n\nSecure Remote Password (SRP)\nAsymmetric KAP protocol based on password, resistant to dictionary attacks.\nInitialization:\n\n\\(m := 2p+1\\) (safe prime), \\(\\alpha\\) generator of \\(\\mathbb{Z}_p^*\\)\n\\(P\\): A’s password, \\(x := H(P)\\) with \\(H\\) a CRHF\nB stores the verifier: \\(v := \\alpha^x \\mod m\\) (not the password!)\n\nProtocol:\n\n\\(A \\rightarrow B: \\gamma := \\alpha^r \\mod m\\) (A generates secret \\(r\\))\n\\(A \\leftarrow B: \\delta := (v + \\alpha^t) \\mod m, u\\) (B generates random \\(t, u\\))\nA computes \\(k := (\\delta - v)^{r+ux} \\mod m\\)\nB computes \\(k := (\\gamma v^u)^t \\mod m\\)\nKey confirmation\n\nProperties:\n\n✅ Protects passwords from dictionary attacks\n✅ Verifier-based: B does not store passwords\n✅ All KEP properties\nIncluded in SSL/TLS, EAP\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAsymmetric KAP with DKE – Secure Remote Password Protocol\n\nLet \\(m\\) be a safe prime with \\(m := 2p+1\\) and \\(p\\) prime.\nLet \\(\\alpha\\) be a generator of \\(\\mathbb{Z}_p^*\\), such that \\(\\alpha \\in \\mathbb{Z}_{p-1}\\).\nLet \\(P\\) be A’s password and \\(x := H(P)\\) with \\(H\\) a CRHF.\nB stores in its password database the verifier \\(v := \\alpha^x \\mod m\\).\n\n\n\\(A \\rightarrow B: \\gamma := \\alpha^r \\mod m\\); A generates a secret random number \\(r\\).\n\\(A \\leftarrow B: \\delta := (v + \\alpha^t) \\mod m, u\\); B generates a secret random number \\(t\\) and another random number \\(u\\).\n\nA computes the symmetric key: \\(k := (\\delta - v)^{r+ux} \\mod m\\).\nB computes the symmetric key: \\(k := (\\gamma v^u)^t \\mod m\\).\nA and B prove knowledge of \\(k\\) (key confirmation) in a subsequent exchange.\n\nSRP protects passwords from dictionary attacks.\nB does not store passwords but verification values (verifier-based).\nSRP also satisfies all KEP properties and is included in many standards (SSL/TLS, EAP, etc.).\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nSRP:\n\nPassword-based KAP\nB stores verifier \\(v := \\alpha^x\\) (not password)\nResistant to dictionary attacks\n✅ All KEP properties\n\n\n\n\n\n\n\n\nAttacks on DH and PFS\nLogjam Attack (2015):\nActive attack enabling:\n\nDowngrade: Man-in-the-Middle forces use of 512-bit DH group.\nDiscrete logarithm computation with Number Field Sieve:\n\nOne-week precomputation for a fixed prime \\(p\\).\n~1-minute individual computation after precomputation.\n\nPrecomputation reuse: Many servers use the same \\(p\\).\n\nConsequence:\nState-level actors can compromise PFS on widespread 1024-bit groups.\nSolutions:\n\nUse groups \\(\\geq\\) 2048 bits.\nDiversify the primes \\(p\\) used.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRecent Attacks on Diffie-Hellman and PFS\nIn 2015, a group of researchers published a series of attacks on the TLS/SSL protocol allowing:\n\nPerforming a downgrade via an active attack called Logjam, whereby a man-in-the-middle successfully reduces the Diffie-Hellman group size to 512 bits for the shared secret key establishment.\nSubsequently computing the discrete logarithms of \\(\\alpha^x \\mod p\\) and \\(\\alpha^y \\mod p\\) using the Number Field Sieve technique.\nFor a group based on a fixed prime \\(p\\), they perform a precomputation phase lasting approximately one week.\nOnce this initial phase is complete, individual logarithm computations take only about one minute!\nA statistical observation shows that a significant percentage of servers rely on the same group (same prime \\(p\\)), allowing the same precomputation phase to be used to compromise multiple servers.\nOne of the conclusions of this research is that major actors with state-level resources would currently be able to break PFS when it is based on (very common today…) 1024-bit groups.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nLogjam (2015):\n\nDowngrade → DH 512 bits\nPrecomputation (1 week) + individual computation (1 min)\nReuse if same \\(p\\)\n⚠️ States can break PFS on 1024-bit groups"
  },
  {
    "objectID": "exam_notes_en.html#ktp",
    "href": "exam_notes_en.html#ktp",
    "title": "Fundamental Security Services",
    "section": "KTP",
    "text": "KTP\n\nSymmetric\n\nTrivial Case\nInitialization: A and B share long-term key \\(S\\).\nProtocol:\n\n\\(A \\rightarrow B: E_S(r_a)\\)\nSession key: \\(K := r_a\\)\n\nProperties:\n\n❌ Entity authentication\n✅ Implicit key authentication\n❌ Key confirmation (improvement: \\(E_S(B, r_a)\\))\n❌ Perfect Forward Secrecy\n\nTimestamp Variant: \\(A \\rightarrow B: E_S(B, t_a, r_a)\\) (requires synchronized clocks).\n\n\nShamir’s No-Key Protocol\nDH equivalent in key transport.\nInitialization: Public prime \\(p\\), A and B generate secrets \\(a, b \\in \\mathbb{Z}_{p-1}\\) with \\(\\gcd(a,p-1)=1\\) and \\(\\gcd(b,p-1)=1\\).\nProtocol:\n\n\\(A \\rightarrow B: K^a \\mod p\\) (A chooses key \\(K\\) and hides it with \\(^a\\))\n\\(A \\leftarrow B: (K^a)^b \\mod p\\) (B exponentiates with \\(b\\))\n\\(A \\rightarrow B: (K^{ab})^{a^{-1}} \\mod p = K^b \\mod p\\) (A undoes \\(^a\\))\nB computes \\(K\\) by exponentiating with \\(b^{-1} \\mod (p-1)\\)\n\nProblem: Vulnerable to Man-in-the-Middle (like DH).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nSymmetric Key Transport Protocol – Trivial Case\n(Init.) A and B share a long-term symmetric key \\(S\\).\n\n\\(A \\rightarrow B: E_S(r_a)\\); A generates a random number and encrypts it with \\(S\\).\n\nThe session key used by both entities is \\(K := r_a\\).\nProperties:\n\nEntity Authentication: NO.\nImplicit Key Authentication: YES (only A and B have access to the key).\nKey Confirmation: NO. B cannot be sure that A possesses the key because \\(r_a\\) is a random number. By adding redundancy (e.g., B’s identity), B can achieve unilateral key confirmation (and thus, explicit key authentication):\n\n(1)’ : \\(A \\rightarrow B: E_S(B, r_a)\\)\n\nPerfect Forward Secrecy: NO.\n\nIf B cannot judge the freshness of (1) from \\(r_a\\) alone, it can ask A to include a timestamp, provided synchronized clocks are available:\n(1)’’ : \\(A \\rightarrow B: E_S(B, t_a, r_a)\\)\nSymmetric KTP: Shamir’s No-Key Protocol\nNumber Theory Reminder: If \\(p\\) is prime and \\(r \\equiv t \\mod p-1\\), then \\(a^r \\equiv a^t \\mod p\\) \\(\\forall a \\in \\mathbb{Z}\\), and thus: \\(r \\cdot r^{-1} \\equiv 1 \\mod p-1\\) implies \\(a^{r \\cdot r^{-1}} \\equiv a \\mod p\\).\n(Init.) (a) Choose and publish a prime \\(p\\) for which it is difficult (by DLP) to compute discrete logarithms in \\(\\mathbb{Z}_p\\).\n\nA (resp. B) generates a secret number \\(a\\) (resp. \\(b\\)), such that \\(\\{a,b\\} \\in \\mathbb{Z}_{p-1}\\) and \\(\\gcd(a,p-1) = 1\\) and \\(\\gcd(b,p-1) = 1\\) (so that inverses exist).\nFor the following, A precomputes \\(a^{-1} \\mod p-1\\) and B precomputes \\(b^{-1} \\mod p-1\\).\n\n\n\\(A \\rightarrow B: K^a \\mod p\\); A chooses a key \\(K \\in \\mathbb{Z}_p\\) and hides it with \\(^a\\).\n\\(A \\leftarrow B: (K^a)^b \\mod p\\); B exponentiates in turn with \\(b\\).\n\\(A \\rightarrow B: (K^{ab})^{a^{-1}} \\mod p\\); A undoes the exponentiation with \\(a^{-1} \\mod p-1\\); but the key remains protected by \\(^b\\).\n\nB only needs to compute \\(K\\) by exponentiating with \\(b^{-1} \\mod p-1\\).\nThis protocol is the key transport equivalent of Diffie-Hellman (in DH, the key is not transported but bilaterally computed). It suffers from the same problems (notably Man-in-the-Middle) as the latter.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nSymmetric KTP:\n\nTrivial: \\(K := r_a\\) with \\(E_S(r_a)\\)\nShamir: Transport via successive exponentiations\nNo PFS\n\n\n\n\n\n\n\n\nAsymmetric\n\nNeedham-Schroeder\nInitialization: A and B have authentic copies of each other’s public keys.\nProtocol:\n\n\\(A \\rightarrow B: E_{pub_B}(k_1, A)\\)\n\\(A \\leftarrow B: E_{pub_A}(k_1, k_2)\\)\n\\(A \\rightarrow B: E_{pub_B}(k_2)\\)\nSession key: \\(K := H(k_1, k_2)\\)\n\nProperties:\n\n✅ Entity authentication + implicit key authentication + key confirmation\n❌ Perfect Forward Secrecy (keys entirely determined by exchanged quantities)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAsymmetric Key Transport Protocol – Needham-Schroeder Public Key Protocol\n(Notation): \\(E_{pub_E}(X)\\) means encrypting with entity E’s public key.\n(Init): A and B possess an authentic copy (possibly a certificate) of the other’s public key.\n\n\\(A \\rightarrow B: E_{pub_B}(k_1, A)\\); A generates a random number \\(k_1\\) + A + Encrypt.\n\\(A \\leftarrow B: E_{pub_A}(k_1, k_2)\\); B does the same for \\(k_2\\) + concatenates with \\(k_1\\) + Encrypt.\n\\(A \\rightarrow B: E_{pub_B}(k_2)\\); A verifies if \\(k_1\\) matches, if yes, encrypts \\(k_2\\); B verifies if \\(k_2\\) matches with (2).\n\nThe key is generated using a cryptographic hash function: \\(K := H(k_1, k_2)\\).\nCharacteristics:\n\nEntity Authentication + implicit key authentication + key confirmation: YES.\nPerfect Forward Secrecy: NO: The keys are entirely determined by the exchanged quantities.\n\nA similar protocol (only (3) changes) can be used for entity authentication.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nAsymmetric Needham-Schroeder:\n\n\\(K := H(k_1, k_2)\\) with encrypted exchanges\n✅ Full authentication\n❌ No PFS\n\n\n\n\n\n\n\n\nHybrid\n\nEncrypted Key Exchange (EKE)\nHybrid protocol (symmetric + asymmetric) resistant to dictionary attacks.\nInitialization: A and B share password \\(p\\).\nProtocol:\n\n\\(A \\rightarrow B: A, E_p(pub_A)\\) (A generates key pair, sends public key encrypted)\n\\(A \\leftarrow B: E_p(E_{pub_A}(k))\\) (B generates session key \\(k\\), double encryption)\n\\(A \\rightarrow B: E_k(r_a)\\) (Key confirmation)\n\\(A \\leftarrow B: E_k(r_a, r_b)\\)\n\\(A \\rightarrow B: E_k(r_b)\\)\n\nAdvantages:\n\nRobust even if password \\(p\\) is weak.\nEve cannot guess without also “breaking” the asymmetric algorithm.\n\nProperties:\n\n✅ Entity authentication + implicit + confirmation\n✅ Perfect Forward Secrecy if \\(pub_A/priv_A\\) is regenerated each time\n❌ No PFS if long-term keys\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nHybrid KTP: Encrypted Key Exchange (EKE)\nThis protocol uses symmetric and asymmetric schemes to minimize the risk of cryptanalysis via dictionary attacks inherent to symmetric systems.\n(Init.): A and B share a symmetric secret \\(p\\) (password).\n\n\\(A \\rightarrow B: A, E_p(pub_A)\\); A generates a public/private key pair and sends the public part to B encrypted with \\(p\\).\n\\(A \\leftarrow B: E_p(E_{pub_A}(k))\\); B generates a session key \\(k\\) and sends it encrypted.\n\\(A \\rightarrow B: E_k(r_a)\\); A generates a random number and sends it encrypted with \\(k\\).\n\\(A \\leftarrow B: E_k(r_a, r_b)\\); B generates \\(r_b\\) and sends it with \\(r_a\\) encrypted with \\(k\\).\n\\(A \\rightarrow B: E_k(r_b)\\); Confirmation from A. If \\(r_b =\\) OK =&gt; END.\nand (2) are responsible for key transport; (3) to (5) for key confirmation.\n\nThis protocol is robust even if the password \\(p\\) shared between A and B is of poor quality. Indeed, Eve cannot attempt to guess without also “breaking” the asymmetric algorithm.\nProperties:\n\nEntity Authentication + implicit key authentication + key confirmation: YES.\nPerfect Forward Secrecy: YES if the \\(pub_A/priv_A\\) pair is regenerated for each protocol instance. NO if \\(pub_A/priv_A\\) is a long-term key.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nEKE (Hybrid):\n\nPassword + asymmetric crypto\nRobust even with weak password\nPFS if keys regenerated each time\n\n\n\n\n\n\n\n\nSymmetric with Key Distribution Center (KDC)\n\nSymmetric Needham-Schroeder\nProtocol with Key Distribution Center (KDC).\nInitialization: A shares \\(K_{AT}\\) with T (KDC), B shares \\(K_{BT}\\) with T.\nProtocol:\n\n\\(A \\rightarrow T: A, B, r_a\\)\n\\(A \\leftarrow T: E_{K_{AT}}(r_a, B, k_{AB}, E_{K_{BT}}(k_{AB}, A))\\)\n\\(A \\rightarrow B: E_{K_{BT}}(k_{AB}, A)\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_b)\\)\n\\(A \\rightarrow B: E_{k_{AB}}(r_b - 1)\\)\n\nProperties:\n\n✅ Entity authentication of A to B\n❌ Entity authentication of B to A (A never saw \\(r_b\\))\n✅ Implicit key authentication\n❌ Key confirmation (only B knows A possesses the key)\n❌ Perfect Forward Secrecy\n\nVulnerabilities:\n\nReplay attacks: A can replay (3) without B’s control.\nKnown-key attack: If an old key \\(k\\) is compromised, an adversary can make B accept it.\n\nSolutions:\n\nKey confirmation and mutual entity authentication:\nReplace 3. and 4. with:\n\n\\(A \\rightarrow B: E_{k_{AB}}(r_a'), E_{K_{BT}}(k_{AB}, A)\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_a' - 1, r_b)\\)\n\nExchange freshness:\nAdd timestamp in 3.: \\(E_{K_{BT}}(k_{AB}, A, t)\\)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nSymmetric KTP with Key Distribution Center – Symmetric Needham-Schroeder\n(Notation): Let T be the Key Distribution Center.\n(Init.): A and T share the symmetric key \\(K_{AT}\\). B and T share \\(K_{BT}\\).\n\n\\(A \\rightarrow T: A, B, r_a\\); A generates a random number \\(r_a\\) and sends it to T with the identities.\n\\(A \\leftarrow T: E_{K_{AT}}(r_a, B, k_{AB}, E_{K_{BT}}(k_{AB}, A))\\); T generates \\(k_{AB}\\) and sends it encrypted.\n\\(A \\rightarrow B: E_{K_{BT}}(k_{AB}, A)\\); A forwards the packet to B.\n\\(A \\leftarrow B: E_{k_{AB}}(r_b)\\); Confirmation from B using \\(k_{AB}\\) and a random number \\(r_b\\).\n\\(A \\rightarrow B: E_{k_{AB}}(r_b - 1)\\); Confirmation from A.\n\nProperties:\n\nEntity Authentication:\n\nA to B: YES.\nB to A: NO: A never saw \\(r_b\\) (it could be \\(E_{k'}(r_b')\\)).\n\nImplicit Key Authentication: YES (keys are always protected by \\(K_{AT}\\) and \\(K_{BT}\\)). However, in case of a known-key attack, this no longer holds for B.\nKey Confirmation: Only B is assured that A possesses the key due to the flaw described in entity authentication.\nPerfect Forward Secrecy: NO. If either \\(K_{AT}\\) or \\(K_{BT}\\) is compromised, session keys \\(k\\) immediately become visible.\n\nSolution to achieve key confirmation and mutual entity authentication:\nReplace (3) and (4) with:\n(3’) \\(A \\rightarrow B: E_{k_{AB}}(r_a'), E_{K_{BT}}(k_{AB}, A)\\)\n(4’) \\(A \\leftarrow B: E_{k_{AB}}(r_a' - 1, r_b)\\)\nProvided the \\(r_i\\) are carefully controlled by the participants.\nHowever: Beware of reflection attacks!\nProblem: A can replay (3) as many times as desired, without any control from B. This problem worsens if an old key \\(k\\) is compromised:\nVulnerable to known-key attack: If a previously used session key \\(k\\) is obtained by an adversary C, it can easily make B accept it by replaying (3) and computing the challenge sent by B in (5). In this case, the properties of entity authentication, implicit key authentication, and key confirmation of A to B are also compromised.\nSolution: Add a timestamp in (3) attesting to the freshness of the exchanges:\n(3’’) \\(A \\rightarrow B: E_{K_{BT}}(k_{AB}, A, t)\\) (this is the solution adopted by Kerberos).\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nSymmetric Needham-Schroeder:\n\nKDC generates and distributes \\(k_{AB}\\)\nVulnerable to replay and known-key attacks\nSolution: Add timestamp\nBasis for Kerberos\n\n\n\n\n\n\n\nKerberos\nAuthentication and key distribution protocol based on Needham-Schroeder with corrections.\nArchitecture:\n\nAuthentication Server (AS): Issues tickets for TGS.\nTicket Granting Server (TGS): Issues tickets for services.\nTickets: Encrypted structures containing session keys.\n\nSimplified Protocol:\nPhase 1: TGT (Ticket Granting Ticket) Request\n\n\\(A \\rightarrow AS: A, TGS, r_a\\)\n\\(A \\leftarrow AS: E_{K_A}(k_{AT}, r_a), Ticket_{AT} := E_{K_T}(A, TGS, t_1, t_2, k_{AT})\\)\n\nPhase 2: Ticket Request for Service B\n\n\\(A \\rightarrow TGS: Authenticator_{AT} := E_{k_{AT}}(A, t), Ticket_{AT}, B, r_a'\\)\n\\(A \\leftarrow TGS: E_{k_{AT}}(k_{AB}, r_a'), Ticket_{AB} := E_{K_B}(A, B, t_1, t_2, k_{AB})\\)\n\nPhase 3: Authentication with B\n\n\\(A \\rightarrow B: Authenticator_{AB} := E_{k_{AB}}(A, t), Ticket_{AB}, r_a'', [request]\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_a''), [response]\\)\n\nProperties:\n\n✅ Entity authentication (all entities)\n✅ Implicit key authentication\n⚠️ Partial key confirmation (not between A and AS)\n❌ Perfect Forward Secrecy\n\nVulnerabilities:\n\nPassword guessing attacks on \\(E_{K_A}(k_{AT}, r_a)\\) (Solution: pre-authentication)\nReplay attacks if \\(r_a\\) is poorly controlled\nRequires clock synchronization\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nSymmetric KTP with Key Distribution Center – Kerberos\nKerberos is a protocol for entity authentication and key distribution within a user network.\nOriginally, Kerberos was designed as a replacement solution to address security issues (weak authentication, cleartext transactions, etc.) inherent to UNIX environments.\nKerberos was created at MIT as part of the ATHENA project.\nThe first three versions were unstable. Version 4 achieved considerable success in both industrial and academic environments and remains predominant. Version 5, although safer and better structured, is more complex and less performant, which has slowed its deployment.\nKerberos also defines a mode of collaboration between domains belonging to distinct administrative authorities (the realms). This allows users from one domain to use resources from another domain “without leaving” the secure Kerberos environment.\nFor inter-realm transactions, symmetric cryptography constitutes a significant obstacle as it requires confidential channels for key pre-distribution.\nKerberos Version 5\n(Notation): - A and B want to establish a secure transaction; in the Kerberos environment, this typically involves a client and a server providing services. - The Kerberos KDC is subdivided into two functional entities: the Authentication Server (AS) and the Ticket Granting Server (TGS). Both access the password database. - The \\(r_a^{(n)}\\) are random numbers, \\(t\\) is a timestamp, \\(t_1\\) and \\(t_2\\) indicate a validity time window.\n(Initialization): A and B share a secret key with AS, namely: \\(K_A\\) and \\(K_B\\) (for clients, this is a OWF of the password). TGS also has a secret key \\(K_T\\).\n\n\\(A \\rightarrow AS: A, TGS, r_a\\)\n\\(A \\leftarrow AS: E_{K_A}(k_{AT}, r_a), Ticket_{AT} := E_{K_T}(A, TGS, t_1, t_2, k_{AT})\\); AS generates \\(k_{AT}\\).\n\\(A \\rightarrow TGS: Authenticator_{AT} := E_{k_{AT}}(A, t), Ticket_{AT}, B, r_a'\\)\n\\(A \\leftarrow TGS: E_{k_{AT}}(k_{AB}, r_a'), Ticket_{AB} := E_{K_B}(A, B, t_1, t_2, k_{AB})\\); TGS generates \\(k_{AB}\\).\n\\(A \\rightarrow B: Authenticator_{AB} := E_{k_{AB}}(A, t), Ticket_{AB}, r_a'', [request]\\)\n\\(A \\leftarrow B: E_{k_{AB}}(r_a''), [response]\\); [request] and [response] optionally encrypted with \\(k_{AB}\\).\n\n(2): TGT request.\n\n\n(4): Ticket request for B.\n\n\n(6): Authentication and key establishment between A and B.\n\n\nKerberos Characteristics\nProperties:\n\nEntity Authentication: YES, for all involved entities.\nImplicit Key Authentication: YES: All generated keys are protected by keys shared between the AS and all participants.\nKey Confirmation:\n\nBetween A and AS: NO: AS has no proof that A possesses the key \\(K_A\\).\nBetween A and TGS: YES for \\(k_{AT}\\) (redundant quantities encrypted with \\(k_{AT}\\) are exchanged between A and TGS); NO for \\(k_{AB}\\) (TGS has no proof from A).\nBetween A and B: YES: Exchange of redundant quantities encrypted with \\(k_{AB}\\).\n\nPerfect Forward Secrecy: NO: All keys are explicitly transferred.\n\nProblems:\n\nInitial keys (like \\(K_A\\)) depend (directly) on user-chosen passwords. This makes the protocol vulnerable to password theft or:\n\nPassword guessing attacks: \\(E_{K_A}(k_{AT}, r_a)\\) in (2) helps crack A’s password. Solution: Pre-authentication in (1): \\(E_{K_A}(t)\\) with \\(t =\\) timestamp (optional in v5).\n\nThe ticket validity window can lead to replay attacks if the \\(r_a^{(n)}\\) are not properly controlled by the participants.\nClock synchronization is necessary! This is not always easy in heterogeneous environments.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nKerberos:\n\nAS issues TGT, TGS issues service tickets\nTickets contain session keys\nAuthentication via authenticators\nVulnerable: password guessing, replay\nSolution: pre-authentication, timestamps"
  },
  {
    "objectID": "exam_notes_en.html#ssltls",
    "href": "exam_notes_en.html#ssltls",
    "title": "Fundamental Security Services",
    "section": "SSL/TLS",
    "text": "SSL/TLS\nSSL/TLS: Secure Socket Layer / Transport Layer Security\nProtocol for securing communications between the transport (TCP) and application layers.\nProvided Services:\n\nConfidentiality, integrity, flow authentication\nServer identification (client optional)\n\nAlgorithms Used:\n\nPublic-key cryptography (RSA, DH, DSA): Key exchange\nMACs: Flow authentication\nSymmetric cryptography (DES, AES, IDEA): Flow encryption\n\nProperties:\n\n✅ Entity authentication (server + optional client via certificates)\n✅ Implicit key authentication\n✅ Key confirmation\n⚠️ Perfect Forward Secrecy: Depends on the exchange protocol (DH → yes, RSA → no)\n\nRemarks:\n\nTLS keys are derived by hashing from random values and the pre_master_secret.\nSSL/TLS is the de facto standard for web security (HTTPS).\nTrust relies on root certificates embedded in browsers.\nMajor vulnerabilities stem from randomness, implementations, and hash functions.\nNotable attacks: renegotiation (2009), Heartbleed (2014).\n\n\nSSL/TLS Architecture\nThree Components:\n\nSSL Record Protocol: Encapsulation above TCP (fragmentation + compression + encryption)\nSSL Handshake Protocol: Authentication + parameter negotiation\nSSL State Machine: Session and connection state variables\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nSecure Socket Layer (SSL) / Transport Level Security (TLS)\nLocated between the transport layer (TCP) and application layer protocols (not only HTTP but also SMTP, FTP, etc.!).\nIt is a meta key establishment protocol highly configurable, allowing many modes of operation and negotiation options.\nProvides confidentiality, integrity, data flow authentication, and server identification (and optionally client identification) services.\nUses the following algorithm families:\n\nPublic-key cryptography (RSA, Diffie-Hellman, DSA, etc.) for symmetric key exchange.\nMACs for data flow authentication.\nSymmetric cryptography (DES, IDEA, AES, etc.) for data flow encryption.\n\nThe use of CAs to certify the association between entities and public keys is strongly recommended… but not mandatory!\nProperties: - Entity authentication via certificates (server and optionally client). - Implicit Key Authentication and Key Confirmation are guaranteed. - Perfect Forward Secrecy depends on the protocol chosen for key exchange.\nSSL/TLS Overview\nSSL is a “mini-stack” of protocols with functionalities from the session, presentation, and application layers.\nSSL consists of three fundamental blocks:\n\nSSL record protocol allowing encapsulation of higher-level protocols above TCP (fragmentation + compression + encryption).\nSSL handshake protocol responsible for participant authentication and encryption parameter negotiation.\nSSL state machine. Unlike HTTP, SSL is a stateful protocol; it therefore requires a set of variables determining the state of a session and a connection.\n\n\n\n\n\n\nSSL Handshake Protocol\n\n\n\n\n\n\nNoneDiagram\n\n\n\n\n\nPhase 1: Hello\n\nClient Hello: Version, random, session ID, accepted algorithms\nServer Hello: Version, random, session ID, selected algorithms\nServer Certificate (optional): Server certificate + CA path\nServer Key Exchange (optional): Server public key information\nCertificate Request (optional): Client certificate request\n\nPhase 2: Client Authentication and Key Exchange\n\nClient Certificate (optional): Client certificate + CA path\nClient Key Exchange: Generates pre_master_secret, sends encrypted with server’s public key\nCertificate Verify (optional): Explicit client certificate verification\n\nPhase 3: Finalization\n\nFinish (client): First message protected with negotiated parameters\nFinish (server): Same for the server\n\nPhase 4: Application\n\nData protected with derived keys\n\n\n\n\n\n\nSSL/TLS Key Generation\nCascading Derivation:\n\\[master\\_secret = MD5(pre\\_master\\_secret + SHA('A' + pre\\_master\\_secret + ClientRandom + ServerRandom))\\] \\[+ MD5(pre\\_master\\_secret + SHA('BB' + ...)) + ...\\]\n\\[key\\_block = MD5(master\\_secret + SHA('A' + master\\_secret + ServerRandom + ClientRandom)) + ...\\]\nPartition of the key_block:\n\nclient_write_MAC_secret[hash_size]\nserver_write_MAC_secret[hash_size]\nclient_write_key[key_material]\nserver_write_key[key_material]\nclient_write_IV[IV_size]\nserver_write_IV[IV_size]\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nSimplified SSL/TLS Handshake Protocol\n[Handshake diagram with 4 phases: Hello, Key Exchange, Finish, Application Data]\nSSL/TLS: Key Generation\nmaster_secret =\n MD5(pre_master_secret + SHA('A' + pre_master_secret +\n ClientHello.random + ServerHello.random)) +\n MD5(pre_master_secret + SHA('BB' + pre_master_secret +\n ClientHello.random + ServerHello.random)) +\n MD5(pre_master_secret + SHA('CCC' + pre_master_secret +\n ClientHello.random + ServerHello.random));\n\nkey_block =\n MD5(master_secret + SHA('A' + master_secret +\n ServerHello.random +\n ClientHello.random)) +\n MD5(master_secret + SHA('BB' + master_secret +\n ServerHello.random +\n ClientHello.random)) +\n MD5(master_secret + SHA('CCC' + master_secret +\n ServerHello.random +\n ClientHello.random)) + [...];\n\n until enough output has been generated. Then the key_block is\n partitioned as follows:\n\n client_write_MAC_secret[CipherSpec.hash_size]\n server_write_MAC_secret[CipherSpec.hash_size]\n client_write_key[CipherSpec.key_material]\n server_write_key[CipherSpec.key_material]\n client_write_IV[CipherSpec.IV_size] /* non-export ciphers */\n server_write_IV[CipherSpec.IV_size] /* non-export ciphers */\nSSL/TLS: Final Remarks\n\nSecret keys are the result of applying hash functions (MD5, SHA) to the random numbers from the Hello records and the pre_master_secret.\nTLS/SSL has become the de facto standard for web security (the basis of https).\nSSL clients (Explorer, Firefox, Opera, Chrome, etc.) contain “hard-coded” certificates corresponding to a few root certification authorities (Verisign, Thawte, Microsoft, RSA, etc.) allowing verification of certificates presented by some servers, but SSL is designed to rely on a global certification network that currently does not exist.\nThe most common security flaws in SSL concern key randomness generation as well as the most common implementation defects: buffer overflows, SQL injection, etc. The weakness of hash functions (MD5, SHA) is also a risk factor.\nIn November 2009, an attack was discovered allowing a Man-in-the-Middle to inject content (chosen plaintext) into an authentic flow following a renegotiation of parameters provided for in the protocol. This is a flaw in the protocol that required a patch in all implementations.\nThe Heartbleed vulnerability based on a buffer overflow seriously disrupted the Internet community upon its discovery in April 2014.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nSSL/TLS:\n\nMeta-protocol between TCP and application\nHandshake: negotiation + authentication\nKeys derived: master_secret → key_block\nHTTPS standard\nFlaws: randomness, Heartbleed, renegotiation"
  },
  {
    "objectID": "exam_notes_en.html#final-remarks-on-keps",
    "href": "exam_notes_en.html#final-remarks-on-keps",
    "title": "Fundamental Security Services",
    "section": "Final Remarks on KEPs",
    "text": "Final Remarks on KEPs\nBefore choosing a KEP:\n\nDefine objectives: Confidentiality, authentication, non-repudiation.\nDefine security level: Key confirmation, PFS, future secrecy.\nEstablish constraints: Users, machines, network, attackers.\n\nBest Practices:\n\n✅ Choose a proven and robust solution.\n❌ Avoid inventing “from scratch.”\n✅ Verify that properties are satisfied.\n\nProtocol Verification:\nTwo complementary approaches:\n\nPractical Analysis: “On paper” and “on machine”\n\nControl random numbers (reflection attacks)\nRedundancy of encrypted/signed quantities\nClassic pitfalls\n\nFormal Analysis: Dedicated logics (BAN logic, etc.)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nKey Establishment Protocols: Final Remarks\nKey establishment protocols are a cornerstone of any security solution. Before choosing (designing) a KEP, it is therefore essential to:\n\nDefine the objectives (confidentiality, entity/data authentication, non-repudiation, etc.).\nDefine the desired security level based on the studied properties (key confirmation, perfect forward secrecy, etc.).\nEstablish a list of constraints related to the environment (users, machines, network, potential attackers, etc.).\n\nBased on these criteria, we can:\n\nChoose a proven and robust solution (better than inventing one from scratch!).\nVerify that the objectives are met and the properties satisfied.\n\nProtocol verification is a complex and delicate process; moreover, published solutions are not always correct. Two approaches are possible (and necessary):\n\nPractical analysis. Analyze protocol flaws “on paper” and “on machine,” considering classic pitfalls: control of random numbers to avoid reflection attacks, redundancy of encrypted/signed quantities, etc.\nFormal analysis with logics specifically designed for this purpose (such as BAN logic).\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nKEP – Best Practices:\n\nDefine objectives and constraints\nChoose a proven solution\nVerify properties (practical + formal)\nAvoid pitfalls: reflection, redundancy, randomness control\n\n\n\n\nHere is the exact English translation of your Trusted Third Parties and Certification document, preserving all content, structure, technical terms, and formatting:"
  },
  {
    "objectID": "exam_notes_en.html#ttp",
    "href": "exam_notes_en.html#ttp",
    "title": "Fundamental Security Services",
    "section": "TTP",
    "text": "TTP\n\nTTP Operating Modes\nThree Operational Modes:\n\nIn-line: TTP acts as an intermediary, relaying all exchanges in real time (e.g., Proxies, Secure Gateways).\nOn-line: TTP participates in real time, but A and B communicate directly (e.g., KDC).\nOff-line: TTP does not participate in real-time exchanges but makes information available a priori (e.g., CA).\n\n\n\n\n\n\ngraph LR\n    A[A] --&gt;|in-line| TTP[TTP]\n    TTP --&gt;|in-line| B[B]\n\n    A2[A] ---|on-line| TTP2[TTP on-line]\n    A2 &lt;--&gt;|direct| B2[B]\n\n    A3[A] -.-&gt;|prior exchange| TTP3[TTP off-line]\n    B3[B] -.-&gt;|prior exchange| TTP3\n    A3 &lt;--&gt;|direct| B3\n\n\n\n\n\n\nComparison:\n\nOff-line: Facilitates exchanges, no need for permanent availability.\nIn-line/On-line: Requires permanent availability.\nOff-line: Revocation of privileges is more complex.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nTTP: Operating Modes\n\nIn-line: The TTP acts as an intermediary to relay exchanges between A and B in real time. Examples: Proxies, Secure Gateways.\nOn-line: The TTP participates in real time in exchanges between A and B, but A and B communicate directly (without passing through the TTP). Example: Key Distribution Center.\nOff-line: The TTP does not participate in real-time exchanges but makes information available a priori. Example: Certification Authorities.\n\nComparison In-line/On-line/Off-line: Exchanges are facilitated, and there is no need for permanent TTP availability in off-line mode (unlike the other two), but privilege revocation (e.g., when a secret key is compromised) is more complex.\n[Diagrams showing the three modes]\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nTTP Modes:\n\nIn-line: Intermediary relay\nOn-line: Real-time participation\nOff-line: Information available a priori (e.g., CA)\nOff-line: No availability required but revocation complex\n\n\n\n\n\n\n\nKey Distribution Centers (KDCs)\nObjective: Solve the \\(n^2\\) key distribution problem.\nPrinciple:\n\nWithout KDC: \\(\\frac{n(n-1)}{2} \\approx n^2\\) keys for \\(n\\) entities.\nWith KDC: Only \\(n\\) keys (each entity shares a key with the KDC).\nSession keys dynamically generated by the KDC.\n\nAdvantages:\n\nScalability: A new entity = only one new key.\nSecure channel establishment via tickets (as in Kerberos).\n\nDisadvantages:\n\nSingle point of security failure: KDC compromise → entire system vulnerable.\nSingle point of operational failure: KDC unavailability (DoS) → system paralysis.\nPerformance bottleneck: Costly operations (encryption, random generation).\n\nSolutions: Mirroring, load balancing.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nTTP: Key Distribution Centers (KDCs)\nGoal: Solve the \\(n^2\\) key distribution problem:\n\nIn a symmetric environment with \\(n\\) entities without an intermediary: \\(n(n-1)/2 \\sim n^2\\) different keys are needed for all pairs of entities to share a different key.\nMoreover, such a system is not scalable because adding an entity results in the generation of \\(n\\) new keys.\n\nIf each entity shares a key with a KDC, only \\(n\\) keys are needed for the system to function, and one key suffices for each new entity. The establishment of secure channels is ensured by the generation of session keys and the presence of tickets as in Kerberos.\nProblems:\n\nSingle point of security failure: By construction, the KDC can impersonate all nodes in the network. If it is compromised, the entire system becomes vulnerable.\nSingle point of operational failure: The usual mode of operation of a KDC is on-line (possibly in-line). If it becomes unavailable (e.g., due to a denial-of-service attack), the entire system is paralyzed.\nPerformance bottleneck: KDC operations are often computationally expensive (encryption/decryption, random generation, etc.). Classic solutions (e.g., mirroring) must be considered to distribute the KDC load.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nKDC:\n\nSolves \\(n^2\\) problem → \\(n\\) keys\nScalable: +1 entity = +1 key\nRisks: Single point of failure (security + operational), bottleneck\n\n\n\n\n\n\n\nCertification Authorities (CAs)\nRole: Authenticate the association between an entity and its public key.\nOperation:\n\nCA verifies identity (passport, etc.).\nCA creates and signs a certificate containing this association.\nCertificates are accessible to entities (may be cached).\n\nVerification: Requires an authentic copy of the CA’s public key.\nAdvantages:\n\nOff-line mode: Short unavailability is acceptable.\nSimpler then safer: No complex protocols needed.\n\nDisadvantages:\n\nAsynchronous revocation: Certificate may become invalid (private key theft).\nSolution: Signed Certificate Revocation Lists (CRLs).\n\nCA Compromise:\nSerious consequences if the private signing key is compromised.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nTTP: Certification Authorities (CAs)\nThe primary role of a Certification Authority (CA) is to authenticate the association between an entity and its public key (think of Man-in-the-Middle attacks!).\nThe CA will create and sign certificates containing this association (using proof of identity such as a passport) and make them accessible to the relevant entities.\nOnce signed, copies of the certificates (cached certificates) can be stored in unprotected locations (e.g., on the user’s disk space). However, to verify the signature of the certificates, the relevant entities require an authentic copy of the CA’s public key.\nSimpler then safer: There is no need to implement complex protocols in a CA.\nThe usual mode of operation of a CA is off-line, which reduces the impact of short periods of unavailability.\nProblem associated with off-line mode: The validity of cached certificates may be questioned asynchronously due to a private key theft.\nRemedy: CAs also publish signed lists of invalid certificates (Certificate Revocation Lists or CRLs).\nCompromising a CA has less obvious but almost as harmful consequences as compromising a KDC, especially if the private key used to sign certificates is also compromised.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nCA:\n\nAuthenticates entity ↔︎ public key association\nSigns certificates (off-line mode)\nCRLs for revocations\nCompromise = serious consequences\n\n\n\n\n\n\nProof of Possession (PoP)\nProblem: Identity verification is not sufficient; possession of the private key must also be verified.\nAttack without PoP:\n\nA signs a document and sends it to B (notary): \\(S_{priv_A}(\\text{Invention}), S_{priv_{CA_A}}(Cert_A)\\).\nC intercepts and requests from \\(CA_C\\) (without PoP) a certificate associating C with \\(pub_A\\).\nC sends to B: \\(S_{priv_A}(\\text{Invention}), S_{priv_{CA_C}}(Cert_C)\\).\nC becomes the inventor!\n\nSimple PoP Protocol:\n\n\\(CA \\rightarrow A: A, r\\) (random number + identity).\n\\(CA \\leftarrow A: S_{priv_A}(A, r)\\).\n\\(CA\\) verifies the signature with \\(pub_A\\).\n\nConsequences:\n\nIntroduces trust levels for CAs.\nCriteria: PoP, CRL updates, signing key security.\nProblem exacerbated by uncontrolled CA proliferation.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nCA: Proof of Possession (PoP)\nVerifying the identity of A to create (or modify) a certificate associating A with its public key is not a sufficient criterion. It is also necessary to verify that A truly possesses the corresponding private key.\nLet A and its CA be \\(CA_A\\). Let’s see what an active attacker C can do in “collaboration” with a \\(CA_C\\) that does not verify PoP:\nA signs a document containing the description of a revolutionary invention and sends it to B (the notary) with its certificate signed by \\(CA_A\\):\n\\(A \\rightarrow B: S_{priv_A}(\\text{Invention}), S_{priv_{CA_A}}(Cert_A)\\)\nC intercepts this packet, approaches \\(CA_C\\), and asks it to create a certificate associating its identity C with A’s public key, and sends to B:\n\\(C \\rightarrow B: S_{priv_A}(\\text{Invention}), S_{priv_{CA_C}}(Cert_C)\\)\nC thus becomes the revolutionary inventor…\nSimple PoP Verification Protocol:\n\\(CA \\rightarrow A: A, r\\); \\(r\\): random number, A to protect A from chosen message attacks.\n\\(CA \\leftarrow A: S_{priv_A}(A, r)\\); CA only needs to verify the signature with \\(pub_A\\).\nThis criterion and other behavioral criteria, such as CRL updates or the security of the signing key, introduce trust levels for CAs and for the certificates they sign.\nThis phenomenon is exacerbated by the uncontrolled proliferation of CAs!\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nPoP (Proof of Possession):\n\nVerify possession of private key (not just identity)\nWithout PoP: Attacker can impersonate identity\nProtocol: CA verifies signature on challenge\nIntroduces trust levels for CAs\n\n\n\n\n\n\n\nSeparation of Certification and Revocation\nProblem: If the same key signs certificates and CRLs, an adversary possessing the CA’s private key can:\n\nPublish a CRL revoking victim A’s certificate.\nCreate a fake certificate associating A with a key controlled by the adversary.\nDecrypt confidential transactions for A.\nImpersonate A (signatures, authentication).\n\nSolution: Separation of Duties\nClear separation of tasks:\n\nCertificates and CRLs signed with different keys.\nBy different functional entities:\n\nCertification Authority (CA)\nRevocation Authority (RA)\n\nResiding on different machines.\nSubject to independent security policies.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nCA: Certification and Revocation\nProblem: If the same key is used to sign certificates and CRLs, an adversary possessing the private signing key of a CA can attack a “victim” A under the authority of this CA as follows:\n\nPublish a CRL containing A’s revoked certificate.\nCreate a certificate associating A with a public key for which it controls the private key to then:\n\nact as a Man-in-the-Middle to decrypt confidential transactions for A;\nimpersonate A for authenticated transactions or signed documents.\n\n\nSolution: Separation of duties: Certification and revocation become clearly differentiated tasks:\n\nCertificates and CRLs are signed with different keys,\nby different functional entities (Certification Authority and Revocation Authority);\nif possible, residing on different machines subject to independent security criteria (security policies).\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nSeparation of Duties:\n\nCertificates ≠ CRLs (different keys)\nCA ≠ Revocation Authority\nSeparate machines and policies\nPrevents post-compromise attacks\n\n\n\n\n\n\n\n\nFunctional Entities Related to Certification\nName Server:\n\nManages a unique and consistent namespace.\nCombined with certification if authentication is required.\nExample: DNSSec (authenticated DNS for the Internet).\n\nRegistration Authority (RA):\n\nTasks requiring direct contact with entities.\nIdentity verification, PoP, certificate requests/modifications.\nDetached from CA for geographical reasons.\n\nKey Generator:\n\nGenerates public/private key pairs.\nAdvantages: User simplicity, enhanced key security.\nDisadvantage: Private key known to another entity → loss of non-repudiation.\n\nCertificate Directory:\n\nRead-only access directory for certificates.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nFunctional Entities Related to Certification\n\nName Server: Responsible for managing a unique and consistent namespace. When authentication is required, name management must be complemented by the certification of public keys associated with these names.\nExample of a pilot solution combining both concepts: DNSsec: authenticated name management environment for the Internet.\nRegistration Authority: Entity responsible for performing tasks related to certificate management requiring direct contact with the relevant entities. These tasks include verifying the parameters necessary for the initial request or modification of certificates (identity verification, PoP, etc.). Detaching this functionality from the CA is typically due to geographical considerations.\nKey Generator: Allows delegation of the public/private key pair creation process to a dedicated entity:\n\nAdvantages: Simplicity for users; possibility to enhance the security of chosen pairs.\nDisadvantage: Private key known to another entity! Loss of non-repudiation.\n\nCertificate Directory: The directory allowing users to access (read-only) the certificates of correspondents.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nCertification Entities:\n\nName Server: Names + DNSSec\nRA: Direct contact, verifications\nKey Generator: Key generation (⚠️ loses non-repudiation)\nCertificate Directory: Read-only certificate access\n\n\n\n\n\n\n\nOther TTPs\nTimestamp Agent (TA):\n\nCertifies the existence of a document/transaction at a specific time.\nMethods:\n\nAssociate a timestamp with the document (or \\(h(\\text{doc})\\)) + sign.\nUse an authentication tree.\n\n\nNotary Agent:\n\nLike TA but also: validity, origin, ownership.\nLegal support for non-repudiation.\n\nKey Escrow Agent (KEA):\n\nAccess to session secret keys under conditions (judicial warrant).\nRequires a dedicated encryption system.\n\nExample: Clipper/Capstone\n\nClipper chip (1993): Symmetric encryption with KEA access.\nControversial, flaws discovered.\nCapstone chip: Successor (Fortezza PCMCIA card).\nMilitary-level security.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nOther TTPs\n\nTimestamp agent (TA): Certifies the existence of a document or the occurrence of a transaction at a well-specified time. To do this, the TA can:\n\nassociate a timestamp with the document (or with \\(h(\\text{doc})\\) where \\(h\\) is a Collision Resistant Hash Function) and sign the whole with its private key, and\nuse an authentication tree (see page 231).\n\nNotary agent: Certifies not only the existence of a document at a given time (like the TA) but also its validity, origin, or ownership by a given entity. This service provides (legally necessary?) support for non-repudiation.\nKey escrow agent (KEA): Entity authorized to access session secret keys provided certain conditions (e.g., a court order) are met. This requires a dedicated encryption system. Example: the Clipper key escrow system:\n\nAnnounced in April 1993 by the US administration, amid great controversy, as the large-scale communication encryption solution.\nThe Clipper chip is a symmetric encryption/decryption device that provides access to session keys when the secret keys of two KEAs (typically federal agencies) are input.\nThe presence of some flaws and the need for asymmetric cryptography led to its successor: the Capstone chip, which can be integrated into a PCMCIA card (called Fortezza and used for military-level security).\n\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nOther TTPs:\n\nTA: Timestamp document existence\nNotary: TA + validity/origin (non-repudiation)\nKEA: Access to keys under legal conditions\nExample: Clipper/Fortezza (controversial)"
  },
  {
    "objectID": "exam_notes_en.html#public-key-authentication",
    "href": "exam_notes_en.html#public-key-authentication",
    "title": "Fundamental Security Services",
    "section": "Public Key Authentication",
    "text": "Public Key Authentication\n\nCertificates\nDefinition: Information associating an entity with its public key.\nGeneric Structure:\n\nSerial Number, Version\nIssuer: Identity of the signing CA (global and unique).\nSignature Algorithm: Algorithm used to compute the signature (e.g., MD5+ElGamal, SHA+RSA).\nSubject: Name of the certified entity (global and unique).\nSubject Public Key: Public key.\n\nRSA: \\((n, e)\\)\nDH: \\((p, \\alpha, \\alpha^x \\mod p)\\)\n\nSubject Public Key Algorithm: RSA, DH, etc.\nValidity: Validity period (UTC).\nSignature: Covers all previous records, ensuring authenticity.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nPublic Key Authenticity: Certificates\nA certificate is a piece of information associating an entity with its public key. Generically, it consists of the following elements:\n\nSerial Number, Version.\nIssuer: The (global and unique) identity of the signing CA.\nSignature Algorithm: The algorithm used to compute the signature on the certificate. E.g.: MD5 + ElGamal or SHA + RSA.\nSubject: The (global and unique) name of the entity whose public key is certified.\nSubject Public Key: The entity’s public key. For example:\n\n\\((n,e)\\): modulus and public exponent for RSA.\n\\((p, \\alpha^x \\mod p)\\): modulus, generator, and public part for Diffie-Hellman.\n\nSubject Public Key Algorithm: The algorithm associated with the public key. E.g.: RSA or Diffie-Hellman.\nValidity: The certificate’s validity period, typically expressed in UTC.\nSignature: Contains the signature computed using the Signature Algorithm and the CA’s private key. It covers all previous records and thus guarantees the authenticity of the information they contain.\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nCertificate:\n\nIssuer (CA) + Subject (entity)\nPublic key + algorithm\nValidity period\nCA signature on all fields\n\n\n\n\n\n\n\nCertificate Revocation Lists (CRLs)\nDefinition: Lists of certificates that have become invalid.\nReasons for Revocation:\n\nPrivate key compromised.\nAlgorithm modification.\nRole change (role-based certificate).\nOther factors invalidating certificate information.\n\nCRL Structure:\n\nIssuer, Signature Algorithm\nDate of Issue, Date of Next Issue\nFor each revoked certificate:\n\nSerial Number\nRevocation Date\n\nSignature: On the entire list.\n\nRequirements:\n\nCAs must publish CRLs frequently.\nWide-audience distribution channels.\nMinimize fraud risk.\n\nProblem: Revocation is the Achilles’ heel of public key systems.\nAlternative Solutions:\n\nCertificates with very short validity (a few minutes).\nPeriodic re-confirmation by CAs.\n⚠️ Return to on-line mode → high availability required.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nCertificate Revocation Lists (CRLs)\nThese are lists containing certificates that have become invalid due to a compromised private key or any other factor affecting the validity of the information contained in a certificate (algorithm change, role change for a role-based certificate, etc.).\nA generic CRL has the following elements:\n\nIssuer, Signature Algorithm: As for certificates.\nDate of Issue, Date of Next Issue: Issue date and next issue date.\nFor each revoked certificate, the following records:\n\nSerial Number of the revoked certificate.\nRevocation Date.\n\nSignature: Signature covering the entire list.\n\nA CA must publish CRLs with a very high frequency and use wide-audience distribution channels to reduce the risk of fraud.\nRevocation is the Achilles’ heel of any public key system…\nA solution: certificates with very short validity periods (a few minutes) requiring periodic re-confirmation by CAs…\n…but this brings us back to on-line mode and thus requires high CA availability.\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nCRLs:\n\nLists of invalid certificates (compromise, etc.)\nStructure: issuer, dates, serial numbers, signature\nFrequent publication required\nAchilles’ heel of PKI\nAlternative: short-lived certificates (→ on-line)\n\n\n\n\n\n\n\nAuthentication Trees\nPrinciple: Alternative to certification for authenticating public information.\nConstruction: Tree (binary) with hash function + root authentication.\nFor \\(n\\) values \\(Y_1, Y_2, ..., Y_n\\):\n\nValues placed in leaves.\nEdges from leaves labeled \\(h(Y_i)\\).\nNon-terminal nodes labeled \\(h(h_1 || h_2)\\) (|| = concatenation).\nRoot \\(R\\) authenticated (digital signature).\n\n\n\n\n\n\ngraph TD\n    R[\"R = h(h2 || h(Y4))\"]\n    h2[\"h2 = h(h1 || h(Y3))\"]\n    h1[\"h1 = h(h(Y1) || h(Y2))\"]\n    Y1[Y1] --&gt; hY1[\"h(Y1)\"]\n    Y2[Y2] --&gt; hY2[\"h(Y2)\"]\n    Y3[Y3] --&gt; hY3[\"h(Y3)\"]\n    Y4[Y4] --&gt; hY4[\"h(Y4)\"]\n    hY1 --&gt; h1\n    hY2 --&gt; h1\n    h1 --&gt; h2\n    hY3 --&gt; h2\n    h2 --&gt; R\n    hY4 --&gt; R\n\n\n\n\n\n\nVerification of \\(Y_1\\): Provide \\(h(Y_2), h(Y_3), h(Y_4)\\), compute \\(h(Y_1), h_1, h_2\\), and verify \\(h(h_2 || h(Y_4)) = R\\).\nAdvantages:\n\nOnly \\(R\\) requires cryptographic protection.\nBalanced trees: Intermediate data \\(\\sim \\log_2 n\\).\n\nDisadvantages:\n\nModified node → recalculate path to root.\nAdding nodes → unbalanced trees recommended.\n\nMain Application: Timestamping\nTA:\n\nBuilds tree.\nProvides signed timestamp + verification path.\nPublishes \\(R\\) daily (newspaper).\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAuthentication Trees\nAuthentication trees are an alternative to certification for authenticating public information.\nThey exploit the advantages of a tree structure (typically binary) with the use of hash functions and root authentication.\nGiven a tree A with \\(n\\) leaves. Let \\(h\\) be a collision-resistant hash function (CRHF). Tree A can be used to authenticate \\(n\\) public values \\(Y_1, Y_2, ..., Y_n\\) by constructing an authentication tree as follows:\n\nThe values \\(Y_1, Y_2, ..., Y_n\\) are placed in the leaves of the tree.\nEach edge from a leaf \\(Y_i\\) is labeled \\(h(Y_i)\\) (\\(h\\) being a CRHF).\nEach non-terminal node with underlying edges labeled \\(h_1\\) and \\(h_2\\) is labeled \\(h(h_1 || h_2)\\) (|| denotes concatenation).\n\n[Tree diagram]\nTo verify the authenticity of \\(Y_1\\), it is necessary to provide the values \\(h(Y_2), h(Y_3), h(Y_4)\\). Then, it suffices to compute \\(h(Y_1), h_1\\), and \\(h_2\\) (according to the figure) and accept the authenticity of \\(Y_1\\) if \\(h(h_2 || h(Y_4)) = R\\). An illicit modification in \\(Y_1\\) would result (by the characteristics of the CRHF) in a different value for \\(h(h_2 || h(Y_4)) \\neq R\\).\nNote that only the value \\(R\\) needs to be authenticated (e.g., using a digital signature). The other values are protected by the irreversibility of the CRHF.\nAdvantage: Only \\(R\\) requires cryptographic protection for authentication!\nDisadvantages:\n\nTo verify the value \\(Y_1\\), the values \\(h(Y_{2,3,4})\\) and the value \\(R\\) are needed. To minimize this effect, balanced trees (trees whose paths differ by at most one edge) can be used to reduce the number of intermediate data to \\(\\sim \\log_2 n\\).\nWhen a node is modified, the entire path to the root must be recalculated.\nWhen new nodes are added, it is advisable to build unbalanced trees (like the one in the figure) and add nodes via the root.\n\nMain application: timestamping: The timestamping agent (TA) builds such a tree and provides the requester with the timestamp signed with its private key along with the verification path. The TA publishes \\(R\\) daily in a newspaper, preventing it from cheating!\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nAuthentication Trees:\n\nCertification alternative via hash + tree\nOnly root \\(R\\) signed\nVerification: path \\(\\sim \\log_2 n\\) values\nApplication: timestamping\nTA publishes \\(R\\) daily\n\n\n\n\n\n\n\nCertification Topologies\nProblem: Communication between users of different CAs → trust question.\nCross-Certification:\n\n\\(CA_A\\) certifies the public key \\(pub_{CA_B}\\) of \\(CA_B\\).\nCross-certificate: \\(CA_A\\{CA_B\\}\\).\nCertification chain: \\(CA_A\\{CA_B\\} \\rightarrow CA_B\\{B\\}\\).\nA verifies B’s key with an authentic copy of \\(pub_{CA_A}\\).\n\nStrict Hierarchical Model (PEM/X.509):\n\n\n\n\n\ngraph TD\n    Root[Root CA]\n    Root --&gt; CA1[Level 1 CA]\n    Root --&gt; CA2[Level 1 CA]\n    CA1 --&gt; CA3[Level 2 CA]\n    CA1 --&gt; CA4[Level 2 CA]\n    CA2 --&gt; CA5[Level 2 CA]\n\n\n\n\n\n\n\nAny non-local chain starts at the root node.\nRoot public key assumed to be globally known.\nProblem: Centralization, single point of failure.\n\nGraph Model (PGP):\n\nUsers act as CAs for correspondents.\nDecentralized graph structure.\nSuitable for closed groups.\nLimitations: Unconnected populations.\n\nHybrid Models:\n\nHierarchy + bidirectional cross-certification.\n\nGolden Rule: Short chains (weakest link!).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nCertification Topologies\nWhen two users belonging to different CAs wish to communicate, a trust problem arises: should one trust a certificate issued by another CA?\nThe cross-certification process allows \\(CA_A\\) to certify the public key \\(pub_{CA_B}\\) of \\(CA_B\\). The resulting certificate is called a cross-certificate, denoted: \\(CA_A\\{CA_B\\}\\).\nIf A wants to verify the authenticity of B’s public key and there exists a cross-certificate \\(CA_A\\{CA_B\\}\\), A will ask B to provide its certificate signed by \\(CA_B\\), i.e., \\(CA_B\\{B\\}\\). The resulting certification chain: \\(CA_A\\{CA_B\\} \\rightarrow CA_B\\{B\\}\\) allows A to verify B’s public key using an authentic copy of \\(pub_{CA_A}\\).\nThe trust relationship necessary for cross-certification is not always easy to establish in competitive environments, which is why hierarchical models among CAs have been proposed. Example: the strict hierarchical model of PEM/X.509:\n[Hierarchy diagram]\nIn the PEM environment, any non-local certification chain starts at the root node, whose public key is assumed to be known worldwide…\nOther models, such as the one proposed by PGP, are based on a graph structure where the nodes are users who act as CAs to certify the public keys of correspondents. Although well-suited for closed user groups, this model has its limitations when applied to unconnected populations.\nOther proposed schemes combine the hierarchical structure with bidirectional cross-certification.\nKeep certification chains as short as possible (a chain is always as vulnerable as its weakest link!).\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nCertification Topologies:\n\nCross-certification: \\(CA_A\\{CA_B\\} \\rightarrow CA_B\\{B\\}\\)\nHierarchical (PEM/X.509): Global root\nGraph (PGP): Users = CAs\nHybrid: Hierarchy + cross-cert\nRule: Short chains!"
  },
  {
    "objectID": "exam_notes_en.html#public-key-infrastructure-pki",
    "href": "exam_notes_en.html#public-key-infrastructure-pki",
    "title": "Fundamental Security Services",
    "section": "Public Key Infrastructure (PKI)",
    "text": "Public Key Infrastructure (PKI)\nDefinition: Integrated infrastructure providing security services based on public-key cryptography.\n\nMain Functional Entities\nCertification Authority (CA):\n\nCreation and maintenance of certificates.\n\nCertificate Repository:\n\nAccessible certificate directory (X.500, LDAP, WWW, DNS).\n\nCertificate Revocation:\n\nManagement of compromised/obsolete certificates (CRLs).\n\nKey Backup and Recovery:\n\nBackup/restoration of lost keys.\nMedia destruction, password loss, employee departure.\n⚠️ Decryption private key (not signature).\n\nAutomatic Key Update:\n\nKey update after validity expiration.\n\nKey and Certificate History:\n\nRetrieval of obsolete keys to decrypt old documents.\n\nCross-Certification:\n\nValidation of certificates from other PKIs (clients, suppliers, partners).\n\nNon-Repudiation Support:\nDemonstrates the proper execution of an authenticated transaction:\n\nData origin authentication.\nTime-stamped data signature.\nSigned receipt of delivery.\n\nSecure Time Stamping:\n\nTime reference accepted by all.\n\nClient Software:\n\nPKI operations on the client side.\nCertificate management, signatures, decryption.\nPeripherals (smart cards, biometrics).\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nPublic Key Infrastructure (PKI): Definitions\nDefinition: A PKI is an integrated infrastructure enabling the provision of a set of security services based on public-key cryptography.\nFunctional Entities:\n\nCertification Authority (CA): Entity responsible for creating and maintaining certificates.\nCertificate Repository: Directory making certificates available to users and applications. Technologies used: X.500, LDAP, WWW servers, DNS, etc.\nCertificate Revocation: Compromised or obsolete certificates (notably CRL management).\nCentralized Key Backup and Recovery: Entity allowing key loss management due to various events: destruction of the material medium, password loss, employee departure, etc. Note that this procedure mainly applies to the decryption private key (as opposed to the signature private key).\nAutomatic Key Update: After their validity expires.\nKey and Certificate History. This entity allows the retrieval of obsolete keys that were used to encrypt a document in the past.\nCross-Certification with other PKIs (clients, suppliers, partners, etc.). This functionality allows (under certain constraints) the validation of certificates issued by other PKIs.\nNon-Repudiation Support: Value-added service providing the necessary evidence to demonstrate the execution of an authenticated transaction (data origin authentication, time-stamped data signature, signed receipt of delivery, etc.).\nSecure Time Stamping: Entity capable of providing a reference time accepted by all PKI participants. Main applications: non-repudiation, arbitration in case of conflicts, etc.\nClient Software: This functional entity allows all PKI operations on the client side. Examples: user certificate management, document signing, information decryption, management of specific peripherals (smart card readers, biometric devices, etc.).\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nPKI – Main Entities:\n\nCA: Certificate creation/maintenance\nRepository: Certificate storage\nRevocation: CRLs\nBackup/Recovery: Lost keys (decryption)\nCross-cert: Validation of other PKIs\nTime stamping: Time reference\nClient: User operations\n\n\n\n\n\n\n\nAdvantages and Disadvantages\nAdvantages:\nSecurity:\n\nIntegrated environment without weak links.\n\nAll-in-One:\n\nIntegration of multiple services: strong authentication, signatures, single sign-on, VPNs, B2C/B2B.\nCost savings vs. “case-by-case” solutions.\n\nInteroperability:\n\nWidespread standards (X.509, PKCS, OCSP).\nCompatible applications and devices.\nPossible inter-enterprise interoperability.\n\nDisadvantages:\nImplementation Cost:\n\nExpensive products.\nRare skills.\n\nComplexity:\n\nComplex implementation and management.\nAlternative: Outsourcing PKI service.\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nPKI: Main Advantages and Disadvantages\nAdvantages\n\nSecurity: The integrated nature of a PKI allows the creation of a security environment without weak links.\nAll-in-One: A PKI enables the integration and management of all security parameters for a wide range of services: strong entity authentication, document signing for non-repudiation, single sign-on, virtual private networks (VPNs), secure communications with clients/partners/suppliers (B2C, B2B), etc. The PKI represents a significant cost saving compared to “case-by-case” solutions.\nIntra- and Inter-Enterprise Interoperability: The main PKI products comply with widely adopted standardization norms (X.509, PKCS, OCSP, etc.). A large number of applications and hardware devices now conform to these standards. The possible compatibility between different PKI providers also allows (with some reservations) inter-enterprise interoperability.\n\nDisadvantages\n\nImplementation Cost: Expensive products, rare skills.\nComplexity…but:\n\nOutsourcing the “PKI service” is an alternative.\n\n\n\n\n\n\n\n\n\n\n\nTipQuick Review\n\n\n\n\n\nPKI:\n✅ Advantages:\n\nIntegrated security\nAll-in-one: multi-services\nInteroperability (standards)\n\n❌ Disadvantages:\n\nHigh cost\nComplexity\nSolution: Outsourcing"
  }
]