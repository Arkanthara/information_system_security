[
  {
    "objectID": "exam_notes_fr.html",
    "href": "exam_notes_fr.html",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "",
    "text": "Les services de sécurité sont les objectifs que l’on cherche à atteindre pour protéger un système.\n\nConfidentialité : Protection contre la divulgation non autorisée.\nIntégrité : Protection contre la modification non autorisée.\nDisponibilité : Garantie d’accès pour les utilisateurs légitimes.\nAuthentification :\n\nEntity authentication (Entité) : Certifier l’identité d’un acteur.\nData origin authentication (Origine) : Certifier la source d’une donnée.\n\nNon-répudiation : Impossibilité de nier une transaction.\nNon-Duplication : Protection contre les copies illicites.\nAnonymat : Préservation de l’identité ou de la source.\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nConfidentialité : Protection de l’information d’une divulgation non autorisée.\nIntégrité : Protection contre la modification non autorisée de l’information.\nDisponibilité : S’assurer que les ressources sont accessibles aux utilisateurs légitimes.\nAuthentification :\n\nAuthentification d’entités (entity authentication) : procédé permettant à une entité d’être sûre de l’identité d’une seconde entité à l’appui d’une évidence corroborant (p.ex.: présence physique, cryptographique, biométrique, etc.). Le terme identification est parfois utilisé pour désigner également ce service.\nAuthentification de l’origine de données (data origin authentication) : procédé permettant à une entité d’être sûre qu’une deuxième entité est la source originale d’un ensemble de données. Par définition, ce service assure également l’intégrité de ces données.\n\nNon-répudiation : Offre la garantie qu’une entité ne pourra pas nier être impliquée dans une transaction.\nNon-Duplication : Protection contre les copies illicites.\nAnonymat (d’entité ou d’origine de données) : Permet de préserver l’identité d’une entité, de la source d’une information ou d’une transaction."
  },
  {
    "objectID": "exam_notes_fr.html#dangers-et-attaques-synthèse",
    "href": "exam_notes_fr.html#dangers-et-attaques-synthèse",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Dangers et Attaques : Synthèse",
    "text": "Dangers et Attaques : Synthèse\n\n\n\n\n\n\n\n\nServices\nDangers\nAttaques\n\n\n\n\nConfidentialité\nfuite d’informations\nécoutes illicites, analyse du trafic\n\n\nIntégrité\nmodification de l’information\ncréation, altération ou destruction illicite\n\n\nDisponibilité\ndenial of service, usage illicite\nvirus, accès répétés visant à inutiliser un système\n\n\nAuthentification d’entités\naccès non autorisés\nVol de mot de passe, faille dans le protocole d’authentification\n\n\nAuthentification de données\nfalsification d’informations\nfalsification de signature, faille dans le protocole d’authentification\n\n\nNon-répudiation\nnier la participation à une transaction\nprétendre un vol de clé ou une faille dans le protocole de signature\n\n\nNon-duplication\nduplication\nfalsification, imitation\n\n\nAnonymat\nidentification\nanalyse d’une transaction, accès non autorisés permettant l’identification"
  },
  {
    "objectID": "exam_notes_fr.html#mécanismes-de-protection",
    "href": "exam_notes_fr.html#mécanismes-de-protection",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Mécanismes de Protection",
    "text": "Mécanismes de Protection\n\n\n\n\n\n\n\n\nServices\nMécanismes classiques\nMécanismes digitaux\n\n\n\n\nConfidentialité\nscellés, coffre-forts, cadenas\ncryptage, autorisation logique\n\n\nIntégrité\nencre spéciale, hologrammes\nfonctions à sens unique + cryptage\n\n\nDisponibilité\ncontrôle d’accès physique, surveillance vidéo\ncontrôle d’accès logique, audit, anti-virus\n\n\nAuth. d’entités\nprésence, voix, pièce d’identité, reconnaissance biométrique\nsecret + protocole d’authentification, adresse réseau + userid, carte à puce + PIN\n\n\nAuth. de données\nsceaux, signature, empreinte digitale\nfonctions à sens unique + cryptage\n\n\nNon-répudiation\nsceaux, signature, signature notariale, envoi recommandé\nfonctions à sens unique + cryptage + signature digitale\n\n\nNon-duplication\nencre spéciale, hologrammes, tatouage\ntatouage digital (watermarks), verrouillage cryptographique\n\n\nAnonymat\nbrouilleur de voix, déguisement, argent liquide\nmixers, remailers, argent électronique, deep web"
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis par E-Mail",
    "text": "Programmes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels (malware).\nE-mails visant à provoquer une action (ouvrir une pièce jointe ou cliquer sur un lien).\nAttaques souvent personnalisées grâce à l’ingénierie sociale.\nConséquences principales :\n\nInstallation de malware (ransomware, keyloggers, etc.).\nPerte ou vol de données personnelles.\nDétournement du système et propagation du malware.\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nMalware diffusé par e-mail\nIncitation à cliquer ou ouvrir\nIngénierie sociale\nVol, perte de données, détournement\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nProgrammes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels ou malware.\nE-mails conçus pour inciter le destinataire à ouvrir une pièce jointe ou à suivre un lien contenant de la publicité non souhaitée, des informations offensives, des programmes à risque, etc.\nSouvent ciblés sur la base des intérêts de la victime (travail préliminaire d’ingénierie sociale (social engineering)).\nConséquences :\n\nInstallation de malware (ransomware, keyloggers, etc.) dans le système de la victime (ordinateur, tablette, smartphone, smartwatch, etc.).\nDestruction de données contenues dans l’ordinateur.\nVol d’informations ou de données personnelles.\nDétournement du système pour des fins malicieuses (p.ex.: minage illicite de bitcoins).\nDiffusion de malware (éventuellement à d’autres utilisateurs)."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail-1",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis par E-Mail",
    "text": "Programmes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels ou malware.\nE-mails conçus pour inciter le destinataire à ouvrir une pièce jointe ou à suivre un lien contenant de la publicité non souhaitée, des informations offensives, des programmes à risque, etc.\nSouvent ciblés sur la base des intérêts de la victime (travail préliminaire d’ingénierie sociale (social engineering)).\nConséquences :\n\nInstallation de malware (ransomware, keyloggers, etc.) dans le système de la victime (ordinateur, tablette, smartphone, smartwatch, etc.).\nDestruction de données contenues dans l’ordinateur.\nVol d’informations ou de données personnelles.\nDétournement du système pour des fins malicieuses (p.ex.: minage illicite de bitcoins).\nDiffusion de malware (éventuellement à d’autres utilisateurs)."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis sur le Web",
    "text": "Programmes Malveillants Transmis sur le Web\n\nMéthode appelée drive-by download : infection automatique lors de la visite d’un site web.\nL’origine peut être :\n\nun site malveillant ;\nun site légitime compromis (p. ex. cross-site scripting).\n\nLa prudence des utilisateurs limite fortement ce mode de propagation.\nLes impacts sont similaires aux infections par e-mail.\nLa restriction des scripts (java/javascript) réduit les risques mais peut affecter la navigation.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nDrive-by download = infection sans action de l’utilisateur\nSites malveillants ou compromis\nSensibilisation + scripts restreints = protection\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nProgrammes Malveillants Transmis sur le Web\n\nCette technique, souvent appelée drive-by download, permet d’infecter le système (ordinateur, tablette, smartphone, smartwatch, etc.) sur lequel s’exécute un client web lors de la simple visite d’un site.\nIl peut s’agir soit :\n\nd’un site malicieux qui contient le malware.\nd’un site web légitime qui aurait été infecté au préalable (par exemple, moyennant une technique appelée cross-site scripting). L’infection pouvant affecter seulement certaines pages…\n\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes conséquences sont semblables à celle des transmissions par e-mail.\nL’exécution restreinte des scripts (java/javascript) dans le navigateur peut limiter la portée de l’infection mais risque de contraindre la navigation dans certains sites."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web-1",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis sur le Web",
    "text": "Programmes Malveillants Transmis sur le Web\n\nCette technique, souvent appelée drive-by download, permet d’infecter le système (ordinateur, tablette, smartphone, smartwatch, etc.) sur lequel s’exécute un client web lors de la simple visite d’un site.\nIl peut s’agir soit :\n\nd’un site malicieux qui contient le malware.\nd’un site web légitime qui aurait été infecté au préalable (par exemple, moyennant une technique appelée cross-site scripting). L’infection pouvant affecter seulement certaines pages…\n\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes conséquences sont semblables à celle des transmissions par e-mail.\nL’exécution restreinte des scripts (java/javascript) dans le navigateur peut limiter la portée de l’infection mais risque de contraindre la navigation dans certains sites."
  },
  {
    "objectID": "exam_notes_fr.html#hameçonnage-phishing",
    "href": "exam_notes_fr.html#hameçonnage-phishing",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hameçonnage (Phishing)",
    "text": "Hameçonnage (Phishing)\n\nTechnique visant à collecter des informations privées par des méthodes de pêche indiscriminée.\nLe phishing peut être :\n\ngénéral (ciblage large) ;\nciblé (spear phishing) lorsqu’une personne ou organisation précise est visée.\n\nLe vecteur principal est un e-mail à adresse falsifiée, difficilement détectable.\nL’objectif est d’obtenir des données sensibles (identifiants, mots de passe, informations personnelles ou bancaires).\nLes attaques reposent sur des prétextes crédibles ou menaçants pour pousser la victime à coopérer.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nVol d’informations par tromperie\nE-mails falsifiés\nSpear phishing = attaque ciblée\nPrétextes urgents ou menaçants\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nHameçonnage (Phishing)\n\nLe mot phishing se compose des mots anglais “password” (mot de passe), “harvesting” (moisson) et “fishing” (pêche).\nCette composition de mots illustre le but principal de cette technique qui consiste à récolter un maximum d’informations privées des utilisateurs via des mécanismes de “pêche indiscriminée”.\nLorsque la pêche aux informations est ciblée vers une personne ou organisation spécifique, la technique est dénommée spear phishing (qui provient de spear fishing ou pêche au harpon).\nLe vecteur de transmission consiste normalement dans un e-mail avec une adresse d’expédition falsifiée (mais souvent indétectable…) qui demande à la victime de fournir des informations privées : adresses e-mail, identifiants (twitter, facebook, etc.), mots de passe, numéros d’identité, numéros de comptes bancaires, etc.\nLes prétextes utilisés sont variés (mise à jour du système informatique, arrêt du service, retrait d’un envoi, etc.) et vont jusqu’à menacer l’utilisateur en cas de refus."
  },
  {
    "objectID": "exam_notes_fr.html#hameçonnage-phishing-1",
    "href": "exam_notes_fr.html#hameçonnage-phishing-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hameçonnage (Phishing)",
    "text": "Hameçonnage (Phishing)\n\nLe mot phishing se compose des mots anglais “password” (mot de passe), “harvesting” (moisson) et “fishing” (pêche).\nCette composition de mots illustre le but principal de cette technique qui consiste à récolter un maximum d’informations privées des utilisateurs via des mécanismes de “pêche indiscriminée”.\nLorsque la pêche aux informations est ciblée vers une personne ou organisation spécifique, la technique est dénommée spear phishing (qui provient de spear fishing ou pêche au harpon).\nLe vecteur de transmission consiste normalement dans un e-mail avec une adresse d’expédition falsifiée (mais souvent indétectable…) qui demande à la victime de fournir des informations privées : adresses e-mail, identifiants (twitter, facebook, etc.), mots de passe, numéros d’identité, numéros de comptes bancaires, etc.\nLes prétextes utilisés sont variés (mise à jour du système informatique, arrêt du service, retrait d’un envoi, etc.) et vont jusqu’à menacer l’utilisateur en cas de refus."
  },
  {
    "objectID": "exam_notes_fr.html#pourriels-spam",
    "href": "exam_notes_fr.html#pourriels-spam",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Pourriels (Spam)",
    "text": "Pourriels (Spam)\n\nE-mails indésirables, souvent publicitaires, ou pop-ups non sollicités lors de la navigation web.\nReprésentent environ 60% des e-mails mondiaux.\nConséquences principales :\n\nConsommation de ressources et perte de temps.\nCertains peuvent transmettre des malware.\n\nCiblent souvent les adresses courtes ou proviennent de listes d’adresses vendues/échangées.\nLes filtres anti-spam entraînent des coûts importants pour les organisations.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nE-mails/publicités indésirables\nRisques : perte de temps, ressources, malware\nCiblage : adresses courtes ou listes\nFiltrage coûteux pour entreprises\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nPourriels (Spam)\n\nEnglobe tous les e-mails indésirables (souvent publicitaires) reçus par les personnes et les organisations.\nTerme utilisé également pour désigner les pages/fenêtres pop-up affichées sans le consentement de l’utilisateur lors de la navigation web.\nOn estime que 60% des e-mails qui circulent dans le monde appartiennent à cette catégorie.\nLes conséquences sont souvent limitées à la consommation de ressources de calcul et stockage ainsi qu’au gaspillage de temps associé à la lecture et traitement de ces messages mais…\n… certains e-mails spam peuvent également constituer des vecteurs de transmission de malware.\nIls ont tendance à cibler plus particulièrement les adresses e-mail courtes (p.ex: abc@gmail.com) mais fonctionnent également sur la base des listes (souvent échangées / vendues) contenant tous types d’adresses.\nLes opérations de filtrage anti-spam entraînent des coûts considérables pour les organisations."
  },
  {
    "objectID": "exam_notes_fr.html#pourriels-spam-1",
    "href": "exam_notes_fr.html#pourriels-spam-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Pourriels (Spam)",
    "text": "Pourriels (Spam)\n\nEnglobe tous les e-mails indésirables (souvent publicitaires) reçus par les personnes et les organisations.\nTerme utilisé également pour désigner les pages/fenêtres pop-up affichées sans le consentement de l’utilisateur lors de la navigation web.\nOn estime que 60% des e-mails qui circulent dans le monde appartiennent à cette catégorie.\nLes conséquences sont souvent limitées à la consommation de ressources de calcul et stockage ainsi qu’au gaspillage de temps associé à la lecture et traitement de ces messages mais…\n… certains e-mails spam peuvent également constituer des vecteurs de transmission de malware.\nIls ont tendance à cibler plus particulièrement les adresses e-mail courtes (p.ex: abc@gmail.com) mais fonctionnent également sur la base des listes (souvent échangées / vendues) contenant tous types d’adresses.\nLes opérations de filtrage anti-spam entraînent des coûts considérables pour les organisations."
  },
  {
    "objectID": "exam_notes_fr.html#rançongiciels-ransomware",
    "href": "exam_notes_fr.html#rançongiciels-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Rançongiciels (Ransomware)",
    "text": "Rançongiciels (Ransomware)\n\nMalware type Cheval de Troie qui chiffre les données pour les rendre inaccessibles.\nExige une rançon (souvent en bitcoins) pour récupérer les fichiers.\nPeut rester dormant, déclenché par un événement ou une date.\nPrincipal vecteur : e-mails malveillants.\nAutres effets possibles : attaques par déni de service, extorsion.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nChiffrement des données par Cheval de Troie\nRançon pour restaurer accès\nDormance programmée possible\nInfection via e-mails malveillants\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nRançongiciels (Ransomware)\n\nCette famille spécifique de malware appartient à la catégorie appelée Chevaux de Troie (Trojan Horses).\nLeur comportement plus habituel consiste à chiffrer les données de la victime (locaux et distants) afin de les rendre totalement inaccessibles.\nUn message apparait ensuite pour demander le paiement d’une rançon (souvent en bitcoins ou une autre monnaie virtuelle) permettant potentiellement de récupérer l’accès aux fichiers chiffrés.\nIls peuvent rester en état dormant dans le système infecté et être déclenchés par un événement spécifique ou à une date donnée (attaques synchronisées).\nLeurs vecteurs d’infection sont variés mais les e-mails contenant des pièces jointes malicieuses sont souvent mis en cause lors des infections primaires.\nDes nombreuses variantes existent et continuent à se développer.\nOn observe parfois d’autres comportements associés à ces malware : dénis de service, extorsions ciblées, menaces, etc."
  },
  {
    "objectID": "exam_notes_fr.html#rançongiciels-ransomware-1",
    "href": "exam_notes_fr.html#rançongiciels-ransomware-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Rançongiciels (Ransomware)",
    "text": "Rançongiciels (Ransomware)\n\nCette famille spécifique de malware appartient à la catégorie appelée Chevaux de Troie (Trojan Horses).\nLeur comportement plus habituel consiste à chiffrer les données de la victime (locaux et distants) afin de les rendre totalement inaccessibles.\nUn message apparait ensuite pour demander le paiement d’une rançon (souvent en bitcoins ou une autre monnaie virtuelle) permettant potentiellement de récupérer l’accès aux fichiers chiffrés.\nIls peuvent rester en état dormant dans le système infecté et être déclenchés par un événement spécifique ou à une date donnée (attaques synchronisées).\nLeurs vecteurs d’infection sont variés mais les e-mails contenant des pièces jointes malicieuses sont souvent mis en cause lors des infections primaires.\nDes nombreuses variantes existent et continuent à se développer.\nOn observe parfois d’autres comportements associés à ces malware : dénis de service, extorsions ciblées, menaces, etc."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot",
    "href": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les Dispositifs Internet of Things (IoT)",
    "text": "Attaques sur les Dispositifs Internet of Things (IoT)\n\nAttaques visant les objets connectés (caméras, TV, capteurs, alarmes, etc.).\nCes dispositifs sont faciles à compromettre à cause de :\n\nfailles connues,\nmots de passe par défaut,\nmanque de sensibilisation des utilisateurs.\n\nLa prise de contrôle à distance permet :\n\nun point d’entrée vers le réseau,\nl’utilisation de l’appareil pour des activités illicites (DDoS, hacking, minage).\n\nUn inventaire précis des dispositifs connectés est indispensable.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nCible les objets connectés\nSécurité faible (failles, mots de passe par défaut)\nRisque d’accès au réseau et d’abus\nInventaire des IoT nécessaire\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nAttaques sur les Dispositifs Internet of Things (IoT)\n\nCiblent les objets connectés de toute sorte (caméras, TVs, frigos, capteurs et interrupteurs domotiques, installations d’alarme, etc.).\nIls sont souvent plus faciles à pirater que les systèmes traditionnels par cause de :\n\nnombreuses failles de sécurité souvent connues des attaquants.\nmots de passe par défaut.\nnégligence de la part des utilisateurs qui ignorent les risques qui leurs sont propres.\n\nLa prise de contrôle à distance de ces appareils par une entité malveillante implique :\n\nUne porte d’entrée au réseau domestique/corporatif.\nUn dispositif pouvant être utilisé pour des activités illicites (hacking, attaques DDoS, minage de bitcoins, etc.).\n\nL’établissement d’un répertoire précis de tous les dispositifs de ce type connectés au réseau est nécessaire!"
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot-1",
    "href": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les Dispositifs Internet of Things (IoT)",
    "text": "Attaques sur les Dispositifs Internet of Things (IoT)\n\nCiblent les objets connectés de toute sorte (caméras, TVs, frigos, capteurs et interrupteurs domotiques, installations d’alarme, etc.).\nIls sont souvent plus faciles à pirater que les systèmes traditionnels par cause de :\n\nnombreuses failles de sécurité souvent connues des attaquants.\nmots de passe par défaut.\nnégligence de la part des utilisateurs qui ignorent les risques qui leurs sont propres.\n\nLa prise de contrôle à distance de ces appareils par une entité malveillante implique :\n\nUne porte d’entrée au réseau domestique/corporatif.\nUn dispositif pouvant être utilisé pour des activités illicites (hacking, attaques DDoS, minage de bitcoins, etc.).\n\nL’établissement d’un répertoire précis de tous les dispositifs de ce type connectés au réseau est nécessaire!"
  },
  {
    "objectID": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement",
    "href": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)",
    "text": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant à altérer les informations sur sites web et réseaux sociaux.\nImpact : réputation compromise et dommages économiques.\nSites web : sécurisation du système hôte, configuration restrictive, audits réguliers.\nRéseaux sociaux : mots de passe forts, authentification multi-facteur, fermeture des sessions, suppression des cookies.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAltération des infos sur sites et réseaux sociaux\nRisques : réputation et pertes économiques\nSites : sécurisation + audits\nRéseaux sociaux : mots de passe forts, MFA, sessions fermées, cookies supprimés\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nModification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant l’intégrité de l’information publiée dans les sites web, les réseaux sociaux, etc.\nElles portent atteinte à la réputation et peuvent provoquer d’importants dommages économiques pour les sociétés ayant une présence Internet.\nDans le cas des sites web, la sécurisation du système hôte est essentielle ainsi qu’une configuration aussi restrictive que possible. Des audits des sécurité récurrents sont vivement recommandés.\nLa protection des informations affichées dans les réseaux sociaux dépend directement du processus d’authentification permettant d’accéder au profil à risque :\n\nÉviter les mots de passe trop simples.\nPrivilégier l’authentification forte, si possible multi-facteur.\nFermer proprement les sessions.\nEffacer les cookies."
  },
  {
    "objectID": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement-1",
    "href": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)",
    "text": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant l’intégrité de l’information publiée dans les sites web, les réseaux sociaux, etc.\nElles portent atteinte à la réputation et peuvent provoquer d’importants dommages économiques pour les sociétés ayant une présence Internet.\nDans le cas des sites web, la sécurisation du système hôte est essentielle ainsi qu’une configuration aussi restrictive que possible. Des audits des sécurité récurrents sont vivement recommandés.\nLa protection des informations affichées dans les réseaux sociaux dépend directement du processus d’authentification permettant d’accéder au profil à risque :\n\nÉviter les mots de passe trop simples.\nPrivilégier l’authentification forte, si possible multi-facteur.\nFermer proprement les sessions.\nEffacer les cookies."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos",
    "href": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques Dénis de Service (Denial of Service / DDoS)",
    "text": "Attaques Dénis de Service (Denial of Service / DDoS)\n\nVise à rendre inaccessibles des systèmes informatiques, surtout pour les organisations.\nDDoS : attaque distribuée par des milliers de dispositifs, générant un trafic massif.\nProtections classiques (firewalls, sondes IDS (Intrusion Detection System) / IPS (Intrusion Prevention System)) souvent insuffisantes.\nConséquences :\n\nRéputation affectée\nPertes financières (parfois rançons)\nRisques élevés pour les infrastructures critiques (hôpitaux, centrales, Internet backbone)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nDDoS = systèmes inaccessibles via attaques massives\nProtections limitées\nRisques : réputation, finances, infrastructures critiques\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nAttaques Dénis de Service (Denial of Service / DDoS)\n\nAttaques destinées à rendre inaccessibles des systèmes informatiques de toute sorte visant surtout les organisations privées ou étatiques.\nLe terme DDoS (Distributed Denial of Service) désigne une famille d’attaques dans laquelle des multiples (souvent des dizaines de milliers) de dispositifs ciblent simultanément le(s) système(s) victime(s).\nLe trafique généré atteint plusieurs centaines de gigabits / seconde.\nL’efficacité des mécanismes de protection traditionnels (firewalls, sondes de prévention et de détection d’intrusion, etc.) est limitée.\nL’indisponibilité d’un service peut engendrer :\n\ndes problèmes réputationnels.\nd’importantes pertes financières (des demandes de rançon peuvent être exigées pour les désactiver).\ndes hauts risques de sécurité (même physique!) lorsque des infrastructures critiques (hôpitaux, centrales électriques, backbone de l’Internet, etc.) sont ciblées."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos-1",
    "href": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques Dénis de Service (Denial of Service / DDoS)",
    "text": "Attaques Dénis de Service (Denial of Service / DDoS)\n\nAttaques destinées à rendre inaccessibles des systèmes informatiques de toute sorte visant surtout les organisations privées ou étatiques.\nLe terme DDoS (Distributed Denial of Service) désigne une famille d’attaques dans laquelle des multiples (souvent des dizaines de milliers) de dispositifs ciblent simultanément le(s) système(s) victime(s).\nLe trafique généré atteint plusieurs centaines de gigabits / seconde.\nL’efficacité des mécanismes de protection traditionnels (firewalls, sondes de prévention et de détection d’intrusion, etc.) est limitée.\nL’indisponibilité d’un service peut engendrer :\n\ndes problèmes réputationnels.\nd’importantes pertes financières (des demandes de rançon peuvent être exigées pour les désactiver).\ndes hauts risques de sécurité (même physique!) lorsque des infrastructures critiques (hôpitaux, centrales électriques, backbone de l’Internet, etc.) sont ciblées."
  },
  {
    "objectID": "exam_notes_fr.html#fonctions-de-hachage-cryptographiques",
    "href": "exam_notes_fr.html#fonctions-de-hachage-cryptographiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fonctions de Hachage Cryptographiques",
    "text": "Fonctions de Hachage Cryptographiques\n\nFonctions faciles à calculer dans un sens mais virtuellement impossibles à inverser.\nToute modification du document source change radicalement le digest (effet avalanche).\nPropriétés clés :\n\nOne-way : impossible de retrouver l’entrée depuis le hash.\nCollision-free : impossible de trouver deux entrées avec le même hash.\n\nTaille des digests : 160 à 512 bits.\nAlgorithmes (très performants) : SHA-1, SHA-256, SHA-3.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nOne-way + collision-free.\nTaille : 160-512 bits.\nAlgos : SHA-1/256/3.\nUsage : intégrité, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nFonctions faciles à calculer dans un sens mais virtuellement impossibles à calculer dans le sens contraire.\nToute modification (même insignifiante) du document source se traduit par un digest fondamentalement différent.\nIl est virtuellement impossible de retrouver le document source à l’aide seulement du digest (one-way).\nIl est virtuellement impossible de retrouver un deuxième document source produisant le même digest (collision-free).\nLongueur habituelle des digests : 160 à 512 bits.\nLes algorithmes à sens unique sont très performants.\nExemples : SHA-1, SHA-256, SHA-3, etc."
  },
  {
    "objectID": "exam_notes_fr.html#générateurs-pseudo-aléatoires",
    "href": "exam_notes_fr.html#générateurs-pseudo-aléatoires",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Générateurs (Pseudo) Aléatoires",
    "text": "Générateurs (Pseudo) Aléatoires\n\nCaractéristiques\n\naléatoire\nimprévisible\nnon reproductible\n\nCritique pour la sécurité (clés, IV, secrets).\nTypes :\n\nVrais aléatoires : basés sur phénomènes physiques (radioactivité, quantique).\nPseudo-aléatoires : déterministes (basés sur un seed: séquence aléatoire initiale).\n\nRisque : “Pseudo-sécurité” si le seed est prévisible (citation de Pitkin).\nApplications : clés de session, IV (DES-CBC), signatures (ElGamal).\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nVrais aléatoires : physiques (quantique).\nPseudo-aléatoires : déterministes (seed).\nRisque : seed prévisible = faille.\nUsages : clés, IV, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nLa génération de nombre aléatoire est un processus très important pouvant compromettre la sécurité d’un bon nombre de systèmes de cryptage.\nApplications : génération de clés de session, vecteurs d’initialisation (DES - CBC mode), secrets pour signatures (ElGamal), etc.\nUn générateur aléatoire (random generator) est un dispositif capable de générer des nombres de façon aléatoire, imprévisible et non reproductible. (e.g. basé sur phénomènes physiques: source radioactive ou quantique).\nLes générateurs pseudo-aléatoires sont des procédés déterministes développés à partir d’une séquence aléatoire initiale (seed) (e.g. frappe utilisateur, accès disque).\nCitation : R. Pitkin dans [Kau95]: “The use of pseudo-random processes to generate secret quantities can result in pseudo-security”"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique",
    "href": "exam_notes_fr.html#cryptographie-symétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique",
    "text": "Cryptographie Symétrique\n\nHistorique : Utilisée depuis Jules César (Iᵉʳ av. J.-C.).\nPrincipe : Une seule clé pour chiffrer/déchiffrer.\nSchéma : Plaintext → Cryptage (Clé) → Ciphertext → Décryptage (Clé) → Plaintext.\nCaractéristiques :\n\nAlgorithmes : AES, DES, IDEA, RC4.\nServices : Confidentialité, Authentification, Intégrité.\nLimite : Pas de signatures (clé partagée).\nProblème : Échange de clé sécurisé requis.\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\n1 clé pour chiffrer/déchiffrer.\nRapide (AES, DES).\nProblème : échange de clé.\nUsages : documents personnels, groupes fermés.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nAussi appelée cryptographie conventionnelle ou à clés secrètes (I av. JC, Julius Cesar).\nIdée : Sur la base d’une seule clé secrète, réaliser une transformation capable respectivement de rendre illisible et de restituer une pièce d’information.\nSchéma : Plaintext \\(\\to\\) Cryptage (Clé) \\(\\to\\) Ciphertext \\(\\to\\) Décryptage (Clé) \\(\\to\\) Plaintext.\nCaractéristiques :\n\nAlgorithmes : AES, DES, IDEA, RC4, RC5, etc. (certains sont gratuits et de libre accès)\nServices : Confidentialité, Authentification, Intégrité.\nPas de support direct pour signatures digitales (car clé connue des deux).\nNécessite un canal confidentiel pour échanger la clé.\nIdéal pour la protection de documents personnels ou groupes fermés."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique",
    "href": "exam_notes_fr.html#cryptographie-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique",
    "text": "Cryptographie Asymétrique\n\nAussi appelée cryptographie publique (1976, Diffie & Hellman).\nPrincipe\n\nPaire de clés (publique/privée) pour chiffrement et signatures.\n\nDeux usages principaux :\n\nConfidentialité :\n\nChiffrement : clé publique du destinataire\nDéchiffrement : clé privée du destinataire\n\nSignature numérique :\n\nSignature : clé privée de l’expéditeur\nVérification : clé publique de l’expéditeur\nOptimisation : On signe généralement le hash du document\nPropriétés fondamentales :\n\nIntégrité : Toute modification invalide la signature\nNon-collision : Impossible d’avoir 2 documents avec la même signature\nNon-répudiation : Seul le détenteur de la clé privée peut signer\n\n\n\nAspects techniques :\n\nAlgorithmes : RSA, ElGamal\nServices : Intégrité, Authentification, Non-Répudiation\nPerformance : beaucoup plus lent que le symétrique (100x plus lent)\nAvantage : Pas besoin de canal confidentiel pour l’échange de clés\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\n2 clés : publique (chiffrer/vérifier) + privée (déchiffrer/signer)\n2 usages :\n\nConfidentialité : chiffrer pour un destinataire\nSignature : prouver l’authenticité\n\nSignatures :\n\nIntégrité + non-répudiation\n\nAlgorithmes : RSA/ElGamal\nAvantage : Pas besoin de canal sécurisé pour échanger les clés\nDésavantage : Lente\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique\n\nAussi appelée cryptographie publique ou à clés publiques (1976, W. Diffie & M. Hellman).\nIdée : Utiliser deux clés différentes - une secrète et une publique - respectivement pour les opérations de cryptage et décryptage.\nChaque utilisateur dispose d’un porte-clés (keyring).\n\nConfidentialité : * Expéditeur crypte avec la clé publique du destinataire. * Destinataire décrypte avec sa clé privée. * Uniquement clé du destinataire utilisée !\nSignature Digitale : * Expéditeur signe avec sa clé privée. * Destinataire vérifie avec la clé publique de l’expéditeur. * Uniquement clé de l’expéditeur utilisée ! * Note : On signe généralement le digest du document (hash) pour des raisons de performance.\nCaractéristiques des signatures : * La signature change si le document change, alors que la clé privée reste la même. * En cas de modification du document ou de la signature, la vérification échoue (intégrité garantie). * Il est virtuellement impossible, même pour le détenteur de la clé privée, de générer un second document produisant la même signature (fonction à sens unique sans collisions). * Seul le détenteur de la clé privée peut générer une signature vérifiable à l’aide de la clé publique correspondante (non-répudiation). * Algorithmes : RSA, ElGamal. * Services : Intégrité, Authentification, Non-Répudiation. * Lenteur : Jusqu’à 50 fois plus lent que la cryptographie symétrique. * Avantage : Pas besoin de canal confidentiel pour échanger les clés (contrairement au symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique",
    "text": "Cryptographie Asymétrique\n\nAussi appelée cryptographie publique ou à clés publiques (1976, W. Diffie & M. Hellman).\nIdée : Utiliser deux clés différentes - une secrète et une publique - respectivement pour les opérations de cryptage et décryptage.\nChaque utilisateur dispose d’un porte-clés (keyring).\n\nConfidentialité : * Expéditeur crypte avec la clé publique du destinataire. * Destinataire décrypte avec sa clé privée. * Uniquement clé du destinataire utilisée !\nSignature Digitale : * Expéditeur signe avec sa clé privée. * Destinataire vérifie avec la clé publique de l’expéditeur. * Uniquement clé de l’expéditeur utilisée ! * Note : On signe généralement le digest du document (hash) pour des raisons de performance.\nCaractéristiques des signatures : * La signature change si le document change, alors que la clé privée reste la même. * En cas de modification du document ou de la signature, la vérification échoue (intégrité garantie). * Il est virtuellement impossible, même pour le détenteur de la clé privée, de générer un second document produisant la même signature (fonction à sens unique sans collisions). * Seul le détenteur de la clé privée peut générer une signature vérifiable à l’aide de la clé publique correspondante (non-répudiation). * Algorithmes : RSA, ElGamal. * Services : Intégrité, Authentification, Non-Répudiation. * Lenteur : Jusqu’à 50 fois plus lent que la cryptographie symétrique. * Avantage : Pas besoin de canal confidentiel pour échanger les clés (contrairement au symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#crypto-asymétrique-symétrique-hybride",
    "href": "exam_notes_fr.html#crypto-asymétrique-symétrique-hybride",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Crypto Asymétrique + Symétrique (Hybride)",
    "text": "Crypto Asymétrique + Symétrique (Hybride)\n\nPrincipe : Utiliser l’asymétrique pour échanger une clé symétrique (clé de session).\nÉtapes :\n\nA génère une clé symétrique aléatoire \\(K_s\\).\nA chiffre \\(K_s\\) avec la clé publique de B.\nA et B communiquent ensuite avec \\(K_s\\) (symétrique).\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAsymétrique : échange de clé symétrique.\nSymétrique : chiffrement des données.\nAvantage : combine sécurité + performance.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nIdée : Utiliser la cryptographie publique uniquement pour échanger des clés symétriques (Clés de session).\nA génère une clé aléatoire \\(K_s\\) et la transmet à B en l’encryptant avec la clé publique de B.\nA & B communiquent ensuite en utilisant \\(K_s\\) (symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Fonctionnement (RSA)",
    "text": "Cryptographie Asymétrique : Fonctionnement (RSA)\n\nConstruction des clés\n\nChoix des nombres premiers :\n\n\\(p\\) et \\(q\\) : deux grands nombres premiers (&gt; 1024 bits)\n\\(n = pq\\) : module RSA (taille = 2048+ bits)\n\nCalcul de l’indicatrice d’Euler :\n\n\\(\\phi(n) = (p-1)(q-1)\\)\nPropriété : Pour tout \\(a\\) premier avec \\(n\\), \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\n\nSélection des exposants :\n\n\\(e\\) : entier premier avec \\(\\phi(n)\\) (exposant public)\n\\(d\\) : inverse modulaire de \\(e\\) (exposant privé), tel que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\n\n\n\nProcessus de chiffrement/déchiffrement\n\nClé publique : \\((n,e)\\)\nClé privée : \\((d)\\)\nChiffrement : \\(C = P^e \\pmod{n}\\)\nDéchiffrement : \\(P = C^d \\pmod{n}\\)\n\n\n\nPreuve mathématique\n\nCongruence fondamentale :\n\n\\(ed = 1 + k\\phi(n)\\) (par définition de \\(d\\))\n\nApplication du théorème d’Euler :\n\n\\(P^{\\phi(n)} \\equiv 1 \\pmod{n}\\) (si \\(P\\) premier avec \\(n\\))\n\nDémonstration :\n\\[\\begin{align*}\n(P^e)^d &\\equiv P^{ed} \\pmod{n} \\\\\n&\\equiv P^{1 + k\\phi(n)} \\pmod{n} \\\\\n&\\equiv P \\cdot (P^{\\phi(n)})^k \\pmod{n} \\\\\n&\\equiv P \\cdot 1^k \\pmod{n} \\\\\n&\\equiv P \\pmod{n}\n\\end{align*}\\]\n\n\n\nSécurité du système\n\nProblème difficile : Factorisation de \\(n\\) en \\(p\\) et \\(q\\)\nTaille recommandée :\n\n\\(n\\) : 2048 bits (minimum pour sécurité actuelle)\n\\(p\\) et \\(q\\) : 1024+ bits chacun\n\nVulnérabilités connues :\n\nAttaques par canal auxiliaire (timing, power analysis)\nChoix inapproprié des paramètres (\\(e\\) trop petit, \\(p\\) et \\(q\\) trop proches)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nClés :\n\nPublique : \\((n,e)\\) où \\(n = pq\\)\nPrivée : \\((d)\\) avec \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\nOpérations :\n\nChiffrement : \\(P^e \\mod n\\)\nDéchiffrement : \\(C^d \\mod n\\)\n\nSécurité : Factorisation de \\(n\\) difficile\nTaille : 2048+ bits pour \\(n\\)\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique: Fonctionnement (RSA)\n\nSoit \\(n := pq\\) avec \\(p\\) et \\(q\\) deux nombres premiers grands (&gt; 1024 bits).\nSoit \\(\\phi(n) = (p-1)(q-1)\\).\nSoit \\(e\\) et \\(d\\) tels que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nPar définition des congruences: \\(ed = 1 + k\\phi(n)\\)\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption : \\(C = P^e \\pmod n\\). Clé publique : \\((n,e)\\).\nDécryption : \\(P = C^d \\pmod n\\). Clé privée : \\((d)\\).\nPreuve : \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique: Fonctionnement (RSA)",
    "text": "Cryptographie Asymétrique: Fonctionnement (RSA)\n\nSoit \\(n := pq\\) avec \\(p\\) et \\(q\\) deux nombres premiers grands (&gt; 1024 bits).\nSoit \\(\\phi(n) = (p-1)(q-1)\\).\nSoit \\(e\\) et \\(d\\) tels que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nPar définition des congruences: \\(ed = 1 + k\\phi(n)\\)\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption : \\(C = P^e \\pmod n\\). Clé publique : \\((n,e)\\).\nDécryption : \\(P = C^d \\pmod n\\). Clé privée : \\((d)\\).\nPreuve : \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-conclusions",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-conclusions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Conclusions",
    "text": "Cryptographie Asymétrique : Conclusions\n\nAlgorithmes dominants : RSA (le plus utilisé), Rabin, ElGamal\nServices complets :\n\nConfidentialité\nAuthentification\nIntégrité\nSignature digitale & Non-répudiation\nNon-duplication\n\nPerformances :\n\n50x plus lent que le symétrique\nSolution optimale : Combinaison asymétrique (échange de clés) + symétrique (chiffrement)\n\nGestion des clés :\n\nAvantage : Échange de clés publiques sans canal confidentiel\nRisque : Nécessité de vérifier l’authenticité des clés publiques\n\nCanal d’acquisition authentifié ou\nCertification par tiers de confiance\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAlgos : RSA (dominant), Rabin, ElGamal\nServices : Confidentialité + Authentification + Intégrité + Signatures\nLenteur : 50x vs symétrique → hybride recommandé\nClés : Échange public simple mais authentification cruciale\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique : Conclusions\n\nIl existe quelques systèmes de cryptage asymétrique (Rabin, ElGamal, etc.) mais le plus utilisé est RSA.\nServices supportés : Confidentialité, Authentification, Intégrité, Signature Digitale & Non-Refus, (Non Duplication).\nLes opérations liées à la cryptographie asymétrique sont jusqu’à 50 fois (!) plus lentes que celles de la cryptographie symétrique. Une combinaison des deux méthodes est souvent souhaitable.\nLa distribution des clés est simplifiée par le fait que seules des clés publiques doivent être échangées entre les intervenants (pas besoin d’un canal confidentiel alternatif) mais…\n… il est nécessaire de vérifier que la clé publique appartient réellement au destinataire :\n\nSoit le canal d’acquisition de la clé publique est protégé contre toute modification (authentifié)\nSoit la clé est certifiée exacte par un tiers"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-conclusions-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-conclusions-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Conclusions",
    "text": "Cryptographie Asymétrique : Conclusions\n\nIl existe quelques systèmes de cryptage asymétrique (Rabin, ElGamal, etc.) mais le plus utilisé est RSA.\nServices supportés : Confidentialité, Authentification, Intégrité, Signature Digitale & Non-Refus, (Non Duplication).\nLes opérations liées à la cryptographie asymétrique sont jusqu’à 50 fois (!) plus lentes que celles de la cryptographie symétrique. Une combinaison des deux méthodes est souvent souhaitable.\nLa distribution des clés est simplifiée par le fait que seules des clés publiques doivent être échangées entre les intervenants (pas besoin d’un canal confidentiel alternatif) mais…\n… il est nécessaire de vérifier que la clé publique appartient réellement au destinataire :\n\nSoit le canal d’acquisition de la clé publique est protégé contre toute modification (authentifié)\nSoit la clé est certifiée exacte par un tiers"
  },
  {
    "objectID": "exam_notes_fr.html#comparaison-symétrique-vs-asymétrique",
    "href": "exam_notes_fr.html#comparaison-symétrique-vs-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Comparaison Symétrique vs Asymétrique",
    "text": "Comparaison Symétrique vs Asymétrique\n\nAvantages comparés\n\nSymétrique :\n\nPerformance : 100x plus rapide\nImplémentation : Facile en hardware\nClés : Courtes (128 bits = 16 caractères mémorisables)\n\nAsymétrique :\n\nÉchange de clés : Canal authentifié suffisant (pas besoin de confidentialité)\nGestion : 1 paire de clés pour n correspondants (vs n clés en symétrique)\n\n\n\n\nProblématiques communes\n\nMaillon faible : Gestion des clés par les utilisateurs\nBase de sécurité : Empirique plutôt que théorique\nContraintes légales : Restrictions d’usage et d’exportation\n\n\n\nRecommandations d’usage\n\n\n\n\n\n\n\n\nCas d’usage\nSolution recommandée\nJustification\n\n\n\n\nDocuments personnels\nSymétrique\nVitesse + clés mémorisables\n\n\nGroupes d’utilisateurs proches\nSymétrique\nVitesse + échange confidentiel facile\n\n\nUtilisateurs distants/inconnus\nAsymétrique\nPas besoin de canal confidentiel\n\n\nTransactions distantes\nHybride (Asymétrique + Symétrique)\nAsymétrique pour l’échange de clé, symétrique pour les données\n\n\nProtection logicielle (distribution)\nHybride\nClé symétrique unique par version, encryptée avec asymétrique\n\n\nSegments réseaux\nSymétrique\nVitesse + environnement contrôlé (échange de clés facile entre administrateurs)\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nSymétrique :\n✅ Rapide (100x)\n✅ Clés courtes (128 bits)  \n❌ Échange de clés confidentiel requis\nAsymétrique :\n✅ Échange de clés simplifié\n✅ 1 paire de clés pour n correspondants\n❌ Lent (50x)\n❌ Clés longues (1024+ bits)\nHybride : Meilleur des deux mondes Problèmes communs : Gestion des clés, base empirique, restrictions légales\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nCryptographie Symétrique vs. Asymétrique\n\nIl existe des centaines d’algorithmes symétriques et asymétriques capables de fournir un niveau de confidentialité suffisant.\nLes solutions symétriques offrent les avantages suivants :\n\nRapidité (jusqu’à 100 fois plus rapide que les solutions asymétriques)\nFacilité d’implantation en hardware\nLongueur de clé réduite : 128 bits (= 16 caractères ⇒ mémorisable !) au lieu de 1024 bits pour des équivalents asymétriques.\n\nLes solutions asymétriques ont comme arguments principaux :\n\nÉchange de clés simplifié : les clés doivent être échangées par un canal authentifié mais non-confidentiel\nGestion de clés simplifiée : une seule paire de clés publique/privée suffit à un utilisateur pour recevoir des messages confidentiels de n utilisateurs (au lieu de n clés différentes dans le cas symétrique).\n\nProblèmes propres aux deux techniques :\n\nLa gestion de clés par l’utilisateur reste le maillon le plus faible\nSécurité (normalement) basée sur des arguments empiriques plutôt que théoriques\nRestrictions légales d’usage et d’exportation\n\n\n\n\nCryptographie Symétrique vs. Asymétrique (II)\n\n\n\n\n\n\n\n\nActivité\nRecommandation\nRemarques\n\n\n\n\nProtection de documents personnels\nCrypto symétrique\nVitesse, clés facilement mémorisables\n\n\nProtection de documents dans un groupe d’utilisateurs proches\nCrypto symétrique\nVitesse, facilité d’échange des clés confidentielles\n\n\nÉtablissement de canaux confidentiels entre utilisateurs distants (inconnus)\nCrypto asymétrique\nPas besoin d’avoir un canal confidentiel : authenticité suffit\n\n\nTransactions entre deux utilisateurs distants, Protection de logiciel (distribution multicast)\nCrypto asymétrique pour protection de clé symétrique + Crypto symétrique pour protection des données\nVitesse, Seule la clé symétrique doit être ré-encryptée pour chaque correspondant, Copie cryptée du logiciel peut être rendue publique\n\n\nProtection des segments réseaux\nCrypto symétrique\nVitesse, Environnement stable → échange confidentiel des clés facile entre sysadmins"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique",
    "href": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique vs. Asymétrique",
    "text": "Cryptographie Symétrique vs. Asymétrique\n\nIl existe des centaines d’algorithmes symétriques et asymétriques capables de fournir un niveau de confidentialité suffisant.\nLes solutions symétriques offrent les avantages suivants :\n\nRapidité (jusqu’à 100 fois plus rapide que les solutions asymétriques)\nFacilité d’implantation en hardware\nLongueur de clé réduite : 128 bits (= 16 caractères ⇒ mémorisable !) au lieu de 1024 bits pour des équivalents asymétriques.\n\nLes solutions asymétriques ont comme arguments principaux :\n\nÉchange de clés simplifié : les clés doivent être échangées par un canal authentifié mais non-confidentiel\nGestion de clés simplifiée : une seule paire de clés publique/privée suffit à un utilisateur pour recevoir des messages confidentiels de n utilisateurs (au lieu de n clés différentes dans le cas symétrique).\n\nProblèmes propres aux deux techniques :\n\nLa gestion de clés par l’utilisateur reste le maillon le plus faible\nSécurité (normalement) basée sur des arguments empiriques plutôt que théoriques\nRestrictions légales d’usage et d’exportation"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique-ii",
    "href": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique-ii",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique vs. Asymétrique (II)",
    "text": "Cryptographie Symétrique vs. Asymétrique (II)\n\n\n\n\n\n\n\n\nActivité\nRecommandation\nRemarques\n\n\n\n\nProtection de documents personnels\nCrypto symétrique\nVitesse, clés facilement mémorisables\n\n\nProtection de documents dans un groupe d’utilisateurs proches\nCrypto symétrique\nVitesse, facilité d’échange des clés confidentielles\n\n\nÉtablissement de canaux confidentiels entre utilisateurs distants (inconnus)\nCrypto asymétrique\nPas besoin d’avoir un canal confidentiel : authenticité suffit\n\n\nTransactions entre deux utilisateurs distants, Protection de logiciel (distribution multicast)\nCrypto asymétrique pour protection de clé symétrique + Crypto symétrique pour protection des données\nVitesse, Seule la clé symétrique doit être ré-encryptée pour chaque correspondant, Copie cryptée du logiciel peut être rendue publique\n\n\nProtection des segments réseaux\nCrypto symétrique\nVitesse, Environnement stable → échange confidentiel des clés facile entre sysadmins"
  },
  {
    "objectID": "exam_notes_fr.html#dissection-dune-attaque-ransomware",
    "href": "exam_notes_fr.html#dissection-dune-attaque-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Dissection d’une Attaque : Ransomware",
    "text": "Dissection d’une Attaque : Ransomware\n\nDéfinition et Impact\n\nDéfinition : Logiciel malveillant qui chiffre les données et exige une rançon pour leur restitution.\nLimites de la définition classique :\n\nNe couvre pas l’impact sur l’infrastructure critique (ex : Colonial Pipeline, mai 2021)\nSous-estime la portée systémique des attaques\n\nStatistiques alarmantes :\n\nMilliards d’attaques annuelles\nConsidéré comme la menace cyber la plus dangereuse en 2021 (“Ransomware Everywhere”)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nMalware : Chiffre les données → demande rançon\nImpact : Infrastructure critique (ex : Colonial Pipeline)\nMenace n°1 en cybersécurité (2021)\nCibles : Particuliers + entreprises + États\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n“Un rançongiciel (de l’anglais ransomware), logiciel rançonneur, logiciel de rançon ou logiciel d’extorsion, est un logiciel malveillant qui prend en otage des données personnelles. Pour ce faire, un rançongiciel chiffre des données personnelles puis demande à leur propriétaire d’envoyer de l’argent en échange de la clé de déchiffrement” (Wikipedia 21 septembre 2021).\n\nDéfinition incomplète car les ransomwares portent sur un vaste spectre de l’infrastructure informatique\nÀ titre d’exemple, en mai 2021, une attaque ransomware dirigée contre la société Colonial Pipeline a provoqué une coupure d’approvisionnement de combustible d’une grande partie de la côte des États-Unis\nAvec un nombre d’attaques global chiffré en milliards par année, “Ransomware Everywhere” est globalement considérée comme la menace la plus directe, visible et dangereuse pour utilisateurs et entreprises en 2021 !"
  },
  {
    "objectID": "exam_notes_fr.html#cycle-de-vie-dune-attaque-ransomware",
    "href": "exam_notes_fr.html#cycle-de-vie-dune-attaque-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cycle de Vie d’une Attaque Ransomware",
    "text": "Cycle de Vie d’une Attaque Ransomware\n\nPrévention et Réponse\n\n\n\n\n\n\n\nPhase\nMesures\n\n\n\n\nPrévention\n- Patching régulier- Solutions de détection (Firewalls, WAFs, IDS/IPS)- Scans anti-malware (e-mails, fichiers)\n\n\nProtection\n- Backups offline (essentiel !)- Politiques de sécurité strictes- Formation des utilisateurs\n\n\nRéponse\n- Ne pas payer (recommandation officielle)- Analyse forensique- Restauration depuis backups\n\n\n\n\n\nDissection Technique\n\nInfection :\n\nVecteurs : Phishing, exploits, RDP vulnérable\nPropagation : Latérale (réseau) ou verticale (système)\n\nExécution :\n\nChiffrement des fichiers ciblés\nSuppression des shadow copies\nPersistance (registre, tâches planifiées)\n\nExtorsion :\n\nAffichage de la demande de rançon\nPaiement en cryptomonnaies (Bitcoin, Monero)\nDélais de paiement avec majoration\n\nOccultation :\n\nObfuscation du code\nCommunication via TOR/Deep Web\nEffacement des logs\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nCycle d’attaque :\n\nInfection (phishing/exploits)\nExécution (chiffrement + persistance)\nExtorsion (rançon en crypto)\nOccultation (TOR + effacement traces)\n\nContre-mesures :\n✅ Backups offline\n✅ Patching + détection\n✅ Formation\n❌ Ne pas payer"
  },
  {
    "objectID": "exam_notes_fr.html#cryptolocker-analyse-technique",
    "href": "exam_notes_fr.html#cryptolocker-analyse-technique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptolocker : Analyse Technique",
    "text": "Cryptolocker : Analyse Technique\n\nSchéma d’Attaque\n\n\n\n\n\ngraph TD\n    A[Infection initiale] --&gt; B[Chiffrement des fichiers]\n    B --&gt; C[Stockage clé privée sur serveurs C2]\n    C --&gt; D[Demande de rançon]\n    D --&gt; E{Paiement ?}\n    E --&gt;|Oui| F[Envoi clé de déchiffrement via TOR]\n    E --&gt;|Non| G[Perte définitive des données]\n\n\n\n\n\n\n\n\nCibles Privilégiées\n\nExtensions critiques (extrait) :\n\nDocuments : .docx, .xlsx, .pdf, .pptx\nBases de données : .mdb, .sql, .sqlite\nMédias : .jpg, .png, .mp4, .avi\nDéveloppement : .java, .cpp, .py, .php\nFinancier : .qbw, .qbb, .wallet\n\nComportement :\n\nChiffrement sélectif (fichiers récents/modifiés)\nDouble extorsion : Chiffrement + menace de fuite\nRaaS (Ransomware-as-a-Service) : Modèle économique\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nMécanisme : - Clé privée stockée sur serveurs C2 - Paiement → clé via TOR - Cibles : 100+ extensions (docs, DB, médias)\nÉvolutions récentes : - Double extorsion (chiffrement + fuite) - RaaS (location de ransomware)\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nRansomware : Vue Intégrale\n(Source : 2017 State of Cybersecurity, F-Secure Inc.)\n\n\nRansomware : Vue Intégrale\n\nPrévision, Remédiation et Réaction\n\nPatching\nDétection active et passive (Firewalls, WAFs, IDS, IPS, e-mail malware scan, etc.)\nBackups offline !\nPolitique de Sécurité - Règles de bon usage de la messagerie\nFormation !\nPayer ou pas payer…\n\n\n\nDissection Technique de l’Attaque\n\nInfection et propagation\nExécution\nPaiement (Crypto-currencies / Bitcoin)\nOccultation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nSchéma Générique d’un Ransomware Cryptolocker\n\nLes clés privées de déchiffrement sont stockées dans les serveurs de l’attaquant\nElles sont envoyées à la victime après paiement en bitcoins\nLa trace est broyée à l’aide des réseaux TOR\n\n\n\n\nRansomware Cryptolocker : Cibles\nExtensions de fichiers ciblées : .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource : Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-vue-intégrale",
    "href": "exam_notes_fr.html#ransomware-vue-intégrale",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware : Vue Intégrale",
    "text": "Ransomware : Vue Intégrale\n(Source : 2017 State of Cybersecurity, F-Secure Inc.)"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-vue-intégrale-1",
    "href": "exam_notes_fr.html#ransomware-vue-intégrale-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware : Vue Intégrale",
    "text": "Ransomware : Vue Intégrale\n\nPrévision, Remédiation et Réaction\n\nPatching\nDétection active et passive (Firewalls, WAFs, IDS, IPS, e-mail malware scan, etc.)\nBackups offline !\nPolitique de Sécurité - Règles de bon usage de la messagerie\nFormation !\nPayer ou pas payer…\n\n\n\nDissection Technique de l’Attaque\n\nInfection et propagation\nExécution\nPaiement (Crypto-currencies / Bitcoin)\nOccultation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nSchéma Générique d’un Ransomware Cryptolocker\n\nLes clés privées de déchiffrement sont stockées dans les serveurs de l’attaquant\nElles sont envoyées à la victime après paiement en bitcoins\nLa trace est broyée à l’aide des réseaux TOR"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-cryptolocker-cibles",
    "href": "exam_notes_fr.html#ransomware-cryptolocker-cibles",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware Cryptolocker : Cibles",
    "text": "Ransomware Cryptolocker : Cibles\nExtensions de fichiers ciblées : .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource : Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_fr.html#principe-de-kerckhoffs",
    "href": "exam_notes_fr.html#principe-de-kerckhoffs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Principe de Kerckhoffs",
    "text": "Principe de Kerckhoffs\n\nPrincipe fondamental : la sécurité repose uniquement sur la clé, pas sur le secret de l’algorithme.\nLe système doit rester sûr même si l’algorithme est public.\nLa clé doit être facilement modifiable et le système simple à utiliser.\nRejet explicite de la sécurité par l’obscurité.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nSécurité basée sur la clé\nAlgorithme public\nPas de sécurité par l’obscurité\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nPrincipe de Kerckhoffs\nAuguste Kerckhoffs publie en 1883 deux articles définissant six principes pour les chiffrements militaires :\n\nLe système doit être pratiquement, voire mathématiquement indéchiffrable.\nIl ne doit pas nécessiter de confidentialité et rester sûr même s’il tombe aux mains de l’ennemi.\nLa clé doit pouvoir être mémorisée, transmise et modifiée facilement, sans notes écrites.\nLe système doit être compatible avec les communications télégraphiques.\nIl doit être portable et utilisable par une seule personne.\nIl doit être simple à utiliser, sans procédures complexes ni contraintes excessives.\n\nKerckhoffs affirme dès le XIXe siècle que la sécurité doit être mathématiquement démontrable et qu’il n’existe pas de sécurité par l’obscurité."
  },
  {
    "objectID": "exam_notes_fr.html#principe-de-kerckhoffs-1",
    "href": "exam_notes_fr.html#principe-de-kerckhoffs-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Principe de Kerckhoffs",
    "text": "Principe de Kerckhoffs\nAuguste Kerckhoffs publie en 1883 deux articles définissant six principes pour les chiffrements militaires :\n\nLe système doit être pratiquement, voire mathématiquement indéchiffrable.\nIl ne doit pas nécessiter de confidentialité et rester sûr même s’il tombe aux mains de l’ennemi.\nLa clé doit pouvoir être mémorisée, transmise et modifiée facilement, sans notes écrites.\nLe système doit être compatible avec les communications télégraphiques.\nIl doit être portable et utilisable par une seule personne.\nIl doit être simple à utiliser, sans procédures complexes ni contraintes excessives.\n\nKerckhoffs affirme dès le XIXe siècle que la sécurité doit être mathématiquement démontrable et qu’il n’existe pas de sécurité par l’obscurité."
  },
  {
    "objectID": "exam_notes_fr.html#classification-des-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#classification-des-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Classification des systèmes de cryptage",
    "text": "Classification des systèmes de cryptage\n\nSécurité inconditionnelle\n(unconditional security / perfect secrecy)\n\nSécurité indépendante de la puissance de calcul.\nCiphertext n’apporte aucune info sur le plaintext.\nConditions : clé ≥ message, jamais réutilisée.\nUsage surtout théorique.\nExemple : one-time pad.\n\n\n\nAs hard as / équivalent / provable security\n\nCryptanalyse aussi difficile qu’un problème mathématique difficile.\nRSA et Rabin prouvés équivalent à la factorisation.\n\nDémontrée par réduction (reduction proof).\n\nConcept central mais controversé.\n\n\n\nSécurité calculatoire\n(computational security / practical security)\n\nSécurité basée sur le coût irréaliste des attaques.\nCatégorie la plus utilisée en pratique.\nExemples : AES, DES, IDEA, RC4.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nInconditionnelle : parfaite, théorique (one-time pad).\nProvable security : équivalence à problème mathématique difficile.\nCalculatoire : sûre en pratique.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nSécurité inconditionnelle (unconditional security aussi appelée perfect secrecy) :\n\nLa sécurité du système de cryptage n’est pas compromise par la puissance de calcul destinée à la cryptanalyse.\nCette catégorie s’appuie sur la théorie de l’information publiée par Shannon en 1949.\nPlus précisément, un système de cryptage est inconditionnellement sûr si la probabilité de rencontrer un plaintext x après l’observation du ciphertext correspondant y est identique à la probabilité à priori de rencontrer le plaintext x.\nEn d’autres termes, le fait de disposer de couples plaintext/ciphertext (x,y) ne constitue aucune aide pour la cryptanalyse.\nUne condition nécessaire pour qu’un système soit inconditionnellement sûr est que la clé soit au moins de la même taille que le message et, surtout, qu’elle ne soit pas réutilisée pour encrypter des messages différents.\nCette condition rend ces systèmes peu adaptés aux besoins cryptographiques habituels et réduit leur domaine d’intérêt à un cadre théorique.\nL’exemple classique est le one-time pad inventé en 1917 par J. Mauborgne and G. Vernam.\nFondements théoriques des systèmes inconditionnellement sûrs + d’autres exemples dans [Sti06].\n\nAs hard as / équivalent / provable security\n\nLorsqu’on peut prouver que la cryptanalyse de l’algorithme est aussi difficile que de résoudre un problème mathématique réputé difficile.\nPar exemple la factorisation de grands nombres, le calcul de racines carrées modulo un “composite”, le calcul de logarithmes discrets dans un groupe fini, etc.\nL’algorithme de Rabin et RSA (cas générique^1 ) sont “prouvés” équivalents à la factorisation.\nUne telle preuve s’appelle de “réduction” (reduction proof).\nLa notion de provable security est à l’origine d’une importante controverse dans le monde cryptographique.\n\nSécurité calculatoire (computational security aussi appelé practical security)\n\nUn système de cryptage est dans cette catégorie si l’effort calculatoire nécessaire à le “casser” en utilisant les meilleures techniques possibles est au delà (avec une marge raisonnable) des ressources de calcul d’un adversaire hypothétique.\nLa grande majorité de systèmes de cryptage symétriques (AES, DES, IDEA, RC4, etc.) sont dans cette catégorie."
  },
  {
    "objectID": "exam_notes_fr.html#entropie",
    "href": "exam_notes_fr.html#entropie",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Entropie",
    "text": "Entropie\n\nL’entropie (Shannon, 1948) mesure la quantité d’information effective contenue dans un message.\nL’entropie conditionnelle mesure l’incertitude qui reste sur le plaintext après observation du ciphertext.\n\n\nPropriétés\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0\\) → aucune incertitude\n\\(H(X) = \\log n\\) → tous les résultats équiprobables\n\n\n\nInterprétation\n\nApproxime le nombre de bits nécessaires pour encoder \\(X\\).\nLa redondance = différence entre codage effectif et entropie.\n\n\n\nEntropie conditionnelle\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\)\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\nMesure l’incertitude restante sur le plaintext après observation du ciphertext.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nEntropie : quantité d’information d’un message.\nEntropie conditionnelle : incertitude sur le plaintext après le ciphertext.\nRedondance : différence entre codage effectif et entropie.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nUne définition essentielle en cryptographie est la quantité d’information effective contenue dans un message.\nPar exemple, les jours de la semaine (lundi, …, dimanche) peuvent intuitivement être encodés comme des chaînes de caractères de longueur (\\(\\le \\text{len}(\\text{``mercredi''})\\)), soit \\((8 \\times 8 = 64)\\) bits. Cependant, la quantité d’information effective de la variable jour de la semaine peut être encodée de manière optimale sur 3 bits (car \\((2^3 = 8)\\) est suffisant pour représenter les 7 variations possibles).\nL’entropie (Shannon, 1948) est la formalisation mathématique de cette définition.\n\n\nDéfinition formelle\nSoit \\(X\\) une variable aléatoire avec un ensemble fini de valeurs possibles \\({x_1, x_2, \\dots, x_n}\\), telles que \\(P(X=x_i) = p_i\\), avec \\(0 \\le p_i \\le 1\\) et \\(\\sum p_i = 1\\). L’entropie de \\(X\\), notée \\(H(X)\\), est définie par\n\\(H(X) = - \\sum_{i=1}^{n} p_i \\log p_i = \\sum_{i=1}^{n} p_i \\log \\left(\\frac{1}{p_i}\\right)\\)\nPar convention : \\(p_i \\log p_i = 0\\) si \\(p_i = 0\\). Tous les logarithmes sont en base 2.\n\n\nInterprétation\n\nApproximation du nombre de bits nécessaires pour encoder les éléments de \\(X\\).\nLa redondance est la différence entre le codage effectif et l’entropie.\n\n\n\nPropriétés\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0 \\iff \\exists i : p_i = 1, p_j = 0 \\ \\forall j \\ne i\\)\n\\(H(X) = \\log n \\iff p_i = 1/n \\ \\forall i\\)\n\n\n\nEntropie conditionnelle\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\),\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\n\nMesure l’incertitude sur \\(X\\) (plaintext) après avoir observé \\(Y\\) (ciphertext)."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#attaques-sur-les-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les systèmes de cryptage",
    "text": "Attaques sur les systèmes de cryptage\n\nCiphertext-only : Adversaire a seulement le ciphertext.\nKnown-plaintext : Adversaire a des couples plaintext/ciphertext.\nChosen-plaintext : Adversaire peut choisir le plaintext et voir le ciphertext (et essaye de trouver le plaintext pour d’autres messages).\nAdaptive chosen-plaintext : dépend des ciphertexts reçus.\nChosen-ciphertext : Adversaire choisit le ciphertext et obtient le plaintext (vise à trouver la clé).\nAdaptive Chosen-ciphertext : Chosen-ciphertext dépend des plaintexts reçus"
  },
  {
    "objectID": "exam_notes_fr.html#oracles-et-modèles-de-sécurité",
    "href": "exam_notes_fr.html#oracles-et-modèles-de-sécurité",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Oracles et Modèles de Sécurité",
    "text": "Oracles et Modèles de Sécurité\n\nOracles Aléatoires et Modèles de Sécurité\n\nOracle Aléatoire (Random Oracle) : Une fonction théorique “parfaite” qui renvoie une valeur uniforme et aléatoire pour chaque nouvelle entrée, mais reste déterministe pour une entrée déjà vue.\nROM (Random Oracle Model - Modèle de l’Oracle Aléatoire) : Cadre de preuve mathématique utilisant cet oracle idéal comme substitut aux fonctions de hachage.\nModèle Standard : Cadre où la sécurité repose uniquement sur la puissance de calcul de l’adversaire face à des algorithmes réels.\nLimite : Une preuve de sécurité en ROM ne garantit pas la sécurité absolue dans le monde réel (avec SHA-256, etc.).\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nUn oracle aléatoire est une entité abstraite accessible aux parties légitimes et aux adversaires.\n\nComportement : Il répond aux requêtes d’entrée \\(x\\) par des réponses parfaitement aléatoires \\(Orc(x)\\).\nDéterminisme : La seule exception réside dans les entrées précédemment traitées (\\(x_1, x_2, \\dots, x_n\\)). Si \\(x_1' = x_1\\), alors \\(Orc(x_1') = Orc(x_1)\\).\nModélisation : On le modélise par une fonction \\(Orc : X \\to Y\\) où \\(\\forall x \\in X, \\Pr(Orc(x) = y) = \\frac{1}{|Y|}\\).\nUtilité : Il se comporte comme une fonction de hachage cryptographique « idéale », outil précieux pour prouver la sécurité dans le Modèle d’Oracle Aléatoire.\nComparaison : Le modèle standard limite les adversaires par des facteurs computationnels. Un protocole sûr dans le modèle d’oracle aléatoire peut devenir vulnérable s’il est utilisé avec une fonction de hachage « réelle » (SHA-1, SHA-256).\n\n\n\n\n\n\n\nOracles de Chiffrement, Déchiffrement et Signature\n\nFonction : Entités qui exécutent des opérations (chiffrer/signer) pour l’adversaire en utilisant des clés secrètes sans jamais les révéler.\nCryptographie symétrique : L’oracle fournit \\(E_k(x)\\) ou \\(D_k(y)\\).\nCryptographie asymétrique : L’oracle est crucial pour les opérations privées (déchiffrement/signature), car les opérations publiques sont déjà libres d’accès.\n\n\n\n\n\n\n\nNoneVersion originale : Oracles Opérationnels\n\n\n\n\n\nUn oracle de chiffrement/déchiffrement/signature est une entité abstraite offrant un service « à la demande ».\n\nAccès aux clés : Il utilise les mêmes clés que les propriétaires légitimes (systèmes symétriques et asymétriques) sans les divulguer.\nPrimitives symétriques : Pour une primitive \\(E\\) et une clé \\(k\\), il renvoie \\(y = E_k(x)\\) ou le clair \\(x\\) correspondant.\nSystèmes à clé publique : L’oracle n’est nécessaire que pour les opérations à clé privée (\\(priv_k\\)).\n\nDéchiffrement : renvoie \\(x\\) tel que \\(E'_{pubk}(x) = y\\).\nSignature : Pour un système \\(S\\), il renvoie \\(y = S_{privk}(x)\\).\n\nAttaques : Les modèles d’attaques par texte clair choisi (CPA) et par texte chiffré choisi (CCA) reposent sur la mise à disposition de ces oracles pour l’adversaire.\n\n\n\n\n\n\n\nIndiscernabilité et Sécurité Sémantique (IND-CPA)\n\nPropriété : Un adversaire ne doit pas pouvoir distinguer les chiffrés de deux messages clairs différents.\nIND-CPA (Indistinguishability under Chosen Plaintext Attack - Indiscernabilité sous attaque à texte clair choisi) : Si l’adversaire ne devine le bon message qu’avec une probabilité de \\(1/2 + \\epsilon\\), le système est considéré comme sûr.\nSécurité Sémantique : Équivalente à l’IND-CPA, elle assure qu’aucune information utile ne fuite du chiffré.\n\n\n\n\n\n\n\nNoneVersion originale : Sécurité Sémantique\n\n\n\n\n\nL’indiscernabilité des textes chiffrés garantit l’incapacité de distinguer les chiffrés de messages clairs donnés.\n\nExpérience (Jeu de sécurité IND-CPA) :\n\nL’adversaire choisit deux messages \\(M_0\\) et \\(M_1\\).\nL’oracle choisit un indice aléatoire \\(i \\in \\{0,1\\}\\) et renvoie \\(c_i = E_k(M_i)\\).\nL’adversaire peut effectuer d’autres calculs ou appels oracles.\n\nDéfinition IND-CPA : Le système est sûr si l’avantage de l’adversaire est négligeable (\\(Prob = 1/2 + \\epsilon\\) avec \\(\\epsilon\\) petit).\nNote : En clé publique, l’oracle de chiffrement est inutile car l’adversaire possède déjà la clé publique. L’IND-CPA offre la sécurité sémantique.\n\n\n\n\n\n\n\nLe Chiffrement Probabiliste et l’OAEP\n\nProblème : Le chiffrement déterministe permet les attaques par dictionnaire (comparaison de chiffrés connus).\nSolution : Ajouter de l’aléa au message avant chiffrement pour que \\(E(M)\\) soit différent à chaque exécution.\nOAEP (Optimal Asymmetric Encryption Padding - Remplissage asymétrique optimal) : Standard utilisé avec RSA. Il combine le message \\(P\\) avec un nombre aléatoire \\(R\\) via des fonctions de hachage \\(h\\) et des XOR (\\(\\oplus\\)).\n\n\n\n\n\n\n\nNoneVersion originale : Déterminisme vs Probabilisme\n\n\n\n\n\nLe comportement déterministe (mêmes entrées = mêmes sorties) crée des failles.\n\nExemple : Si Alice envoie “Oui” ou “Non”, l’adversaire peut calculer \\(C_{yes} = E_{pub}(``Oui\")\\) et comparer. Il peut créer un livre de codes (dictionnaire) pour identifier les messages sans casser la clé.\nChiffrement probabiliste : Ajoute un caractère aléatoire. L’objectif est la sécurité sémantique pour la clé publique.\nOAEP : Utilisé dans RSA-PKCS1. Le texte \\(P\\) est combiné avec un aléa \\(R\\) :\n\n\\(M_1 := P \\oplus h(R)\\)\n\\(M_2 := R \\oplus h(M_1)\\)\nLe chiffrement porte sur \\(M_1\\) et \\(M_2\\). Au déchiffrement, on retrouve \\(R = M_2 \\oplus h(M_1)\\), puis \\(P = h(R) \\oplus M_1\\).\n\n\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nOracle Aléatoire : Fonction de hachage “idéale” (modèle théorique).\nOracles CPA/CCA : Simulent un accès à la clé secrète pour tester la résistance.\nIND-CPA : Impossibilité de distinguer deux chiffrés (Sécurité Sémantique).\nChiffrement Probabiliste : Indispensable pour contrer les livres de codes (attaques par dictionnaire).\nOAEP : Méthode de padding (remplissage) ajoutant l’aléa nécessaire au RSA."
  },
  {
    "objectID": "exam_notes_fr.html#histoire-de-la-cryptographie-et-sécurité-inconditionnelle",
    "href": "exam_notes_fr.html#histoire-de-la-cryptographie-et-sécurité-inconditionnelle",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Histoire de la Cryptographie et Sécurité Inconditionnelle",
    "text": "Histoire de la Cryptographie et Sécurité Inconditionnelle\n\nSystèmes de Cryptage Historiques\nLa cryptographie a longtemps été limitée à la seule recherche de la confidentialité. Les systèmes historiques reposent sur deux principes fondamentaux : la substitution et la transposition.\n\nChiffre de César (substitution mono-alphabétique) : Décalage fixe des lettres. Très vulnérable à l’analyse de fréquences.\nChiffre de Vigenère (substitution polyalphabétique) : Utilisation d’une clé pour varier le décalage. Plus complexe, mais cassable en identifiant la longueur de la clé.\nChiffre de Transposition : Réorganisation des caractères du texte original selon une permutation définie par une clé.\n\n\n\n\n\n\n\nNoneVersion originale : Cryptographie Historique\n\n\n\n\n\nPendant des siècles la confidentialité a été la seule application de la cryptographie…\n\nI av. JC, Caesar Cipher : Cryptage à substitution mono-alphabétique \\(e_k(x) = (x + k) \\pmod{26}\\), \\(d_k(y) = (y - k) \\pmod{26}\\) où \\(x, y, k \\in \\mathbb{Z}_{26}\\).\n\nExemple: \\(E_1(\\text{'bonjour'}) = \\text{'cpokpws'}\\).\nCryptanalyse : facile, basée sur la fréquence des caractères.\n\nXVI siècle, Vigenère : Cryptage à substitution polyalphabétique \\(e_k(x_1, \\dots, x_n) = (x_1 + k_1, \\dots, x_m + k_m, x_{m+1} + k_1, \\dots) \\pmod{26}\\).\n\nCryptanalyse : trouver la taille \\(m\\) de la clé en identifiant les portions de ciphertext répétées et analyser les blocs séparés comme dans le Caesar Cipher.\n\nTransposition Ciphers (Porta, 1563) : La clé définit une permutation sur le plaintext.\nCes techniques sont toujours à la base des systèmes de cryptage actuels (ex: Enigma, qualifiée par W. Churchill d’arme secrète ayant gagné la guerre).\n\n\n\n\n\n\nLe One-Time Pad (Masque Jetable)\nLe One-Time Pad (OTP), ou chiffre de Vernam, est le seul système prouvé inconditionnellement sûr (sécurité parfaite).\n\nPrincipe : Le message est combiné à une clé de même longueur via l’opération XOR (\\(\\oplus\\)).\nSécurité Inconditionnelle : L’observation du message chiffré n’apporte aucune information sur le message clair. Même un adversaire avec une puissance de calcul infinie ne peut pas le briser.\nContraintes de Shannon : La clé doit être aussi longue que le message, purement aléatoire, et utilisée une seule fois.\nRéutilisation de la clé : Si une clé est réutilisée pour deux messages, un attaquant peut éliminer la clé par XOR (\\(y_a \\oplus y_b = x_a \\oplus x_b\\)) et retrouver les messages clairs.\n\n\n\n\n\n\n\nNoneVersion originale : Le One-Time Pad\n\n\n\n\n\nSoit \\(n \\ge 1\\) et les espaces \\(P, C, K\\) tels que \\(P, C, K = (\\mathbb{Z}_2)^n\\). Les opérations d’encryption et decryption d’un one-time pad (Vernam Cipher) sont : \\(E_k(x_i) = x_i \\oplus k_i\\) et \\(D_k(y_i) = y_i \\oplus k_i\\) pour \\(1 \\le i \\le n\\).\n\nSécurité inconditionnelle : Si \\(k_i\\) sont aléatoires et indépendants, l’observation des ciphertexts n’aide pas la cryptanalyse. L’entropie de \\(X\\) ne diminue pas : \\(H(X|C) = H(X)\\).\nThéorème de Shannon : Condition nécessaire : \\(H(K) \\ge H(X)\\). La longueur de la clé aléatoire doit être au moins aussi grande que celle du plaintext.\nRéutilisation de clé : \\(y_a \\oplus y_b = x_a \\oplus x_b\\). Avec des messages de faible entropie, on retrouve les clairs et la clé (\\(k = y_a \\oplus x_a\\)).\nVulnérable à l’attaque Known Plaintext (si la clé est réutilisée).\nProblème majeur : La distribution et gestion des clés de grande taille. Relancé par la cryptographie quantique proposant des canaux confidentiels de distribution de clés de longueur illimitées.\n\n\n\n\n\n\nStéganographie\nÀ l’inverse de la cryptographie qui rend le message illisible, la stéganographie dissimule l’existence même du message.\n\nMéthode : Utiliser un “canal subliminal” (un support innocent comme une image ou un texte banal).\nTechnique moderne : Insertion de données dans les bits les moins significatifs (LSB - Least Significant Bits) de fichiers multimédias, permettant de cacher de gros volumes de données sans altération visible.\n\n\n\n\n\n\n\nNoneVersion originale : Stéganographie\n\n\n\n\n\nLa stéganographie cache un message à l’intérieur d’un autre. Éléments constituants :\n\nUn canal physique ou logique différent (canal subliminal).\nUn mécanisme secret pour identifier ce canal.\n\n\nExemples classiques : Premières lettres des mots d’un texte, encre invisible.\nExemple moderne : Utiliser les least significant bits (bits les moins significatifs) des frames d’un CD Photo.\nPour une image 2048x3072 (RGB 24 bits), cacher un message sur 1 bit permet de stocker 2.3 Mb sans détériorer la qualité.\n\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nHistorique : Substitution (César/Vigenère) et Transposition (permutation).\nOne-Time Pad : Sécurité absolue si la clé est aléatoire, unique et aussi longue que le message (\\(H(K) \\ge H(X)\\)).\nStéganographie : Cacher l’existence du message (ex: technique des LSB dans les images)."
  },
  {
    "objectID": "exam_notes_fr.html#stream-ciphers-cryptage-en-chaîne",
    "href": "exam_notes_fr.html#stream-ciphers-cryptage-en-chaîne",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Stream Ciphers (Cryptage en chaîne)",
    "text": "Stream Ciphers (Cryptage en chaîne)\n\nIntroduction aux Stream Ciphers\n\nDéfinition et Principe\nLes stream ciphers (chiffrements en flux) sont une famille de systèmes de cryptage caractérisés par :\n\nTaille de bloc unitaire : chaque bloc encrypté = 1 bit\nArchitecture en deux phases :\n\nGénération du keystream : production de la séquence de clés\nSubstitution : opération sur les bits du plaintext en fonction du keystream\n\n\nExemple classique : le one-time pad\n\nGénération : générateur (pseudo-)aléatoire\nSubstitution : opération XOR (\\(\\oplus\\)) avec le keystream\n\n\n\nCaractéristiques Générales\nAvantages :\n\nRapidité : cryptage au niveau des registres, idéal pour le streaming en temps réel (vidéo)\nLégèreté : fonctionnent sur systèmes à ressources CPU limitées\nFaible mémoire : pas ou peu de buffering nécessaire\nErreurs non propagées : retransmission des paquets défectueux suffisante (adapté aux transmissions sans fil - WiFi)\n\nInconvénients :\n\nDépendance à la qualité du keystream : le caractère aléatoire (randomness) détermine la robustesse\nRéutilisation dangereuse : la réutilisation du keystream permet une cryptanalyse facile\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nCryptage en chaîne (Stream Ciphers)\n\nLes stream ciphers constituent une famille de systèmes de cryptage où la taille du bloc encrypté est égale à 1 bit.\nLes stream ciphers sont généralement composés de deux phases:\n\nUne phase de génération de la séquence d’éléments formant la clé (le keystream).\nUne phase de substitution où les bits du plaintext subissent une opération spécifique dépendante du keystream.\n\nUn exemple évident d’un stream cipher est le one-time pad avec:\n\nUne phase de génération du keystream effectuée par un générateur (pséudo-) aléatoire.\nUne phase de substitution qui consiste à effectuer un xor (\\(\\oplus\\)) avec le keystream.\n\n\n\n\nStream Ciphers: Caractéristiques\n\nRapidité: Le cryptage se fait directement au niveau des registres. Idéal pour des applications nécessitant un cryptage “on the fly” comme le video streaming.\nFacilité: Les opérations peuvent être effectuées par des systèmes ayant des ressources CPU limitées.\nPas (ou peu…) besoin de mémoire/buffering.\nPropagation des erreurs limitée ou absente: la retransmission des paquets fautifs suffit normalement (adapté aux applications où les pertes de paquets sont fréquentes comme les transmissions sans fil (WiFi)).\nInconvénients:\n\nLa qualité en termes de randomness du keystream généré détermine la robustesse du système.\nLa réutilisation du keystream permet une cryptanalyse facile (cf. le one-time pad).\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nStream Ciphers = cryptage bit par bit en 2 phases (génération keystream + substitution).\nAvantages : rapides, légers, pas de propagation d’erreurs.\nInconvénients : qualité du keystream critique, réutilisation = vulnérabilité.\n\n\n\n\n\n\n\nStream Ciphers Synchrones\n\nPrincipe de Fonctionnement\nDans un stream cipher synchrone, le keystream dépend uniquement de la clé, indépendamment du plaintext et du ciphertext.\nÉquations du processus :\n\\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nOù :\n\n\\(\\sigma_i\\) : état à l’instant \\(i\\) (état initial \\(\\sigma_0\\) peut dépendre de \\(k\\))\n\\(k\\) : clé secrète\n\\(f\\) : fonction de transition d’état\n\\(g\\) : fonction de production du keystream \\(z_i\\)\n\\(h\\) : fonction de sortie produisant le ciphertext \\(c_i\\) à partir du plaintext \\(m_i\\)\n\n\n\n\n\n\ngraph LR\n    A[Clé k] --&gt; B[État σi]\n    B --&gt; C[Fonction f]\n    C --&gt; D[État σi+1]\n    B --&gt; E[Fonction g]\n    E --&gt; F[Keystream zi]\n    F --&gt; G[Fonction h]\n    H[Plaintext mi] --&gt; G\n    G --&gt; I[Ciphertext ci]\n    D -.-&gt;|boucle| B\n\n\n\n\n\n\n\n\nCaractéristiques\nExigence de synchronisation :\n\nÉmetteur et récepteur doivent partager la même clé \\(k\\) ET le même état \\(\\sigma_i\\)\nPerte de synchronisation = nécessité de mécanismes externes (marqueurs, analyse de redondance)\n\nPropriétés :\n\nPas de propagation d’erreur : modification du ciphertext n’affecte pas les séquences ultérieures\nAttention : suppression d’un ciphertext = désynchronisation du récepteur\n\nVulnérabilités aux attaques actives :\n\n✓ Détection : insertion, élimination, replay de fragments\n✗ Modification de bits : adversaire peut modifier des bits et analyser l’impact sur le plaintext\nSolution : mécanismes d’authentification supplémentaires nécessaires\n\n\n\nCas particulier : Stream Cipher Additif\nLe cas le plus fréquent où :\n\nFonctions \\(f\\) et \\(g\\) remplacées par un générateur aléatoire\nFonction \\(h\\) = addition modulo 2 (XOR : \\(\\oplus\\))\n\nFormule : \\(c_i = z_i \\oplus m_i\\)\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers Synchrones\n\nLe keystream généré dépend seulement de la clé et non pas du plaintext ni du ciphertext.\nLe processus d’encryption d’un stream cipher synchrone est décrit par les équations suivantes: \\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] avec \\(\\sigma_i\\) l’état initial qui peut dépendre de la clé \\(k\\), \\(f\\) la fonction qui détermine l’état suivant, \\(g\\) la fonction qui produit le keystream \\(z_i\\) et \\(h\\) la fonction de sortie qui produit le ciphertext \\(c_i\\) à partir du plaintext \\(m_i\\).\n\n\n\nStream Ciphers Synchrones: Caractéristiques\n\nNécessitent la synchronisation de l’émetteur et du récepteur: En plus d’utiliser la même clé \\(k\\), les deux doivent se trouver dans le même état pour que le processus fonctionne. Si la synchronisation est perdue il faut des mécanismes externes pour la récupérer (marqueurs spéciaux, analyses de redondance du plaintext, etc.)\nPas de propagation d’erreur. La modification du ciphertext pendant la transmission n’entraîne pas des perturbations dans des séquences de ciphertext ultérieures (cependant, la suppression d’un ciphertext provoquerait la désynchronisation du récepteur).\nAttaques actives: L’insertion, l’élimination ou le replay de parties de ciphertext sont détectés par le récepteur. Cependant, un adversaire pourrait modifier certains bits du ciphertext et analyser l’impact sur le plaintext correspondant. Des mécanismes d’authentification d’origine supplémentaires sont nécessaires afin de détecter ces attaques.\nCas les plus fréquent des Stream Cipher Synchrones: le stream cipher additif (cf. le one-time pad) où les fonctions \\(f\\) et \\(g\\) générant le keystream sont remplacées par un générateur aléatoire et la fonction \\(h\\) est une addition modulo 2 (xor).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nSynchrone : keystream = \\(f\\)(clé uniquement). Équations : \\(\\sigma_{i+1} = f(\\sigma_i, k)\\), \\(z_i = g(\\sigma_i, k)\\), \\(c_i = h(z_i, m_i)\\).\nExige synchronisation émetteur/récepteur. Pas de propagation d’erreur mais vulnérable aux modifications de bits.\nCas fréquent : cipher additif avec XOR.\n\n\n\n\n\n\n\nStream Ciphers Asynchrones\n\nPrincipe de Fonctionnement\nAussi appelés auto-synchronisés (self-synchronizing ciphers).\nLe keystream dépend de la clé ET d’un nombre fixe de ciphertexts précédents.\nÉquations du processus :\n\\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nOù \\(\\sigma_i\\) représente un buffer des \\(t\\) derniers ciphertexts.\n\n\n\n\n\ngraph LR\n    A[Clé k] --&gt; B[Fonction g]\n    C[Buffer: ci-t...ci-1] --&gt; B\n    B --&gt; D[Keystream zi]\n    D --&gt; E[Fonction h]\n    F[Plaintext mi] --&gt; E\n    E --&gt; G[Ciphertext ci]\n    G -.-&gt;|feedback| C\n\n\n\n\n\n\n\n\nCaractéristiques\nAuto-synchronisation :\n\nEn cas d’insertion/élimination de ciphertexts, le récepteur se re-synchronise automatiquement\nMécanisme : mémorisation (buffer) des derniers ciphertexts\n\nPropagation d’erreurs limitée :\n\nErreur se propage uniquement sur la taille du buffer (\\(t\\) bits)\nAprès épuisement du buffer, décryption correcte reprend\n\nSécurité face aux attaques actives :\n\nMeilleure détection : modifications détectées grâce à la propagation d’erreurs\nAttention : l’auto-synchronisation permet au récepteur de continuer même après insertions/suppressions\nSolution : vérification de l’intégrité et l’authenticité du flux entier nécessaire\n\nDiffusion des statistiques du plaintext :\n\nChaque bit du plaintext influence tous les ciphertexts subséquents\nRésultat : meilleure dispersion des statistiques vs. cas synchrone\nApplication : utiliser pour plaintexts à faible entropie ou fortement redondants\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers Asynchrones\n\nAussi appelés auto-synchronisés (self synchronizing ciphers).\nLe keystream généré dépend de la clé ainsi que d’un nombre fixé de ciphertexts précédents.\nLe processus d’encryption d’un stream cipher asynchrone est décrit par les équations suivantes: \\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] avec \\(\\sigma_i\\), \\(g\\) et \\(h\\) comme pour le cas synchrone.\n\n\n\nStream Ciphers Asynchrones: Caractéristiques\n\nAuto-synchronisation: En cas d’élimination ou d’insertion de ciphertexts en cours de route, le récepteur est capable de se re-synchroniser avec l’émetteur grâce à la mémorisation (buffer) d’un nombre de ciphertext précédents.\nPropagation d’erreurs limitée: La propagation d’erreurs s’étend uniquement au nombre de bits du ciphertext mémorisés (taille du buffer). Après, la decryption se déroule à nouveau correctement.\nAttaques actives: La modification de fragments du ciphertext sera plus facilement détecté que dans le cas synchrone à cause de la propagation d’erreurs. Cependant, comme le récepteur est capable de s’auto-synchroniser avec l’émetteur, même si des ciphertexts sont éliminés ou insérés en cours de route, il convient de vérifier l’intégrité et l’authenticité du flot entier.\nDiffusion des statistiques du plaintext: Le fait que chaque bit du plaintext aura une influence sur la totalité des ciphertexts subséquents se traduit par une plus grande dispersion des statistiques du plaintext comparée au cas synchrone…\n… Il convient, donc, d’utiliser des stream ciphers asynchrones lorsque l’entropie des plaintexts est limitée et pourrait permettre des attaques ciblées aux plaintexts fortement redondants.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nAsynchrone (auto-synchronisé) : keystream = \\(f\\)(clé + derniers ciphertexts). État \\(\\sigma_i\\) = buffer de \\(t\\) ciphertexts précédents.\nAuto-synchronisation automatique. Propagation d’erreur limitée au buffer.\nMeilleure diffusion des statistiques → idéal pour plaintexts redondants/faible entropie.\n\n\n\n\n\n\n\nGénérateurs de Keystreams : LSFR\n\nContexte et Nécessité\nProblématique : générer un keystream de longueur \\(m\\) à partir d’une clé secrète de longueur \\(l\\) avec \\(l \\ll m\\).\nSolution : Linear Feedback Shift Register (LSFR ou LFSR)\n\n\nCaractéristiques des LSFR\nAvantages :\n\nImplémentation hardware optimale : circuits très efficaces\nPériodes longues : séquences de grande longueur\nBonne qualité aléatoire : randomness notable\nBase mathématique : propriétés algébriques des combinaisons linéaires\n\nStructure générique : LSFR de longueur \\(L\\)\n\n\n\n\n\ngraph LR\n    A[bit L-1] --&gt; B[bit L-2]\n    B --&gt; C[...]\n    C --&gt; D[bit 1]\n    D --&gt; E[bit 0]\n    E --&gt; F[Output]\n    A -.-&gt;|feedback| G[⊕]\n    D -.-&gt;|coeff| G\n    C -.-&gt;|coeff| G\n    G --&gt; A\n\n\n\n\n\n\n\n\nRemarques Importantes sur les LSFR\nHistorique et Usage :\n\nConstruction très répandue en cryptographie et théorie des codes\nNombreux stream ciphers militaires basés sur LSFR\n\nLimites de Sécurité :\n\nNiveau de sécurité insuffisant comparé aux block ciphers modernes\nVulnérabilité : l’algorithme de Berlekamp-Massey permet de :\n\nDéterminer la complexité linéaire d’un LSFR\nCalculer un nombre arbitraire de séquences générées\n\n\nMétrique : Complexité linéaire (linear complexity)\nSolution d’Amélioration :\nRemplacer la combinaison linéaire par une fonction non linéaire \\(f\\)\n→ Non Linear Feedback Shift Registers (NLFSR)\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers: Générateurs de Keystreams\n\nLorsqu’il convient de générer un keystream d’une longueur \\(m\\) à partir d’une clé secrète de longueur \\(l\\) avec \\(l \\ll m\\), on fait appel à des générateurs de keystreams.\nLe plus courant de ces générateurs est le Linear Feedback Shift Register (LSFR).\nUn LSFR a les caractéristiques suivantes:\n\nS’adapte très bien aux implantations hardware.\nProduit des séquences de périodes longues et avec une qualité aléatoire notable (randomness assez forte)\nSe base sur les propriétés algébriques des combinaisons linéaires.\n\n\n\n\nLSFRs: Quelques Remarques\n\nLes LSFRs sont des constructions très répandues dans la cryptographie et dans la théorie de codes.\nUn grand nombre de stream ciphers basés sur les LSFRs (surtout dans la sphère militaire) ont été développés dans le passé.\nMalheureusement, le niveau de sécurité offert par ces systèmes est jugé insuffisant de nos jours (comparé à celui des blocks ciphers…)\nLa métrique permettant d’analyser un LFSR est sa complexité linéaire (linear complexity). L’algorithme de Berlekamp-Massey permet de déterminer la complexité linéaire d’un LSFR et de calculer ainsi un nombre arbitrairement grand de séquences générées par un LSFR.\nUne solution pour augmenter la complexité est de substituer la combinaison linéaire des bits du ciphertext par une fonction non linéaire \\(f\\). Ce sont les Non Linear Feedback Shift Registers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nLSFR : générateur de keystream long (\\(m\\)) depuis clé courte (\\(l\\)). Base = combinaisons linéaires.\nAvantages : hardware efficace, périodes longues.\nProblème : sécurité insuffisante, vulnérable à Berlekamp-Massey (calcul de complexité linéaire).\nSolution : NLFSR (fonction non linéaire).\n\n\n\n\n\n\n\nRC4 : Stream Cipher Logiciel\n\nPrésentation Générale\nRC4™ (Rivest Cipher 4) développé en 1987 par Ron Rivest pour RSA Security.\nCaractéristiques principales :\n\nClé variable : longueur flexible\nExtrêmement rapide : 10× plus rapide que DES\nMode synchrone : keystream indépendant du plaintext/ciphertext\n\nHistorique :\n\n1987-1994 : breveté, détails confidentiels (contrat NDA requis)\n1994 : publication non officielle dans un newsgroup\nDepuis : analyse intensive par la communauté cryptographique\n\n\n\nArchitecture\nComposants clés :\n\nS-box : boîte de substitution 8×8 (256 entrées)\n\nContenu : permutation des nombres 0 à 255\nDépend de la clé principale de longueur variable : \\(0 &lt; len(k) \\leq 255\\)\n\nCombinaisons : linéaires et non linéaires\nChiffrement final : XOR entre keystream et plaintext\n\n\n\nApplications et Sécurité\nUtilisations commerciales (nombreuses) :\n\nLotus Notes\nOracle SQL\nMicrosoft Windows\nSSL/TLS\nEt bien d’autres…\n\nAnalyses et Vulnérabilités :\n\nTravaux exhaustifs sur le key scheduling et le PRGA\nFaille majeure : implémentation dans WEP (WiFi Wired Equivalent Privacy)\n\nProtocole WEP complètement compromis\nProblème : mode d’utilisation défaillant, pas l’algorithme RC4 lui-même\n\n\n\n\nFonctionnement\nRC4 se décompose en deux étapes :\n\nKey Scheduling Algorithm (KSA)\n\nResponsable de la permutation initiale de la S-box\nFonction de la clé de longueur variable \\(len(k) = l\\)\n\nPseudo Random Generator Algorithm (PRGA)\n\nGénère le keystream de taille arbitraire\nS’appuie sur la S-box permutée par KSA\n\n\n\n\n\n\n\ngraph TB\n    A[Clé k de longueur variable] --&gt; B[KSA: Key Scheduling]\n    B --&gt; C[S-box permutée]\n    C --&gt; D[PRGA: Génération]\n    D --&gt; E[Keystream zi]\n    E --&gt; F[XOR]\n    G[Plaintext mi] --&gt; F\n    F --&gt; H[Ciphertext ci]\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nSoftware Cipher Streams: RC4\n\nLe grand désavantage des stream ciphers basés sur des registres est qu’ils sont très lents en version programmée dans une machine générique. RC4™ est un stream cipher à clé variable développé en 1987 par Ron Rivest pour la société RSA security. Il est très rapide (10 fois plus rapide que DES !)\nPendant 7 ans, cet algorithme était breveté et les détails son fonctionnement interne était dévoilés seulement après la signature d’un contrat de confidentialité. Depuis sa publication (non officielle) dans un newsgroup en 1994, il est globalement discuté et analysé dans toute la communauté cryptographique.\nL’algorithme travaille en mode synchrone (le keystream est indépendant du ciphertext et du plaintext).\nIl est composé de combinaisons linéaires et non linéaires. L’élément clé est une boîte de substitution (S-box) de taille 8×8 dont les entrées sont une permutation des chiffres 0 à 255. La permutation est une fonction de la clé principale de taille variable avec \\(0 &lt; len(k) \\leq 255\\). L’encryption finale est obtenue par un xor entre le keystream et le plaintext.\nRC4 est utilisé dans un grand nombre d’applications commerciales: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. Il est l’objet d’un grand nombre de travaux analytiques et exhaustifs qui ont réussi à compromettre la sécurité du key scheduling et du PRGA.\nEn particulier l’application de RC4 sur les Wired Equivalent Privacy (WiFi WEP) protocole a été “cassée” suite à une faille dans le mode d’utilisation du protocole.\n\n\n\nRC4: Fonctionnement\n\nL’algorithme est constitué de deux étapes:\n\nLe Key Scheduling Algorithm (KSA): Responsable de la permutation initiale qui remplira la S-box en fonction de la clé de longueur variable \\(len(k) = l\\).\nLe Pseudo Random Generator Algorithm (PRGA): Génère le keystream de taille arbitraire en s’appuyant sur la S-box.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nRC4 : stream cipher logiciel, clé variable, 10× plus rapide que DES.\nArchitecture : S-box 8×8 (permutation 0-255) + XOR.\n2 étapes : KSA (permutation S-box) + PRGA (génération keystream). Mode synchrone.\nVulnérabilité : WEP cassé (faille d’utilisation). Utilisé dans SSL, Windows, Oracle…"
  },
  {
    "objectID": "exam_notes_fr.html#block-ciphers-cryptage-par-blocs",
    "href": "exam_notes_fr.html#block-ciphers-cryptage-par-blocs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Block Ciphers (Cryptage par Blocs)",
    "text": "Block Ciphers (Cryptage par Blocs)\n\n1. Introduction aux Block Ciphers\n\nDéfinition et Principe\nUn block cipher (chiffrement par blocs) est une fonction cryptographique qui :\n\nTransforme des blocs de taille fixe : fait correspondre un bloc de \\(n\\) bits à un autre bloc de la même taille\nEst paramétrisée par une clé : la clé \\(K\\) de \\(k\\) bits définit la transformation\nDoit être bijective : pour permettre un décryptage unique\nChaque clé = bijection différente : garantit la variabilité\n\nTaille nominale : taille d’entrée du bloc sur lequel s’applique l’encryption\n\n\nCritères de Qualité\n1. Taille/Entropie de la clé\n\nClés idéalement équiprobables avec entropie = \\(k\\) bits\nForte entropie protège contre les attaques brute-force\nMinimum requis : 128 bits pour les block ciphers modernes\n\n2. Performances\n\nVitesse d’exécution\nEfficacité en software/hardware\n\n3. Taille du bloc\n\nBloc trop petit = vulnérabilité aux dictionnaires plaintext/ciphertext\nStandard moderne : blocs ≥ 128 bits\n\n4. Résistance cryptographique\n\nRésistance aux techniques connues :\n\nCryptanalyse linéaire\nCryptanalyse différentielle\nMeet in the middle\n\nEffort de cryptanalyse équivalent au brute force\n\n\n\n\n\n\ngraph LR\n    A[Plaintext n bits] --&gt; B[Block Cipher]\n    C[Clé K k bits] --&gt; B\n    B --&gt; D[Ciphertext n bits]\n    \n    style B fill:#e1f5ff\n    style C fill:#fff4e1\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\nCryptage par Blocs (Block Ciphers)\n\nLes block ciphers symétriques constituent la pierre angulaire de la cryptographie. Leur fonctionnalité principale est la confidentialité mais ils sont également à la base des services d’authentification, fonctions de hachage, génération aléatoire, etc.\nDéfinition: Un block cipher est une fonction qui fait correspondre à un bloc de \\(n\\) bits un autre bloc de la même taille. La fonction est paramètrée par une clé \\(K\\) de \\(k\\) bits. Afin de permettre une decryption unique, la fonction doit être bijective. Chaque clé définit une bijection différente. La taille d’entrée du bloc sur lequel s’applique l’encryption s’appelle aussi taille nominale de l’algorithme.\nCritères pour évaluer la qualité d’un block cipher:\n\nTaille/Entropie de la clé: Idéalement, les clés sont équiprobables et l’espace des clés a une entropie égale à \\(k\\). Une forte entropie de la clé protège des attaques brute-force à partir de chosen/known plaintexts. Les block ciphers modernes doivent avoir des clés d’au moins 128 bits.\nPerformances\nTaille du bloc: Un bloc trop petit permettrait des attaques où des “dictionnaires” plaintext/ciphertext seraient construits. De nos jours, des blocs de taille ≥ 128 bits deviennent courants.\nRésistance cryptographique: Le block cipher doit se montrer résistant à des techniques de cryptanalyse connues: cryptanalyse linéaire ou différentielle, meet in the middle, etc. L’effort inhérent à ces attaques (complexité, stockage, parallélisation, etc.) doit être équivalent à celui d’une attaque brute force.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nBlock cipher : fonction bijective transformant blocs de \\(n\\) bits avec clé \\(K\\) de \\(k\\) bits. Critères : entropie clé ≥ 128 bits, taille bloc ≥ 128 bits, résistance cryptanalyse = effort brute force. Usage : confidentialité, authentification, hachage, génération aléatoire.\n\n\n\n\n\n\n\n2. Modes d’Opération des Block Ciphers\n\n2.1 Electronic Codebook (ECB)\nPrincipe : chaque bloc de plaintext est encrypté indépendamment avec la même clé.\n\\[c_i = E_K(m_i)\\] \\[m_i = D_K(c_i)\\]\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        P1[Plaintext Block 1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext Block 1]\n        \n        P2[Plaintext Block 2] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext Block 2]\n    end\n    \n    style E1 fill:#ffcccc\n    style E2 fill:#ffcccc\n    style K1 fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\nCaractéristiques :\n\n✗ Plaintexts identiques → ciphertexts identiques (prévisible)\n✓ Pas de propagation d’erreurs : erreur sur \\(c_j\\) n’affecte que \\(m_j\\)\n✗ Patterns visibles : structure du plaintext transparente dans le ciphertext\n✓ Parallélisable : chaque bloc traité indépendamment\n\n⚠️ Vulnérabilité majeure : Ne doit PAS être utilisé pour des données redondantes\n\n\n\n2.2 Cipher Block Chaining (CBC)\nPrincipe : chaque bloc de plaintext est XORé avec le ciphertext précédent avant encryption.\n\\[c_i = E_K(m_i \\oplus c_{i-1})\\] \\[m_i = D_K(c_i) \\oplus c_{i-1}\\]\nAvec \\(c_0 = IV\\) (Initialization Vector)\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        IV[IV] --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext c1]\n        \n        C1 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ccffcc\n    style E2 fill:#ccffcc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Patterns effacés : chaînage masque la structure\n✓ Propagation d’erreurs limitée : erreur sur \\(c_j\\) affecte \\(m_j\\) et \\(m_{j+1}\\) uniquement\n✗ Non parallélisable en encryption (séquentiel)\n✓ Parallélisable en décryption\n\nIV (Initialization Vector) :\n\nDoit être aléatoire ou pseudo-aléatoire\nPeut être transmis en clair\nDoit être différent pour chaque message avec la même clé\n\n\n\n\n2.3 Cipher Feedback Mode (CFB)\nPrincipe : fonctionne comme un stream cipher où le keystream est généré par le block cipher. Le keystream dépend des ciphertexts précédents (mode asynchrone).\n\\[c_i = m_i \\oplus E_K(c_{i-1})\\] \\[m_i = c_i \\oplus E_K(c_{i-1})\\]\nAvec \\(c_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph CFB_Encryption\n        IV[IV / ci-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        C1 -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#ffccff\n    style X1 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Chaînage : dépendances entre ciphertexts\n⚠️ Propagation d’erreurs : erreur sur \\(c_j\\) affecte \\(\\frac{n}{r}\\) blocs suivants\n\n\\(n\\) = taille nominale du block cipher\n\\(r\\) = taille des plaintexts\n\n✗ Non parallélisable\n⚠️ IV non confidentiel mais doit être transmis\n\nUsage : adapté aux transmissions avec pertes de paquets fréquentes\n\n\n\n2.4 Output Feedback Mode (OFB)\nPrincipe : fonctionne comme un stream cipher synchrone. Le keystream est entièrement déterminé par la clé et l’IV, indépendant du plaintext et du ciphertext.\n\\[z_i = E_K(z_{i-1})\\] \\[c_i = m_i \\oplus z_i\\] \\[m_i = c_i \\oplus z_i\\]\nAvec \\(z_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph OFB_Mode\n        IV[IV / zi-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; Z[zi keystream]\n        Z --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        Z -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#cce5ff\n    style X1 fill:#ffffcc\n    style Z fill:#e1ffe1\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Pas de propagation d’erreurs : erreur sur \\(c_j\\) n’affecte que \\(m_j\\)\n✓ Keystream pré-calculable : efficace\n⚠️ CRITIQUE : ne JAMAIS réutiliser le même IV avec la même clé (sinon keystream identique)\n✓ Parallélisable si keystream pré-calculé\n\n⚠️ Attention réutilisation : Modifier l’IV pour chaque nouveau message !\n\n\n\n\n\n\nNote📄 Texte original (Modes CFB et OFB)\n\n\n\n\n\nModes CFB et OFB: Caractéristiques\nLes modes CFB et OFB fonctionnent comme un stream cipher avec un keystream généré par le bloc de cryptage. Dans CFB, le keystream dépend des ciphertexts précédents (asynchrone) alors que dans OFB, le keystream est entièrement déterminé par la clé et le IV (synchrone).\nParticularités de CFB:\n\nComme dans le mode CBC, des plaintext identiques sont traduits en ciphertexts différents si le IV change. Le IV n’est pas nécessairement confidentiel et peut être échangé en clair entre les parties.\nLe chaînage introduit également des dépendances entre les ciphertexts courants et les ciphertexts précédents. En particulier, si \\(n\\) est la taille nominale de l’algorithme et \\(r\\) est la taille des plaintexts, le ciphertext courant dépendra des \\(\\frac{n}{r}\\) ciphertexts précédents (chaque itération décalera l’entrée fautive de \\(r\\) positions, après \\(\\frac{n}{r}\\) itérations le ciphertext fautif sera “expulsé” complètement).\nLa propagation d’erreurs obéit au même principe: une erreur dans un ciphertext se traduira par une mauvaise decryption des \\(\\frac{n}{r}\\) ciphertexts suivants.\n\nParticularités de OFB:\n\nOFB a un comportement identique aux modes CBC et CFB pour l’encryption de plaintext identiques.\nPas de propagation d’erreurs sur les ciphertexts adjacents.\nModifiez le IV si la clé ne change pas pour éviter la réutilisation du keystream !!!\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Modes CFB/OFB)\n\n\n\n\n\nCFB (asynchrone) : keystream = \\(f\\)(ciphertexts précédents). Propagation erreur limitée (\\(\\frac{n}{r}\\) blocs).\nOFB (synchrone) : keystream = \\(f\\)(clé + IV uniquement). Pas propagation erreur.\nCRITIQUE : ne JAMAIS réutiliser même IV avec même clé. IV transmissible en clair.\n\n\n\n\n\n\n2.5 Counter Mode (CTR)\nPrincipe : le keystream est généré par l’encryption d’un compteur incrémenté à chaque bloc.\n\\[c_i = m_i \\oplus E_K(counter + i)\\] \\[m_i = c_i \\oplus E_K(counter + i)\\]\n\n\n\n\n\ngraph TB\n    subgraph CTR_Mode\n        CTR1[Counter + 0] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; C1[Ciphertext c1]\n        \n        CTR2[Counter + 1] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ffe6cc\n    style E2 fill:#ffe6cc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Mode synchrone : keystream = \\(f\\)(compteur)\n✓ Parallélisable : keystream pré-calculable pour encryption ET décryption\n✓ Accès aléatoire : chaque bloc décryptable indépendamment\n✓ Pas de propagation d’erreurs\n✓ Profite des architectures SIMD : pas de dépendances entre blocs\n⚠️ Compteur : doit être de taille \\(2^b\\) (\\(b\\) = taille du bloc)\n⚠️ CRITIQUE : ne JAMAIS réutiliser le même compteur avec la même clé\n\nGestion du compteur :\n\nIncrémenter modulo \\(2^b\\) après chaque itération\nSolution : toujours incrémenter pour chaque flux encrypté\nPremier bloc du flux \\(i+1\\) &gt; dernier bloc du flux \\(i\\)\n\nApplications :\n\nATM (Asynchronous Transfer Mode)\nIPsec (IP security)\nLignes à haut débit : transmission sélective des blocs\nTransferts de grands volumes : vidéo\n\n\n\n\n\n\n\nNote📄 Texte original (Counter Mode)\n\n\n\n\n\n\nCounter Mode (CTR Mode)\nFréquemment utilisé comme support d’encryption dans des protocoles de transfert de données comme ATM (Asynchronous Transfer Mode) et IPsec (IP security).\n\n\nCounter Mode (II)\n\nLe keystream est généré par l’encryption d’un compteur aléatoire de taille \\(2^b\\) (avec \\(b\\) la taille du bloc) et nécessaire pour la décryption. Ce compteur est incrémenté modulo \\(2^b\\) après chaque itération.\nTravaille en mode synchrone. La réutilisation d’un même compteur se traduit par un keystream identique !\nSolution: Toujours incrémenter le compteur pour chaque flot encrypté de telle sorte que le compteur du premier bloc d’un flot soit plus grand que le dernier bloc du flot précédent.\nFacilement parallélisable: Le keystream peut être pré-calculé aussi bien pour l’encryption que pour la décryption. Profite pleinement des architectures SIMD car contrairement aux autres modes de chaînage il n’y a pas des dépendances entre les opérations des différents blocs.\nAccès aléatoire à l’encryption/décryption de chaque bloc: Contrairement aux autres modes de chaînage où la \\(i\\)-ème opération dépend de la \\((i-1)\\)-ème opération.\nSi à ceci on ajoute l’absence de propagation d’erreurs, le mode compteur facilite la (re)transmission sélective des blocs de ciphertext, ce qui le rend très attractif pour la sécurisation de lignes à haut débit ainsi que pour les transferts encryptés de grands volumes d’information (p.ex. vidéo).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Counter Mode)\n\n\n\n\n\nCTR : keystream = \\(E_K\\)(compteur + \\(i\\)).\nAvantages : parallélisable (encryption + décryption), accès aléatoire, pas propagation erreur, SIMD-friendly.\nCRITIQUE : ne jamais réutiliser compteur.\nUsage : ATM, IPsec, haut débit, vidéo.\n\n\n\n\n\n\n\n3. Product Ciphers et Feistel Ciphers\n\nProduct Ciphers\nDéfinition : schéma de cryptage combinant une série de transformations successives pour renforcer la résistance à la cryptanalyse.\nTransformations courantes :\n\nTranspositions (permutations)\nSubstitutions (S-boxes)\nXORs\nCombinaisons linéaires\nMultiplications modulaires\n\n\n\nFeistel Ciphers\nDéfinition : product cipher itératif avec structure spécifique.\nPrincipe de fonctionnement :\n\nEntrée : plaintext de \\(2t\\) bits = \\((L_0, R_0)\\) (deux sous-blocs de \\(t\\) bits)\nSortie : ciphertext de \\(2t\\) bits = \\((R_r, L_r)\\) après \\(r\\) étapes (rounds)\nChaque étape : bijection inversible (pour décryption unique)\n\nÉquations d’une étape \\(i\\) (\\(1 \\leq i \\leq r\\)) :\n\\[(L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\]\nAvec :\n\n\\(L_i = R_{i-1}\\)\n\\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph Feistel_Round\n        L0[Li-1] --&gt; R1[Ri = Li-1 ⊕ f]\n        R0[Ri-1] --&gt; L1[Li = Ri-1]\n        R0 --&gt; F[Function f]\n        K[Key Ki] --&gt; F\n        F --&gt; XOR[⊕]\n        L0 --&gt; XOR\n        XOR --&gt; R1\n    end\n    \n    style F fill:#ffcccc\n    style XOR fill:#ffffcc\n    style K fill:#fff4e1\n\n\n\n\n\n\nCaractéristiques :\n\n\\(K_i\\) : sous-clés générées à partir de la clé principale \\(K\\)\nNombre d’étapes \\(r\\) : généralement pair et \\(\\geq 3\\)\n\nExemple : DES a 16 étapes\n\nPermutation finale : \\((L_r, R_r) \\rightarrow (R_r, L_r)\\)\nDécryption : identique à l’encryption mais sous-clés appliquées en ordre inverse (de \\(K_r\\) à \\(K_1\\))\n\nOpérations fréquentes :\n\nPermutations\nSubstitutions (S-boxes)\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\nProduct Ciphers et Feistel Ciphers\n\nUn product cipher est un schéma de cryptage combinant une série de transformations successives dans le but de renforcer la résistance à la cryptanalyse. Des transformations courantes pour un product cipher sont: des transpositions, des substitutions, des XORs, des combinaisons linéaires, des multiplications modulaires, etc.\nUn Feistel cipher est un product cipher itératif capable de transformer un plaintext de \\(2t\\) bits de la forme \\((L_0, R_0)\\) composé par deux sous-blocs \\(L_0\\) et \\(R_0\\) de \\(t\\) bits en un ciphertext de taille \\(2t\\) de la forme \\((R_r, L_r)\\) après \\(r\\) étapes (rounds) successives avec \\(r \\geq 1\\). Chaque étape définit une bijection (inversible !) pour permettre une decryption unique.\nDes permutations et des substitutions sont les opérations les plus fréquentes.\nLes étapes \\(1 \\leq i \\leq r\\) s’écrivent: \\((L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\) avec \\(L_i = R_{i-1}\\) et \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\). Les \\(K_i\\) sont des sous-clés, différentes pour chaque étape, générées à partir de la clé principale \\(K\\) du schéma de cryptage.\nLe nombre d’étapes propres à un Feistel cipher est normalement pair et \\(\\geq 3\\) (p.ex. DES a 16 étapes)\nAprès l’exécution de toutes les étapes, un Feistel cipher effectue une permutation des deux parties \\((L_r, R_r)\\) en \\((R_r, L_r)\\).\nLa decryption d’un Feistel Cipher est identique à l’encryption sauf que les sous-clés \\(K_i\\) sont appliquées en ordre inverse (De \\(K_r\\) à \\(K_1\\)).\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nProduct cipher : combinaison de transformations successives (transpositions, substitutions, XOR).\nFeistel cipher :\n\nproduct cipher itératif\nplaintext \\(2t\\) bits = \\((L_0, R_0)\\)\n\\(r\\) rounds avec \\(L_i = R_{i-1}\\) et \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\).\nDécryption = encryption avec sous-clés inversées.\nExemple : DES (16 rounds).\n\n\n\n\n\n\n\n\n4. Data Encryption Standard (DES)\n\nPrésentation Générale\nDES (Data Encryption Standard) : algorithme cryptographique le plus important jusqu’à l’avènement d’AES en 2001.\nCaractéristiques principales :\n\nType : Feistel Cipher\nTaille des blocs : 64 bits (taille nominale)\nTaille de la clé : 56 bits effectifs (64 bits totaux avec 8 bits de parité)\nNombre d’étapes : 16 rounds\nSous-clés : 16 sous-clés de 48 bits (une par étape)\nModes d’utilisation : ECB, CBC, CFB, OFB\n\n\n\n\n\n\ngraph TB\n    subgraph DES_Overview\n        P[Plaintext 64 bits] --&gt; DES[DES Encryption]\n        K[Key 56 bits] --&gt; DES\n        DES --&gt; C[Ciphertext 64 bits]\n        \n        C --&gt; DES_INV[DES Decryption]\n        K2[Key 56 bits] --&gt; DES_INV\n        DES_INV --&gt; P2[Plaintext 64 bits]\n    end\n    \n    style DES fill:#ffcccc\n    style DES_INV fill:#ccffcc\n    style K fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\n\n\nStructure de DES\nComposants principaux :\n\nPermutation initiale (IP) : permutation des 64 bits d’entrée\n16 rounds Feistel : transformation itérative\nPermutation finale (IP⁻¹) : inverse de IP\n\nChaque round applique :\n\nDivision en deux moitiés : \\(L_{i-1}\\) et \\(R_{i-1}\\) (32 bits chacune)\nFonction \\(f\\) sur \\(R_{i-1}\\) avec sous-clé \\(K_i\\)\nXOR avec \\(L_{i-1}\\)\nÉchange des moitiés\n\n\n\n\n\n\ngraph TB\n    Plain[Plaintext 64 bits] --&gt; IP[Initial Permutation IP]\n    IP --&gt; Split[Split L0, R0]\n    \n    Split --&gt; Round1[Round 1]\n    K1[K1] --&gt; Round1\n    Round1 --&gt; Round2[Round 2]\n    K2[K2] --&gt; Round2\n    Round2 --&gt; Dots[...]\n    Dots --&gt; Round16[Round 16]\n    K16[K16] --&gt; Round16\n    \n    Round16 --&gt; Swap[Swap R16, L16]\n    Swap --&gt; IP_inv[Final Permutation IP⁻¹]\n    IP_inv --&gt; Cipher[Ciphertext 64 bits]\n    \n    style IP fill:#e1f5ff\n    style IP_inv fill:#e1f5ff\n    style Round1 fill:#ffcccc\n    style Round2 fill:#ffcccc\n    style Round16 fill:#ffcccc\n\n\n\n\n\n\n\n\nFonction Cipher de DES\nLa fonction \\(f\\) pour chaque round :\n\nExpansion E : 32 bits → 48 bits (table E)\nKey Addition : XOR avec sous-clé \\(K_i\\) (48 bits)\nS-boxes : 8 S-boxes transforment 48 bits → 32 bits\n\nChaque S-box : 6 bits entrée → 4 bits sortie\n\nPermutation P : permutation des 32 bits résultants\n\n\n\n\n\n\ngraph TB\n    R[Ri-1 32 bits] --&gt; E[Expansion E]\n    E --&gt; E_out[48 bits]\n    E_out --&gt; XOR1[⊕]\n    K[Ki 48 bits] --&gt; XOR1\n    XOR1 --&gt; S[8 S-boxes]\n    S --&gt; S_out[32 bits]\n    S_out --&gt; P[Permutation P]\n    P --&gt; F_out[f output 32 bits]\n    \n    style E fill:#cce5ff\n    style S fill:#ffcccc\n    style P fill:#e1ffe1\n    style XOR1 fill:#ffffcc\n\n\n\n\n\n\nFonctionnement des S-boxes :\nEntrée : \\(a_1a_2a_3a_4a_5a_6\\) (6 bits)\n\nLigne : \\(a_1 + 2a_6\\) (bits externes)\nColonne : \\(a_2 + 2a_3 + 4a_4 + 8a_5\\) (bits internes)\nSortie : valeur de la cellule correspondante (4 bits)\n\n\n\nGénération des Sous-clés\nProcessus :\n\nClé principale : 64 bits (56 effectifs + 8 parité)\nPermuted Choice 1 (PC-1) : sélection de 56 bits\nDivision en deux moitiés : \\(C_0\\) et \\(D_0\\) (28 bits chacune)\nPour chaque round \\(i\\) :\n\nRotation circulaire gauche de \\(C_{i-1}\\) et \\(D_{i-1}\\)\nPermuted Choice 2 (PC-2) : sélection de 48 bits pour \\(K_i\\)\n\n\nRotations :\n\nRounds 1, 2, 9, 16 : 1 position\nAutres rounds : 2 positions\n\n\n\n\n\n\n\nNote📄 Texte original (DES Fonctionnement)\n\n\n\n\n\nDES: Fonctionnement\nCipher Fonction\n\nExpansion E: Les 32 bits de l’entrée sont transformés en un vecteur de 48 bits en utilisant la table E. La première ligne de cette table indique comment sera généré le premier sous-bloc de 6 bits: on prendra en premier le 32e bit et après les bits 1,2,3,4,5. Le deuxième sous-bloc commence par le 4e bit ensuite les bits 5,6,7,8,9 et ainsi de suite…\nKey addition: XOR du vecteur de 48 bits avec la clé.\nS-boxes: On applique 8 S-boxes sur le vecteur de 48 bits résultant du XOR précédent. Chacune de ces S-boxes prend un sous-bloc de 6 bits et le transforme en un sous-bloc de 4 bits. L’opération s’effectue de la manière suivante: Si on dénote les 6 bits d’input de la S-box comme: \\(a_1a_2a_3a_4a_5a_6\\). La sortie est donnée par le contenu de la cellule située dans la ligne \\(a_1 + 2a_6\\) et la colonne \\(a_2 + 2a_3 + 4a_4 + 8a_5\\).\nPermutation P: La permutation P fonctionne comme suit: Le premier bit est envoyé à la 16e position, le deuxième à la 7e position et ainsi de suite.\n\nPermutations IP et IP⁻¹\n\nAgissent respectivement au début et à la fin du traitement du bloc et sur l’ensemble des 64 bits.\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (DES)\n\n\n\n\n\nDES : Feistel cipher, 64 bits blocs, 56 bits clé effective, 16 rounds.\nFonction \\(f\\) : Expansion E (32→48 bits) → XOR \\(K_i\\) → 8 S-boxes (48→32 bits) → Permutation P.\nS-box : 6 bits input → 4 bits output via table (ligne = bits externes, colonne = bits internes).\nPermutations : IP (initiale) et IP⁻¹ (finale) sur 64 bits.\n\n\n\n\n\n\n\n5. Triple-DES et Sécurité de DES\n\nVulnérabilités de DES\nProblème principal : taille de l’espace de clés \\(\\{0,1\\}^{56}\\) insuffisante.\nAttaque brute force :\n\n1999 : clé trouvée en 24 heures\nTechnique : brute force massivement parallèle (100’000 PCs sur Internet)\nKnown plaintext attack\n\n\n\nTriple-DES (3DES)\nSolution : augmenter l’espace des clés à \\(\\{0,1\\}^{112}\\).\nSchéma :\n\\[C = E_{K_1}(D_{K_2}(E_{K_1}(P)))\\]\nAvec :\n\n\\(E\\) : encryption DES\n\\(D\\) : décryption DES\n\\(K_1, K_2\\) : deux clés de 56 bits\n\n\n\n\n\n\ngraph LR\n    P[Plaintext 64 bits] --&gt; E1[DES Encrypt K1]\n    E1 --&gt; D[DES Decrypt K2]\n    D --&gt; E2[DES Encrypt K1]\n    E2 --&gt; C[Ciphertext 64 bits]\n    \n    K1a[Key K1 56 bits] --&gt; E1\n    K2[Key K2 56 bits] --&gt; D\n    K1b[Key K1 56 bits] --&gt; E2\n    \n    style E1 fill:#ffcccc\n    style D fill:#ccffcc\n    style E2 fill:#ffcccc\n\n\n\n\n\n\nAvantages :\n\n✓ Sécurité satisfaisante : espace de clés \\(2^{112}\\)\n✓ Compatibilité : réutilisation du hardware/software DES existant\n✓ Migration progressive : en attendant AES\n\nInconvénient :\n\n✗ Performances : 3× plus lent (3 exécutions DES successives)\n\n\n\nPropriétés de DES\n1. DES n’est pas un groupe\nDES n’est PAS un groupe pour la composition :\n\\[\\nexists K_3 \\text{ tel que } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)\\]\nConséquence : encryption composée (Triple-DES) augmente considérablement la sécurité.\nSi DES était un groupe : recherche exhaustive sur \\(\\{0,1\\}^{56}\\) casserait l’algorithme indépendamment du nombre d’exécutions consécutives.\n2. Clés faibles et semi-faibles\n\nClé faible : \\(E_K(E_K(x)) = x\\)\nPaire de clés semi-faibles : \\(E_{K_1}(E_{K_2}(x)) = x\\)\n\nCaractéristique : clés faibles génèrent des sous-clés identiques par paires :\n\n\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)\nFacilite la cryptanalyse\n\nDES a 4 clés faibles :\n\n\n\nClé faible (hexadécimal)\n\n\n\n\n0101 0101 0101 0101\n\n\n0101 0101 FEFE FEFE\n\n\nFEFE FEFE FEFE FEFE\n\n\nFEFE FEFE 0101 0101\n\n\n\nEt 6 paires de clés semi-faibles\n\n\n\n\n\n\nNote📄 Texte original (DES et 3DES)\n\n\n\n\n\n\nDES et Triple-DES\n\nLa taille de l’ensemble de clés (\\(\\{0,1\\}^{56}\\)) constitue la plus grande menace qui pèse sur DES avec les ressources de calcul actuels. En 1999 il a suffit de 24 heures pour trouver la clé à partir d’un known plaintext en utilisant une technique brute force massivement parallèle (100’000 PCs connectés sur Internet).\nTriple DES nous met à l’abri de ces attaques brute force en augmentant l’espace des clés possibles à \\(\\{0,1\\}^{112}\\).\nCette alternative permet de continuer à utiliser les “boîtes” DES (hardware et software) en attendant une migration vers AES.\nLe niveau de sécurité obtenu par cette solution est très satisfaisant.\nL’impact en termes de performances de trois exécutions successives de DES reste un inconvénient pour certaines applications.\n\n\n\nDES: propriétés\n\nDES n’est pas un groupe (au sens algébrique) avec la composition: En d’autres termes, DES étant une permutation: \\(\\{0,1\\}^{64} \\rightarrow \\{0,1\\}^{64}\\), si DES était un groupe pour la composition, ceci voudrait dire que: \\(\\exists K_3\\) t.q. \\(E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)\\)\nCette propriété permet d’assurer que l’encryption composée (comme Triple-DES) augmente considérablement la sécurité de DES. Si DES était un groupe, la recherche exhaustive sur l’ensemble de clés possibles (\\(\\{0,1\\}^{56}\\)) permettrait de “casser” l’algorithme indépendamment du nombre d’exécutions consécutives de DES.\nClés faibles et mi-faibles (weak and semi-weak keys):\n\nUne clé \\(K\\) est dite faible si \\(E_K(E_K(x)) = x\\).\nUne paire de clés \\((K_1, K_2)\\) est dite mi-faible si \\(E_{K_1}(E_{K_2}(x)) = x\\).\n\nLes clés faibles ont la particularité de générer de sous-clés identiques par paires (\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)), ce qui facilite la cryptanalyse.\nDES a 4 clés faibles (et 6 paires de clés mi-faibles).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (3DES et sécurité)\n\n\n\n\n\nVulnérabilité DES : espace clés \\(2^{56}\\) cassable en 24h (1999). Triple-DES : \\(E_{K_1}(D_{K_2}(E_{K_1}(P)))\\), espace \\(2^{112}\\), réutilise hardware DES, 3× plus lent. DES ≠ groupe → encryption composée renforce sécurité. 4 clés faibles générant sous-clés identiques par paires → facilite cryptanalyse.\n\n\n\n\n\n\n\n6. Advanced Encryption Standard (AES)\n\nPrésentation Générale\nAES (Advanced Encryption Standard) : standard adopté en novembre 2001.\nConception : Johan Daemen et Vincent Rijmen (nom original : Rijndael)\nCaractéristiques principales :\n\nType : block cipher itératif (mais PAS un Feistel Cipher)\nTaille des blocs : 128 bits\nTaille de clé variable : 128, 192 ou 256 bits\nNombre de rounds : dépend de la taille de clé\n\n10 rounds pour clé 128 bits\n12 rounds pour clé 192 bits\n14 rounds pour clé 256 bits\n\nModes d’utilisation : ECB, CBC, CFB, OFB, CTR\n\nAvantages par rapport à DES :\n\n✓ Processus ouvert : consultation et analyse par experts mondiaux\n✓ ~2× plus performant en software\n✓ ~10²² fois plus sûr (théoriquement)\n✓ Évolutif : taille de clé augmentable si nécessaire\n\n\n\nStructure d’AES\nUnité de base : matrice State de 4 lignes × 4 colonnes (pour clé 128 bits)\n\nChaque élément = 1 byte\nTotal : 16 bytes = 128 bits\n\nOpérations sur le corps \\(GF(2^8)\\) :\n\nByte = élément de \\(GF(2^8)\\)\nCorps fini de polynômes de degré ≤ 7 avec coefficients dans \\(GF(2)\\)\nAdditions, multiplications définies dans \\(GF(2^8)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph State_Matrix\n        S00[s0,0] --- S01[s0,1]\n        S01 --- S02[s0,2]\n        S02 --- S03[s0,3]\n        \n        S10[s1,0] --- S11[s1,1]\n        S11 --- S12[s1,2]\n        S12 --- S13[s1,3]\n        \n        S20[s2,0] --- S21[s2,1]\n        S21 --- S22[s2,2]\n        S22 --- S23[s2,3]\n        \n        S30[s3,0] --- S31[s3,1]\n        S31 --- S32[s3,2]\n        S32 --- S33[s3,3]\n    end\n    \n    style S00 fill:#ffe6cc\n    style S11 fill:#ffe6cc\n    style S22 fill:#ffe6cc\n    style S33 fill:#ffe6cc\n\n\n\n\n\n\n\n\nDétail d’un Round AES\nQuatre opérations par round :\n1. SubBytes (ByteSub)\n\nSubstitution non linéaire via S-box\nChaque byte transformé indépendamment\nRésistance à la cryptanalyse linéaire et différentielle\n\n2. ShiftRows\n\nPermutation des bytes avec décalages variables par ligne\nLigne 0 : pas de décalage\nLigne 1 : décalage gauche 1 position\nLigne 2 : décalage gauche 2 positions\nLigne 3 : décalage gauche 3 positions\n\n3. MixColumns\n\nChaque colonne = combinaison linéaire des autres colonnes\nMultiplication de matrices dans \\(GF(2^8)\\)\nDiffusion maximale\n\n4. AddRoundKey\n\nXOR de la matrice State avec la sous-clé du round\nSous-clé = résultat du Key Schedule\n\n\n\n\n\n\ngraph TB\n    Input[State Input] --&gt; SB[SubBytes]\n    SB --&gt; SR[ShiftRows]\n    SR --&gt; MC[MixColumns]\n    MC --&gt; ARK[AddRoundKey]\n    K[Round Key] --&gt; ARK\n    ARK --&gt; Output[State Output]\n    \n    style SB fill:#ffcccc\n    style SR fill:#ccffcc\n    style MC fill:#cce5ff\n    style ARK fill:#ffffcc\n\n\n\n\n\n\nRound final : identique SAUF pas de MixColumns\n\n\nKey Schedule (Génération des Sous-clés)\nProcessus :\n\nKey Expansion : génération d’une matrice étendue\n\nClé 128 bits → matrice 4 × 4 × (\\(N_e\\) + 1) bytes\n\\(N_e\\) = nombre de rounds\n\nKey Selection : extraction des sous-clés\n\nPremière sous-clé : 4 premières colonnes\nDeuxième sous-clé : 4 colonnes suivantes\nEtc.\n\n\nOpérations :\n\nRotations de bytes\nSubstitutions via S-box\nXOR avec constantes (Rcon)\n\n\n\nPseudo-code AES\nRijndael(State, CipherKey) {\n    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule\n    \n    AddRoundKey(State, ExpandedKey[0..3]); // XOR initial\n    \n    for(i = 1; i &lt; Ne; i++) {\n        Round(State, ExpandedKey[4*i...(4*i)+3]);\n    }\n    \n    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Sans MixColumns\n}\n\n\nDécryption AES\nPrincipe : appliquer les opérations inverses dans chaque round.\nOpérations inverses :\n\nInvSubBytes : substitution inverse via S-box⁻¹\nInvShiftRows : décalages droite (au lieu de gauche)\nInvMixColumns : multiplication matricielle inverse\nAddRoundKey : auto-inverse (XOR)\n\nOrdre : inverse de l’encryption avec sous-clés en ordre inverse\n\n\n\n\n\n\nNote📄 Texte original (AES)\n\n\n\n\n\nAdvanced Encryption Standard (AES)\n\nAdopté comme standard en Novembre 2001, conçu par Johan Daemen et Vincent Rijmen (d’où son nom original Rijndael).\nIl s’agit également d’un block cipher itératif (comme DES) mais pas d’un Feistel Cipher.\nBlocs Plaintext/Ciphertext: 128 bits.\nClé de longueur variable: 128, 192, ou 256 bits.\nContrairement à DES, AES est issu d’un processus de consultation et d’analyse ouvert à des experts mondiaux.\nTechniques semblables à DES (substitutions, permutations, XOR…) complémentées par des opérations algébriques simples et très performantes.\nToutes les opérations s’effectuent dans le corps \\(GF(2^8)\\): le corps fini de polynômes de degré ≤ 7 avec des coefficients dans \\(GF(2)\\).\nEn particulier, un byte pour AES est un élément dans \\(GF(2^8)\\) et les opérations sur les bytes (additions, multiplications,…) sont définies comme sur \\(GF(2^8)\\).\n~2 fois plus performant (en software) et ~10²² fois (en théorie…) plus sûr que DES…\nÉvolutif: La taille de la clé peut être augmentée si nécessaire.\n\n\nDétail d’une Etape (round) AES\nL’unité de base sur laquelle s’appliquent les calculs est une matrice de 4 lignes et 4 colonnes (dans le cas d’une clé de 128 bits) dont les éléments sont des bytes:\n\nByteSub: Opération non linéaire (S-box) conçu pour résister à la cryptanalyse linéaire et différentielle.\nShiftRow: Permutation des bytes introduisant des décalages variables sur les lignes.\nMixColumn: Chaque colonne est remplacée par des combinaisons linéaires des autres colonnes (multiplication des matrices !)\nAddRoundKey: XOR de la matrice courante avec la sous-clé correspondante à l’étape courante.\n\n\n\nAES: Fonctionnement Global\n\nLe nombre d’étapes d’AES varie en fonction de la taille de la clé. Pour une clé de 128 bits, il faut effectuer 10 étapes. Chaque augmentation de 32 bits sur la taille de la clé, entraîne une étape supplémentaire (14 étapes pour des clés de 256 bits).\nLa decryption consiste en appliquer les opérations inverses dans chacune des étapes (InvSubBytes, InvShiftRows, InvMixColumns). AddRoundKey (à cause du XOR) est sa propre inverse.\nLe Key Schedule consiste en:\n\nUne opération d’expansion de la clé principal. Si \\(N_e\\) est le nombre d’étapes (dépendant de la clé), une matrice de 4 lignes et 4 × (\\(N_e\\) + 1) colonnes est générée.\nUne opération de sélection de la clé d’étape: La première sous-clé sera constituée des 4 premières colonnes de la matrice générée lors de l’expansion et ainsi de suite.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (AES)\n\n\n\n\n\nAES (Rijndael 2001) : block cipher itératif (PAS Feistel), 128 bits blocs, clés 128/192/256 bits → 10/12/14 rounds.\nState : matrice 4×4 bytes dans \\(GF(2^8)\\).\n4 opérations/round :\n\nSubBytes (S-box non linéaire)\nShiftRows (décalages lignes)\nMixColumns (combinaisons linéaires)\nAddRoundKey (XOR sous-clé).\n\n2× plus rapide que DES, 10²² fois plus sûr.\n\n\n\n\n\n\n\n7. Attaques et Sécurité d’AES\n\nForces d’AES\nSimplicité et performances :\n\n✓ Algorithme simple et efficace\n✓ Fonctionne sur plateformes limitées (cartes à puce 8 bits)\n✓ Optimisations hardware et software\n\n\n\nAttaques Publiées\n1. Attaques algébriques (2002)\nTechnique XSL (N. Courtois et P. Pieprzyk) :\n\nReprésente AES comme système de 8000 équations quadratiques avec 1600 inconnues binaires\nEffort estimé : \\(2^{100}\\) opérations (encore une conjecture)\nCaractéristique : nécessite peu de known plaintexts\nDistinction : différent des attaques linéaires/différentielles\n\nCritique : basées sur le caractère “fortement algébrique” d’AES (largement contesté)\n2. Related Key Attacks (2009-2011)\nPrincipe : attaques basées sur des clés similaires\n\nRésultats intéressants sur versions réduites d’AES\nNe compromettent pas AES complet\n\n3. Side Channel Attacks\nPrincipe : attaques sur l’implémentation (pas l’algorithme)\nTechniques :\n\nCache timing attacks : analyse des accès cache\nPower analysis : consommation électrique\nElectromagnetic analysis : émissions électromagnétiques\n\nExemple (2005) : Osvik, Shamir, Tromer\n\nExtraction de clé 128 bits avec 6-7 couples plaintext/ciphertext\nBasée sur analyse des accès cache\n\n4. Meet in the Middle sur structures bicycliques (2011-2015)\nRésultat :\n\nRéduit l’effort pour AES-128 à \\(2^{126}\\) (facteur 4 vs brute force)\nReste largement au-dessus des capacités actuelles\n\n\n\nSécurité Pratique\nHypothèse fondamentale : clé d’entropie maximale\nAttaques récentes (WPA2, etc.) :\n\nExploitent la faiblesse des passwords/passphrases\nPas de faille dans AES lui-même\nProblème : génération de clés depuis passwords faibles\n\n⚠️ Rappel critique : qualité de la clé = sécurité du système\n\n\n\n\n\n\nNote📄 Texte original (Attaques AES)\n\n\n\n\n\n\nAES: Remarques Finales et Attaques (I)\n\nLa plus grande force de AES réside dans sa simplicité et dans ses performances, y compris sur des plate-formes à capacité de calcul réduite (p.ex. des cartes à puces avec des processeurs à 8 bits).\nDepuis sa publication officielle, des nombreux travaux de cryptanalyse ont été publiés avec des résultats très intéressants. En particulier, N. Courtois et P.Pieprzyk ont présenté une technique appelée XSL permettant de représenter AES comme un système de 8000 équations quadratiques avec 1600 inconnues binaires. L’effort nécessaire pour casser ce système est estimé (il s’agit encore d’une conjecture…) à \\(2^{100}\\).\nCes attaques se basent sur le caractère fortement algébrique (et largement contesté…) de AES. De plus, il suffit de quelques known plaintexts pour les mettre en place, ce qui les distingue des attaques linéaires et différentielles.\nCes dernières années (2009-2011) des attaques basées sur des clés similaires (related key attacks) ont obtenu des résultats intéressants sur des versions réduites d’AES.\nUne autre famille d’attaques dénommée side channel attacks agissant directement sur l’implémentation de l’algorithme permet d’extraire des informations d’intérêt cryptographique lors de l’exécution de l’encryption.\n\n\n\nAES: Remarques finales et Attaques (II)\n\nEn 2015 une attaque de type Meet in the Middle basé sur des structure bicycliques a montré qu’il était possible de réduire l’effort nécessaire pour trouver une clé AES-128 à \\(2^{126}\\), soit un facteur 4 par rapport au brute force. Ceci reste tout de même largement au dessus des capacités de calcul actuelles.\nUne autre famille d’attaques dénommée side channel attacks agissant directement sur l’implémentation de l’algorithme permet d’extraire des informations d’intérêt cryptographique lors de l’exécution de l’encryption. En particulier, les auteurs arrivent à extraire la clé de 128 bits avec seulement 6-7 couples plaintext/ciphertexts en se basant sur les accès cache.\nLa sécurité de AES (comme pour tout autre algorithme d’encryption) se base toujours sur l’hypothèse d’une clé d’entropie maximale. Les attaques publiées récemment sur des protocoles basés sur AES (comme WPA2) exploitent la faiblesse des passwords/passphrases qui sont à l’origine des clés utilisées.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Sécurité AES)\n\n\n\n\n\nForces : simplicité, performances (même cartes 8 bits). Attaques : XSL (\\(2^{100}\\), algébrique), related keys (versions réduites), side channel (implémentation, cache), Meet-in-Middle bicyclique (\\(2^{126}\\)). Sécurité : hypothèse clé entropie max. Attaques pratiques = passwords faibles, pas faille AES.\n\n\n\n\n\n\n\n8. Techniques de Cryptanalyse des Block Ciphers\n\n8.1 Cryptanalyse Différentielle\nPrincipe : attaque chosen plaintext analysant la propagation des différences entre deux plaintexts à travers les rounds.\nMéthode :\n\nChoisir deux plaintexts avec différence connue : \\(x_a\\) et \\(x_b\\)\nObserver la propagation : \\(\\Delta x = x_a \\oplus x_b\\)\nAnalyser les ciphertexts : \\(\\Delta y = y_a \\oplus y_b\\)\nAttribuer des probabilités aux clés selon les changements observés\nClé la plus probable = clé correcte (après nombreux essais)\n\nCaractéristiques :\n\nNécessite \\(2^{47}\\) couples chosen plaintext pour DES\nProbabilités : dépendent des S-boxes et de la structure\nPlus le nombre de couples augmente, plus la probabilité de succès augmente\n\nSensibilité : très sensible au nombre de rounds\n\nChances de réussite augmentent exponentiellement quand rounds diminuent\n\n\n\n8.2 Cryptanalyse Linéaire\nPrincipe : attaque known plaintext créant un simulateur linéaire du block cipher.\nMéthode :\n\nCréer des approximations linéaires de l’algorithme\nAnalyser un grand nombre de paires plaintext/ciphertext\nLes bits de la clé du simulateur tendent à coïncider avec ceux de la clé réelle (calcul probabiliste)\n\nComplexité pour DES :\n\n\\(2^{38}\\) known plaintexts → probabilité 10% de deviner juste\n\\(2^{43}\\) known plaintexts → probabilité 85% de succès\n\nCaractéristiques :\n\nAttaque analytique la plus puissante à ce jour sur block ciphers\nAussi sensible au nombre de rounds\n\n\n\n8.3 Comparaison Différentielle vs Linéaire\nDifficultés communes :\n\n✗ Parallélisation : moins efficace que brute force parallèle\n⚠️ Sensibilité aux rounds : efficacité diminue exponentiellement avec le nombre de rounds\n\nDES et ces attaques :\n\nConjecture répandue : concepteurs de DES connaissaient ces attaques (années 1970, inédites à l’époque)\nDesign des S-boxes : résistance très grande aux deux techniques\n\n\n\n8.4 Attaque Meet-in-the-Middle\nPrincipe : exploite les constructions composées du type \\(y = E_{K_2}(E_{K_1}(x))\\).\nMéthode :\n\nConstruire liste \\(L_1\\) : \\(L_1 = \\{E_{K_1}(x) \\mid K_1 \\in \\text{KeySpace}\\}\\)\nConstruire liste \\(L_2\\) : \\(L_2 = \\{D_{K_2}(y) \\mid K_2 \\in \\text{KeySpace}\\}\\)\nIdentifier éléments répétés dans \\(L_1\\) et \\(L_2\\)\nVérifier hypothèse avec deuxième known plaintext\nLes clés \\(K_1\\) et \\(K_2\\) associées sont probablement les clés recherchées\n\nExemple pour DES :\nEspace de clés intuitif pour \\(E_{K_2}(E_{K_1}(x))\\) : \\(\\{0,1\\}^{112}\\)\nEffort réel :\n\n\\(2^{57}\\) opérations pour établir les deux listes\n\\(2^{56}\\) blocs de 64 bits de stockage\nNettement inférieur au \\(2^{112}\\) estimé intuitivement\n\nApplications :\n\nAttaques sur constructions composées\nCryptanalyse interne des block ciphers\n\n\n\n\n\n\ngraph TB\n    subgraph Meet_in_Middle\n        X[Known Plaintext x] --&gt; E1[Encrypt K1]\n        E1 --&gt; M[Middle Value m]\n        M --&gt; E2[Encrypt K2]\n        E2 --&gt; Y[Known Ciphertext y]\n        \n        X2[x] --&gt; L1[List L1: EK1 pour tous K1]\n        Y2[y] --&gt; L2[List L2: DK2 pour tous K2]\n        \n        L1 -.match.-&gt; Match[Trouver m commun]\n        L2 -.match.-&gt; Match\n    end\n    \n    style M fill:#ffffcc\n    style Match fill:#ccffcc\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original (Cryptanalyse)\n\n\n\n\n\n\nTechniques de Cryptanalyse sur les Block Ciphers\nCryptanalyse Différentielle\n\nIl s’agit d’une attaque chosen plaintext qui s’intéresse à la propagation des différences dans deux plaintexts au fur et à mesure qu’ils évoluent dans les différentes étapes de l’algorithme.\nIl attribue des probabilités aux clés qu’il “devine” en fonction des changements qu’elles induisent sur les ciphertexts. La clé la plus probable a des bonnes chances d’être la clé correcte après un grand nombre de couples plaintext/ciphertext.\nNécessite \\(2^{47}\\) couples chosen plaintext (pour DES) pour obtenir des résultats corrects.\n\nCryptanalyse Linéaire\n\nIl s’agit d’une attaque known plaintext qui crée un simulateur du bloc à partir des approximations linéaires. En analysant un grand nombre de paires plaintext/ciphertexts, les bits de la clé du simulateur ont tendance à coïncider avec ceux du block cipher analysés (calcul probabiliste)\nPour DES une attaque basée sur cette technique nécessite \\(2^{38}\\) known plaintexts pour obtenir une probabilité de 10% de deviner juste et \\(2^{43}\\) pour un 85% !\nIl s’agit de l’attaque analytique la plus puissante à ce jour sur les block ciphers.\n\n\n\nTechniques de Cryptanalyse sur les Block Ciphers (II)\n\nLa mise en pratique des attaques différentielles et linéaires présente des difficultés dans la parallélisation des calculs par rapport à une recherche exhaustive de la clé.\nCes deux attaques sont très sensibles au nombre d’étapes du block cipher: les chances de réussite augmentent exponentiellement au fur et à mesure que le nombre d’étapes de l’algorithme diminue.\nUne conjecture très répandue parmi les cryptographes est que ces attaques, à l’époque inédites, étaient connues par les concepteurs des DES. En particulier, le design des S-boxes offre une résistance très grande aux deux techniques.\n\nAttaque Meet-in-the-Middle\n\nS’applique aux constructions du type \\(y := E_{K_2}(E_{K_1}(x))\\). Pour DES, l’espace de clés pour cette solution serait de \\(\\{0,1\\}^{112}\\). On construit d’abord deux listes \\(L_1\\) et \\(L_2\\) de \\(2^{56}\\) messages de la forme: \\(L_1 = E_{K_1}(x)\\) et \\(L_2 = D_{K_2}(y)\\) avec \\(E\\) et \\(D\\) les opérations d’encryption et decryption respectivement. Il faut alors identifier des éléments qui se répètent dans les deux listes et vérifier notre hypothèse avec un deuxième known plaintext. Les \\(K_1\\) et \\(K_2\\) associées à cette paire de known plaintexts seront (en toute vraisemblance) les clés recherchées !\nEffort nécessaire à réaliser les attaques (pour DES): \\(2^{57}\\) opérations pour établir les deux listes + \\(2^{56}\\) blocs de 64 bits de stockage pour mémoriser les résultats intermédiaires… nettement inférieur au \\(2^{112}\\) estimé intuitivement…\nCes techniques meet-in-the-middle sont aussi appliquées à la cryptanalyse interne des block ciphers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Cryptanalyse)\n\n\n\n\n\nDifférentielle : chosen plaintext, propagation différences, probabilités sur clés, \\(2^{47}\\) couples (DES).\nLinéaire : known plaintext, approximations linéaires, \\(2^{38}\\)-\\(2^{43}\\) plaintexts (DES), attaque la plus puissante.\nMeet-in-Middle : constructions composées, 2 listes \\(2^{56}\\), effort \\(2^{57}\\) &lt;&lt; \\(2^{112}\\).\nSensibilité : très dépendantes du nombre de rounds."
  },
  {
    "objectID": "exam_notes_fr.html#fondements-mathématiques",
    "href": "exam_notes_fr.html#fondements-mathématiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fondements Mathématiques",
    "text": "Fondements Mathématiques\n\nThéorème Fondamental de l’Arithmétique et Fonction Phi d’Euler\nLa cryptographie asymétrique repose sur des fondements mathématiques solides issus de la théorie des nombres. Deux concepts sont essentiels :\nThéorème Fondamental de l’Arithmétique : Tout nombre entier strictement positif \\(n\\) s’écrit de façon unique (à l’ordre près) comme produit de puissances de nombres premiers :\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nFonction Phi d’Euler \\(\\phi(n)\\) : Nombre d’entiers positifs plus petits que \\(n\\) qui sont premiers avec \\(n\\).\nPour calculer \\(\\phi(n)\\) :\n\\[\\phi(n) = \\prod_{i=1}^{m} p_i^{e_i} \\cdot \\left(1 - \\frac{1}{p_i}\\right)\\]\nCas particulier important : Si \\(n = p \\cdot q\\) avec \\(p\\) et \\(q\\) premiers, alors :\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques\nThéorème Fondamental de l’Arithmétique : Tout nombre entier strictement positif \\(n\\) s’écrit de façon unique (à l’ordre près) comme un produit de puissances de nombres premiers \\(p_i\\) distincts :\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nFonction Phi d’Euler : Soit \\(n \\in \\mathbb{Z}^+\\), la fonction phi d’Euler \\(\\phi(n)\\) est égale au nombre d’entiers positifs plus petits que \\(n\\) qui sont relativement premiers à \\(n\\).\nCalcul de la fonction phi d’Euler : D’après le théorème fondamental de l’arithmétique, tout nombre entier \\(n &gt; 1\\) s’écrit :\n\\[n = \\prod_{i=1}^{m} p_i^{e_i}\\]\nalors \\(\\phi(n)\\) se calcule :\n\\[\\phi(n) = \\prod_{i=1}^{m} \\left(p_i^{e_i} - p_i^{e_i-1}\\right)\\]\nEn particulier, si \\(n = p \\cdot q\\) avec \\(p\\) et \\(q\\) premiers, alors :\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nDécomposition unique : tout entier = produit de nombres premiers\n\\(\\phi(n)\\) : compte les entiers \\(&lt; n\\) premiers avec \\(n\\)\nClé pour RSA : si \\(n = pq\\) (premiers) alors \\(\\phi(n) = (p-1)(q-1)\\)\n\n\n\n\n\n\n\nThéorèmes d’Euler et de Fermat\nCes théorèmes sont au cœur du fonctionnement de RSA et d’autres algorithmes asymétriques.\nThéorème d’Euler : Si \\(n \\in \\mathbb{Z}^+\\) et \\(a \\in \\mathbb{Z}\\) avec \\(\\text{pgcd}(a,n) = 1\\), alors :\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nPetit Théorème de Fermat (cas particulier si \\(n = p\\) premier) : Si \\(a \\in \\mathbb{Z}\\) et \\(p\\) premier ne divise pas \\(a\\) :\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nApplications importantes :\n\nRéduction des exposants : Si \\(n\\) est produit de premiers distincts et \\(r \\equiv s \\pmod{\\phi(n)}\\), alors : \\[a^r \\equiv a^s \\pmod{n}\\]\nCalcul des inverses : \\(a^{\\phi(n)-1}\\) est l’inverse de \\(a\\) modulo \\(n\\). En particulier, si \\(p\\) est premier, \\(a^{p-2}\\) est l’inverse de \\(a\\) modulo \\(p\\).\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques (II)\nThéorème d’Euler : Soient \\(n \\in \\mathbb{Z}^+\\) et \\(a \\in \\mathbb{Z}\\) avec \\(\\text{pgcd}(a,n) = 1\\), alors on a :\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nPetit Théorème de Fermat (cas particulier du théorème d’Euler si \\(n\\) est premier) : Soient \\(a \\in \\mathbb{Z}\\) et \\(p\\) un nombre premier tel que \\(p\\) ne divise pas \\(a\\), alors on a :\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nÀ noter que puisque \\(p\\) est premier, on a \\(\\phi(p) = p-1\\).\nRéduction des exposants \\(\\bmod \\phi(n)\\) : Si \\(n\\) est le produit de premiers distincts et \\(r, s \\in \\mathbb{Z}\\) t.q. \\(r \\equiv s \\pmod{\\phi(n)}\\) alors \\(\\forall a \\in \\mathbb{Z}\\) :\n\\[a^r \\equiv a^s \\pmod{n}\\]\nApplication du Théorème d’Euler au calcul des inverses : Suite au théorème d’Euler, on a que :\n\\[a \\cdot a^{\\phi(n)-1} \\equiv 1 \\pmod{n}\\]\nce qui signifie que \\(a^{\\phi(n)-1}\\) est l’inverse de \\(a\\) modulo \\(n\\). En particulier, \\(a^{p-2}\\) est l’inverse de \\(a\\) modulo \\(n\\) si \\(p\\) est premier.\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\nFermat : cas spécial si \\(p\\) premier : \\(a^{p-1} \\equiv 1 \\pmod{p}\\)\nInverse modulaire : \\(a^{-1} \\equiv a^{\\phi(n)-1} \\pmod{n}\\)\nBase de RSA : permet encryption/decryption avec exposants\n\n\n\n\n\n\n\nGroupes Multiplicatifs et Générateurs\nGroupe multiplicatif \\(\\mathbb{Z}_n^*\\) : Ensemble des éléments de \\(\\mathbb{Z}_n\\) premiers avec \\(n\\) :\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{pgcd}(a,n) = 1\\}\\]\nSi \\(n\\) est premier : \\(\\mathbb{Z}_n^* = \\{1, 2, \\ldots, n-1\\}\\)\nOrdre d’un élément : Plus petit entier positif \\(t\\) tel que \\(a^t \\equiv 1 \\pmod{n}\\)\nGénérateur : Un élément \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) si son ordre est \\(\\phi(n)\\). On dit alors que \\(\\mathbb{Z}_n^*\\) est cyclique.\nPropriétés des générateurs :\n\n\\(\\mathbb{Z}_n^*\\) a un générateur ssi \\(n = 2, 4, p^k\\) ou \\(2p^k\\) (avec \\(p\\) premier, \\(p \\neq 2\\) et \\(k \\geq 1\\))\nSi \\(p\\) est premier, \\(\\mathbb{Z}_p^*\\) a toujours un générateur\nSi \\(\\alpha\\) est générateur, tous les éléments s’écrivent : \\(\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i &lt; \\phi(n)\\}\\)\nLe nombre de générateurs est \\(\\phi(\\phi(n))\\)\n\nTest de générateur\n\n\\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) ssi \\(\\forall\\) premier \\(p\\) divisant \\(\\phi(n)\\), \\(\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\)\nsi \\(n = 2p+1\\) est un “safe prime” avec \\(p\\) premier : \\(\\alpha\\) est générateur ssi \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) et \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques (III)\nDéfinition : Le groupe multiplicatif de \\(\\mathbb{Z}_n\\), noté \\(\\mathbb{Z}_n^*\\) est :\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{pgcd}(a,n) = 1\\}\\]\nEn particulier, si \\(n\\) est premier : \\(\\mathbb{Z}_n^* = \\{a \\mid 1 \\leq a \\leq n-1\\}\\)\nLe nombre d’éléments ou ordre du groupe multiplicatif \\(\\mathbb{Z}_n^*\\) est \\(\\phi(n)\\) (par définition de \\(\\phi\\)).\nDéfinition : Soit \\(a \\in \\mathbb{Z}_n\\), l’ordre de \\(a\\) est le plus petit entier positif \\(t\\) pour lequel :\n\\[a^t \\equiv 1 \\pmod{n}\\]\nDéfinition : Soit \\(\\alpha \\in \\mathbb{Z}_n^*\\), si l’ordre de \\(\\alpha\\) est \\(\\phi(n)\\), alors \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\). Lorsqu’un groupe \\(\\mathbb{Z}_n^*\\) a un générateur, on dit qu’il est cyclique.\nPropriétés des générateurs :\n\n\\(\\mathbb{Z}_n^*\\) a un générateur ssi \\(n = 2, 4, p^k\\) ou \\(2p^k\\), avec \\(p\\) premier, \\(p \\neq 2\\) et \\(k \\geq 1\\). En particulier, si \\(p\\) est premier, \\(\\mathbb{Z}_p^*\\) a un générateur.\nSi \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\), alors tous les éléments de \\(\\mathbb{Z}_n^*\\) s’écrivent : \\[\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i \\leq \\phi(n)-1\\}\\]\nLe nombre de générateurs de \\(\\mathbb{Z}_n^*\\) est \\(\\phi(\\phi(n))\\).\n\\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) ssi pour tout premier \\(p\\) divisant \\(\\phi(n)\\), on a : \\[\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\]\n\nEn particulier si \\(n\\) est un premier de la forme \\(n = 2p+1\\) avec \\(p\\) premier (un tel \\(n\\) est appelé un safe prime), \\(\\alpha\\) est générateur de \\(\\mathbb{Z}_n^*\\) ssi \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) et \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\n\\(\\mathbb{Z}_n^*\\) : éléments premiers avec \\(n\\), cardinal = \\(\\phi(n)\\)\nGénérateur : élément d’ordre \\(\\phi(n)\\) (génère tout le groupe)\nCrucial pour DH et ElGamal : sécurité basée sur logarithme discret dans groupe cyclique\nSafe prime : \\(n = 2p+1\\) avec \\(p\\) et \\(n\\) premiers\n\n\n\n\n\n\n\nFast Exponentiation (Exponentiation Rapide)\nCalcul efficace de \\(a^k \\bmod n\\) en temps polynomial, essentiel pour tous les algorithmes asymétriques.\nPrincipe : Utiliser la représentation binaire de l’exposant \\(k\\).\nExemple : Calcul de \\(2^{644} \\bmod 645\\)\n\nReprésentation binaire : \\((644)_{10} = (1010000100)_2\\)\nCalculer les puissances de 2 successives modulo 645 :\n\n\\(2^1 \\bmod 645\\)\n\\(2^2 \\bmod 645\\)\n\\(2^4 \\bmod 645\\)\n\\(2^8 \\bmod 645\\)\n…\n\\(2^{512} \\bmod 645\\)\n\nCombiner selon les bits à 1 : \\(2^{644} = 2^{512} \\cdot 2^{128} \\cdot 2^4\\)\n\nComplexité : \\(O(\\log^3 n)\\) - très efficace !\nApplication : Calcul de l’inverse avec le théorème d’Euler en temps polynomial.\nAlternative : Algorithme d’Euclide étendu pour trouver \\(x\\) tel que \\(ax \\equiv 1 \\pmod{n}\\) en résolvant \\(ax - kn = 1 = \\text{pgcd}(a,n)\\). Complexité également \\(O(\\log^3 n)\\).\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFast Exponentiation\nFast exponentiation : En utilisant la représentation binaire d’un nombre, on peut calculer des puissances très efficacement.\nExemple : calcul de \\(2^{644} \\bmod 645\\)\n\\((644)_{10} = (1010000100)_2\\)\nMaintenant, on calcule les exposants correspondants aux puissances de 2, soient :\n\\[2^1 \\bmod 645, \\quad 2^2 \\bmod 645, \\quad 2^4 \\bmod 645, \\quad \\ldots, \\quad 2^{512} \\bmod 645\\]\nD’après la représentation binaire, on calcule :\n\\[2^{644} = 2^{512+128+4} = 2^{512} \\cdot 2^{128} \\cdot 2^4 = 160 \\cdot 153 \\cdot 6 \\bmod 645\\]\nLa complexité de cet algorithme fast exponentiation est \\(O(\\log^3 n)\\).\nEn s’appuyant sur le théorème d’Euler, le calcul de l’inverse d’un nombre dans un tel groupe est donc effectué en temps polynomial.\nL’algorithme d’Euclide étendu peut être également utilisé pour trouver un \\(x\\) tel que :\n\\[ax \\equiv 1 \\pmod{n}\\]\npuisque cette congruence s’écrit : \\(ax - 1 = kn\\) et donc :\n\\[ax - kn = 1 = \\text{pgcd}(a,n)\\]\nLa complexité de cet algorithme est également \\(O(\\log^3 n)\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nIdée : représentation binaire de l’exposant\nComplexité : \\(O(\\log^3 n)\\) - polynomial !\nEssentiel : rend RSA, ElGamal, DH praticables\nAlternative : algorithme d’Euclide étendu pour inverses\n\n\n\n\n\n\n\nThéorème des Restes Chinois (CRT)\nLe CRT permet de résoudre des systèmes de congruences simultanées, avec des applications importantes en cryptographie.\nThéorème : Soient \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) premiers deux à deux (pgcd\\((n_i, n_j) = 1\\) si \\(i \\neq j\\)) et \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Alors le système :\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\na une solution unique \\(x \\bmod N\\) avec \\(N := n_1 \\cdot n_2 \\cdots n_t\\).\nAlgorithme de Gauss (1801) pour calculer \\(x\\) :\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\navec :\n\n\\(N_i = N/n_i\\)\n\\(M_i = N_i^{-1} \\bmod n_i\\) (inverse modulaire)\n\nComplexité : \\(O(\\log^3 n)\\) - polynomial !\nApplications cryptographiques :\n\nAccélération des calculs RSA (utiliser \\(p\\) et \\(q\\) séparément)\nPartage de secret (secret sharing schemes)\nCertaines attaques sur RSA (si exposant petit et messages multiples)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nThéorème des Restes Chinois\nLe Théorème des Restes Chinois (IIIe siècle!) permet de résoudre des systèmes linéaires de congruences simultanées. Il résout des problèmes soulevés dans des anciens puzzles chinois. Il s’agissait, par exemple, de trouver un nombre qui produit un reste de 1 lorsqu’il est divisé par 3, de 2 lorsqu’il est divisé par 5 et de 3 lorsqu’il est divisé par 7… Il fut également utilisé pour calculer le moment exact d’alignement de plusieurs astres ayant des orbites (et donc des périodes) différentes.\nThéorème des Restes Chinois : Soient \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) premiers deux à deux (c.à.d. pgcd\\((n_i, n_j) = 1\\), \\(\\forall i \\neq j\\)) et \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Alors, le système de congruences :\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\na une solution unique \\(x \\bmod N := n_1 n_2 \\cdots n_t\\)\nAlgorithme de Gauss (1801) pour le calcul de \\(x\\) :\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\navec \\(N_i = N/n_i\\) et \\(M_i = N_i^{-1} \\bmod n_i\\).\nLa complexité de cet algorithme est \\(O(\\log^3 n)\\).\nIl est donc possible en temps polynomial de passer des congruences mod \\(n_i\\) aux congruences mod \\(N\\) !\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nRésout : systèmes de congruences avec moduli premiers entre eux\nSolution unique : modulo produit des moduli\nComplexité : \\(O(\\log^3 n)\\) (polynomial)\nUsage crypto : optimisation RSA, attaques si petit exposant"
  },
  {
    "objectID": "exam_notes_fr.html#problèmes-de-base-et-complexité",
    "href": "exam_notes_fr.html#problèmes-de-base-et-complexité",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Problèmes de Base et Complexité",
    "text": "Problèmes de Base et Complexité\n\nClassification des Problèmes Difficiles\nLa sécurité de la cryptographie asymétrique repose sur des problèmes mathématiques réputés difficiles :\nProblèmes génériques :\n\nFactorisation (FACTP) : Étant donné \\(n\\), trouver sa factorisation en nombres premiers\n\nBase de RSA et Rabin\n\nLogarithmes discrets (DLP) : Étant donné \\(p\\) premier, un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et \\(\\beta \\in \\mathbb{Z}_p^*\\), trouver \\(x\\) tel que : \\[\\alpha^x \\equiv \\beta \\pmod{p}\\]\n\nBase de ElGamal et Diffie-Hellman\n\nRacine carrée modulo composite (SQROOTP) : Étant donné \\(n\\) composite et un résidu quadratique \\(a\\), trouver \\(\\sqrt{a} \\bmod n\\)\n\nBase de Rabin\n\n\nProblèmes spécifiques :\n\nRSA Problem (RSAP) : Étant donné \\(n = pq\\), \\(e\\) avec pgcd\\((e, \\phi(n)) = 1\\) et \\(c\\), trouver \\(m\\) tel que \\(m^e \\equiv c \\pmod{n}\\)\nDiffie-Hellman Problem (DHP) : Étant donné \\(p\\) premier, \\(\\alpha\\) générateur, \\(\\alpha^a \\bmod p\\) et \\(\\alpha^b \\bmod p\\), trouver \\(\\alpha^{ab} \\bmod p\\)\n\nÉquivalences prouvées :\n\nDHP ⟺ DLP (équivalent sous certaines conditions)\nRSAP ⟺ FACTP (prouvé équivalent pour le cas générique)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nProblèmes de Base\nProblèmes génériques principaux :\n\nFactorisation (FACTP) : Étant donné un entier positif \\(n\\), trouver sa factorisation en nombres premiers.\nLogarithmes discrets (DLP) : Étant donné un nombre premier \\(p\\), un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et un élément \\(\\beta \\in \\mathbb{Z}_p^*\\), trouver l’entier \\(x\\), \\(0 \\leq x \\leq p-2\\), tel que : \\(\\alpha^x \\equiv \\beta \\pmod{p}\\).\nRacine carrée dans \\(\\mathbb{Z}_n\\) si \\(n\\) est composite (SQROOTP) : Étant donné un entier composite \\(n\\) et un résidu quadratique \\(a\\), trouver la racine carrée de \\(a\\) mod \\(n\\).\n\nProblèmes spécifiques (propres à un système de cryptage) :\n\nRSA (RSAP) : Étant donné un entier positif \\(n = pq\\), un entier positif \\(e\\) avec gcd\\((e, (p-1)(q-1)) = 1\\) et un entier \\(c\\), trouver un entier \\(m\\) avec \\(m^e \\equiv c \\pmod{n}\\).\nDiffie-Hellman (DHP) : Étant donné un nombre premier \\(p\\), un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et les éléments \\(\\alpha^a \\bmod p\\) et \\(\\alpha^b \\bmod p\\), trouver \\(\\alpha^{ab} \\bmod p\\).\n\nRésultats prouvés :\n\nDHP ⟺ DLP (Équivalent sous certaines conditions)\nRSAP ⟺ FACTP (Prouvé équivalent pour le problème générique)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nFACTP : factoriser \\(n\\) → base de RSA/Rabin\nDLP : trouver logarithme discret → base ElGamal/DH\nSQROOTP : racine carrée mod composite → Rabin\nÉquivalences : cassage = résolution du problème de base\n\n\n\n\n\n\n\nTechniques de Factorisation\nLa sécurité de RSA dépend de la difficulté de factoriser de grands nombres.\nMéthodes à temps exponentiel : \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division (division successive)\nCrible d’Ératosthène (IIe siècle av. J.-C.)\nMéthode de Fermat (~1650)\nMéthode \\(\\rho\\) de Pollard (1975)\nMéthode \\(p-1\\) de Pollard (1974)\n\nMéthodes à temps sous-exponentiel : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981) - très efficace en pratique\nNumber Field Sieve - NFS (1990) - le plus rapide actuellement\nGeneral Number Field Sieve - GNFS (2006)\n\nMéthodes à temps polynomial :\n\nAlgorithme de Shor (1994) : \\(O(\\log^c n)\\) sur ordinateur quantique\n\nRecords actuels (2020) :\n\nPlus grand nombre factorisé : RSA-829 (250 chiffres, 829 bits)\nTemps de calcul : 2700 années-cœur (CPUs Intel Xeon Gold 6130)\nMéthode : General Number Field Sieve\n\nImplications :\n\nClés RSA &lt; 1024 bits : vulnérables\nClés RSA 1024 bits : limites (états avec ressources importantes)\nRecommandation : 2048 bits minimum (3072-4096 pour long terme)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nClassical Factoring Techniques et New Developments\nTemps exponentiel : \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division\nEratosthenes’ Sieve (II B.C.)\nFermat’s Difference of Squares Method (~1650)\nSquare Form Factorization (1971)\nPollard’s p-1 method (1974)\nPollard’s Rho Method (1975)\n\nTemps sous-exponentiel : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981)\nNumber Field Sieve - NFS (1990)\nGeneral Number Field Sieve - GNFS (2006)\n\nTemps polynomial :\n\nShor’s Algorithm in a Quantum Computer (1994) : \\(O(\\log^c n)\\)\n\nDéveloppements récents :\n\nL’ordinateur NFS spécifique de Bernstein pour factoriser un nombre de 1536 bits prendrait le même temps qu’un calcul 512 bits sur machine conventionnelle\nPlus grande factorisation à ce jour (2020) : RSA-829 (nombre de 250 chiffres) utilisant NFS\nTemps de calcul total : 2700 années-cœur (CPUs Intel Xeon Gold 6130 à 2.1GHz)\n\nFactorisation sur ordinateur quantique :\n\nProblèmes significatifs (erreurs, dispersion, etc.)\n2001 : ordinateur 7 qubits (IBM Almaden)\nFaisabilité d’un ordinateur avec millions de qubits… ?\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nSous-exponentiel : NFS actuellement le plus rapide\nRecord 2020 : RSA-829 (829 bits) en 2700 années-cœur\nRecommandation : clés ≥ 2048 bits pour RSA\nMenace future : ordinateurs quantiques (Shor)"
  },
  {
    "objectID": "exam_notes_fr.html#lalgorithme-rsa",
    "href": "exam_notes_fr.html#lalgorithme-rsa",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "L’Algorithme RSA",
    "text": "L’Algorithme RSA\n\nFonctionnement de RSA (Encryption/Decryption)\nRSA (Rivest-Shamir-Adleman, 1978) est l’algorithme asymétrique le plus utilisé.\nGénération des clés :\n\nChoisir deux nombres premiers grands \\(p\\) et \\(q\\) (≥ 1024 bits chacun)\nCalculer \\(n := p \\cdot q\\) et \\(\\phi(n) = (p-1)(q-1)\\)\nChoisir exposant d’encryption \\(e\\) avec :\n\n\\(1 &lt; e &lt; \\phi(n)\\)\npgcd\\((e, \\phi(n)) = 1\\)\n\nCalculer exposant de décryption \\(d\\) tel que : \\[e \\cdot d \\equiv 1 \\pmod{\\phi(n)}\\] (avec algorithme d’Euclide étendu ou fast exponentiation)\n\nClés résultantes :\n\nClé publique : \\((n, e)\\)\nClé privée : \\(d\\) (garder \\(p\\) et \\(q\\) secrets aussi !)\n\nEncryption (par Bob, vers Alice) :\n\nObtenir clé publique authentique \\((n, e)\\) d’Alice\nTransformer plaintext en entiers \\(m_i \\in [0, n-1]\\)\nCalculer ciphertexts : \\(c_i := m_i^e \\bmod n\\)\nEnvoyer les \\(c_i\\) à Alice\n\nDecryption (par Alice) :\n\nUtiliser clé privée \\(d\\) pour calculer : \\[m_i = c_i^d \\bmod n\\]\n\nPreuve de fonctionnement :\n\\[c^d \\equiv (m^e)^d \\equiv m^{ed} \\pmod{n}\\]\nComme \\(ed \\equiv 1 \\pmod{\\phi(n)}\\), il existe \\(k\\) tel que \\(ed = 1 + k\\phi(n)\\), donc :\n\\[c^d \\equiv m^{1+k\\phi(n)} \\equiv m \\cdot (m^{\\phi(n)})^k \\equiv m \\cdot 1^k \\equiv m \\pmod{n}\\]\n(par le théorème d’Euler)\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nProcédé d’Encryption/Decryption de RSA et Preuve\nGénération des clés :\n\nChaque entité (A) crée une paire de clés (publique et privée) comme suit :\n\nA choisit la taille du modulus \\(n\\) (p.ex. taille\\((n) = 1024\\) ou taille\\((n) = 2048\\)).\nA génère deux nombres premiers \\(p\\) et \\(q\\) de grande taille \\((n/2)\\).\nA calcule \\(n := pq\\) et \\(\\phi(n) = (p-1)(q-1)\\).\nA génère l’exposant d’encryption \\(e\\), avec \\(1 &lt; e &lt; \\phi(n)\\) t.q. pgcd\\((e, \\phi(n)) = 1\\).\nA calcule l’exposant de decryption \\(d\\), t.q. : \\(ed \\equiv 1 \\pmod{\\phi(n)}\\) avec l’algorithme d’Euclide étendu ou avec l’algorithme fast exponentiation.\n\nLe couple \\((n,e)\\) est la clé publique de A ; \\(d\\) est la clé privée de A.\n\nEncryption :\n\nL’entité B obtient \\((n,e)\\), la clé publique authentique de A.\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, n-1]\\) \\(\\forall i\\).\nB calcule le ciphertext \\(c_i := m_i^e \\bmod n\\), \\(\\forall i\\) avec l’algorithme fast exponentiation.\nB envoie à A tous les ciphertext \\(c_i\\).\n\nDecryption :\n\nA utilise sa clé privée pour calculer les plaintexts \\(m_i = c_i^d \\bmod n\\).\n\nPreuve : Soit \\(m\\) le plaintext et \\(c\\) le ciphertext avec \\(c := m^e \\bmod n\\), il s’agit de prouver : \\(m \\stackrel{!}{=} c^d \\bmod n\\)\nEn substituant \\(c\\) par sa valeur on obtient : \\[c^d \\bmod n = m^{ed} \\bmod n \\quad (*)\\]\nmais, on sait que : \\[ed \\equiv 1 \\pmod{\\phi(n)}\\]\net donc par définition des congruences, il existe un entier \\(k\\) avec : \\[ed - 1 = k\\phi(n)\\]\nen substituant dans (*) : \\[c^d \\equiv m^{k\\phi(n)+1} \\equiv m^{k\\phi(n)} \\cdot m \\pmod{n}\\]\nSi pgcd\\((m,n) = 1\\), on a par le théorème d’Euler : \\[m^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\ndonc : \\[c^d \\equiv (m^{\\phi(n)})^k \\cdot m \\equiv m \\pmod{n}\\] c.q.f.d. !\nSi pgcd\\((m,n) \\neq 1\\), \\(m\\) est nécessairement multiple de \\(p\\) ou de \\(q\\) (cas très peu probable…), on peut montrer en faisant les calculs mod \\(p\\) et mod \\(q\\) que la congruence reste vraie.\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nClé publique : \\((n, e)\\) avec \\(n = pq\\)\nClé privée : \\(d\\) tel que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\nChiffrement : \\(c = m^e \\bmod n\\)\nDéchiffrement : \\(m = c^d \\bmod n\\)\nSécurité : basée sur difficulté de factoriser \\(n\\)\n\n\n\n\n\n\n\n\n\ngraph LR\n    A[Plaintext m] --&gt;|Encryption: m^e mod n| B[Ciphertext c]\n    B --&gt;|Decryption: c^d mod n| C[Plaintext m]\n    D[Clé publique: n, e] -.-&gt;|utilisée pour| A\n    E[Clé privée: d] -.-&gt;|utilisée pour| B\n    F[p, q premiers secrets] --&gt;|n = pq| D\n    F --&gt;|φn = p-1q-1| E\n\n\n\n\n\n\n\n\n\nSécurité de RSA\nÉquivalence problème RSA ⟺ Factorisation :\n\nTrouver \\(d\\) ⟺ factoriser \\(n\\) (prouvé équivalent)\nDécrypter sans \\(d\\) n’est pas prouvé aussi difficile que factoriser, mais…\nAucune méthode plus rapide que factorisation n’est connue\n\nComplexité de la factorisation :\n\nMéthodes les plus rapides : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\) (sous-exponentiel)\nCalculatoirement impossible pour \\(n \\geq 1024\\) bits\nRecommandation actuelle : 2048 bits minimum (3072-4096 pour sécurité durable)\n\nChoix des exposants :\nExposant d’encryption \\(e\\) :\n\nSouvent petit pour accélérer : \\(e = 3, 17, 65537\\) (commun)\nAttention : si \\(e\\) trop petit ET \\(m &lt; n^{1/e}\\), attaque possible (racine \\(e\\)-ième dans \\(\\mathbb{Z}\\))\nSolution : randomization (padding) du message\n\nExposant de décryption \\(d\\) :\n\nDoit être grand : au moins la moitié de la taille de \\(n\\)\nSi \\(d\\) petit : vulnérable à l’attaque de Wiener\n\nConséquence performance :\n\nEncryption rapide (\\(e\\) petit)\nDecryption lente (\\(d\\) grand)\n\nRecommandations :\n\nSéparer clés d’encryption et de signature (politiques différentes)\nUtiliser exposants publics différents pour différents usages\nToujours appliquer padding (OAEP) avant encryption\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nRSA: Sécurité\nLe problème RSAP consistant à trouver \\(m\\) à partir de \\(c\\) n’est pas prouvé comme étant aussi difficile que la factorisation mais… :\n\nOn peut prouver que si on trouve \\(d\\) on peut facilement calculer \\(p\\) et \\(q\\). Ceci équivaut à dire que factoriser \\(n\\) et trouver \\(d\\) nécessitent un effort de calcul équivalent.\nOn sait que les méthodes les plus rapides pour factoriser ont une complexité sub-exponentielle \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\). Le problème reste donc calculatoirement impossible pour des modulus \\(\\geq 1048\\) bits (2048 bits est un choix fréquent pour une sécurité durable…).\nAfin d’améliorer la vitesse d’encryption, on a tendance à choisir des exposants \\(e\\) assez petits (typiquement : \\(e := 3\\), \\(e := 17\\) et \\(e := 19\\)). On a cependant prouvé que le calcul d’une \\(i\\)-ème racine (avec \\(i\\) petit) modulo un composite \\(n\\) peut être nettement plus facile que la factorisation de \\(n\\). Par contre, en 2008 on a prouvé que la résolution générique du problème RSA est équivalent à la factorisation.\nL’exposant de decryption \\(d\\) doit impérativement être de grande taille (au moins la moitié de la taille de \\(n\\)) pour garantir la sécurité du système.\nPar conséquent, l’encryption est normalement nettement plus rapide que la decryption puisque les exposants utilisés sont beaucoup plus petits !\nIl convient de différencier les paires de clés d’encryption et de signature puisqu’elles nécessitent des politiques de stockage, sauvegarde et mise à jour distinctes.\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nSécurité : basée sur difficulté de FACTP (factorisation)\nTaille recommandée : \\(n \\geq 2048\\) bits\n\\(e\\) petit : encryption rapide (3, 17, 65537)\n\\(d\\) grand : au moins \\(\\text{taille}(n)/2\\)\nClés séparées : encryption ≠ signature\n\n\n\n\n\n\n\nAttaques sur RSA\n1. Attaque sur exposant petit avec même message :\nSi on envoie le même message \\(m\\) à 3 destinataires avec \\(e = 3\\) : - \\(c_1 \\equiv m^3 \\pmod{n_1}\\) - \\(c_2 \\equiv m^3 \\pmod{n_2}\\) - \\(c_3 \\equiv m^3 \\pmod{n_3}\\)\nLe Théorème des Restes Chinois donne une solution unique \\(x \\bmod n_1n_2n_3\\) telle que : \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nSi \\(m^3 &lt; n_1n_2n_3\\) (souvent vrai), alors \\(x = m^3\\) dans \\(\\mathbb{Z}\\) et on peut calculer \\(m\\) en prenant simplement la racine cubique entière !\nProtection : toujours randomizer le message avant encryption (padding OAEP)\n2. Attaque si message petit :\nSi \\(m &lt; n^{1/e}\\), alors \\(m^e &lt; n\\), donc \\(c = m^e\\) (dans \\(\\mathbb{Z}\\), pas modulo). On peut calculer directement la racine \\(e\\)-ième !\nProtection : padding obligatoire\n3. Propriété multiplicative :\n\\[E(m_1) \\cdot E(m_2) \\equiv (m_1 \\cdot m_2)^e \\equiv E(m_1 \\cdot m_2) \\pmod{n}\\]\nPermet des attaques de type chosen-ciphertext et blind signatures.\n4. Attaque générale :\nLa méthode la plus efficace reste la factorisation de \\(n\\) (si paramètres bien choisis et implémentation correcte).\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nRSA: Attaques\nLors qu’on souhaite encrypter le même message pour un groupe de correspondants, il convient d’introduire des variations (randomization) avant l’encryption pour éviter l’attaque suivante :\nAdmettons qu’on calcule des ciphertexts \\(c_1, c_2, c_3\\) à partir du même plaintext \\(m\\) et du même exposant \\(e := 3\\) adressés à trois entités avec des modulus : \\(n_1, n_2, n_3\\).\nLe Théorème des Restes Chinois nous dit qu’il existe une solution \\(x \\bmod n_1n_2n_3\\), t.q. : \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nMais si \\(m\\) ne change pas pour les trois encryptions, on a que \\(x = m^3 \\bmod n_1n_2n_3\\) et, de plus : \\(m^3 &lt; n_1n_2n_3\\). On peut, donc, trouver \\(m\\) en calculant la racine cubique entière de \\(m^3\\), en sachant que pour ce calcul il existe des algorithmes efficaces !\nPlus généralement, si \\(m &lt; n^{1/e}\\), on peut appliquer des algorithmes rapides (dans \\(\\mathbb{Z}\\)) pour calculer les racines \\(e\\)-ièmes de \\(m^e\\). Il convient donc d’effectuer des opérations de “randomization” de \\(m\\) avant d’encrypter !\nLa propriété multiplicative de RSA : \\((m_1 m_2)^e \\equiv m_1^e \\cdot m_2^e \\equiv c_1 \\cdot c_2 \\pmod{n}\\)\ndonne lieu à des failles dangereuses (voir signatures aveugles).\nEn admettant que les paramètres sont correctement choisis et que l’implantation n’a pas de failles, la méthode la plus efficace pour “casser” l’algorithme générique RSA reste la factorisation de \\(n\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nMême message, petit \\(e\\) : CRT permet d’extraire \\(m\\) !\nMessage trop petit : \\(m &lt; n^{1/e}\\) → racine directe\nPropriété multiplicative : \\(E(m_1) \\cdot E(m_2) = E(m_1 m_2)\\)\nProtection : toujours padding/randomization (OAEP)"
  },
  {
    "objectID": "exam_notes_fr.html#lalgorithme-elgamal",
    "href": "exam_notes_fr.html#lalgorithme-elgamal",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "L’Algorithme ElGamal",
    "text": "L’Algorithme ElGamal\n\nFonctionnement d’ElGamal (Encryption/Decryption)\nElGamal (1985) est basé sur le problème du logarithme discret (DLP).\nGénération des clés :\n\nGénérer un nombre premier grand \\(p\\) (≥ 1024 bits)\nChoisir un générateur \\(\\alpha\\) de \\(\\mathbb{Z}_p^*\\)\nChoisir un nombre aléatoire secret \\(a\\) avec \\(1 \\leq a \\leq p-2\\)\nCalculer \\(\\beta := \\alpha^a \\bmod p\\)\n\nClés résultantes : - Clé publique : \\((p, \\alpha, \\beta)\\) - Clé privée : \\(a\\)\nEncryption (par Bob, vers Alice) :\n\nObtenir clé publique authentique \\((p, \\alpha, \\beta)\\) d’Alice\nTransformer plaintext en entiers \\(m_i \\in [0, p-1]\\)\nPour chaque message \\(m_i\\) :\n\nGénérer un nombre aléatoire unique \\(k\\) avec \\(1 \\leq k \\leq p-2\\)\nCalculer :\n\n\\(\\gamma := \\alpha^k \\bmod p\\)\n\\(\\delta := m_i \\cdot \\beta^k \\bmod p\\)\n\nEnvoyer le ciphertext : \\(c_i := (\\gamma, \\delta)\\)\n\n\nDecryption (par Alice) :\n\nUtiliser clé privée \\(a\\) pour calculer : \\[\\gamma^{p-1-a} \\bmod p\\] (noter que \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv (\\alpha^k)^{-a} \\equiv \\alpha^{-ak} \\pmod{p}\\))\nRetrouver plaintext : \\[m_i = \\delta \\cdot \\gamma^{-a} \\bmod p\\]\n\nPreuve de fonctionnement :\n\\[\\delta \\cdot \\gamma^{-a} \\equiv m \\cdot \\beta^k \\cdot (\\alpha^k)^{-a} \\equiv m \\cdot (\\alpha^a)^k \\cdot \\alpha^{-ak} \\equiv m \\pmod{p}\\]\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nProcédé d’Encryption/Decryption d’ElGamal\nGénération des clés : - Chaque entité (A) crée une paire de clés (publique et privée) comme suit : - A génère un nombre premier \\(p\\) de grande taille (len\\((p) \\geq 1024\\) bits) et un générateur \\(\\alpha\\) de \\(\\mathbb{Z}_p^*\\). - A génère un nombre a"
  },
  {
    "objectID": "exam_notes_en.html",
    "href": "exam_notes_en.html",
    "title": "Fundamental Security Services",
    "section": "",
    "text": "Security services are the objectives aimed at protecting a system.\n\nConfidentiality: Protection against unauthorized disclosure.\nIntegrity: Protection against unauthorized modification.\nAvailability: Guarantee of access for legitimate users.\nAuthentication:\n\nEntity authentication: Certifying the identity of an actor.\nData origin authentication: Certifying the source of data.\n\nNon-repudiation: Inability to deny a transaction.\nNon-duplication: Protection against illicit copying.\nAnonymity: Preservation of identity or source.\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nConfidentiality: Protection of information from unauthorized disclosure.\nIntegrity: Protection against unauthorized modification of information.\nAvailability: Ensuring that resources are accessible to legitimate users.\nAuthentication:\n\nEntity authentication (entity authentication): Process allowing one entity to be certain of the identity of a second entity, supported by corroborating evidence (e.g., physical presence, cryptographic, biometric, etc.). The term identification is sometimes also used for this service.\nData origin authentication (data origin authentication): Process allowing one entity to be certain that a second entity is the original source of a set of data. By definition, this service also ensures the integrity of the data.\n\nNon-repudiation: Guarantees that an entity cannot deny being involved in a transaction.\nNon-duplication: Protection against illicit copying.\nAnonymity (entity or data origin): Preserves the identity of an entity, the source of information, or a transaction."
  },
  {
    "objectID": "exam_notes_en.html#threats-and-attacks-summary",
    "href": "exam_notes_en.html#threats-and-attacks-summary",
    "title": "Fundamental Security Services",
    "section": "Threats and Attacks: Summary",
    "text": "Threats and Attacks: Summary\n\n\n\n\n\n\n\n\nServices\nThreats\nAttacks\n\n\n\n\nConfidentiality\nInformation leakage\nUnauthorized eavesdropping, traffic analysis\n\n\nIntegrity\nInformation modification\nIllicit creation, alteration, or destruction\n\n\nAvailability\nDenial of service, illicit use\nViruses, repeated access attempts to disable a system\n\n\nEntity Authentication\nUnauthorized access\nPassword theft, authentication protocol flaw\n\n\nData Authentication\nInformation falsification\nSignature forgery, protocol flaw\n\n\nNon-repudiation\nDenying involvement in a transaction\nClaiming key theft or signature protocol flaw\n\n\nNon-duplication\nDuplication\nFalsification, imitation\n\n\nAnonymity\nIdentification\nTransaction analysis, unauthorized access enabling identification"
  },
  {
    "objectID": "exam_notes_en.html#protection-mechanisms",
    "href": "exam_notes_en.html#protection-mechanisms",
    "title": "Fundamental Security Services",
    "section": "Protection Mechanisms",
    "text": "Protection Mechanisms\n\n\n\n\n\n\n\n\nServices\nClassic Mechanisms\nDigital Mechanisms\n\n\n\n\nConfidentiality\nSeals, safes, padlocks\nEncryption, logical authorization\n\n\nIntegrity\nSpecial ink, holograms\nOne-way functions + encryption\n\n\nAvailability\nPhysical access control, video surveillance\nLogical access control, audit, antivirus\n\n\nEntity Authentication\nPresence, voice, ID card, biometric recognition\nSecret + authentication protocol, network address + userid, smart card + PIN\n\n\nData Authentication\nSeals, signature, fingerprint\nOne-way functions + encryption\n\n\nNon-repudiation\nSeals, signature, notary signature, registered mail\nOne-way functions + encryption + digital signature\n\n\nNon-duplication\nSpecial ink, holograms, tagging\nDigital watermarking, cryptographic locking\n\n\nAnonymity\nVoice scrambler, disguise, cash\nMixers, remailers, e-money, deep web"
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-e-mail",
    "href": "exam_notes_en.html#malware-delivered-via-e-mail",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via E-Mail",
    "text": "Malware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to trigger an action (open attachment or click a link).\nOften personalized using social engineering.\nMain consequences:\n\nMalware installation (ransomware, keyloggers, etc.).\nLoss or theft of personal data.\nSystem hijacking and malware propagation.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nMalware spread by email\nPrompting clicks or opens\nSocial engineering\nData theft, loss, hijacking\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nMalware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to incite the recipient to open an attachment or follow a link containing ads, offensive info, risky programs, etc.\nOften targeted based on victim interests (preliminary social engineering).\nConsequences:\n\nMalware installation (ransomware, keyloggers, etc.) on victim systems (computer, tablet, smartphone, smartwatch, etc.).\nData destruction.\nTheft of personal information or data.\nSystem hijacking for malicious purposes (e.g., illegal bitcoin mining).\nMalware propagation (potentially to other users)."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-e-mail-1",
    "href": "exam_notes_en.html#malware-delivered-via-e-mail-1",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via E-Mail",
    "text": "Malware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to incite the recipient to open an attachment or follow a link containing ads, offensive info, risky programs, etc.\nOften targeted based on victim interests (preliminary social engineering).\nConsequences:\n\nMalware installation (ransomware, keyloggers, etc.) on victim systems (computer, tablet, smartphone, smartwatch, etc.).\nData destruction.\nTheft of personal information or data.\nSystem hijacking for malicious purposes (e.g., illegal bitcoin mining).\nMalware propagation (potentially to other users)."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-web",
    "href": "exam_notes_en.html#malware-delivered-via-web",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via Web",
    "text": "Malware Delivered via Web\n\nMethod called drive-by download: automatic infection when visiting a website.\nSources can be:\n\nA malicious website\nA compromised legitimate site (e.g., cross-site scripting).\n\nUser caution greatly reduces this propagation method.\nImpacts are similar to email-borne infections.\nScript restriction (Java/JavaScript) reduces risk but can affect browsing.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nDrive-by download = infection without user action\nMalicious or compromised sites\nAwareness + restricted scripts = protection\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nMalware Delivered via Web\n\nOften called drive-by download, allows infecting the system (computer, tablet, smartphone, smartwatch, etc.) simply by visiting a website.\nSources may be:\n\nMalicious site containing malware\nLegitimate website previously infected (e.g., cross-site scripting). Infection may only affect certain pages.\n\nUser awareness (avoiding suspicious sites) reduces the effectiveness.\nConsequences are similar to email infections.\nRestricted script execution (Java/JavaScript) in browsers can limit infection but may constrain navigation."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-web-1",
    "href": "exam_notes_en.html#malware-delivered-via-web-1",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via Web",
    "text": "Malware Delivered via Web\n\nOften called drive-by download, allows infecting the system (computer, tablet, smartphone, smartwatch, etc.) simply by visiting a website.\nSources may be:\n\nMalicious site containing malware\nLegitimate website previously infected (e.g., cross-site scripting). Infection may only affect certain pages.\n\nUser awareness (avoiding suspicious sites) reduces the effectiveness.\nConsequences are similar to email infections.\nRestricted script execution (Java/JavaScript) in browsers can limit infection but may constrain navigation."
  },
  {
    "objectID": "exam_notes_en.html#phishing",
    "href": "exam_notes_en.html#phishing",
    "title": "Fundamental Security Services",
    "section": "Phishing",
    "text": "Phishing\n\nTechnique to collect private information through indiscriminate fishing.\nPhishing can be:\n\nGeneral (broad targeting)\nTargeted (spear phishing) for a specific person or organization.\n\nMain vector: forged email address, hard to detect.\nGoal: obtain sensitive data (credentials, passwords, personal or banking info).\nAttacks use credible or threatening pretexts to prompt victim cooperation.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nInformation theft by deception\nForged emails\nSpear phishing = targeted attack\nUrgent or threatening pretexts\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nPhishing\n\nThe word phishing comes from English “password”, “harvesting”, and “fishing”.\nShows the technique’s main goal: collect as much private info via indiscriminate fishing.\nTargeted attacks are called spear phishing (from spear fishing).\nTransmission vector: email with forged sender address requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.\nPretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored."
  },
  {
    "objectID": "exam_notes_en.html#phishing-1",
    "href": "exam_notes_en.html#phishing-1",
    "title": "Fundamental Security Services",
    "section": "Phishing",
    "text": "Phishing\n\nThe word phishing comes from English “password”, “harvesting”, and “fishing”.\nShows the technique’s main goal: collect as much private info via indiscriminate fishing.\nTargeted attacks are called spear phishing (from spear fishing).\nTransmission vector: email with forged sender address requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.\nPretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored."
  },
  {
    "objectID": "exam_notes_en.html#spam",
    "href": "exam_notes_en.html#spam",
    "title": "Fundamental Security Services",
    "section": "Spam",
    "text": "Spam\n\nUnwanted emails, often ads, or unsolicited pop-ups during web browsing.\nRepresent about 60% of global emails.\nMain consequences:\n\nResource consumption and time loss.\nSome can transmit malware.\n\nOften target short addresses or come from sold/exchanged address lists.\nAnti-spam filters incur significant costs for organizations.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nUnwanted emails/ads\nRisks: time/resource loss, malware\nTargeting: short addresses or lists\nFiltering costly for organizations\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nSpam\n\nIncludes all unwanted emails (often ads) received by people and organizations.\nAlso applies to pages/pop-up windows shown without user consent during web browsing.\nAround 60% of global emails belong to this category.\nConsequences: resource consumption and wasted time, but some spam can also transmit malware.\nOften target short email addresses or list-based addresses (sold/exchanged).\nAnti-spam filtering incurs high organizational costs."
  },
  {
    "objectID": "exam_notes_en.html#spam-1",
    "href": "exam_notes_en.html#spam-1",
    "title": "Fundamental Security Services",
    "section": "Spam",
    "text": "Spam\n\nIncludes all unwanted emails (often ads) received by people and organizations.\nAlso applies to pages/pop-up windows shown without user consent during web browsing.\nAround 60% of global emails belong to this category.\nConsequences: resource consumption and wasted time, but some spam can also transmit malware.\nOften target short email addresses or list-based addresses (sold/exchanged).\nAnti-spam filtering incurs high organizational costs."
  },
  {
    "objectID": "exam_notes_en.html#ransomware",
    "href": "exam_notes_en.html#ransomware",
    "title": "Fundamental Security Services",
    "section": "Ransomware",
    "text": "Ransomware\n\nTrojan-type malware that encrypts data to make it inaccessible.\nDemands a ransom (often in bitcoins) to recover files.\nCan remain dormant, triggered by an event or date.\nMain vector: malicious emails.\nOther effects: DoS attacks, extortion.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nData encrypted by Trojan\nRansom to restore access\nPossible programmed dormancy\nInfection via malicious emails\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nRansomware\n\nTrojan malware family.\nTypically encrypts victim’s data to make it completely inaccessible.\nThen displays a message requesting ransom payment (often in bitcoins).\nMay stay in dormant state triggered by event or date.\nInfection vectors vary, but malicious email attachments often responsible.\nVariants exist and continue to evolve.\nOther behaviors: DoS, targeted extortion, threats, etc."
  },
  {
    "objectID": "exam_notes_en.html#ransomware-1",
    "href": "exam_notes_en.html#ransomware-1",
    "title": "Fundamental Security Services",
    "section": "Ransomware",
    "text": "Ransomware\n\nTrojan malware family.\nTypically encrypts victim’s data to make it completely inaccessible.\nThen displays a message requesting ransom payment (often in bitcoins).\nMay stay in dormant state triggered by event or date.\nInfection vectors vary, but malicious email attachments often responsible.\nVariants exist and continue to evolve.\nOther behaviors: DoS, targeted extortion, threats, etc."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-internet-of-things-iot-devices",
    "href": "exam_notes_en.html#attacks-on-internet-of-things-iot-devices",
    "title": "Fundamental Security Services",
    "section": "Attacks on Internet of Things (IoT) Devices",
    "text": "Attacks on Internet of Things (IoT) Devices\n\nTarget connected objects (cameras, TVs, sensors, alarms, etc.).\nDevices are easy to compromise due to:\n\nKnown vulnerabilities\nDefault passwords\nUser unawareness\n\nRemote control enables:\n\nEntry point to the network\nDevice abuse for illicit activities (DDoS, hacking, mining)\n\nA precise inventory of connected devices is essential.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nTargets connected objects\nWeak security (vulnerabilities, default passwords)\nRisk of network access and abuse\nIoT inventory needed\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAttacks on IoT Devices\n\nTarget connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).\nOften easier to hack than traditional systems due to:\n\nMany vulnerabilities known to attackers\nDefault passwords\nUser negligence\n\nRemote takeover allows:\n\nEntry point to home/corporate network\nDevice use for illicit activities (hacking, DDoS, bitcoin mining)\n\nMaintaining a detailed directory of all connected devices is necessary."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-iot-devices",
    "href": "exam_notes_en.html#attacks-on-iot-devices",
    "title": "Fundamental Security Services",
    "section": "Attacks on IoT Devices",
    "text": "Attacks on IoT Devices\n\nTarget connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).\nOften easier to hack than traditional systems due to:\n\nMany vulnerabilities known to attackers\nDefault passwords\nUser negligence\n\nRemote takeover allows:\n\nEntry point to home/corporate network\nDevice use for illicit activities (hacking, DDoS, bitcoin mining)\n\nMaintaining a detailed directory of all connected devices is necessary."
  },
  {
    "objectID": "exam_notes_en.html#information-spoofing-and-website-defacement",
    "href": "exam_notes_en.html#information-spoofing-and-website-defacement",
    "title": "Fundamental Security Services",
    "section": "Information Spoofing and Website Defacement",
    "text": "Information Spoofing and Website Defacement\n\nAttacks aiming to alter information on websites and social media.\nImpact: compromised reputation and economic damage.\nWebsites: secure host system, restrictive configuration, regular audits.\nSocial media: strong passwords, multi-factor authentication, session closure, cookie deletion.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAltered info on websites and social media\nRisks: reputation, economic losses\nWebsites: security + audits\nSocial media: strong passwords, MFA, closed sessions, cookies cleared\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nInformation Spoofing and Website Defacement\n\nTarget integrity of published info on websites and social media.\nAffects reputation and can cause economic damage.\nWebsites: secure host system, as restrictive configuration as possible, recurring security audits recommended.\nSocial media: depends on authentication process:\n\nAvoid simple passwords\nPrefer strong, possibly multi-factor authentication\nClose sessions properly\nClear cookies"
  },
  {
    "objectID": "exam_notes_en.html#information-spoofing-and-website-defacement-1",
    "href": "exam_notes_en.html#information-spoofing-and-website-defacement-1",
    "title": "Fundamental Security Services",
    "section": "Information Spoofing and Website Defacement",
    "text": "Information Spoofing and Website Defacement\n\nTarget integrity of published info on websites and social media.\nAffects reputation and can cause economic damage.\nWebsites: secure host system, as restrictive configuration as possible, recurring security audits recommended.\nSocial media: depends on authentication process:\n\nAvoid simple passwords\nPrefer strong, possibly multi-factor authentication\nClose sessions properly\nClear cookies"
  },
  {
    "objectID": "exam_notes_en.html#denial-of-service-dos-ddos-attacks",
    "href": "exam_notes_en.html#denial-of-service-dos-ddos-attacks",
    "title": "Fundamental Security Services",
    "section": "Denial of Service (DoS / DDoS) Attacks",
    "text": "Denial of Service (DoS / DDoS) Attacks\n\nAim to make IT systems inaccessible, especially for organizations.\nDDoS: distributed attack using thousands of devices, generating massive traffic.\nClassic protections (firewalls, IDS/IPS sensors) often insufficient.\nConsequences:\n\nAffected reputation\nFinancial losses (sometimes ransom)\nHigh risk for critical infrastructure (hospitals, power plants, Internet backbone)\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nDDoS = inaccessible systems via massive attacks\nLimited protections\nRisks: reputation, finances, critical infrastructures\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nDenial of Service (DoS / DDoS) Attacks\n\nAim to render IT systems inaccessible, mainly targeting private or governmental organizations.\nDDoS (Distributed Denial of Service): multiple devices (often tens of thousands) simultaneously target victim system(s).\nTraffic can reach several hundred Gbps.\nTraditional protection (firewalls, intrusion detection/prevention sensors) has limited effectiveness.\nService unavailability can cause:\n\nReputational issues\nSignificant financial losses (ransom demands)\nHigh security risks (even physical) for critical infrastructures (hospitals, power plants, Internet backbone)."
  },
  {
    "objectID": "exam_notes_en.html#denial-of-service-dos-ddos-attacks-1",
    "href": "exam_notes_en.html#denial-of-service-dos-ddos-attacks-1",
    "title": "Fundamental Security Services",
    "section": "Denial of Service (DoS / DDoS) Attacks",
    "text": "Denial of Service (DoS / DDoS) Attacks\n\nAim to render IT systems inaccessible, mainly targeting private or governmental organizations.\nDDoS (Distributed Denial of Service): multiple devices (often tens of thousands) simultaneously target victim system(s).\nTraffic can reach several hundred Gbps.\nTraditional protection (firewalls, intrusion detection/prevention sensors) has limited effectiveness.\nService unavailability can cause:\n\nReputational issues\nSignificant financial losses (ransom demands)\nHigh security risks (even physical) for critical infrastructures (hospitals, power plants, Internet backbone)."
  },
  {
    "objectID": "exam_notes_en.html#cryptographic-hash-functions",
    "href": "exam_notes_en.html#cryptographic-hash-functions",
    "title": "Fundamental Security Services",
    "section": "Cryptographic Hash Functions",
    "text": "Cryptographic Hash Functions\n\nFunctions easy to compute in one direction but virtually impossible to reverse.\nAny modification of the source document radically changes the digest (avalanche effect).\nKey properties:\n\nOne-way: impossible to retrieve the input from the hash.\nCollision-free: impossible to find two inputs with the same hash.\n\nDigest size: 160 to 512 bits.\nAlgorithms (very performant): SHA-1, SHA-256, SHA-3.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nOne-way + collision-free.\nSize: 160-512 bits.\nAlgos: SHA-1/256/3.\nUsage: integrity, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nFunctions easy to compute in one direction but virtually impossible to compute in the reverse direction.\nAny modification (even insignificant) of the source document results in a fundamentally different digest.\nIt is virtually impossible to retrieve the source document using only the digest (one-way).\nIt is virtually impossible to find a second source document producing the same digest (collision-free).\nUsual digest length: 160 to 512 bits.\nOne-way algorithms are very performant.\nExamples: SHA-1, SHA-256, SHA-3, etc."
  },
  {
    "objectID": "exam_notes_en.html#pseudo-random-generators",
    "href": "exam_notes_en.html#pseudo-random-generators",
    "title": "Fundamental Security Services",
    "section": "(Pseudo) Random Generators",
    "text": "(Pseudo) Random Generators\n\nCharacteristics\n\nrandom\nunpredictable\nnon-reproducible\n\nCritical for security (keys, IV, secrets).\nTypes:\n\nTrue random: based on physical phenomena (radioactivity, quantum).\nPseudo-random: deterministic (based on a seed: initial random sequence).\n\nRisk: “Pseudo-security” if the seed is predictable (Pitkin quote).\nApplications: session keys, IV (DES-CBC), signatures (ElGamal).\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nTrue random: physical (quantum).\nPseudo-random: deterministic (seed).\nRisk: predictable seed = vulnerability.\nUses: keys, IV, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nRandom number generation is a very important process that can compromise the security of many encryption systems.\nApplications: session key generation, initialization vectors (DES - CBC mode), secrets for signatures (ElGamal), etc.\nA random generator is a device capable of generating numbers in a random, unpredictable and non-reproducible way. (e.g. based on physical phenomena: radioactive or quantum source).\nPseudo-random generators are deterministic processes developed from an initial random sequence (seed) (e.g. user keystrokes, disk access).\nQuote: R. Pitkin in [Kau95]: “The use of pseudo-random processes to generate secret quantities can result in pseudo-security”"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-cryptography",
    "href": "exam_notes_en.html#symmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Symmetric Cryptography",
    "text": "Symmetric Cryptography\n\nHistory: Used since Julius Caesar (1st century BC).\nPrinciple: A single key for encryption/decryption.\nScheme: Plaintext → Encryption (Key) → Ciphertext → Decryption (Key) → Plaintext.\nCharacteristics:\n\nAlgorithms: AES, DES, IDEA, RC4.\nServices: Confidentiality, Authentication, Integrity.\nLimit: No signatures (shared key).\nProblem: Secure key exchange required.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\n1 key to encrypt/decrypt.\nFast (AES, DES).\nProblem: key exchange.\nUses: personal documents, closed groups.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nAlso called conventional cryptography or secret key cryptography (1st century BC, Julius Caesar).\nIdea: Based on a single secret key, perform a transformation capable of respectively making information unreadable and restoring it.\nScheme: Plaintext \\(\\to\\) Encryption (Key) \\(\\to\\) Ciphertext \\(\\to\\) Decryption (Key) \\(\\to\\) Plaintext.\nCharacteristics:\n\nAlgorithms: AES, DES, IDEA, RC4, RC5, etc. (some are free and openly available)\nServices: Confidentiality, Authentication, Integrity.\nNo direct support for digital signatures (because key known by both).\nRequires a confidential channel to exchange the key.\nIdeal for protection of personal documents or closed groups."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography",
    "href": "exam_notes_en.html#asymmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography",
    "text": "Asymmetric Cryptography\n\nAlso called public cryptography (1976, Diffie & Hellman).\nPrinciple\n\nKey pair (public/private) for encryption and signatures.\n\nTwo main uses:\n\nConfidentiality:\n\nEncryption: recipient’s public key\nDecryption: recipient’s private key\n\nDigital signature:\n\nSignature: sender’s private key\nVerification: sender’s public key\nOptimization: Generally sign the hash of the document\nFundamental properties:\n\nIntegrity: Any modification invalidates the signature\nNon-collision: Impossible to have 2 documents with the same signature\nNon-repudiation: Only the holder of the private key can sign\n\n\n\nTechnical aspects:\n\nAlgorithms: RSA, ElGamal\nServices: Integrity, Authentication, Non-Repudiation\nPerformance: much slower than symmetric (100x slower)\nAdvantage: No need for a confidential channel for key exchange\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\n2 keys: public (encrypt/verify) + private (decrypt/sign)\n2 uses:\n\nConfidentiality: encrypt for a recipient\nSignature: prove authenticity\n\nSignatures:\n\nIntegrity + non-repudiation\n\nAlgorithms: RSA/ElGamal\nAdvantage: No need for secure channel to exchange keys\nDisadvantage: Slow\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography\n\nAlso called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).\nIdea: Use two different keys - one secret and one public - respectively for encryption and decryption operations.\nEach user has a keyring.\n\nConfidentiality: * Sender encrypts with the recipient’s public key. * Recipient decrypts with their private key. * Only the recipient’s key is used!\nDigital Signature: * Sender signs with their private key. * Recipient verifies with the sender’s public key. * Only the sender’s key is used! * Note: Generally sign the digest of the document (hash) for performance reasons.\nSignature characteristics: * The signature changes if the document changes, while the private key remains the same. * If the document or signature is modified, verification fails (integrity guaranteed). * It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function without collisions). * Only the holder of the private key can generate a signature verifiable using the corresponding public key (non-repudiation). * Algorithms: RSA, ElGamal. * Services: Integrity, Authentication, Non-Repudiation. * Slowness: Up to 50 times slower than symmetric cryptography. * Advantage: No need for a confidential channel to exchange keys (unlike symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography",
    "text": "Asymmetric Cryptography\n\nAlso called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).\nIdea: Use two different keys - one secret and one public - respectively for encryption and decryption operations.\nEach user has a keyring.\n\nConfidentiality: * Sender encrypts with the recipient’s public key. * Recipient decrypts with their private key. * Only the recipient’s key is used!\nDigital Signature: * Sender signs with their private key. * Recipient verifies with the sender’s public key. * Only the sender’s key is used! * Note: Generally sign the digest of the document (hash) for performance reasons.\nSignature characteristics: * The signature changes if the document changes, while the private key remains the same. * If the document or signature is modified, verification fails (integrity guaranteed). * It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function without collisions). * Only the holder of the private key can generate a signature verifiable using the corresponding public key (non-repudiation). * Algorithms: RSA, ElGamal. * Services: Integrity, Authentication, Non-Repudiation. * Slowness: Up to 50 times slower than symmetric cryptography. * Advantage: No need for a confidential channel to exchange keys (unlike symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-symmetric-cryptography-hybrid",
    "href": "exam_notes_en.html#asymmetric-symmetric-cryptography-hybrid",
    "title": "Fundamental Security Services",
    "section": "Asymmetric + Symmetric Cryptography (Hybrid)",
    "text": "Asymmetric + Symmetric Cryptography (Hybrid)\n\nPrinciple: Use asymmetric to exchange a symmetric key (session key).\nSteps:\n\nA generates a random symmetric key \\(K_s\\).\nA encrypts \\(K_s\\) with B’s public key.\nA and B then communicate using \\(K_s\\) (symmetric).\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAsymmetric: exchange of symmetric key.\nSymmetric: data encryption.\nAdvantage: combines security + performance.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nIdea: Use public cryptography only to exchange symmetric keys (Session keys).\nA generates a random key \\(K_s\\) and transmits it to B by encrypting it with B’s public key.\nA & B then communicate using \\(K_s\\) (symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-operation-rsa",
    "href": "exam_notes_en.html#asymmetric-cryptography-operation-rsa",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Operation (RSA)",
    "text": "Asymmetric Cryptography: Operation (RSA)\n\nKey Construction\n\nChoice of prime numbers:\n\n\\(p\\) and \\(q\\): two large prime numbers (&gt; 1024 bits)\n\\(n = pq\\): RSA modulus (size = 2048+ bits)\n\nCalculation of Euler’s totient function:\n\n\\(\\phi(n) = (p-1)(q-1)\\)\nProperty: For any \\(a\\) coprime with \\(n\\), \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\n\nSelection of exponents:\n\n\\(e\\): integer coprime with \\(\\phi(n)\\) (public exponent)\n\\(d\\): modular inverse of \\(e\\) (private exponent), such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\n\n\n\nEncryption/decryption process\n\nPublic key: \\((n,e)\\)\nPrivate key: \\((d)\\)\nEncryption: \\(C = P^e \\pmod{n}\\)\nDecryption: \\(P = C^d \\pmod{n}\\)\n\n\n\nMathematical proof\n\nFundamental congruence:\n\n\\(ed = 1 + k\\phi(n)\\) (by definition of \\(d\\))\n\nApplication of Euler’s theorem:\n\n\\(P^{\\phi(n)} \\equiv 1 \\pmod{n}\\) (if \\(P\\) coprime with \\(n\\))\n\nDemonstration:\n\\[\\begin{align*}\n(P^e)^d &\\equiv P^{ed} \\pmod{n} \\\\\n&\\equiv P^{1 + k\\phi(n)} \\pmod{n} \\\\\n&\\equiv P \\cdot (P^{\\phi(n)})^k \\pmod{n} \\\\\n&\\equiv P \\cdot 1^k \\pmod{n} \\\\\n&\\equiv P \\pmod{n}\n\\end{align*}\\]\n\n\n\nSystem security\n\nHard problem: Factorization of \\(n\\) into \\(p\\) and \\(q\\)\nRecommended size:\n\n\\(n\\): 2048 bits (minimum for current security)\n\\(p\\) and \\(q\\): 1024+ bits each\n\nKnown vulnerabilities:\n\nSide-channel attacks (timing, power analysis)\nInappropriate parameter choices (\\(e\\) too small, \\(p\\) and \\(q\\) too close)\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nKeys:\n\nPublic: \\((n,e)\\) where \\(n = pq\\)\nPrivate: \\((d)\\) with \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\nOperations:\n\nEncryption: \\(P^e \\mod n\\)\nDecryption: \\(C^d \\mod n\\)\n\nSecurity: Factorization of \\(n\\) difficult\nSize: 2048+ bits for \\(n\\)\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography: Operation (RSA)\n\nLet \\(n := pq\\) with \\(p\\) and \\(q\\) two large prime numbers (&gt; 1024 bits).\nLet \\(\\phi(n) = (p-1)(q-1)\\).\nLet \\(e\\) and \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nBy definition of congruences: \\(ed = 1 + k\\phi(n)\\)\nEuler’s theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption: \\(C = P^e \\pmod n\\). Public key: \\((n,e)\\).\nDecryption: \\(P = C^d \\pmod n\\). Private key: \\((d)\\).\nProof: \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-operation-rsa-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-operation-rsa-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Operation (RSA)",
    "text": "Asymmetric Cryptography: Operation (RSA)\n\nLet \\(n := pq\\) with \\(p\\) and \\(q\\) two large prime numbers (&gt; 1024 bits).\nLet \\(\\phi(n) = (p-1)(q-1)\\).\nLet \\(e\\) and \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nBy definition of congruences: \\(ed = 1 + k\\phi(n)\\)\nEuler’s theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption: \\(C = P^e \\pmod n\\). Public key: \\((n,e)\\).\nDecryption: \\(P = C^d \\pmod n\\). Private key: \\((d)\\).\nProof: \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-conclusions",
    "href": "exam_notes_en.html#asymmetric-cryptography-conclusions",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Conclusions",
    "text": "Asymmetric Cryptography: Conclusions\n\nDominant algorithms: RSA (most used), Rabin, ElGamal\nComplete services:\n\nConfidentiality\nAuthentication\nIntegrity\nDigital signature & Non-repudiation\nNon-duplication\n\nPerformance:\n\n50x slower than symmetric\nOptimal solution: Combination of asymmetric (key exchange) + symmetric (encryption)\n\nKey management:\n\nAdvantage: Public key exchange without confidential channel\nRisk: Need to verify authenticity of public keys\n\nAuthenticated acquisition channel or\nCertification by trusted third party\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAlgos: RSA (dominant), Rabin, ElGamal\nServices: Confidentiality + Authentication + Integrity + Signatures\nSlowness: 50x vs symmetric → hybrid recommended\nKeys: Simple public exchange but authentication crucial\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography: Conclusions\n\nThere are a few asymmetric encryption systems (Rabin, ElGamal, etc.) but the most used is RSA.\nSupported services: Confidentiality, Authentication, Integrity, Digital Signature & Non-Repudiation, (Non-Duplication).\nOperations related to asymmetric cryptography are up to 50 times (!) slower than those of symmetric cryptography. A combination of the two methods is often desirable.\nKey distribution is simplified by the fact that only public keys need to be exchanged between participants (no need for an alternative confidential channel) but…\n… it is necessary to verify that the public key actually belongs to the recipient:\n\nEither the acquisition channel of the public key is protected against any modification (authenticated)\nOr the key is certified accurate by a third party"
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-conclusions-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-conclusions-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Conclusions",
    "text": "Asymmetric Cryptography: Conclusions\n\nThere are a few asymmetric encryption systems (Rabin, ElGamal, etc.) but the most used is RSA.\nSupported services: Confidentiality, Authentication, Integrity, Digital Signature & Non-Repudiation, (Non-Duplication).\nOperations related to asymmetric cryptography are up to 50 times (!) slower than those of symmetric cryptography. A combination of the two methods is often desirable.\nKey distribution is simplified by the fact that only public keys need to be exchanged between participants (no need for an alternative confidential channel) but…\n… it is necessary to verify that the public key actually belongs to the recipient:\n\nEither the acquisition channel of the public key is protected against any modification (authenticated)\nOr the key is certified accurate by a third party"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs-asymmetric-comparison",
    "href": "exam_notes_en.html#symmetric-vs-asymmetric-comparison",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs Asymmetric Comparison",
    "text": "Symmetric vs Asymmetric Comparison\n\nComparative advantages\n\nSymmetric:\n\nPerformance: 100x faster\nImplementation: Easy in hardware\nKeys: Short (128 bits = 16 memorable characters)\n\nAsymmetric:\n\nKey exchange: Authenticated channel sufficient (no need for confidentiality)\nManagement: 1 key pair for n correspondents (vs n keys in symmetric)\n\n\n\n\nCommon issues\n\nWeak link: Key management by users\nSecurity basis: Empirical rather than theoretical\nLegal constraints: Usage and export restrictions\n\n\n\nUsage recommendations\n\n\n\n\n\n\n\n\nUse case\nRecommended solution\nJustification\n\n\n\n\nPersonal documents\nSymmetric\nSpeed + memorable keys\n\n\nGroups of close users\nSymmetric\nSpeed + easy confidential exchange\n\n\nDistant/unknown users\nAsymmetric\nNo need for confidential channel\n\n\nRemote transactions\nHybrid (Asymmetric + Symmetric)\nAsymmetric for key exchange, symmetric for data\n\n\nSoftware protection (distribution)\nHybrid\nUnique symmetric key per version, encrypted with asymmetric\n\n\nNetwork segments\nSymmetric\nSpeed + controlled environment (easy key exchange between administrators)\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nSymmetric:\n✅ Fast (100x)\n✅ Short keys (128 bits)\n❌ Confidential key exchange required\nAsymmetric:\n✅ Simplified key exchange\n✅ 1 key pair for n correspondents\n❌ Slow (50x)\n❌ Long keys (1024+ bits)\nHybrid: Best of both worlds Common problems: Key management, empirical basis, legal restrictions\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nSymmetric vs. Asymmetric Cryptography\n\nThere are hundreds of symmetric and asymmetric algorithms capable of providing a sufficient level of confidentiality.\nSymmetric solutions offer the following advantages:\n\nSpeed (up to 100 times faster than asymmetric solutions)\nEase of hardware implementation\nReduced key length: 128 bits (= 16 characters ⇒ memorable!) instead of 1024 bits for asymmetric equivalents.\n\nAsymmetric solutions have as main arguments:\n\nSimplified key exchange: keys must be exchanged through an authenticated but non-confidential channel\nSimplified key management: a single public/private key pair is sufficient for a user to receive confidential messages from n users (instead of n different keys in the symmetric case).\n\nProblems common to both techniques:\n\nKey management by the user remains the weakest link\nSecurity (normally) based on empirical arguments rather than theoretical ones\nLegal restrictions on usage and export\n\n\n\n\nSymmetric vs. Asymmetric Cryptography (II)\n\n\n\n\n\n\n\n\nActivity\nRecommendation\nRemarks\n\n\n\n\nProtection of personal documents\nSymmetric crypto\nSpeed, easily memorable keys\n\n\nProtection of documents in a group of close users\nSymmetric crypto\nSpeed, ease of exchanging confidential keys\n\n\nEstablishment of confidential channels between distant users (unknown)\nAsymmetric crypto\nNo need to have a confidential channel: authenticity suffices\n\n\nTransactions between two distant users, Software protection (multicast distribution)\nAsymmetric crypto for symmetric key protection + Symmetric crypto for data protection\nSpeed, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public\n\n\nProtection of network segments\nSymmetric crypto\nSpeed, Stable environment → easy confidential key exchange between sysadmins"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography",
    "href": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs. Asymmetric Cryptography",
    "text": "Symmetric vs. Asymmetric Cryptography\n\nThere are hundreds of symmetric and asymmetric algorithms capable of providing a sufficient level of confidentiality.\nSymmetric solutions offer the following advantages:\n\nSpeed (up to 100 times faster than asymmetric solutions)\nEase of hardware implementation\nReduced key length: 128 bits (= 16 characters ⇒ memorable!) instead of 1024 bits for asymmetric equivalents.\n\nAsymmetric solutions have as main arguments:\n\nSimplified key exchange: keys must be exchanged through an authenticated but non-confidential channel\nSimplified key management: a single public/private key pair is sufficient for a user to receive confidential messages from n users (instead of n different keys in the symmetric case).\n\nProblems common to both techniques:\n\nKey management by the user remains the weakest link\nSecurity (normally) based on empirical arguments rather than theoretical ones\nLegal restrictions on usage and export"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography-ii",
    "href": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography-ii",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs. Asymmetric Cryptography (II)",
    "text": "Symmetric vs. Asymmetric Cryptography (II)\n\n\n\n\n\n\n\n\nActivity\nRecommendation\nRemarks\n\n\n\n\nProtection of personal documents\nSymmetric crypto\nSpeed, easily memorable keys\n\n\nProtection of documents in a group of close users\nSymmetric crypto\nSpeed, ease of exchanging confidential keys\n\n\nEstablishment of confidential channels between distant users (unknown)\nAsymmetric crypto\nNo need to have a confidential channel: authenticity suffices\n\n\nTransactions between two distant users, Software protection (multicast distribution)\nAsymmetric crypto for symmetric key protection + Symmetric crypto for data protection\nSpeed, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public\n\n\nProtection of network segments\nSymmetric crypto\nSpeed, Stable environment → easy confidential key exchange between sysadmins"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-attack-lifecycle",
    "href": "exam_notes_en.html#ransomware-attack-lifecycle",
    "title": "Fundamental Security Services",
    "section": "Ransomware Attack Lifecycle",
    "text": "Ransomware Attack Lifecycle\n\nPrevention and Response\n\n\n\n\n\n\n\nPhase\nMeasures\n\n\n\n\nPrevention\n- Regular patching- Detection solutions (Firewalls, WAFs, IDS/IPS)- Anti-malware scans (emails, files)\n\n\nProtection\n- Offline backups (essential!)- Strict security policies- User training\n\n\nResponse\n- Do not pay (official recommendation)- Forensic analysis- Restoration from backups\n\n\n\n\n\nTechnical Dissection\n\nInfection:\n\nVectors: Phishing, exploits, vulnerable RDP\nPropagation: Lateral (network) or vertical (system)\n\nExecution:\n\nEncryption of targeted files\nDeletion of shadow copies\nPersistence (registry, scheduled tasks)\n\nExtortion:\n\nDisplay of ransom demand\nPayment in cryptocurrencies (Bitcoin, Monero)\nPayment deadlines with penalties\n\nObfuscation:\n\nCode obfuscation\nCommunication via TOR/Deep Web\nLog erasure\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nAttack cycle:\n\nInfection (phishing/exploits)\nExecution (encryption + persistence)\nExtortion (ransom in crypto)\nObfuscation (TOR + trace erasure)\n\nCountermeasures:\n✅ Offline backups\n✅ Patching + detection\n✅ Training\n❌ Do not pay"
  },
  {
    "objectID": "exam_notes_en.html#cryptolocker-technical-analysis",
    "href": "exam_notes_en.html#cryptolocker-technical-analysis",
    "title": "Fundamental Security Services",
    "section": "Cryptolocker: Technical Analysis",
    "text": "Cryptolocker: Technical Analysis\n\nAttack Scheme\n\n\n\n\n\ngraph TD\n    A[Initial infection] --&gt; B[File encryption]\n    B --&gt; C[Private key storage on C2 servers]\n    C --&gt; D[Ransom demand]\n    D --&gt; E{Payment ?}\n    E --&gt;|Yes| F[Decryption key sent via TOR]\n    E --&gt;|No| G[Permanent data loss]\n\n\n\n\n\n\n\n\nPreferred Targets\n\nCritical extensions (extract):\n\nDocuments: .docx, .xlsx, .pdf, .pptx\nDatabases: .mdb, .sql, .sqlite\nMedia: .jpg, .png, .mp4, .avi\nDevelopment: .java, .cpp, .py, .php\nFinancial: .qbw, .qbb, .wallet\n\nBehavior:\n\nSelective encryption (recent/modified files)\nDouble extortion: Encryption + threat of leakage\nRaaS (Ransomware-as-a-Service): Economic model\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nMechanism: - Private key stored on C2 servers - Payment → key via TOR - Targets: 100+ extensions (docs, DB, media)\nRecent evolutions: - Double extortion (encryption + leakage) - RaaS (ransomware rental)\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nRansomware: Complete View\n(Source: 2017 State of Cybersecurity, F-Secure Inc.)\n\n\nRansomware: Complete View\n\nPrevention, Remediation and Response\n\nPatching\nActive and passive detection (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)\nOffline backups !\nSecurity Policy - Rules for proper email usage\nTraining !\nTo pay or not to pay…\n\n\n\nTechnical Dissection of the Attack\n\nInfection and propagation\nExecution\nPayment (Crypto-currencies / Bitcoin)\nObfuscation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nGeneric Scheme of a Cryptolocker Ransomware\n\nDecryption private keys are stored on the attacker’s servers\nThey are sent to the victim after bitcoin payment\nThe trace is shredded using TOR networks\n\n\n\n\nRansomware Cryptolocker: Targets\nTargeted file extensions: .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource: Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-complete-view",
    "href": "exam_notes_en.html#ransomware-complete-view",
    "title": "Fundamental Security Services",
    "section": "Ransomware: Complete View",
    "text": "Ransomware: Complete View\n(Source: 2017 State of Cybersecurity, F-Secure Inc.)"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-complete-view-1",
    "href": "exam_notes_en.html#ransomware-complete-view-1",
    "title": "Fundamental Security Services",
    "section": "Ransomware: Complete View",
    "text": "Ransomware: Complete View\n\nPrevention, Remediation and Response\n\nPatching\nActive and passive detection (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)\nOffline backups !\nSecurity Policy - Rules for proper email usage\nTraining !\nTo pay or not to pay…\n\n\n\nTechnical Dissection of the Attack\n\nInfection and propagation\nExecution\nPayment (Crypto-currencies / Bitcoin)\nObfuscation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nGeneric Scheme of a Cryptolocker Ransomware\n\nDecryption private keys are stored on the attacker’s servers\nThey are sent to the victim after bitcoin payment\nThe trace is shredded using TOR networks"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-cryptolocker-targets",
    "href": "exam_notes_en.html#ransomware-cryptolocker-targets",
    "title": "Fundamental Security Services",
    "section": "Ransomware Cryptolocker: Targets",
    "text": "Ransomware Cryptolocker: Targets\nTargeted file extensions: .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource: Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_en.html#kerckhoffs-principle",
    "href": "exam_notes_en.html#kerckhoffs-principle",
    "title": "Fundamental Security Services",
    "section": "Kerckhoffs’ Principle",
    "text": "Kerckhoffs’ Principle\n\nFundamental principle: security relies solely on the key, not on the secrecy of the algorithm.\nThe system must remain secure even if the algorithm is public.\nThe key must be easily modifiable and the system simple to use.\nExplicit rejection of security through obscurity.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nSecurity based on the key\nPublic algorithm\nNo security through obscurity\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nKerckhoffs’ Principle\nAuguste Kerckhoffs published in 1883 two articles defining six principles for military ciphers:\n\nThe system must be practically, if not mathematically, undecipherable.\nIt must not require confidentiality and remain secure even if it falls into enemy hands.\nThe key must be able to be memorized, transmitted and modified easily, without written notes.\nThe system must be compatible with telegraphic communications.\nIt must be portable and usable by a single person.\nIt must be simple to use, without complex procedures or excessive constraints.\n\nKerckhoffs stated as early as the 19th century that security must be mathematically demonstrable and that there is no security through obscurity."
  },
  {
    "objectID": "exam_notes_en.html#kerckhoffs-principle-1",
    "href": "exam_notes_en.html#kerckhoffs-principle-1",
    "title": "Fundamental Security Services",
    "section": "Kerckhoffs’ Principle",
    "text": "Kerckhoffs’ Principle\nAuguste Kerckhoffs published in 1883 two articles defining six principles for military ciphers:\n\nThe system must be practically, if not mathematically, undecipherable.\nIt must not require confidentiality and remain secure even if it falls into enemy hands.\nThe key must be able to be memorized, transmitted and modified easily, without written notes.\nThe system must be compatible with telegraphic communications.\nIt must be portable and usable by a single person.\nIt must be simple to use, without complex procedures or excessive constraints.\n\nKerckhoffs stated as early as the 19th century that security must be mathematically demonstrable and that there is no security through obscurity."
  },
  {
    "objectID": "exam_notes_en.html#classification-of-encryption-systems",
    "href": "exam_notes_en.html#classification-of-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "Classification of Encryption Systems",
    "text": "Classification of Encryption Systems\n\nUnconditional Security\n(unconditional security / perfect secrecy)\n\nSecurity independent of computing power.\nCiphertext provides no information about the plaintext.\nConditions: key ≥ message, never reused.\nMostly theoretical use.\nExample: one-time pad.\n\n\n\nAs hard as / equivalent / provable security\n\nCryptanalysis as difficult as a hard mathematical problem.\nRSA and Rabin proven equivalent to factorization.\n\nDemonstrated by reduction (reduction proof).\n\nCentral but controversial concept.\n\n\n\nComputational Security\n(computational security / practical security)\n\nSecurity based on unrealistic cost of attacks.\nMost used category in practice.\nExamples: AES, DES, IDEA, RC4.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nUnconditional: perfect, theoretical (one-time pad).\nProvable security: equivalence to hard mathematical problem.\nComputational: secure in practice.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nUnconditional security (unconditional security also called perfect secrecy):\n\nThe security of the encryption system is not compromised by the computing power intended for cryptanalysis.\nThis category relies on information theory published by Shannon in 1949.\nMore precisely, an encryption system is unconditionally secure if the probability of encountering a plaintext x after observing the corresponding ciphertext y is identical to the a priori probability of encountering plaintext x.\nIn other words, having plaintext/ciphertext pairs (x,y) provides no help for cryptanalysis.\nA necessary condition for a system to be unconditionally secure is that the key be at least the same size as the message and, above all, that it not be reused to encrypt different messages.\nThis condition makes these systems poorly suited to usual cryptographic needs and reduces their domain of interest to a theoretical framework.\nThe classic example is the one-time pad invented in 1917 by J. Mauborgne and G. Vernam.\nTheoretical foundations of unconditionally secure systems + other examples in [Sti06].\n\nAs hard as / equivalent / provable security\n\nWhen it can be proven that cryptanalyzing the algorithm is as difficult as solving a reputedly hard mathematical problem.\nFor example factorization of large numbers, calculation of square roots modulo a composite, calculation of discrete logarithms in a finite group, etc.\nThe Rabin and RSA algorithms (generic case^1) are “proven” equivalent to factorization.\nSuch a proof is called a “reduction” (reduction proof).\nThe notion of provable security is at the origin of an important controversy in the cryptographic world.\n\nComputational security (computational security also called practical security)\n\nAn encryption system is in this category if the computational effort needed to “break” it using the best possible techniques is beyond (with a reasonable margin) the computing resources of a hypothetical adversary.\nThe vast majority of symmetric encryption systems (AES, DES, IDEA, RC4, etc.) are in this category."
  },
  {
    "objectID": "exam_notes_en.html#entropy",
    "href": "exam_notes_en.html#entropy",
    "title": "Fundamental Security Services",
    "section": "Entropy",
    "text": "Entropy\n\nEntropy (Shannon, 1948) measures the effective amount of information contained in a message.\nConditional entropy measures the uncertainty that remains about the plaintext after observing the ciphertext.\n\n\nProperties\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0\\) → no uncertainty\n\\(H(X) = \\log n\\) → all outcomes equally probable\n\n\n\nInterpretation\n\nApproximates the number of bits needed to encode \\(X\\).\nRedundancy = difference between effective encoding and entropy.\n\n\n\nConditional Entropy\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\)\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\nMeasures the remaining uncertainty about the plaintext after observing the ciphertext.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nEntropy: amount of information in a message.\nConditional entropy: uncertainty about plaintext after ciphertext.\nRedundancy: difference between effective encoding and entropy.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nAn essential definition in cryptography is the effective amount of information contained in a message.\nFor example, days of the week (Monday, …, Sunday) can intuitively be encoded as character strings of length (\\(\\le \\text{len}(\\text{``Wednesday''})\\)), i.e., \\((8 \\times 8 = 64)\\) bits. However, the effective amount of information of the variable day of the week can be optimally encoded on 3 bits (since \\((2^3 = 8)\\) is sufficient to represent the 7 possible variations).\nEntropy (Shannon, 1948) is the mathematical formalization of this definition.\n\n\nFormal Definition\nLet \\(X\\) be a random variable with a finite set of possible values \\({x_1, x_2, \\dots, x_n}\\), such that \\(P(X=x_i) = p_i\\), with \\(0 \\le p_i \\le 1\\) and \\(\\sum p_i = 1\\). The entropy of \\(X\\), denoted \\(H(X)\\), is defined by\n\\(H(X) = - \\sum_{i=1}^{n} p_i \\log p_i = \\sum_{i=1}^{n} p_i \\log \\left(\\frac{1}{p_i}\\right)\\)\nBy convention: \\(p_i \\log p_i = 0\\) if \\(p_i = 0\\). All logarithms are in base 2.\n\n\nInterpretation\n\nApproximation of the number of bits needed to encode the elements of \\(X\\).\nRedundancy is the difference between the effective encoding and entropy.\n\n\n\nProperties\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0 \\iff \\exists i : p_i = 1, p_j = 0 \\ \\forall j \\ne i\\)\n\\(H(X) = \\log n \\iff p_i = 1/n \\ \\forall i\\)\n\n\n\nConditional Entropy\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\),\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\n\nMeasures the uncertainty about \\(X\\) (plaintext) after having observed \\(Y\\) (ciphertext)."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-encryption-systems",
    "href": "exam_notes_en.html#attacks-on-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "Attacks on Encryption Systems",
    "text": "Attacks on Encryption Systems\n\nCiphertext-only: Adversary has only the ciphertext.\nKnown-plaintext: Adversary has plaintext/ciphertext pairs.\nChosen-plaintext: Adversary chooses the plaintext and see the ciphertext (and tries to find the plaintext for other messages).\nAdaptive chosen-plaintext: depends on the received ciphertexts.\nChosen-ciphertext: Adversary chooses the ciphertext and obtains the plaintext (aims to find the key).\nAdaptive Chosen-ciphertext: Chosen-ciphertext depends on the received plaintexts."
  },
  {
    "objectID": "exam_notes_en.html#oracles-and-security-models",
    "href": "exam_notes_en.html#oracles-and-security-models",
    "title": "Fundamental Security Services",
    "section": "Oracles and Security Models",
    "text": "Oracles and Security Models\n\nRandom Oracles and Security Models\n\nRandom Oracle: A theoretical “perfect” function that returns a uniform and random value for each new input, but remains deterministic for an input already seen.\nROM (Random Oracle Model): Mathematical proof framework using this ideal oracle as a substitute for hash functions.\nStandard Model: Framework where security relies solely on the adversary’s computing power against real algorithms.\nLimit: A security proof in ROM does not guarantee absolute security in the real world (with SHA-256, etc.).\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nA random oracle is an abstract entity accessible to legitimate parties and adversaries.\n\nBehavior: It responds to input queries \\(x\\) with perfectly random responses \\(Orc(x)\\).\nDeterminism: The only exception lies in previously processed inputs (\\(x_1, x_2, \\dots, x_n\\)). If \\(x_1' = x_1\\), then \\(Orc(x_1') = Orc(x_1)\\).\nModeling: It is modeled by a function \\(Orc : X \\to Y\\) where \\(\\forall x \\in X, \\Pr(Orc(x) = y) = \\frac{1}{|Y|}\\).\nUtility: It behaves like an “ideal” cryptographic hash function, a valuable tool for proving security in the Random Oracle Model.\nComparison: The standard model limits adversaries by computational factors. A protocol secure in the random oracle model can become vulnerable if used with a “real” hash function (SHA-1, SHA-256).\n\n\n\n\n\n\n\nEncryption, Decryption and Signature Oracles\n\nFunction: Entities that perform operations (encrypt/sign) for the adversary using secret keys without ever revealing them.\nSymmetric cryptography: The oracle provides \\(E_k(x)\\) or \\(D_k(y)\\).\nAsymmetric cryptography: The oracle is crucial for private operations (decryption/signature), as public operations are already freely accessible.\n\n\n\n\n\n\n\nNoneOriginal version: Operational Oracles\n\n\n\n\n\nAn encryption/decryption/signature oracle is an abstract entity offering an “on-demand” service.\n\nKey access: It uses the same keys as the legitimate owners (symmetric and asymmetric systems) without disclosing them.\nSymmetric primitives: For a primitive \\(E\\) and a key \\(k\\), it returns \\(y = E_k(x)\\) or the corresponding plaintext \\(x\\).\nPublic key systems: The oracle is only needed for operations with the private key (\\(priv_k\\)).\n\nDecryption: returns \\(x\\) such that \\(E'_{pubk}(x) = y\\).\nSignature: For a system \\(S\\), it returns \\(y = S_{privk}(x)\\).\n\nAttacks: The attack models using chosen plaintext (CPA) and chosen ciphertext (CCA) rely on making these oracles available to the adversary.\n\n\n\n\n\n\n\nIndistinguishability and Semantic Security (IND-CPA)\n\nProperty: An adversary must not be able to distinguish the ciphertexts of two different plaintext messages.\nIND-CPA (Indistinguishability under Chosen Plaintext Attack): If the adversary guesses the correct message only with a probability of \\(1/2 + \\epsilon\\), the system is considered secure.\nSemantic Security: Equivalent to IND-CPA, it ensures that no useful information leaks from the ciphertext.\n\n\n\n\n\n\n\nNoneOriginal version: Semantic Security\n\n\n\n\n\nCiphertext indistinguishability guarantees the inability to distinguish the ciphertexts of given plaintexts.\n\nExperiment (IND-CPA Security Game):\n\nThe adversary chooses two messages \\(M_0\\) and \\(M_1\\).\nThe oracle chooses a random index \\(i \\in \\{0,1\\}\\) and returns \\(c_i = E_k(M_i)\\).\nThe adversary can perform other calculations or oracle calls.\n\nIND-CPA Definition: The system is secure if the adversary’s advantage is negligible (\\(Prob = 1/2 + \\epsilon\\) with \\(\\epsilon\\) small).\nNote: In public key, the encryption oracle is useless because the adversary already possesses the public key. IND-CPA provides semantic security.\n\n\n\n\n\n\n\nProbabilistic Encryption and OAEP\n\nProblem: Deterministic encryption allows dictionary attacks (comparison of known ciphertexts).\nSolution: Add randomness to the message before encryption so that \\(E(M)\\) is different each time.\nOAEP (Optimal Asymmetric Encryption Padding): Standard used with RSA. It combines the message \\(P\\) with a random number \\(R\\) via hash functions \\(h\\) and XOR operations (\\(\\oplus\\)).\n\n\n\n\n\n\n\nNoneOriginal version: Determinism vs. Probabilism\n\n\n\n\n\nDeterministic behavior (same inputs = same outputs) creates vulnerabilities.\n\nExample: If Alice sends “Yes” or “No”, the adversary can compute \\(C_{yes} = E_{pub}(``Yes\")\\) and compare. They can create a codebook (dictionary) to identify messages without breaking the key.\nProbabilistic encryption: Adds randomness. The goal is semantic security for the public key.\nOAEP: Used in RSA-PKCS1. The text \\(P\\) is combined with randomness \\(R\\):\n\n\\(M_1 := P \\oplus h(R)\\)\n\\(M_2 := R \\oplus h(M_1)\\)\nEncryption applies to \\(M_1\\) and \\(M_2\\). During decryption, we recover \\(R = M_2 \\oplus h(M_1)\\), then \\(P = h(R) \\oplus M_1\\).\n\n\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nRandom Oracle: “Ideal” hash function (theoretical model).\nCPA/CCA Oracles: Simulate access to the secret key to test resistance.\nIND-CPA: Inability to distinguish two ciphertexts (Semantic Security).\nProbabilistic Encryption: Essential to counter codebooks (dictionary attacks).\nOAEP: Padding method adding the necessary randomness to RSA."
  },
  {
    "objectID": "exam_notes_en.html#history-of-cryptography-and-unconditional-security",
    "href": "exam_notes_en.html#history-of-cryptography-and-unconditional-security",
    "title": "Fundamental Security Services",
    "section": "History of Cryptography and Unconditional Security",
    "text": "History of Cryptography and Unconditional Security\n\nHistorical Encryption Systems\nCryptography was for a long time limited to the sole pursuit of confidentiality. Historical systems are based on two fundamental principles: substitution and transposition.\n\nCaesar Cipher (mono-alphabetic substitution): Fixed letter shift. Very vulnerable to frequency analysis.\nVigenère Cipher (polyalphabetic substitution): Uses a key to vary the shift. More complex, but breakable by identifying the key length.\nTransposition Cipher: Reorganization of the original text characters according to a permutation defined by a key.\n\n\n\n\n\n\n\nNoneOriginal version: Historical Cryptography\n\n\n\n\n\nFor centuries confidentiality was the only application of cryptography…\n\n1st century BC, Caesar Cipher: Mono-alphabetic substitution encryption \\(e_k(x) = (x + k) \\pmod{26}\\), \\(d_k(y) = (y - k) \\pmod{26}\\) where \\(x, y, k \\in \\mathbb{Z}_{26}\\).\n\nExample: \\(E_1(\\text{'hello'}) = \\text{'ifmmp'}\\).\nCryptanalysis: easy, based on character frequency.\n\n16th century, Vigenère: Polyalphabetic substitution encryption \\(e_k(x_1, \\dots, x_n) = (x_1 + k_1, \\dots, x_m + k_m, x_{m+1} + k_1, \\dots) \\pmod{26}\\).\n\nCryptanalysis: find the key length \\(m\\) by identifying repeated ciphertext portions and analyzing separate blocks as in the Caesar Cipher.\n\nTransposition Ciphers (Porta, 1563): The key defines a permutation on the plaintext.\nThese techniques are still the basis of modern encryption systems (ex: Enigma, qualified by W. Churchill as the secret weapon that won the war).\n\n\n\n\n\n\nThe One-Time Pad (OTP)\nThe One-Time Pad (OTP), or Vernam cipher, is the only system proven to be unconditionally secure (perfect secrecy).\n\nPrinciple: The message is combined with a key of the same length via the XOR operation (\\(\\oplus\\)).\nUnconditional Security: Observation of the encrypted message provides no information about the plaintext message. Even an adversary with infinite computing power cannot break it.\nShannon’s Constraints: The key must be as long as the message, purely random, and used only once.\nKey Reuse: If a key is reused for two messages, an attacker can eliminate the key by XOR (\\(y_a \\oplus y_b = x_a \\oplus x_b\\)) and recover the plaintext messages.\n\n\n\n\n\n\n\nNoneOriginal version: The One-Time Pad\n\n\n\n\n\nLet \\(n \\ge 1\\) and the spaces \\(P, C, K\\) such that \\(P, C, K = (\\mathbb{Z}_2)^n\\). The encryption and decryption operations of a one-time pad (Vernam Cipher) are: \\(E_k(x_i) = x_i \\oplus k_i\\) and \\(D_k(y_i) = y_i \\oplus k_i\\) for \\(1 \\le i \\le n\\).\n\nUnconditional security: If \\(k_i\\) are random and independent, observation of ciphertexts does not help cryptanalysis. The entropy of \\(X\\) does not decrease: \\(H(X|C) = H(X)\\).\nShannon’s Theorem: Necessary condition: \\(H(K) \\ge H(X)\\). The length of the random key must be at least as large as that of the plaintext.\nKey reuse: \\(y_a \\oplus y_b = x_a \\oplus x_b\\). With low-entropy messages, the plaintexts and the key (\\(k = y_a \\oplus x_a\\)) can be recovered.\nVulnerable to the Known Plaintext attack (if the key is reused).\nMajor problem: The distribution and management of large keys. Revived by quantum cryptography proposing confidential channels for unlimited-length key distribution.\n\n\n\n\n\n\nSteganography\nIn contrast to cryptography, which makes the message unreadable, steganography conceals the very existence of the message.\n\nMethod: Use a “subliminal channel” (an innocent medium like an image or a banal text).\nModern technique: Insertion of data into the least significant bits (LSB) of multimedia files, allowing the hiding of large volumes of data without visible alteration.\n\n\n\n\n\n\n\nNoneOriginal version: Steganography\n\n\n\n\n\nSteganography hides a message inside another. Constituent elements:\n\nA different physical or logical channel (subliminal channel).\nA secret mechanism to identify this channel.\n\n\nClassic examples: First letters of words in a text, invisible ink.\nModern example: Use the least significant bits of the frames of a Photo CD.\nFor a 2048x3072 image (RGB 24 bits), hiding a message using 1 bit allows storing 2.3 Mb without deteriorating quality.\n\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nHistory: Substitution (Caesar/Vigenère) and Transposition (permutation).\nOne-Time Pad: Absolute security if the key is random, unique, and as long as the message (\\(H(K) \\ge H(X)\\)).\nSteganography: Hiding the existence of the message (ex: LSB technique in images)."
  },
  {
    "objectID": "exam_notes_en.html#stream-ciphers-stream-encryption",
    "href": "exam_notes_en.html#stream-ciphers-stream-encryption",
    "title": "Fundamental Security Services",
    "section": "Stream Ciphers (Stream Encryption)",
    "text": "Stream Ciphers (Stream Encryption)\n\nIntroduction to Stream Ciphers\n\nDefinition and Principle\nStream ciphers are a family of encryption systems characterized by:\n\nUnit block size: each encrypted block = 1 bit\nTwo-phase architecture:\n\nKeystream generation: production of the key sequence\nSubstitution: operation on plaintext bits based on the keystream\n\n\nClassic example: the one-time pad\n\nGeneration: (pseudo-)random generator\nSubstitution: XOR operation (\\(\\oplus\\)) with the keystream\n\n\n\nGeneral Characteristics\nAdvantages:\n\nSpeed: encryption at register level, ideal for real-time streaming (video)\nLightweight: work on systems with limited CPU resources\nLow memory: little or no buffering needed\nNon-propagated errors: retransmission of defective packets is sufficient (suitable for wireless transmissions - WiFi)\n\nDisadvantages:\n\nDependency on keystream quality: randomness determines robustness\nDangerous reuse: keystream reuse allows easy cryptanalysis\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nStream Ciphers\n\nStream ciphers constitute a family of encryption systems where the size of the encrypted block is equal to 1 bit.\nStream ciphers are generally composed of two phases:\n\nA generation phase of the sequence of elements forming the key (the keystream).\nA substitution phase where the plaintext bits undergo a specific operation dependent on the keystream.\n\nAn obvious example of a stream cipher is the one-time pad with:\n\nA keystream generation phase performed by a (pseudo-)random generator.\nA substitution phase consisting of performing a xor (\\(\\oplus\\)) with the keystream.\n\n\n\n\nStream Ciphers: Characteristics\n\nSpeed: Encryption is done directly at the register level. Ideal for applications requiring “on the fly” encryption like video streaming.\nEase: Operations can be performed by systems with limited CPU resources.\nNo (or little…) need for memory/buffering.\nLimited or absent error propagation: retransmission of faulty packets is normally sufficient (suitable for applications where packet loss is frequent like wireless transmissions (WiFi)).\nDisadvantages:\n\nThe quality in terms of randomness of the generated keystream determines the system’s robustness.\nKeystream reuse allows easy cryptanalysis (cf. the one-time pad).\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nStream Ciphers = encryption bit by bit in 2 phases (keystream generation + substitution).\nAdvantages: fast, lightweight, no error propagation.\nDisadvantages: keystream quality critical, reuse = vulnerability.\n\n\n\n\n\n\n\nSynchronous Stream Ciphers\n\nOperating Principle\nIn a synchronous stream cipher, the keystream depends only on the key, independent of the plaintext and ciphertext.\nProcess equations:\n\\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nWhere:\n\n\\(\\sigma_i\\): state at time \\(i\\) (initial state \\(\\sigma_0\\) may depend on \\(k\\))\n\\(k\\): secret key\n\\(f\\): state transition function\n\\(g\\): keystream production function producing \\(z_i\\)\n\\(h\\): output function producing ciphertext \\(c_i\\) from plaintext \\(m_i\\)\n\n\n\n\n\n\ngraph LR\n    A[Key k] --&gt; B[State σi]\n    B --&gt; C[Function f]\n    C --&gt; D[State σi+1]\n    B --&gt; E[Function g]\n    E --&gt; F[Keystream zi]\n    F --&gt; G[Function h]\n    H[Plaintext mi] --&gt; G\n    G --&gt; I[Ciphertext ci]\n    D -.-&gt;|loop| B\n\n\n\n\n\n\n\n\nCharacteristics\nSynchronization requirement:\n\nTransmitter and receiver must share the same key \\(k\\) AND the same state \\(\\sigma_i\\)\nLoss of synchronization = need for external mechanisms (markers, redundancy analysis)\n\nProperties:\n\nNo error propagation: modification of ciphertext does not affect subsequent sequences\nAttention: deletion of a ciphertext = receiver desynchronization\n\nVulnerabilities to active attacks:\n\n✓ Detection: insertion, elimination, replay of fragments\n✗ Bit modification: adversary can modify bits and analyze impact on plaintext\nSolution: additional authentication mechanisms necessary\n\n\n\nSpecial case: Additive Stream Cipher\nThe most frequent case where:\n\nFunctions \\(f\\) and \\(g\\) replaced by a random generator\nFunction \\(h\\) = modulo 2 addition (XOR: \\(\\oplus\\))\n\nFormula: \\(c_i = z_i \\oplus m_i\\)\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nSynchronous Stream Ciphers\n\nThe generated keystream depends only on the key and not on the plaintext nor the ciphertext.\nThe encryption process of a synchronous stream cipher is described by the following equations: \\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] with \\(\\sigma_i\\) the initial state which may depend on the key \\(k\\), \\(f\\) the function determining the next state, \\(g\\) the function producing the keystream \\(z_i\\) and \\(h\\) the output function producing the ciphertext \\(c_i\\) from the plaintext \\(m_i\\).\n\n\n\nSynchronous Stream Ciphers: Characteristics\n\nRequire synchronization of the transmitter and receiver: In addition to using the same key \\(k\\), both must be in the same state for the process to work. If synchronization is lost, external mechanisms are needed to recover it (special markers, plaintext redundancy analysis, etc.)\nNo error propagation. Modification of the ciphertext during transmission does not cause disturbances in subsequent ciphertext sequences (however, the deletion of a ciphertext would cause desynchronization of the receiver).\nActive attacks: Insertion, elimination or replay of parts of ciphertext are detected by the receiver. However, an adversary could modify certain bits of the ciphertext and analyze the impact on the corresponding plaintext. Additional origin authentication mechanisms are necessary to detect these attacks.\nMost frequent case of Synchronous Stream Ciphers: the additive stream cipher (cf. the one-time pad) where the functions \\(f\\) and \\(g\\) generating the keystream are replaced by a random generator and the function \\(h\\) is a modulo 2 addition (xor).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nSynchronous: keystream = \\(f\\)(key only). Equations: \\(\\sigma_{i+1} = f(\\sigma_i, k)\\), \\(z_i = g(\\sigma_i, k)\\), \\(c_i = h(z_i, m_i)\\).\nRequires synchronization transmitter/receiver. No error propagation but vulnerable to bit modifications.\nFrequent case: additive cipher with XOR.\n\n\n\n\n\n\n\nAsynchronous Stream Ciphers\n\nOperating Principle\nAlso called self-synchronizing ciphers.\nThe keystream depends on the key AND a fixed number of previous ciphertexts.\nProcess equations:\n\\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nWhere \\(\\sigma_i\\) represents a buffer of the last \\(t\\) ciphertexts.\n\n\n\n\n\ngraph LR\n    A[Key k] --&gt; B[Function g]\n    C[Buffer: ci-t...ci-1] --&gt; B\n    B --&gt; D[Keystream zi]\n    D --&gt; E[Function h]\n    F[Plaintext mi] --&gt; E\n    E --&gt; G[Ciphertext ci]\n    G -.-&gt;|feedback| C\n\n\n\n\n\n\n\n\nCharacteristics\nSelf-synchronization:\n\nIn case of insertion/elimination of ciphertexts, the receiver automatically re-synchronizes\nMechanism: memorization (buffer) of the last ciphertexts\n\nLimited error propagation:\n\nError propagates only over the buffer size (\\(t\\) bits)\nAfter buffer exhaustion, correct decryption resumes\n\nSecurity against active attacks:\n\nBetter detection: modifications detected thanks to error propagation\nAttention: self-synchronization allows receiver to continue even after insertions/deletions\nSolution: verification of integrity and authenticity of entire stream necessary\n\nDiffusion of plaintext statistics:\n\nEach plaintext bit influences all subsequent ciphertexts\nResult: better dispersion of statistics vs. synchronous case\nApplication: use for low entropy or highly redundant plaintexts\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nAsynchronous Stream Ciphers\n\nAlso called self-synchronizing ciphers.\nThe generated keystream depends on the key as well as a fixed number of previous ciphertexts.\nThe encryption process of an asynchronous stream cipher is described by the following equations: \\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] with \\(\\sigma_i\\), \\(g\\) and \\(h\\) as for the synchronous case.\n\n\n\nAsynchronous Stream Ciphers: Characteristics\n\nSelf-synchronization: In case of elimination or insertion of ciphertexts along the way, the receiver is capable of re-synchronizing with the transmitter thanks to the memorization (buffer) of a number of previous ciphertexts.\nLimited error propagation: Error propagation extends only to the number of ciphertext bits memorized (buffer size). Afterwards, decryption proceeds correctly again.\nActive attacks: Modification of ciphertext fragments will be more easily detected than in the synchronous case because of error propagation. However, since the receiver is capable of self-synchronizing with the transmitter, even if ciphertexts are eliminated or inserted along the way, it is necessary to verify the integrity and authenticity of the entire stream.\nDiffusion of plaintext statistics: The fact that each plaintext bit will influence all subsequent ciphertexts results in a greater dispersion of statistics compared to the synchronous case…\n… It is therefore advisable to use asynchronous stream ciphers when the entropy of plaintexts is limited and could allow targeted attacks on highly redundant plaintexts.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nAsynchronous (self-synchronizing): keystream = \\(f\\)(key + last ciphertexts). State \\(\\sigma_i\\) = buffer of \\(t\\) previous ciphertexts.\nAutomatic self-synchronization. Limited error propagation to buffer.\nBetter diffusion of statistics → ideal for redundant/low entropy plaintexts.\n\n\n\n\n\n\n\nKeystream Generators: LSFR\n\nContext and Necessity\nProblem: generate a keystream of length \\(m\\) from a secret key of length \\(l\\) with \\(l \\ll m\\).\nSolution: Linear Feedback Shift Register (LSFR or LFSR)\n\n\nLSFR Characteristics\nAdvantages:\n\nOptimal hardware implementation: very efficient circuits\nLong periods: sequences of great length\nGood random quality: notable randomness\nMathematical basis: algebraic properties of linear combinations\n\nGeneric structure: LSFR of length \\(L\\)\n\n\n\n\n\ngraph LR\n    A[bit L-1] --&gt; B[bit L-2]\n    B --&gt; C[...]\n    C --&gt; D[bit 1]\n    D --&gt; E[bit 0]\n    E --&gt; F[Output]\n    A -.-&gt;|feedback| G[⊕]\n    D -.-&gt;|coeff| G\n    C -.-&gt;|coeff| G\n    G --&gt; A\n\n\n\n\n\n\n\n\nImportant Remarks on LSFR\nHistory and Usage:\n\nVery widespread construction in cryptography and coding theory\nMany military stream ciphers based on LSFR\n\nSecurity Limits:\n\nInsufficient security level compared to modern block ciphers\nVulnerability: the Berlekamp-Massey algorithm allows to:\n\nDetermine the linear complexity of an LSFR\nCalculate an arbitrary number of generated sequences\n\n\nMetric: Linear complexity (linear complexity)\nImprovement Solution:\nReplace the linear combination with a non-linear function \\(f\\)\n→ Non Linear Feedback Shift Registers (NLFSR)\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nStream Ciphers: Keystream Generators\n\nWhen it is necessary to generate a keystream of length \\(m\\) from a secret key of length \\(l\\) with \\(l \\ll m\\), we call upon keystream generators.\nThe most common of these generators is the Linear Feedback Shift Register (LSFR).\nAn LSFR has the following characteristics:\n\nAdapts very well to hardware implementations.\nProduces sequences of long periods and with notable random quality (quite strong randomness)\nBased on the algebraic properties of linear combinations.\n\n\n\n\nLSFRs: Some Remarks\n\nLSFRs are very widespread constructions in cryptography and coding theory.\nA large number of stream ciphers based on LSFRs (especially in the military sphere) were developed in the past.\nUnfortunately, the security level offered by these systems is deemed insufficient nowadays (compared to that of block ciphers…)\nThe metric allowing analysis of an LFSR is its linear complexity. The Berlekamp-Massey algorithm allows determining the linear complexity of an LSFR and thus calculating an arbitrarily large number of sequences generated by an LSFR.\nA solution to increase complexity is to substitute the linear combination of ciphertext bits with a non-linear function \\(f\\). These are the Non Linear Feedback Shift Registers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nLSFR: long keystream generator (\\(m\\)) from short key (\\(l\\)). Base = linear combinations.\nAdvantages: efficient hardware, long periods.\nProblem: insufficient security, vulnerable to Berlekamp-Massey (linear complexity calculation).\nSolution: NLFSR (non-linear function).\n\n\n\n\n\n\n\nRC4: Software Stream Cipher\n\nGeneral Presentation\nRC4™ (Rivest Cipher 4) developed in 1987 by Ron Rivest for RSA Security.\nMain characteristics:\n\nVariable key: flexible length\nExtremely fast: 10× faster than DES\nSynchronous mode: keystream independent of plaintext/ciphertext\n\nHistory:\n\n1987-1994: patented, details confidential (NDA contract required)\n1994: unofficial publication in a newsgroup\nSince then: intensive analysis by cryptographic community\n\n\n\nArchitecture\nKey components:\n\nS-box: 8×8 substitution box (256 entries)\n\nContent: permutation of numbers 0 to 255\nDepends on the main key of variable length: \\(0 &lt; len(k) \\leq 255\\)\n\nCombinations: linear and non-linear\nFinal encryption: XOR between keystream and plaintext\n\n\n\nApplications and Security\nCommercial uses (numerous):\n\nLotus Notes\nOracle SQL\nMicrosoft Windows\nSSL/TLS\nAnd many more…\n\nAnalyses and Vulnerabilities:\n\nExhaustive work on key scheduling and PRGA\nMajor flaw: implementation in WEP (WiFi Wired Equivalent Privacy)\n\nWEP protocol completely compromised\nProblem: faulty usage mode, not the RC4 algorithm itself\n\n\n\n\nOperation\nRC4 decomposes into two steps:\n\nKey Scheduling Algorithm (KSA)\n\nResponsible for initial permutation of the S-box\nFunction of the variable length key \\(len(k) = l\\)\n\nPseudo Random Generator Algorithm (PRGA)\n\nGenerates keystream of arbitrary size\nRelies on S-box permuted by KSA\n\n\n\n\n\n\n\ngraph TB\n    A[Variable length key k] --&gt; B[KSA: Key Scheduling]\n    B --&gt; C[Permuted S-box]\n    C --&gt; D[PRGA: Generation]\n    D --&gt; E[Keystream zi]\n    E --&gt; F[XOR]\n    G[Plaintext mi] --&gt; F\n    F --&gt; H[Ciphertext ci]\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nSoftware Cipher Streams: RC4\n\nThe major disadvantage of stream ciphers based on registers is that they are very slow in programmed version on a generic machine. RC4™ is a variable key stream cipher developed in 1987 by Ron Rivest for RSA security. It is very fast (10 times faster than DES !)\nFor 7 years, this algorithm was patented and its internal operational details were disclosed only after signing a confidentiality contract. Since its (unofficial) publication in a newsgroup in 1994, it has been widely discussed and analyzed by the entire cryptographic community.\nThe algorithm works in synchronous mode (the keystream is independent of the ciphertext and plaintext).\nIt is composed of linear and non-linear combinations. The key element is an 8×8 substitution box (S-box) whose entries are a permutation of the numbers 0 to 255. The permutation is a function of the main key of variable size with \\(0 &lt; len(k) \\leq 255\\). The final encryption is obtained by a xor between the keystream and the plaintext.\nRC4 is used in a large number of commercial applications: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. It is the subject of a large number of analytical and exhaustive works that have managed to compromise the security of the key scheduling and the PRGA.\nIn particular the application of RC4 to the Wired Equivalent Privacy (WiFi WEP) protocol has been “broken” due to a flaw in the protocol’s usage mode.\n\n\n\nRC4: Operation\n\nThe algorithm consists of two steps:\n\nThe Key Scheduling Algorithm (KSA): Responsible for the initial permutation that will fill the S-box depending on the variable length key \\(len(k) = l\\).\nThe Pseudo Random Generator Algorithm (PRGA): Generates the keystream of arbitrary size relying on the S-box.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nRC4: software stream cipher, variable key, 10× faster than DES.\nArchitecture: 8×8 S-box (permutation 0-255) + XOR.\n2 steps: KSA (S-box permutation) + PRGA (keystream generation). Synchronous mode.\nVulnerability: WEP broken (usage flaw). Used in SSL, Windows, Oracle…"
  },
  {
    "objectID": "exam_notes_en.html#block-ciphers-block-encryption",
    "href": "exam_notes_en.html#block-ciphers-block-encryption",
    "title": "Fundamental Security Services",
    "section": "Block Ciphers (Block Encryption)",
    "text": "Block Ciphers (Block Encryption)\n\n1. Introduction to Block Ciphers\n\nDefinition and Principle\nA block cipher is a cryptographic function that:\n\nTransforms fixed-size blocks: maps a block of \\(n\\) bits to another block of the same size\nIs parameterized by a key: the key \\(K\\) of \\(k\\) bits defines the transformation\nMust be bijective: to allow unique decryption\nEach key = different bijection: guarantees variability\n\nNominal size: input block size on which encryption is applied\n\n\nQuality Criteria\n1. Key size/Entropy\n\nKeys ideally equiprobable with entropy = \\(k\\) bits\nStrong entropy protects against brute-force attacks\nMinimum required: 128 bits for modern block ciphers\n\n2. Performance\n\nExecution speed\nSoftware/hardware efficiency\n\n3. Block size\n\nToo small block = vulnerability to plaintext/ciphertext dictionaries\nModern standard: blocks ≥ 128 bits\n\n4. Cryptographic resistance\n\nResistance to known techniques:\n\nLinear cryptanalysis\nDifferential cryptanalysis\nMeet in the middle\n\nCryptanalysis effort equivalent to brute force\n\n\n\n\n\n\ngraph LR\n    A[Plaintext n bits] --&gt; B[Block Cipher]\n    C[Key K k bits] --&gt; B\n    B --&gt; D[Ciphertext n bits]\n    \n    style B fill:#e1f5ff\n    style C fill:#fff4e1\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\nBlock Ciphers\n\nSymmetric block ciphers constitute the cornerstone of cryptography. Their main functionality is confidentiality but they are also the basis for authentication, hashing functions, random generation, etc.\nDefinition: A block cipher is a function that maps a block of \\(n\\) bits to another block of the same size. The function is parameterized by a key \\(K\\) of \\(k\\) bits. To allow unique decryption, the function must be bijective. Each key defines a different bijection. The input block size on which encryption is applied is also called nominal algorithm size.\nCriteria to evaluate the quality of a block cipher:\n\nKey size/Entropy: Ideally, keys are equiprobable and the key space has an entropy equal to \\(k\\). A strong key entropy protects against brute-force attacks from chosen/known plaintexts. Modern block ciphers must have keys of at least 128 bits.\nPerformance\nBlock size: A too small block would allow attacks where plaintext/ciphertext “dictionaries” could be built. Nowadays, blocks of size ≥ 128 bits are becoming common.\nCryptographic resistance: The block cipher must show resistance to known cryptanalysis techniques: linear or differential cryptanalysis, meet in the middle, etc. The inherent effort of these attacks (complexity, storage, parallelization, etc.) must be equivalent to that of a brute force attack.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nBlock cipher: bijective function transforming blocks of \\(n\\) bits with key \\(K\\) of \\(k\\) bits. Criteria: key entropy ≥ 128 bits, block size ≥ 128 bits, cryptanalysis resistance = brute force effort. Usage: confidentiality, authentication, hashing, random generation.\n\n\n\n\n\n\n\n2. Block Cipher Modes of Operation\n\n2.1 Electronic Codebook (ECB)\nPrinciple: each plaintext block is encrypted independently with the same key.\n\\[c_i = E_K(m_i)\\] \\[m_i = D_K(c_i)\\]\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        P1[Plaintext Block 1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext Block 1]\n        \n        P2[Plaintext Block 2] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext Block 2]\n    end\n    \n    style E1 fill:#ffcccc\n    style E2 fill:#ffcccc\n    style K1 fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\nCharacteristics:\n\n✗ Identical plaintexts → identical ciphertexts (predictable)\n✓ No error propagation: error on \\(c_j\\) affects only \\(m_j\\)\n✗ Visible patterns: plaintext structure transparent in ciphertext\n✓ Parallelizable: each block processed independently\n\n⚠️ Major vulnerability: Should NOT be used for redundant data\n\n\n\n2.2 Cipher Block Chaining (CBC)\nPrinciple: each plaintext block is XORed with the previous ciphertext before encryption.\n\\[c_i = E_K(m_i \\oplus c_{i-1})\\] \\[m_i = D_K(c_i) \\oplus c_{i-1}\\]\nWith \\(c_0 = IV\\) (Initialization Vector)\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        IV[IV] --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext c1]\n        \n        C1 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ccffcc\n    style E2 fill:#ccffcc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ Patterns erased: chaining masks the structure\n✓ Limited error propagation: error on \\(c_j\\) affects \\(m_j\\) and \\(m_{j+1}\\) only\n✗ Not parallelizable in encryption (sequential)\n✓ Parallelizable in decryption\n\nIV (Initialization Vector):\n\nMust be random or pseudo-random\nCan be transmitted in clear\nMust be different for each message with the same key\n\n\n\n\n2.3 Cipher Feedback Mode (CFB)\nPrinciple: works like a stream cipher where the keystream is generated by the block cipher. The keystream depends on previous ciphertexts (asynchronous mode).\n\\[c_i = m_i \\oplus E_K(c_{i-1})\\] \\[m_i = c_i \\oplus E_K(c_{i-1})\\]\nWith \\(c_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph CFB_Encryption\n        IV[IV / ci-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        C1 -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#ffccff\n    style X1 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ Chaining: dependencies between ciphertexts\n⚠️ Error propagation: error on \\(c_j\\) affects \\(\\frac{n}{r}\\) following blocks\n\n\\(n\\) = nominal size of block cipher\n\\(r\\) = size of plaintexts\n\n✗ Not parallelizable\n⚠️ IV non-confidential but must be transmitted\n\nUsage: suitable for transmissions with frequent packet loss\n\n\n\n2.4 Output Feedback Mode (OFB)\nPrinciple: works like a synchronous stream cipher. The keystream is entirely determined by the key and IV, independent of plaintext and ciphertext.\n\\[z_i = E_K(z_{i-1})\\] \\[c_i = m_i \\oplus z_i\\] \\[m_i = c_i \\oplus z_i\\]\nWith \\(z_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph OFB_Mode\n        IV[IV / zi-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; Z[zi keystream]\n        Z --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        Z -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#cce5ff\n    style X1 fill:#ffffcc\n    style Z fill:#e1ffe1\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ No error propagation: error on \\(c_j\\) affects only \\(m_j\\)\n✓ Pre-computable keystream: efficient\n⚠️ CRITICAL: NEVER reuse the same IV with the same key (otherwise identical keystream)\n✓ Parallelizable if keystream pre-computed\n\n⚠️ Reuse warning: Change IV for each new message!\n\n\n\n\n\n\nNote📄 Original text (CFB and OFB Modes)\n\n\n\n\n\nCFB and OFB Modes: Characteristics\nThe CFB and OFB modes work as a stream cipher with a keystream generated by the encryption block. In CFB, the keystream depends on previous ciphertexts (asynchronous) whereas in OFB, the keystream is entirely determined by the key and the IV (synchronous).\nParticularities of CFB:\n\nAs in CBC mode, identical plaintexts are translated into different ciphertexts if the IV changes. The IV is not necessarily confidential and can be exchanged in clear between parties.\nChaining also introduces dependencies between current ciphertexts and previous ciphertexts. In particular, if \\(n\\) is the nominal algorithm size and \\(r\\) is the plaintext size, the current ciphertext will depend on the \\(\\frac{n}{r}\\) previous ciphertexts (each iteration will shift the faulty input by \\(r\\) positions, after \\(\\frac{n}{r}\\) iterations the faulty ciphertext will be completely “expelled”).\nError propagation follows the same principle: an error in a ciphertext will result in incorrect decryption of the \\(\\frac{n}{r}\\) following ciphertexts.\n\nParticularities of OFB:\n\nOFB has identical behavior to CBC and CFB modes for encryption of identical plaintexts.\nNo error propagation on adjacent ciphertexts.\nModify the IV if the key does not change to avoid keystream reuse !!!\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (CFB/OFB)\n\n\n\n\n\nCFB (asynchronous): keystream = \\(f\\)(previous ciphertexts). Limited error propagation (\\(\\frac{n}{r}\\) blocks).\nOFB (synchronous): keystream = \\(f\\)(key + IV only). No error propagation.\nCRITICAL: NEVER reuse same IV with same key. IV transmissible in clear.\n\n\n\n\n\n\n2.5 Counter Mode (CTR)\nPrinciple: the keystream is generated by encryption of a counter incremented at each block.\n\\[c_i = m_i \\oplus E_K(counter + i)\\] \\[m_i = c_i \\oplus E_K(counter + i)\\]\n\n\n\n\n\ngraph TB\n    subgraph CTR_Mode\n        CTR1[Counter + 0] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; C1[Ciphertext c1]\n        \n        CTR2[Counter + 1] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ffe6cc\n    style E2 fill:#ffe6cc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Synchronous mode: keystream = \\(f\\)(counter)\n✓ Parallelizable: keystream pre-computable for encryption AND decryption\n✓ Random access: each block decryptable independently\n✓ No error propagation\n✓ Benefits from SIMD architectures: no dependencies between blocks\n⚠️ Counter: must be of size \\(2^b\\) (\\(b\\) = block size)\n⚠️ CRITICAL: NEVER reuse the same counter with the same key\n\nCounter management:\n\nIncrement modulo \\(2^b\\) after each iteration\nSolution: always increment for each encrypted stream\nFirst block of stream \\(i+1\\) &gt; last block of stream \\(i\\)\n\nApplications:\n\nATM (Asynchronous Transfer Mode)\nIPsec (IP security)\nHigh-speed lines: selective transmission of blocks\nLarge volume transfers: video\n\n\n\n\n\n\n\nNote📄 Original text (Counter Mode)\n\n\n\n\n\n\nCounter Mode (CTR Mode)\nFrequently used as encryption support in data transfer protocols like ATM (Asynchronous Transfer Mode) and IPsec (IP security).\n\n\nCounter Mode (II)\n\nThe keystream is generated by the encryption of a random counter of size \\(2^b\\) (with \\(b\\) the block size) and necessary for decryption. This counter is incremented modulo \\(2^b\\) after each iteration.\nWorks in synchronous mode. Reuse of the same counter results in an identical keystream !\nSolution: Always increment the counter for each encrypted stream such that the counter of the first block of a stream is larger than the last block of the previous stream.\nEasily parallelizable: The keystream can be pre-calculated both for encryption and decryption. Fully benefits from SIMD architectures because unlike other chaining modes there are no dependencies between operations of different blocks.\nRandom access to encryption/decryption of each block: Unlike other chaining modes where the \\(i\\)-th operation depends on the \\((i-1)\\)-th operation.\nIf we add absence of error propagation, the counter mode facilitates selective (re)transmission of ciphertext blocks, making it very attractive for securing high-speed lines as well as for encrypted transfers of large volumes of information (e.g. video).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (Counter Mode)\n\n\n\n\n\nCTR: keystream = \\(E_K\\)(counter + \\(i\\)).\nAdvantages: parallelizable (encryption + decryption), random access, no error propagation, SIMD-friendly.\nCRITICAL: never reuse counter.\nUsage: ATM, IPsec, high speed, video.\n\n\n\n\n\n\n\n3. Product Ciphers and Feistel Ciphers\n\nProduct Ciphers\nDefinition: encryption scheme combining a series of successive transformations to strengthen resistance to cryptanalysis.\nCommon transformations:\n\nTranspositions (permutations)\nSubstitutions (S-boxes)\nXORs\nLinear combinations\nModular multiplications\n\n\n\nFeistel Ciphers\nDefinition: iterative product cipher with specific structure.\nOperating principle:\n\nInput: plaintext of \\(2t\\) bits = \\((L_0, R_0)\\) (two sub-blocks of \\(t\\) bits)\nOutput: ciphertext of \\(2t\\) bits = \\((R_r, L_r)\\) after \\(r\\) steps (rounds)\nEach step: invertible bijection (for unique decryption)\n\nEquations of step \\(i\\) (\\(1 \\leq i \\leq r\\)):\n\\[(L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\]\nWith:\n\n\\(L_i = R_{i-1}\\)\n\\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph Feistel_Round\n        L0[Li-1] --&gt; R1[Ri = Li-1 ⊕ f]\n        R0[Ri-1] --&gt; L1[Li = Ri-1]\n        R0 --&gt; F[Function f]\n        K[Key Ki] --&gt; F\n        F --&gt; XOR[⊕]\n        L0 --&gt; XOR\n        XOR --&gt; R1\n    end\n    \n    style F fill:#ffcccc\n    style XOR fill:#ffffcc\n    style K fill:#fff4e1\n\n\n\n\n\n\nCharacteristics:\n\n\\(K_i\\): subkeys generated from the main key \\(K\\)\nNumber of steps \\(r\\): generally even and \\(\\geq 3\\)\n\nExample: DES has 16 steps\n\nFinal permutation: \\((L_r, R_r) \\rightarrow (R_r, L_r)\\)\nDecryption: identical to encryption but subkeys applied in reverse order (from \\(K_r\\) to \\(K_1\\))\n\nFrequent operations:\n\nPermutations\nSubstitutions (S-boxes)\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\nProduct Ciphers and Feistel Ciphers\n\nA product cipher is an encryption scheme combining a series of successive transformations to strengthen resistance to cryptanalysis. Common transformations for a product cipher are: transpositions, substitutions, XORs, linear combinations, modular multiplications, etc.\nA Feistel cipher is an iterative product cipher capable of transforming a plaintext of \\(2t\\) bits of the form \\((L_0, R_0)\\) composed of two sub-blocks \\(L_0\\) and \\(R_0\\) of \\(t\\) bits into a ciphertext of size \\(2t\\) of the form \\((R_r, L_r)\\) after \\(r\\) successive steps (rounds) with \\(r \\geq 1\\). Each step defines a bijection (inversible !) to allow unique decryption.\nPermutations and substitutions are the most frequent operations.\nThe steps \\(1 \\leq i \\leq r\\) are written: \\((L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\) with \\(L_i = R_{i-1}\\) and \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\). The \\(K_i\\) are sub-keys, different for each step, generated from the main key \\(K\\) of the encryption scheme.\nThe number of steps proper to a Feistel cipher is normally even and \\(\\geq 3\\) (e.g. DES has 16 steps)\nAfter execution of all steps, a Feistel cipher performs a permutation of the two parts \\((L_r, R_r)\\) into \\((R_r, L_r)\\).\nThe decryption of a Feistel Cipher is identical to encryption except that the sub-keys \\(K_i\\) are applied in reverse order (From \\(K_r\\) to \\(K_1\\)).\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nProduct cipher: combination of successive transformations (transpositions, substitutions, XOR).\nFeistel cipher:\n\niterative product cipher\nplaintext \\(2t\\) bits = \\((L_0, R_0)\\)\n\\(r\\) rounds with \\(L_i = R_{i-1}\\) and \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\).\nDecryption = encryption with reversed sub-keys.\nExample: DES (16 rounds).\n\n\n\n\n\n\n\n\n4. Data Encryption Standard (DES)\n\nGeneral Presentation\nDES (Data Encryption Standard): most important cryptographic algorithm until the advent of AES in 2001.\nMain characteristics:\n\nType: Feistel Cipher\nBlock size: 64 bits (nominal size)\nKey size: 56 effective bits (64 total bits with 8 parity bits)\nNumber of steps: 16 rounds\nSubkeys: 16 subkeys of 48 bits (one per step)\nUsage modes: ECB, CBC, CFB, OFB\n\n\n\n\n\n\ngraph TB\n    subgraph DES_Overview\n        P[Plaintext 64 bits] --&gt; DES[DES Encryption]\n        K[Key 56 bits] --&gt; DES\n        DES --&gt; C[Ciphertext 64 bits]\n        \n        C --&gt; DES_INV[DES Decryption]\n        K2[Key 56 bits] --&gt; DES_INV\n        DES_INV --&gt; P2[Plaintext 64 bits]\n    end\n    \n    style DES fill:#ffcccc\n    style DES_INV fill:#ccffcc\n    style K fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\n\n\nDES Structure\nMain components:\n\nInitial permutation (IP): permutation of the 64 input bits\n16 Feistel rounds: iterative transformation\nFinal permutation (IP⁻¹): inverse of IP\n\nEach round applies:\n\nDivision into two halves: \\(L_{i-1}\\) and \\(R_{i-1}\\) (32 bits each)\nFunction \\(f\\) on \\(R_{i-1}\\) with subkey \\(K_i\\)\nXOR with \\(L_{i-1}\\)\nExchange of halves\n\n\n\n\n\n\ngraph TB\n    Plain[Plaintext 64 bits] --&gt; IP[Initial Permutation IP]\n    IP --&gt; Split[Split L0, R0]\n    \n    Split --&gt; Round1[Round 1]\n    K1[K1] --&gt; Round1\n    Round1 --&gt; Round2[Round 2]\n    K2[K2] --&gt; Round2\n    Round2 --&gt; Dots[...]\n    Dots --&gt; Round16[Round 16]\n    K16[K16] --&gt; Round16\n    \n    Round16 --&gt; Swap[Swap R16, L16]\n    Swap --&gt; IP_inv[Final Permutation IP⁻¹]\n    IP_inv --&gt; Cipher[Ciphertext 64 bits]\n    \n    style IP fill:#e1f5ff\n    style IP_inv fill:#e1f5ff\n    style Round1 fill:#ffcccc\n    style Round2 fill:#ffcccc\n    style Round16 fill:#ffcccc\n\n\n\n\n\n\n\n\nDES Cipher Function\nThe function \\(f\\) for each round:\n\nExpansion E: 32 bits → 48 bits (table E)\nKey Addition: XOR with subkey \\(K_i\\) (48 bits)\nS-boxes: 8 S-boxes transform 48 bits → 32 bits\n\nEach S-box: 6 bits input → 4 bits output\n\nPermutation P: permutation of the resulting 32 bits\n\n\n\n\n\n\ngraph TB\n    R[Ri-1 32 bits] --&gt; E[Expansion E]\n    E --&gt; E_out[48 bits]\n    E_out --&gt; XOR1[⊕]\n    K[Ki 48 bits] --&gt; XOR1\n    XOR1 --&gt; S[8 S-boxes]\n    S --&gt; S_out[32 bits]\n    S_out --&gt; P[Permutation P]\n    P --&gt; F_out[f output 32 bits]\n    \n    style E fill:#cce5ff\n    style S fill:#ffcccc\n    style P fill:#e1ffe1\n    style XOR1 fill:#ffffcc\n\n\n\n\n\n\nS-box operation:\nInput: \\(a_1a_2a_3a_4a_5a_6\\) (6 bits)\n\nRow: \\(a_1 + 2a_6\\) (external bits)\nColumn: \\(a_2 + 2a_3 + 4a_4 + 8a_5\\) (internal bits)\nOutput: value of the corresponding cell (4 bits)\n\n\n\nSubkey Generation\nProcess:\n\nMain key: 64 bits (56 effective + 8 parity)\nPermuted Choice 1 (PC-1): selection of 56 bits\nDivision into two halves: \\(C_0\\) and \\(D_0\\) (28 bits each)\nFor each round \\(i\\):\n\nLeft circular rotation of \\(C_{i-1}\\) and \\(D_{i-1}\\)\nPermuted Choice 2 (PC-2): selection of 48 bits for \\(K_i\\)\n\n\nRotations:\n\nRounds 1, 2, 9, 16: 1 position\nOther rounds: 2 positions\n\n\n\n\n\n\n\nNote📄 Original text (DES Operation)\n\n\n\n\n\nDES: Operation\nCipher Function\n\nExpansion E: The 32 bits of the input are transformed into a vector of 48 bits using the table E. The first line of this table indicates how the first sub-block of 6 bits will be generated: first take the 32nd bit then bits 1,2,3,4,5. The second sub-block starts with the 4th bit then bits 5,6,7,8,9 and so on…\nKey addition: XOR of the 48-bit vector with the key.\nS-boxes: Apply 8 S-boxes on the resulting 48-bit vector. Each of these S-boxes takes a 6-bit sub-block and transforms it into a 4-bit sub-block. The operation is performed as follows: If we denote the 6 input bits of the S-box as: \\(a_1a_2a_3a_4a_5a_6\\). The output is given by the content of the cell located in the row \\(a_1 + 2a_6\\) and the column \\(a_2 + 2a_3 + 4a_4 + 8a_5\\).\nPermutation P: Permutation P works as follows: The first bit is sent to the 16th position, the second to the 7th position and so on.\n\nPermutations IP and IP⁻¹\n\nAct respectively at the beginning and at the end of the block processing and on the entirety of the 64 bits.\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (DES)\n\n\n\n\n\nDES: Feistel cipher, 64-bit blocks, 56-bit effective key, 16 rounds.\nFunction \\(f\\): Expansion E (32→48 bits) → XOR \\(K_i\\) → 8 S-boxes (48→32 bits) → Permutation P.\nS-box: 6 bits input → 4 bits output via table (row = external bits, column = internal bits).\nPermutations: IP (initial) and IP⁻¹ (final) on 64 bits.\n\n\n\n\n\n\n\n5. Triple-DES and DES Security\n\nDES Vulnerabilities\nMain problem: key space size \\(\\{0,1\\}^{56}\\) insufficient.\nBrute force attack:\n\n1999: key found in 24 hours\nTechnique: massively parallel brute force (100,000 PCs on Internet)\nKnown plaintext attack\n\n\n\nTriple-DES (3DES)\nSolution: increase key space to \\(\\{0,1\\}^{112}\\).\nScheme:\n\\[C = E_{K_1}(D_{K_2}(E_{K_1}(P)))\\]\nWith:\n\n\\(E\\): DES encryption\n\\(D\\): DES decryption\n\\(K_1, K_2\\): two 56-bit keys\n\n\n\n\n\n\ngraph LR\n    P[Plaintext 64 bits] --&gt; E1[DES Encrypt K1]\n    E1 --&gt; D[DES Decrypt K2]\n    D --&gt; E2[DES Encrypt K1]\n    E2 --&gt; C[Ciphertext 64 bits]\n    \n    K1a[Key K1 56 bits] --&gt; E1\n    K2[Key K2 56 bits] --&gt; D\n    K1b[Key K1 56 bits] --&gt; E2\n    \n    style E1 fill:#ffcccc\n    style D fill:#ccffcc\n    style E2 fill:#ffcccc\n\n\n\n\n\n\nAdvantages:\n\n✓ Satisfactory security: key space \\(2^{112}\\)\n✓ Compatibility: reuse of existing DES hardware/software\n✓ Gradual migration: while waiting for AES\n\nDisadvantage:\n\n✗ Performance: 3× slower (3 successive DES executions)\n\n\n\nDES Properties\n1. DES is not a group\nDES is NOT a group under composition:\n\\[\\nexists K_3 \\text{ such that } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)\\]\nConsequence: composite encryption (Triple-DES) considerably increases security.\nIf DES were a group: exhaustive search on \\(\\{0,1\\}^{56}\\) would break the algorithm regardless of the number of consecutive executions.\n2. Weak and semi-weak keys\n\nWeak key: \\(E_K(E_K(x)) = x\\)\nPair of semi-weak keys: \\(E_{K_1}(E_{K_2}(x)) = x\\)\n\nCharacteristic: weak keys generate identical subkeys in pairs:\n\n\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)\nFacilitates cryptanalysis\n\nDES has 4 weak keys:\n\n\n\nWeak key (hexadecimal)\n\n\n\n\n0101 0101 0101 0101\n\n\n0101 0101 FEFE FEFE\n\n\nFEFE FEFE FEFE FEFE\n\n\nFEFE FEFE 0101 0101\n\n\n\nAnd 6 pairs of semi-weak keys\n\n\n\n\n\n\nNote📄 Original text (DES and 3DES)\n\n\n\n\n\n\nDES and Triple-DES\n\nThe size of the key set (\\(\\{0,1\\}^{56}\\)) constitutes the greatest threat weighing on DES with current computing resources. In 1999 it took only 24 hours to find the key from a known plaintext using a massively parallel brute force technique (100,000 PCs connected to the Internet).\nTriple DES protects us from these brute force attacks by increasing the possible key space to \\(\\{0,1\\}^{112}\\).\nThis alternative allows continuing to use DES “boxes” (hardware and software) while waiting for migration to AES.\nThe security level obtained by this solution is very satisfactory.\nThe performance impact of three successive DES executions remains a disadvantage for some applications.\n\n\n\nDES: properties\n\nDES is not a group (in the algebraic sense) under composition: In other words, DES being a permutation: \\(\\{0,1\\}^{64} \\rightarrow \\{0,1\\}^{64}\\), if DES were a group under composition, this would mean that: \\(\\exists K_3\\) such that \\(E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)\\)\nThis property ensures that composite encryption (like Triple-DES) considerably increases the security of DES. If DES were a group, exhaustive search on the possible key set (\\(\\{0,1\\}^{56}\\)) would allow “breaking” the algorithm regardless of the number of consecutive executions of DES.\nWeak and semi-weak keys (weak and semi-weak keys):\n\nA key \\(K\\) is said to be weak if \\(E_K(E_K(x)) = x\\).\nA pair of keys \\((K_1, K_2)\\) is said to be semi-weak if \\(E_{K_1}(E_{K_2}(x)) = x\\).\n\nWeak keys have the particularity of generating identical subkeys in pairs (\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)), which facilitates cryptanalysis.\nDES has 4 weak keys (and 6 pairs of semi-weak keys).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (3DES and security)\n\n\n\n\n\nDES vulnerability: key space \\(2^{56}\\) breakable in 24h (1999). Triple-DES: \\(E_{K_1}(D_{K_2}(E_{K_1}(P)))\\), space \\(2^{112}\\), reuses DES hardware, 3× slower. DES ≠ group → composite encryption strengthens security. 4 weak keys generating identical subkeys in pairs → facilitates cryptanalysis.\n\n\n\n\n\n\n\n6. Advanced Encryption Standard (AES)\n\nGeneral Presentation\nAES (Advanced Encryption Standard): standard adopted in November 2001.\nDesign: Johan Daemen and Vincent Rijmen (original name: Rijndael)\nMain characteristics:\n\nType: iterative block cipher (but NOT a Feistel Cipher)\nBlock size: 128 bits\nVariable key size: 128, 192 or 256 bits\nNumber of rounds: depends on key size\n\n10 rounds for 128-bit key\n12 rounds for 192-bit key\n14 rounds for 256-bit key\n\nUsage modes: ECB, CBC, CFB, OFB, CTR\n\nAdvantages over DES:\n\n✓ Open process: consultation and analysis by worldwide experts\n✓ ~2× more performant in software\n✓ ~10²² times more secure (theoretically)\n✓ Scalable: key size can be increased if necessary\n\n\n\nAES Structure\nBasic unit: State matrix of 4 rows × 4 columns (for 128-bit key)\n\nEach element = 1 byte\nTotal: 16 bytes = 128 bits\n\nOperations on field \\(GF(2^8)\\):\n\nByte = element of \\(GF(2^8)\\)\nFinite field of polynomials of degree ≤ 7 with coefficients in \\(GF(2)\\)\nAdditions, multiplications defined in \\(GF(2^8)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph State_Matrix\n        S00[s0,0] --- S01[s0,1]\n        S01 --- S02[s0,2]\n        S02 --- S03[s0,3]\n        \n        S10[s1,0] --- S11[s1,1]\n        S11 --- S12[s1,2]\n        S12 --- S13[s1,3]\n        \n        S20[s2,0] --- S21[s2,1]\n        S21 --- S22[s2,2]\n        S22 --- S23[s2,3]\n        \n        S30[s3,0] --- S31[s3,1]\n        S31 --- S32[s3,2]\n        S32 --- S33[s3,3]\n    end\n    \n    style S00 fill:#ffe6cc\n    style S11 fill:#ffe6cc\n    style S22 fill:#ffe6cc\n    style S33 fill:#ffe6cc\n\n\n\n\n\n\n\n\nAES Round Detail\nFour operations per round:\n1. SubBytes (ByteSub)\n\nNon-linear substitution via S-box\nEach byte transformed independently\nResistance to linear and differential cryptanalysis\n\n2. ShiftRows\n\nPermutation of bytes with variable shifts per row\nRow 0: no shift\nRow 1: left shift 1 position\nRow 2: left shift 2 positions\nRow 3: left shift 3 positions\n\n3. MixColumns\n\nEach column = linear combination of other columns\nMatrix multiplication in \\(GF(2^8)\\)\nMaximum diffusion\n\n4. AddRoundKey\n\nXOR of the State matrix with the round subkey\nSubkey = result of Key Schedule\n\n\n\n\n\n\ngraph TB\n    Input[State Input] --&gt; SB[SubBytes]\n    SB --&gt; SR[ShiftRows]\n    SR --&gt; MC[MixColumns]\n    MC --&gt; ARK[AddRoundKey]\n    K[Round Key] --&gt; ARK\n    ARK --&gt; Output[State Output]\n    \n    style SB fill:#ffcccc\n    style SR fill:#ccffcc\n    style MC fill:#cce5ff\n    style ARK fill:#ffffcc\n\n\n\n\n\n\nFinal round: identical EXCEPT no MixColumns\n\n\nKey Schedule (Subkey Generation)\nProcess:\n\nKey Expansion: generation of an extended matrix\n\nKey 128 bits → matrix 4 × 4 × (\\(N_e\\) + 1) bytes\n\\(N_e\\) = number of rounds\n\nKey Selection: extraction of subkeys\n\nFirst subkey: first 4 columns\nSecond subkey: next 4 columns\nEtc.\n\n\nOperations:\n\nByte rotations\nSubstitutions via S-box\nXOR with constants (Rcon)\n\n\n\nAES Pseudo-code\nRijndael(State, CipherKey) {\n    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule\n    \n    AddRoundKey(State, ExpandedKey[0..3]); // Initial XOR\n    \n    for(i = 1; i &lt; Ne; i++) {\n        Round(State, ExpandedKey[4*i...(4*i)+3]);\n    }\n    \n    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Without MixColumns\n}\n\n\nAES Decryption\nPrinciple: apply the inverse operations in each round.\nInverse operations:\n\nInvSubBytes: inverse substitution via S-box⁻¹\nInvShiftRows: right shifts (instead of left)\nInvMixColumns: inverse matrix multiplication\nAddRoundKey: self-inverse (XOR)\n\nOrder: inverse of encryption with subkeys in reverse order\n\n\n\n\n\n\nNote📄 Original text (AES)\n\n\n\n\n\nAdvanced Encryption Standard (AES)\n\nAdopted as standard in November 2001, designed by Johan Daemen and Vincent Rijmen (hence its original name Rijndael).\nIt is also an iterative block cipher (like DES) but not a Feistel Cipher.\nPlaintext/Ciphertext Blocks: 128 bits.\nVariable key length: 128, 192, or 256 bits.\nUnlike DES, AES comes from an open consultation and analysis process involving worldwide experts.\nTechniques similar to DES (substitutions, permutations, XOR…) complemented by simple and very performant algebraic operations.\nAll operations are performed in the field \\(GF(2^8)\\): the finite field of polynomials of degree ≤ 7 with coefficients in \\(GF(2)\\).\nIn particular, a byte for AES is an element in \\(GF(2^8)\\) and the operations on bytes (additions, multiplications,…) are defined as in \\(GF(2^8)\\).\n~2 times more performant (in software) and ~10²² times (in theory…) more secure than DES…\nScalable: The key size can be increased if necessary.\n\n\nDetail of an AES Step (round)\nThe basic unit on which calculations are applied is a matrix of 4 rows and 4 columns (in the case of a 128-bit key) whose elements are bytes:\n\nByteSub: Non-linear operation (S-box) designed to resist linear and differential cryptanalysis.\nShiftRow: Permutation of bytes introducing variable shifts on the rows.\nMixColumn: Each column is replaced by linear combinations of the other columns (matrix multiplication !)\nAddRoundKey: XOR of the current matrix with the subkey corresponding to the current step.\n\n\n\nAES: Global Operation\n\nThe number of steps of AES varies depending on the key size. For a 128-bit key, 10 steps must be performed. Each increase of 32 bits in the key size entails an additional step (14 steps for 256-bit keys).\nDecryption consists of applying the inverse operations in each of the steps (InvSubBytes, InvShiftRows, InvMixColumns). AddRoundKey (because of XOR) is its own inverse.\nThe Key Schedule consists of:\n\nAn operation of key expansion of the main key. If \\(N_e\\) is the number of steps (depending on the key), a matrix of 4 rows and 4 × (\\(N_e\\) + 1) columns is generated.\nAn operation of step key selection: The first subkey will be constituted by the first 4 columns of the matrix generated during expansion and so on.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (AES)\n\n\n\n\n\nAES (Rijndael 2001): iterative block cipher (NOT Feistel), 128-bit blocks, keys 128/192/256 bits → 10/12/14 rounds.\nState: 4×4 byte matrix in \\(GF(2^8)\\).\n4 operations/round:\n\nSubBytes (non-linear S-box)\nShiftRows (row shifts)\nMixColumns (linear combinations)\nAddRoundKey (XOR subkey).\n\n2× faster than DES, 10²² times more secure.\n\n\n\n\n\n\n\n7. Attacks and AES Security\n\nAES Strengths\nSimplicity and performance:\n\n✓ Simple and efficient algorithm\n✓ Works on limited platforms (8-bit smart cards)\n✓ Hardware and software optimizations\n\n\n\nPublished Attacks\n1. Algebraic attacks (2002)\nXSL technique (N. Courtois and P. Pieprzyk):\n\nRepresents AES as system of 8000 quadratic equations with 1600 binary unknowns\nEstimated effort: \\(2^{100}\\) operations (still a conjecture)\nCharacteristic: requires few known plaintexts\nDistinction: different from linear/differential attacks\n\nCritique: based on the “highly algebraic” character of AES (largely contested)\n2. Related Key Attacks (2009-2011)\nPrinciple: attacks based on similar keys\n\nInteresting results on reduced versions of AES\nDo not compromise full AES\n\n3. Side Channel Attacks\nPrinciple: attacks on implementation (not the algorithm)\nTechniques:\n\nCache timing attacks: cache access analysis\nPower analysis: power consumption\nElectromagnetic analysis: electromagnetic emissions\n\nExample (2005): Osvik, Shamir, Tromer\n\nExtraction of 128-bit key with 6-7 plaintext/ciphertext pairs\nBased on cache access analysis\n\n4. Meet in the Middle on biclique structures (2011-2015)\nResult:\n\nReduces effort for AES-128 to \\(2^{126}\\) (factor 4 vs brute force)\nRemains well above current capabilities\n\n\n\nPractical Security\nFundamental assumption: key of maximum entropy\nRecent attacks (WPA2, etc.):\n\nExploit weakness of passwords/passphrases\nNo flaw in AES itself\nProblem: key generation from weak passwords\n\n⚠️ Critical reminder: key quality = system security\n\n\n\n\n\n\nNote📄 Original text (AES Attacks)\n\n\n\n\n\n\nAES: Final Remarks and Attacks (I)\n\nThe greatest strength of AES lies in its simplicity and its performance, including on reduced computing capacity platforms (e.g. smart cards with 8-bit processors).\nSince its official publication, many cryptanalysis works have been published with very interesting results. In particular, N. Courtois and P.Pieprzyk presented a technique called XSL allowing to represent AES as a system of 8000 quadratic equations with 1600 binary unknowns. The effort needed to break this system is estimated (it is still a conjecture…) to be \\(2^{100}\\).\nThese attacks are based on the highly algebraic character (and largely contested…) of AES. Moreover, only a few known plaintexts are needed to set them up, which distinguishes them from linear and differential attacks.\nIn recent years (2009-2011) attacks based on similar keys (related key attacks) have obtained interesting results on reduced versions of AES.\nAnother family of attacks called side channel attacks acting directly on the algorithm implementation allows extracting cryptographically relevant information during encryption execution.\n\n\n\nAES: Final remarks and Attacks (II)\n\nIn 2015 a Meet in the Middle type attack based on biclique structures showed that it was possible to reduce the effort needed to find an AES-128 key to \\(2^{126}\\), i.e., a factor of 4 compared to brute force. This nevertheless remains well above current computing capabilities.\nAnother family of attacks called side channel attacks acting directly on the algorithm implementation allows extracting cryptographically relevant information during encryption execution. In particular, the authors manage to extract the 128-bit key with only 6-7 plaintext/ciphertext pairs based on cache accesses.\nThe security of AES (as for any other encryption algorithm) is always based on the assumption of a key of maximum entropy. The attacks published recently on protocols based on AES (like WPA2) exploit the weakness of passwords/passphrases that are the origin of the keys used.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (AES Security)\n\n\n\n\n\nStrengths: simplicity, performance (even 8-bit cards). Attacks: XSL (\\(2^{100}\\), algebraic), related keys (reduced versions), side channel (implementation, cache), Meet-in-Middle biclique (\\(2^{126}\\)). Security: assumption of max entropy key. Practical attacks = weak passwords, not AES flaw.\n\n\n\n\n\n\n\n8. Block Cipher Cryptanalysis Techniques\n\n8.1 Differential Cryptanalysis\nPrinciple: chosen plaintext attack analyzing the propagation of differences between two plaintexts through the rounds.\nMethod:\n\nChoose two plaintexts with known difference: \\(x_a\\) and \\(x_b\\)\nObserve propagation: \\(\\Delta x = x_a \\oplus x_b\\)\nAnalyze ciphertexts: \\(\\Delta y = y_a \\oplus y_b\\)\nAssign probabilities to keys according to observed changes\nMost probable key = correct key (after many trials)\n\nCharacteristics:\n\nRequires \\(2^{47}\\) chosen plaintext pairs for DES\nProbabilities: depend on S-boxes and structure\nThe more pairs increase, the more success probability increases\n\nSensitivity: very sensitive to number of rounds\n\nChances of success increase exponentially when rounds decrease\n\n\n\n8.2 Linear Cryptanalysis\nPrinciple: known plaintext attack creating a linear simulator of the block cipher.\nMethod:\n\nCreate linear approximations of the algorithm\nAnalyze a large number of plaintext/ciphertext pairs\nThe bits of the simulator key tend to coincide with those of the real key (probabilistic calculation)\n\nComplexity for DES:\n\n\\(2^{38}\\) known plaintexts → 10% probability of guessing correctly\n\\(2^{43}\\) known plaintexts → 85% success probability\n\nCharacteristics:\n\nMost powerful analytical attack to date on block ciphers\nAlso sensitive to number of rounds\n\n\n\n8.3 Differential vs Linear Comparison\nCommon difficulties:\n\n✗ Parallelization: less efficient than parallel brute force\n⚠️ Sensitivity to rounds: efficiency decreases exponentially with number of rounds\n\nDES and these attacks:\n\nWidespread conjecture: DES designers knew these attacks (1970s, unpublished at the time)\nS-box design: very high resistance to both techniques\n\n\n\n8.4 Meet-in-the-Middle Attack\nPrinciple: exploits composite constructions of type \\(y = E_{K_2}(E_{K_1}(x))\\).\nMethod:\n\nBuild list \\(L_1\\): \\(L_1 = \\{E_{K_1}(x) \\mid K_1 \\in \\text{KeySpace}\\}\\)\nBuild list \\(L_2\\): \\(L_2 = \\{D_{K_2}(y) \\mid K_2 \\in \\text{KeySpace}\\}\\)\nIdentify repeated elements in \\(L_1\\) and \\(L_2\\)\nVerify hypothesis with second known plaintext\nThe associated keys \\(K_1\\) and \\(K_2\\) are probably the sought keys\n\nExample for DES:\nIntuitive key space for \\(E_{K_2}(E_{K_1}(x))\\): \\(\\{0,1\\}^{112}\\)\nActual effort:\n\n\\(2^{57}\\) operations to establish the two lists\n\\(2^{56}\\) blocks of 64 bits storage\nSignificantly lower than the intuitive \\(2^{112}\\)\n\nApplications:\n\nAttacks on composite constructions\nInternal cryptanalysis of block ciphers\n\n\n\n\n\n\ngraph TB\n    subgraph Meet_in_Middle\n        X[Known Plaintext x] --&gt; E1[Encrypt K1]\n        E1 --&gt; M[Middle Value m]\n        M --&gt; E2[Encrypt K2]\n        E2 --&gt; Y[Known Ciphertext y]\n        \n        X2[x] --&gt; L1[List L1: EK1 for all K1]\n        Y2[y] --&gt; L2[List L2: DK2 for all K2]\n        \n        L1 -.match.-&gt; Match[Find common m]\n        L2 -.match.-&gt; Match\n    end\n    \n    style M fill:#ffffcc\n    style Match fill:#ccffcc\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text (Cryptanalysis)\n\n\n\n\n\n\nBlock Cipher Cryptanalysis Techniques\nDifferential Cryptanalysis\n\nThis is a chosen plaintext attack that focuses on the propagation of differences in two plaintexts as they evolve through the different steps of the algorithm.\nIt assigns probabilities to keys it “guesses” based on the changes they induce on the ciphertexts. The most probable key has a good chance of being the correct key after a large number of plaintext/ciphertext pairs.\nRequires \\(2^{47}\\) chosen plaintext pairs (for DES) to obtain correct results.\n\nLinear Cryptanalysis\n\nThis is a known plaintext attack that creates a block simulator from linear approximations. By analyzing a large number of plaintext/ciphertext pairs, the bits of the simulator key tend to coincide with those of the analyzed block cipher (probabilistic calculation)\nFor DES an attack based on this technique requires \\(2^{38}\\) known plaintexts to obtain a probability of 10% of guessing correctly and \\(2^{43}\\) for 85% !\nIt is the most powerful analytical attack to date on block ciphers.\n\n\n\nBlock Cipher Cryptanalysis Techniques (II)\n\nThe practical implementation of differential and linear attacks presents difficulties in parallelizing calculations compared to an exhaustive key search.\nThese two attacks are very sensitive to the number of steps of the block cipher: chances of success increase exponentially as the number of algorithm steps decreases.\nA widespread conjecture among cryptographers is that these attacks, at the time unpublished, were known to the designers of DES. In particular, the design of the S-boxes offers a very high resistance to both techniques.\n\nMeet-in-the-Middle Attack\n\nApplies to constructions of the type \\(y := E_{K_2}(E_{K_1}(x))\\). For DES, the key space for this solution would be \\(\\{0,1\\}^{112}\\). First build two lists \\(L_1\\) and \\(L_2\\) of \\(2^{56}\\) messages of the form: \\(L_1 = E_{K_1}(x)\\) and \\(L_2 = D_{K_2}(y)\\) with \\(E\\) and \\(D\\) the encryption and decryption operations respectively. Then identify elements that repeat in both lists and verify our hypothesis with a second known plaintext. The \\(K_1\\) and \\(K_2\\) associated with this pair of known plaintexts will (in all likelihood) be the sought keys !\nEffort required to carry out the attacks (for DES): \\(2^{57}\\) operations to establish the two lists + \\(2^{56}\\) blocks of 64 bits of storage to memorize intermediate results… significantly lower than the intuitive \\(2^{112}\\)…\nThese meet-in-the-middle techniques are also applied to the internal cryptanalysis of block ciphers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (Cryptanalysis)\n\n\n\n\n\nDifferential: chosen plaintext, difference propagation, probabilities on keys, \\(2^{47}\\) pairs (DES).\nLinear: known plaintext, linear approximations, \\(2^{38}\\)-\\(2^{43}\\) plaintexts (DES), most powerful attack.\nMeet-in-Middle: composite constructions, 2 lists \\(2^{56}\\), effort \\(2^{57}\\) &lt;&lt; \\(2^{112}\\).\nSensitivity: very dependent on number of rounds."
  }
]