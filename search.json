[
  {
    "objectID": "exam_notes_fr.html",
    "href": "exam_notes_fr.html",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "",
    "text": "Les services de sécurité sont les objectifs que l’on cherche à atteindre pour protéger un système.\n\nConfidentialité : Protection contre la divulgation non autorisée.\nIntégrité : Protection contre la modification non autorisée.\nDisponibilité : Garantie d’accès pour les utilisateurs légitimes.\nAuthentification :\n\nEntity authentication (Entité) : Certifier l’identité d’un acteur.\nData origin authentication (Origine) : Certifier la source d’une donnée.\n\nNon-répudiation : Impossibilité de nier une transaction.\nNon-Duplication : Protection contre les copies illicites.\nAnonymat : Préservation de l’identité ou de la source.\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nConfidentialité : Protection de l’information d’une divulgation non autorisée.\nIntégrité : Protection contre la modification non autorisée de l’information.\nDisponibilité : S’assurer que les ressources sont accessibles aux utilisateurs légitimes.\nAuthentification :\n\nAuthentification d’entités (entity authentication) : procédé permettant à une entité d’être sûre de l’identité d’une seconde entité à l’appui d’une évidence corroborant (p.ex.: présence physique, cryptographique, biométrique, etc.). Le terme identification est parfois utilisé pour désigner également ce service.\nAuthentification de l’origine de données (data origin authentication) : procédé permettant à une entité d’être sûre qu’une deuxième entité est la source originale d’un ensemble de données. Par définition, ce service assure également l’intégrité de ces données.\n\nNon-répudiation : Offre la garantie qu’une entité ne pourra pas nier être impliquée dans une transaction.\nNon-Duplication : Protection contre les copies illicites.\nAnonymat (d’entité ou d’origine de données) : Permet de préserver l’identité d’une entité, de la source d’une information ou d’une transaction."
  },
  {
    "objectID": "exam_notes_fr.html#dangers-et-attaques-synthèse",
    "href": "exam_notes_fr.html#dangers-et-attaques-synthèse",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Dangers et Attaques : Synthèse",
    "text": "Dangers et Attaques : Synthèse\n\n\n\n\n\n\n\n\nServices\nDangers\nAttaques\n\n\n\n\nConfidentialité\nfuite d’informations\nécoutes illicites, analyse du trafic\n\n\nIntégrité\nmodification de l’information\ncréation, altération ou destruction illicite\n\n\nDisponibilité\ndenial of service, usage illicite\nvirus, accès répétés visant à inutiliser un système\n\n\nAuthentification d’entités\naccès non autorisés\nVol de mot de passe, faille dans le protocole d’authentification\n\n\nAuthentification de données\nfalsification d’informations\nfalsification de signature, faille dans le protocole d’authentification\n\n\nNon-répudiation\nnier la participation à une transaction\nprétendre un vol de clé ou une faille dans le protocole de signature\n\n\nNon-duplication\nduplication\nfalsification, imitation\n\n\nAnonymat\nidentification\nanalyse d’une transaction, accès non autorisés permettant l’identification"
  },
  {
    "objectID": "exam_notes_fr.html#mécanismes-de-protection",
    "href": "exam_notes_fr.html#mécanismes-de-protection",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Mécanismes de Protection",
    "text": "Mécanismes de Protection\n\n\n\n\n\n\n\n\nServices\nMécanismes classiques\nMécanismes digitaux\n\n\n\n\nConfidentialité\nscellés, coffre-forts, cadenas\ncryptage, autorisation logique\n\n\nIntégrité\nencre spéciale, hologrammes\nfonctions à sens unique + cryptage\n\n\nDisponibilité\ncontrôle d’accès physique, surveillance vidéo\ncontrôle d’accès logique, audit, anti-virus\n\n\nAuth. d’entités\nprésence, voix, pièce d’identité, reconnaissance biométrique\nsecret + protocole d’authentification, adresse réseau + userid, carte à puce + PIN\n\n\nAuth. de données\nsceaux, signature, empreinte digitale\nfonctions à sens unique + cryptage\n\n\nNon-répudiation\nsceaux, signature, signature notariale, envoi recommandé\nfonctions à sens unique + cryptage + signature digitale\n\n\nNon-duplication\nencre spéciale, hologrammes, tatouage\ntatouage digital (watermarks), verrouillage cryptographique\n\n\nAnonymat\nbrouilleur de voix, déguisement, argent liquide\nmixers, remailers, argent électronique, deep web"
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis par E-Mail",
    "text": "Programmes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels (malware).\nE-mails visant à provoquer une action (ouvrir une pièce jointe ou cliquer sur un lien).\nAttaques souvent personnalisées grâce à l’ingénierie sociale.\nConséquences principales :\n\nInstallation de malware (ransomware, keyloggers, etc.).\nPerte ou vol de données personnelles.\nDétournement du système et propagation du malware.\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nMalware diffusé par e-mail\nIncitation à cliquer ou ouvrir\nIngénierie sociale\nVol, perte de données, détournement\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nProgrammes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels ou malware.\nE-mails conçus pour inciter le destinataire à ouvrir une pièce jointe ou à suivre un lien contenant de la publicité non souhaitée, des informations offensives, des programmes à risque, etc.\nSouvent ciblés sur la base des intérêts de la victime (travail préliminaire d’ingénierie sociale (social engineering)).\nConséquences :\n\nInstallation de malware (ransomware, keyloggers, etc.) dans le système de la victime (ordinateur, tablette, smartphone, smartwatch, etc.).\nDestruction de données contenues dans l’ordinateur.\nVol d’informations ou de données personnelles.\nDétournement du système pour des fins malicieuses (p.ex.: minage illicite de bitcoins).\nDiffusion de malware (éventuellement à d’autres utilisateurs)."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail-1",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-par-e-mail-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis par E-Mail",
    "text": "Programmes Malveillants Transmis par E-Mail\n\nAussi appelés maliciels ou malware.\nE-mails conçus pour inciter le destinataire à ouvrir une pièce jointe ou à suivre un lien contenant de la publicité non souhaitée, des informations offensives, des programmes à risque, etc.\nSouvent ciblés sur la base des intérêts de la victime (travail préliminaire d’ingénierie sociale (social engineering)).\nConséquences :\n\nInstallation de malware (ransomware, keyloggers, etc.) dans le système de la victime (ordinateur, tablette, smartphone, smartwatch, etc.).\nDestruction de données contenues dans l’ordinateur.\nVol d’informations ou de données personnelles.\nDétournement du système pour des fins malicieuses (p.ex.: minage illicite de bitcoins).\nDiffusion de malware (éventuellement à d’autres utilisateurs)."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis sur le Web",
    "text": "Programmes Malveillants Transmis sur le Web\n\nMéthode appelée drive-by download : infection automatique lors de la visite d’un site web.\nL’origine peut être :\n\nun site malveillant ;\nun site légitime compromis (p. ex. cross-site scripting).\n\nLa prudence des utilisateurs limite fortement ce mode de propagation.\nLes impacts sont similaires aux infections par e-mail.\nLa restriction des scripts (java/javascript) réduit les risques mais peut affecter la navigation.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nDrive-by download = infection sans action de l’utilisateur\nSites malveillants ou compromis\nSensibilisation + scripts restreints = protection\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nProgrammes Malveillants Transmis sur le Web\n\nCette technique, souvent appelée drive-by download, permet d’infecter le système (ordinateur, tablette, smartphone, smartwatch, etc.) sur lequel s’exécute un client web lors de la simple visite d’un site.\nIl peut s’agir soit :\n\nd’un site malicieux qui contient le malware.\nd’un site web légitime qui aurait été infecté au préalable (par exemple, moyennant une technique appelée cross-site scripting). L’infection pouvant affecter seulement certaines pages…\n\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes conséquences sont semblables à celle des transmissions par e-mail.\nL’exécution restreinte des scripts (java/javascript) dans le navigateur peut limiter la portée de l’infection mais risque de contraindre la navigation dans certains sites."
  },
  {
    "objectID": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web-1",
    "href": "exam_notes_fr.html#programmes-malveillants-transmis-sur-le-web-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Programmes Malveillants Transmis sur le Web",
    "text": "Programmes Malveillants Transmis sur le Web\n\nCette technique, souvent appelée drive-by download, permet d’infecter le système (ordinateur, tablette, smartphone, smartwatch, etc.) sur lequel s’exécute un client web lors de la simple visite d’un site.\nIl peut s’agir soit :\n\nd’un site malicieux qui contient le malware.\nd’un site web légitime qui aurait été infecté au préalable (par exemple, moyennant une technique appelée cross-site scripting). L’infection pouvant affecter seulement certaines pages…\n\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes conséquences sont semblables à celle des transmissions par e-mail.\nL’exécution restreinte des scripts (java/javascript) dans le navigateur peut limiter la portée de l’infection mais risque de contraindre la navigation dans certains sites."
  },
  {
    "objectID": "exam_notes_fr.html#hameçonnage-phishing",
    "href": "exam_notes_fr.html#hameçonnage-phishing",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hameçonnage (Phishing)",
    "text": "Hameçonnage (Phishing)\n\nTechnique visant à collecter des informations privées par des méthodes de pêche indiscriminée.\nLe phishing peut être :\n\ngénéral (ciblage large) ;\nciblé (spear phishing) lorsqu’une personne ou organisation précise est visée.\n\nLe vecteur principal est un e-mail à adresse falsifiée, difficilement détectable.\nL’objectif est d’obtenir des données sensibles (identifiants, mots de passe, informations personnelles ou bancaires).\nLes attaques reposent sur des prétextes crédibles ou menaçants pour pousser la victime à coopérer.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nVol d’informations par tromperie\nE-mails falsifiés\nSpear phishing = attaque ciblée\nPrétextes urgents ou menaçants\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nHameçonnage (Phishing)\n\nLe mot phishing se compose des mots anglais “password” (mot de passe), “harvesting” (moisson) et “fishing” (pêche).\nCette composition de mots illustre le but principal de cette technique qui consiste à récolter un maximum d’informations privées des utilisateurs via des mécanismes de “pêche indiscriminée”.\nLorsque la pêche aux informations est ciblée vers une personne ou organisation spécifique, la technique est dénommée spear phishing (qui provient de spear fishing ou pêche au harpon).\nLe vecteur de transmission consiste normalement dans un e-mail avec une adresse d’expédition falsifiée (mais souvent indétectable…) qui demande à la victime de fournir des informations privées : adresses e-mail, identifiants (twitter, facebook, etc.), mots de passe, numéros d’identité, numéros de comptes bancaires, etc.\nLes prétextes utilisés sont variés (mise à jour du système informatique, arrêt du service, retrait d’un envoi, etc.) et vont jusqu’à menacer l’utilisateur en cas de refus."
  },
  {
    "objectID": "exam_notes_fr.html#hameçonnage-phishing-1",
    "href": "exam_notes_fr.html#hameçonnage-phishing-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hameçonnage (Phishing)",
    "text": "Hameçonnage (Phishing)\n\nLe mot phishing se compose des mots anglais “password” (mot de passe), “harvesting” (moisson) et “fishing” (pêche).\nCette composition de mots illustre le but principal de cette technique qui consiste à récolter un maximum d’informations privées des utilisateurs via des mécanismes de “pêche indiscriminée”.\nLorsque la pêche aux informations est ciblée vers une personne ou organisation spécifique, la technique est dénommée spear phishing (qui provient de spear fishing ou pêche au harpon).\nLe vecteur de transmission consiste normalement dans un e-mail avec une adresse d’expédition falsifiée (mais souvent indétectable…) qui demande à la victime de fournir des informations privées : adresses e-mail, identifiants (twitter, facebook, etc.), mots de passe, numéros d’identité, numéros de comptes bancaires, etc.\nLes prétextes utilisés sont variés (mise à jour du système informatique, arrêt du service, retrait d’un envoi, etc.) et vont jusqu’à menacer l’utilisateur en cas de refus."
  },
  {
    "objectID": "exam_notes_fr.html#pourriels-spam",
    "href": "exam_notes_fr.html#pourriels-spam",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Pourriels (Spam)",
    "text": "Pourriels (Spam)\n\nE-mails indésirables, souvent publicitaires, ou pop-ups non sollicités lors de la navigation web.\nReprésentent environ 60% des e-mails mondiaux.\nConséquences principales :\n\nConsommation de ressources et perte de temps.\nCertains peuvent transmettre des malware.\n\nCiblent souvent les adresses courtes ou proviennent de listes d’adresses vendues/échangées.\nLes filtres anti-spam entraînent des coûts importants pour les organisations.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nE-mails/publicités indésirables\nRisques : perte de temps, ressources, malware\nCiblage : adresses courtes ou listes\nFiltrage coûteux pour entreprises\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nPourriels (Spam)\n\nEnglobe tous les e-mails indésirables (souvent publicitaires) reçus par les personnes et les organisations.\nTerme utilisé également pour désigner les pages/fenêtres pop-up affichées sans le consentement de l’utilisateur lors de la navigation web.\nOn estime que 60% des e-mails qui circulent dans le monde appartiennent à cette catégorie.\nLes conséquences sont souvent limitées à la consommation de ressources de calcul et stockage ainsi qu’au gaspillage de temps associé à la lecture et traitement de ces messages mais…\n… certains e-mails spam peuvent également constituer des vecteurs de transmission de malware.\nIls ont tendance à cibler plus particulièrement les adresses e-mail courtes (p.ex: abc@gmail.com) mais fonctionnent également sur la base des listes (souvent échangées / vendues) contenant tous types d’adresses.\nLes opérations de filtrage anti-spam entraînent des coûts considérables pour les organisations."
  },
  {
    "objectID": "exam_notes_fr.html#pourriels-spam-1",
    "href": "exam_notes_fr.html#pourriels-spam-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Pourriels (Spam)",
    "text": "Pourriels (Spam)\n\nEnglobe tous les e-mails indésirables (souvent publicitaires) reçus par les personnes et les organisations.\nTerme utilisé également pour désigner les pages/fenêtres pop-up affichées sans le consentement de l’utilisateur lors de la navigation web.\nOn estime que 60% des e-mails qui circulent dans le monde appartiennent à cette catégorie.\nLes conséquences sont souvent limitées à la consommation de ressources de calcul et stockage ainsi qu’au gaspillage de temps associé à la lecture et traitement de ces messages mais…\n… certains e-mails spam peuvent également constituer des vecteurs de transmission de malware.\nIls ont tendance à cibler plus particulièrement les adresses e-mail courtes (p.ex: abc@gmail.com) mais fonctionnent également sur la base des listes (souvent échangées / vendues) contenant tous types d’adresses.\nLes opérations de filtrage anti-spam entraînent des coûts considérables pour les organisations."
  },
  {
    "objectID": "exam_notes_fr.html#rançongiciels-ransomware",
    "href": "exam_notes_fr.html#rançongiciels-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Rançongiciels (Ransomware)",
    "text": "Rançongiciels (Ransomware)\n\nMalware type Cheval de Troie qui chiffre les données pour les rendre inaccessibles.\nExige une rançon (souvent en bitcoins) pour récupérer les fichiers.\nPeut rester dormant, déclenché par un événement ou une date.\nPrincipal vecteur : e-mails malveillants.\nAutres effets possibles : attaques par déni de service, extorsion.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nChiffrement des données par Cheval de Troie\nRançon pour restaurer accès\nDormance programmée possible\nInfection via e-mails malveillants\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nRançongiciels (Ransomware)\n\nCette famille spécifique de malware appartient à la catégorie appelée Chevaux de Troie (Trojan Horses).\nLeur comportement plus habituel consiste à chiffrer les données de la victime (locaux et distants) afin de les rendre totalement inaccessibles.\nUn message apparait ensuite pour demander le paiement d’une rançon (souvent en bitcoins ou une autre monnaie virtuelle) permettant potentiellement de récupérer l’accès aux fichiers chiffrés.\nIls peuvent rester en état dormant dans le système infecté et être déclenchés par un événement spécifique ou à une date donnée (attaques synchronisées).\nLeurs vecteurs d’infection sont variés mais les e-mails contenant des pièces jointes malicieuses sont souvent mis en cause lors des infections primaires.\nDes nombreuses variantes existent et continuent à se développer.\nOn observe parfois d’autres comportements associés à ces malware : dénis de service, extorsions ciblées, menaces, etc."
  },
  {
    "objectID": "exam_notes_fr.html#rançongiciels-ransomware-1",
    "href": "exam_notes_fr.html#rançongiciels-ransomware-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Rançongiciels (Ransomware)",
    "text": "Rançongiciels (Ransomware)\n\nCette famille spécifique de malware appartient à la catégorie appelée Chevaux de Troie (Trojan Horses).\nLeur comportement plus habituel consiste à chiffrer les données de la victime (locaux et distants) afin de les rendre totalement inaccessibles.\nUn message apparait ensuite pour demander le paiement d’une rançon (souvent en bitcoins ou une autre monnaie virtuelle) permettant potentiellement de récupérer l’accès aux fichiers chiffrés.\nIls peuvent rester en état dormant dans le système infecté et être déclenchés par un événement spécifique ou à une date donnée (attaques synchronisées).\nLeurs vecteurs d’infection sont variés mais les e-mails contenant des pièces jointes malicieuses sont souvent mis en cause lors des infections primaires.\nDes nombreuses variantes existent et continuent à se développer.\nOn observe parfois d’autres comportements associés à ces malware : dénis de service, extorsions ciblées, menaces, etc."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot",
    "href": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les Dispositifs Internet of Things (IoT)",
    "text": "Attaques sur les Dispositifs Internet of Things (IoT)\n\nAttaques visant les objets connectés (caméras, TV, capteurs, alarmes, etc.).\nCes dispositifs sont faciles à compromettre à cause de :\n\nfailles connues,\nmots de passe par défaut,\nmanque de sensibilisation des utilisateurs.\n\nLa prise de contrôle à distance permet :\n\nun point d’entrée vers le réseau,\nl’utilisation de l’appareil pour des activités illicites (DDoS, hacking, minage).\n\nUn inventaire précis des dispositifs connectés est indispensable.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nCible les objets connectés\nSécurité faible (failles, mots de passe par défaut)\nRisque d’accès au réseau et d’abus\nInventaire des IoT nécessaire\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nAttaques sur les Dispositifs Internet of Things (IoT)\n\nCiblent les objets connectés de toute sorte (caméras, TVs, frigos, capteurs et interrupteurs domotiques, installations d’alarme, etc.).\nIls sont souvent plus faciles à pirater que les systèmes traditionnels par cause de :\n\nnombreuses failles de sécurité souvent connues des attaquants.\nmots de passe par défaut.\nnégligence de la part des utilisateurs qui ignorent les risques qui leurs sont propres.\n\nLa prise de contrôle à distance de ces appareils par une entité malveillante implique :\n\nUne porte d’entrée au réseau domestique/corporatif.\nUn dispositif pouvant être utilisé pour des activités illicites (hacking, attaques DDoS, minage de bitcoins, etc.).\n\nL’établissement d’un répertoire précis de tous les dispositifs de ce type connectés au réseau est nécessaire!"
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot-1",
    "href": "exam_notes_fr.html#attaques-sur-les-dispositifs-internet-of-things-iot-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les Dispositifs Internet of Things (IoT)",
    "text": "Attaques sur les Dispositifs Internet of Things (IoT)\n\nCiblent les objets connectés de toute sorte (caméras, TVs, frigos, capteurs et interrupteurs domotiques, installations d’alarme, etc.).\nIls sont souvent plus faciles à pirater que les systèmes traditionnels par cause de :\n\nnombreuses failles de sécurité souvent connues des attaquants.\nmots de passe par défaut.\nnégligence de la part des utilisateurs qui ignorent les risques qui leurs sont propres.\n\nLa prise de contrôle à distance de ces appareils par une entité malveillante implique :\n\nUne porte d’entrée au réseau domestique/corporatif.\nUn dispositif pouvant être utilisé pour des activités illicites (hacking, attaques DDoS, minage de bitcoins, etc.).\n\nL’établissement d’un répertoire précis de tous les dispositifs de ce type connectés au réseau est nécessaire!"
  },
  {
    "objectID": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement",
    "href": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)",
    "text": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant à altérer les informations sur sites web et réseaux sociaux.\nImpact : réputation compromise et dommages économiques.\nSites web : sécurisation du système hôte, configuration restrictive, audits réguliers.\nRéseaux sociaux : mots de passe forts, authentification multi-facteur, fermeture des sessions, suppression des cookies.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAltération des infos sur sites et réseaux sociaux\nRisques : réputation et pertes économiques\nSites : sécurisation + audits\nRéseaux sociaux : mots de passe forts, MFA, sessions fermées, cookies supprimés\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nModification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant l’intégrité de l’information publiée dans les sites web, les réseaux sociaux, etc.\nElles portent atteinte à la réputation et peuvent provoquer d’importants dommages économiques pour les sociétés ayant une présence Internet.\nDans le cas des sites web, la sécurisation du système hôte est essentielle ainsi qu’une configuration aussi restrictive que possible. Des audits des sécurité récurrents sont vivement recommandés.\nLa protection des informations affichées dans les réseaux sociaux dépend directement du processus d’authentification permettant d’accéder au profil à risque :\n\nÉviter les mots de passe trop simples.\nPrivilégier l’authentification forte, si possible multi-facteur.\nFermer proprement les sessions.\nEffacer les cookies."
  },
  {
    "objectID": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement-1",
    "href": "exam_notes_fr.html#modification-illicite-des-informations-publiées-information-spoofing-and-website-defacement-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)",
    "text": "Modification Illicite des Informations Publiées (Information Spoofing and Website Defacement)\n\nAttaques visant l’intégrité de l’information publiée dans les sites web, les réseaux sociaux, etc.\nElles portent atteinte à la réputation et peuvent provoquer d’importants dommages économiques pour les sociétés ayant une présence Internet.\nDans le cas des sites web, la sécurisation du système hôte est essentielle ainsi qu’une configuration aussi restrictive que possible. Des audits des sécurité récurrents sont vivement recommandés.\nLa protection des informations affichées dans les réseaux sociaux dépend directement du processus d’authentification permettant d’accéder au profil à risque :\n\nÉviter les mots de passe trop simples.\nPrivilégier l’authentification forte, si possible multi-facteur.\nFermer proprement les sessions.\nEffacer les cookies."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos",
    "href": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques Dénis de Service (Denial of Service / DDoS)",
    "text": "Attaques Dénis de Service (Denial of Service / DDoS)\n\nVise à rendre inaccessibles des systèmes informatiques, surtout pour les organisations.\nDDoS : attaque distribuée par des milliers de dispositifs, générant un trafic massif.\nProtections classiques (firewalls, sondes IDS (Intrusion Detection System) / IPS (Intrusion Prevention System)) souvent insuffisantes.\nConséquences :\n\nRéputation affectée\nPertes financières (parfois rançons)\nRisques élevés pour les infrastructures critiques (hôpitaux, centrales, Internet backbone)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nDDoS = systèmes inaccessibles via attaques massives\nProtections limitées\nRisques : réputation, finances, infrastructures critiques\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nAttaques Dénis de Service (Denial of Service / DDoS)\n\nAttaques destinées à rendre inaccessibles des systèmes informatiques de toute sorte visant surtout les organisations privées ou étatiques.\nLe terme DDoS (Distributed Denial of Service) désigne une famille d’attaques dans laquelle des multiples (souvent des dizaines de milliers) de dispositifs ciblent simultanément le(s) système(s) victime(s).\nLe trafique généré atteint plusieurs centaines de gigabits / seconde.\nL’efficacité des mécanismes de protection traditionnels (firewalls, sondes de prévention et de détection d’intrusion, etc.) est limitée.\nL’indisponibilité d’un service peut engendrer :\n\ndes problèmes réputationnels.\nd’importantes pertes financières (des demandes de rançon peuvent être exigées pour les désactiver).\ndes hauts risques de sécurité (même physique!) lorsque des infrastructures critiques (hôpitaux, centrales électriques, backbone de l’Internet, etc.) sont ciblées."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos-1",
    "href": "exam_notes_fr.html#attaques-dénis-de-service-denial-of-service-ddos-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques Dénis de Service (Denial of Service / DDoS)",
    "text": "Attaques Dénis de Service (Denial of Service / DDoS)\n\nAttaques destinées à rendre inaccessibles des systèmes informatiques de toute sorte visant surtout les organisations privées ou étatiques.\nLe terme DDoS (Distributed Denial of Service) désigne une famille d’attaques dans laquelle des multiples (souvent des dizaines de milliers) de dispositifs ciblent simultanément le(s) système(s) victime(s).\nLe trafique généré atteint plusieurs centaines de gigabits / seconde.\nL’efficacité des mécanismes de protection traditionnels (firewalls, sondes de prévention et de détection d’intrusion, etc.) est limitée.\nL’indisponibilité d’un service peut engendrer :\n\ndes problèmes réputationnels.\nd’importantes pertes financières (des demandes de rançon peuvent être exigées pour les désactiver).\ndes hauts risques de sécurité (même physique!) lorsque des infrastructures critiques (hôpitaux, centrales électriques, backbone de l’Internet, etc.) sont ciblées."
  },
  {
    "objectID": "exam_notes_fr.html#fonctions-de-hachage-cryptographiques",
    "href": "exam_notes_fr.html#fonctions-de-hachage-cryptographiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fonctions de Hachage Cryptographiques",
    "text": "Fonctions de Hachage Cryptographiques\n\nFonctions faciles à calculer dans un sens mais virtuellement impossibles à inverser.\nToute modification du document source change radicalement le digest (effet avalanche).\nPropriétés clés :\n\nOne-way : impossible de retrouver l’entrée depuis le hash.\nCollision-free : impossible de trouver deux entrées avec le même hash.\n\nTaille des digests : 160 à 512 bits.\nAlgorithmes (très performants) : SHA-1, SHA-256, SHA-3.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nOne-way + collision-free.\nTaille : 160-512 bits.\nAlgos : SHA-1/256/3.\nUsage : intégrité, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nFonctions faciles à calculer dans un sens mais virtuellement impossibles à calculer dans le sens contraire.\nToute modification (même insignifiante) du document source se traduit par un digest fondamentalement différent.\nIl est virtuellement impossible de retrouver le document source à l’aide seulement du digest (one-way).\nIl est virtuellement impossible de retrouver un deuxième document source produisant le même digest (collision-free).\nLongueur habituelle des digests : 160 à 512 bits.\nLes algorithmes à sens unique sont très performants.\nExemples : SHA-1, SHA-256, SHA-3, etc."
  },
  {
    "objectID": "exam_notes_fr.html#générateurs-pseudo-aléatoires",
    "href": "exam_notes_fr.html#générateurs-pseudo-aléatoires",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Générateurs (Pseudo) Aléatoires",
    "text": "Générateurs (Pseudo) Aléatoires\n\nCaractéristiques\n\naléatoire\nimprévisible\nnon reproductible\n\nCritique pour la sécurité (clés, IV, secrets).\nTypes :\n\nVrais aléatoires : basés sur phénomènes physiques (radioactivité, quantique).\nPseudo-aléatoires : déterministes (basés sur un seed: séquence aléatoire initiale).\n\nRisque : “Pseudo-sécurité” si le seed est prévisible (citation de Pitkin).\nApplications : clés de session, IV (DES-CBC), signatures (ElGamal).\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nVrais aléatoires : physiques (quantique).\nPseudo-aléatoires : déterministes (seed).\nRisque : seed prévisible = faille.\nUsages : clés, IV, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nLa génération de nombre aléatoire est un processus très important pouvant compromettre la sécurité d’un bon nombre de systèmes de cryptage.\nApplications : génération de clés de session, vecteurs d’initialisation (DES - CBC mode), secrets pour signatures (ElGamal), etc.\nUn générateur aléatoire (random generator) est un dispositif capable de générer des nombres de façon aléatoire, imprévisible et non reproductible. (e.g. basé sur phénomènes physiques: source radioactive ou quantique).\nLes générateurs pseudo-aléatoires sont des procédés déterministes développés à partir d’une séquence aléatoire initiale (seed) (e.g. frappe utilisateur, accès disque).\nCitation : R. Pitkin dans [Kau95]: “The use of pseudo-random processes to generate secret quantities can result in pseudo-security”"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique",
    "href": "exam_notes_fr.html#cryptographie-symétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique",
    "text": "Cryptographie Symétrique\n\nHistorique : Utilisée depuis Jules César (Iᵉʳ av. J.-C.).\nPrincipe : Une seule clé pour chiffrer/déchiffrer.\nSchéma : Plaintext → Cryptage (Clé) → Ciphertext → Décryptage (Clé) → Plaintext.\nCaractéristiques :\n\nAlgorithmes : AES, DES, IDEA, RC4.\nServices : Confidentialité, Authentification, Intégrité.\nLimite : Pas de signatures (clé partagée).\nProblème : Échange de clé sécurisé requis.\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\n1 clé pour chiffrer/déchiffrer.\nRapide (AES, DES).\nProblème : échange de clé.\nUsages : documents personnels, groupes fermés.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nAussi appelée cryptographie conventionnelle ou à clés secrètes (I av. JC, Julius Cesar).\nIdée : Sur la base d’une seule clé secrète, réaliser une transformation capable respectivement de rendre illisible et de restituer une pièce d’information.\nSchéma : Plaintext \\(\\to\\) Cryptage (Clé) \\(\\to\\) Ciphertext \\(\\to\\) Décryptage (Clé) \\(\\to\\) Plaintext.\nCaractéristiques :\n\nAlgorithmes : AES, DES, IDEA, RC4, RC5, etc. (certains sont gratuits et de libre accès)\nServices : Confidentialité, Authentification, Intégrité.\nPas de support direct pour signatures digitales (car clé connue des deux).\nNécessite un canal confidentiel pour échanger la clé.\nIdéal pour la protection de documents personnels ou groupes fermés."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique",
    "href": "exam_notes_fr.html#cryptographie-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique",
    "text": "Cryptographie Asymétrique\n\nAussi appelée cryptographie publique (1976, Diffie & Hellman).\nPrincipe\n\nPaire de clés (publique/privée) pour chiffrement et signatures.\n\nDeux usages principaux :\n\nConfidentialité :\n\nChiffrement : clé publique du destinataire\nDéchiffrement : clé privée du destinataire\n\nSignature numérique :\n\nSignature : clé privée de l’expéditeur\nVérification : clé publique de l’expéditeur\nOptimisation : On signe généralement le hash du document\nPropriétés fondamentales :\n\nIntégrité : Toute modification invalide la signature\nNon-collision : Impossible d’avoir 2 documents avec la même signature\nNon-répudiation : Seul le détenteur de la clé privée peut signer\n\n\n\nAspects techniques :\n\nAlgorithmes : RSA, ElGamal\nServices : Intégrité, Authentification, Non-Répudiation\nPerformance : beaucoup plus lent que le symétrique (100x plus lent)\nAvantage : Pas besoin de canal confidentiel pour l’échange de clés\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\n2 clés : publique (chiffrer/vérifier) + privée (déchiffrer/signer)\n2 usages :\n\nConfidentialité : chiffrer pour un destinataire\nSignature : prouver l’authenticité\n\nSignatures :\n\nIntégrité + non-répudiation\n\nAlgorithmes : RSA/ElGamal\nAvantage : Pas besoin de canal sécurisé pour échanger les clés\nDésavantage : Lente\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique\n\nAussi appelée cryptographie publique ou à clés publiques (1976, W. Diffie & M. Hellman).\nIdée : Utiliser deux clés différentes - une secrète et une publique - respectivement pour les opérations de cryptage et décryptage.\nChaque utilisateur dispose d’un porte-clés (keyring).\n\nConfidentialité : * Expéditeur crypte avec la clé publique du destinataire. * Destinataire décrypte avec sa clé privée. * Uniquement clé du destinataire utilisée !\nSignature Digitale : * Expéditeur signe avec sa clé privée. * Destinataire vérifie avec la clé publique de l’expéditeur. * Uniquement clé de l’expéditeur utilisée ! * Note : On signe généralement le digest du document (hash) pour des raisons de performance.\nCaractéristiques des signatures : * La signature change si le document change, alors que la clé privée reste la même. * En cas de modification du document ou de la signature, la vérification échoue (intégrité garantie). * Il est virtuellement impossible, même pour le détenteur de la clé privée, de générer un second document produisant la même signature (fonction à sens unique sans collisions). * Seul le détenteur de la clé privée peut générer une signature vérifiable à l’aide de la clé publique correspondante (non-répudiation). * Algorithmes : RSA, ElGamal. * Services : Intégrité, Authentification, Non-Répudiation. * Lenteur : Jusqu’à 50 fois plus lent que la cryptographie symétrique. * Avantage : Pas besoin de canal confidentiel pour échanger les clés (contrairement au symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique",
    "text": "Cryptographie Asymétrique\n\nAussi appelée cryptographie publique ou à clés publiques (1976, W. Diffie & M. Hellman).\nIdée : Utiliser deux clés différentes - une secrète et une publique - respectivement pour les opérations de cryptage et décryptage.\nChaque utilisateur dispose d’un porte-clés (keyring).\n\nConfidentialité : * Expéditeur crypte avec la clé publique du destinataire. * Destinataire décrypte avec sa clé privée. * Uniquement clé du destinataire utilisée !\nSignature Digitale : * Expéditeur signe avec sa clé privée. * Destinataire vérifie avec la clé publique de l’expéditeur. * Uniquement clé de l’expéditeur utilisée ! * Note : On signe généralement le digest du document (hash) pour des raisons de performance.\nCaractéristiques des signatures : * La signature change si le document change, alors que la clé privée reste la même. * En cas de modification du document ou de la signature, la vérification échoue (intégrité garantie). * Il est virtuellement impossible, même pour le détenteur de la clé privée, de générer un second document produisant la même signature (fonction à sens unique sans collisions). * Seul le détenteur de la clé privée peut générer une signature vérifiable à l’aide de la clé publique correspondante (non-répudiation). * Algorithmes : RSA, ElGamal. * Services : Intégrité, Authentification, Non-Répudiation. * Lenteur : Jusqu’à 50 fois plus lent que la cryptographie symétrique. * Avantage : Pas besoin de canal confidentiel pour échanger les clés (contrairement au symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#crypto-asymétrique-symétrique-hybride",
    "href": "exam_notes_fr.html#crypto-asymétrique-symétrique-hybride",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Crypto Asymétrique + Symétrique (Hybride)",
    "text": "Crypto Asymétrique + Symétrique (Hybride)\n\nPrincipe : Utiliser l’asymétrique pour échanger une clé symétrique (clé de session).\nÉtapes :\n\nA génère une clé symétrique aléatoire \\(K_s\\).\nA chiffre \\(K_s\\) avec la clé publique de B.\nA et B communiquent ensuite avec \\(K_s\\) (symétrique).\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAsymétrique : échange de clé symétrique.\nSymétrique : chiffrement des données.\nAvantage : combine sécurité + performance.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nIdée : Utiliser la cryptographie publique uniquement pour échanger des clés symétriques (Clés de session).\nA génère une clé aléatoire \\(K_s\\) et la transmet à B en l’encryptant avec la clé publique de B.\nA & B communiquent ensuite en utilisant \\(K_s\\) (symétrique)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Fonctionnement (RSA)",
    "text": "Cryptographie Asymétrique : Fonctionnement (RSA)\n\nConstruction des clés\n\nChoix des nombres premiers :\n\n\\(p\\) et \\(q\\) : deux grands nombres premiers (&gt; 1024 bits)\n\\(n = pq\\) : module RSA (taille = 2048+ bits)\n\nCalcul de l’indicatrice d’Euler :\n\n\\(\\phi(n) = (p-1)(q-1)\\)\nPropriété : Pour tout \\(a\\) premier avec \\(n\\), \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\n\nSélection des exposants :\n\n\\(e\\) : entier premier avec \\(\\phi(n)\\) (exposant public)\n\\(d\\) : inverse modulaire de \\(e\\) (exposant privé), tel que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\n\n\n\nProcessus de chiffrement/déchiffrement\n\nClé publique : \\((n,e)\\)\nClé privée : \\((d)\\)\nChiffrement : \\(C = P^e \\pmod{n}\\)\nDéchiffrement : \\(P = C^d \\pmod{n}\\)\n\n\n\nPreuve mathématique\n\nCongruence fondamentale :\n\n\\(ed = 1 + k\\phi(n)\\) (par définition de \\(d\\))\n\nApplication du théorème d’Euler :\n\n\\(P^{\\phi(n)} \\equiv 1 \\pmod{n}\\) (si \\(P\\) premier avec \\(n\\))\n\nDémonstration :\n\\[\\begin{align*}\n(P^e)^d &\\equiv P^{ed} \\pmod{n} \\\\\n&\\equiv P^{1 + k\\phi(n)} \\pmod{n} \\\\\n&\\equiv P \\cdot (P^{\\phi(n)})^k \\pmod{n} \\\\\n&\\equiv P \\cdot 1^k \\pmod{n} \\\\\n&\\equiv P \\pmod{n}\n\\end{align*}\\]\n\n\n\nSécurité du système\n\nProblème difficile : Factorisation de \\(n\\) en \\(p\\) et \\(q\\)\nTaille recommandée :\n\n\\(n\\) : 2048 bits (minimum pour sécurité actuelle)\n\\(p\\) et \\(q\\) : 1024+ bits chacun\n\nVulnérabilités connues :\n\nAttaques par canal auxiliaire (timing, power analysis)\nChoix inapproprié des paramètres (\\(e\\) trop petit, \\(p\\) et \\(q\\) trop proches)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nClés :\n\nPublique : \\((n,e)\\) où \\(n = pq\\)\nPrivée : \\((d)\\) avec \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\nOpérations :\n\nChiffrement : \\(P^e \\mod n\\)\nDéchiffrement : \\(C^d \\mod n\\)\n\nSécurité : Factorisation de \\(n\\) difficile\nTaille : 2048+ bits pour \\(n\\)\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique: Fonctionnement (RSA)\n\nSoit \\(n := pq\\) avec \\(p\\) et \\(q\\) deux nombres premiers grands (&gt; 1024 bits).\nSoit \\(\\phi(n) = (p-1)(q-1)\\).\nSoit \\(e\\) et \\(d\\) tels que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nPar définition des congruences: \\(ed = 1 + k\\phi(n)\\)\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption : \\(C = P^e \\pmod n\\). Clé publique : \\((n,e)\\).\nDécryption : \\(P = C^d \\pmod n\\). Clé privée : \\((d)\\).\nPreuve : \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-fonctionnement-rsa-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique: Fonctionnement (RSA)",
    "text": "Cryptographie Asymétrique: Fonctionnement (RSA)\n\nSoit \\(n := pq\\) avec \\(p\\) et \\(q\\) deux nombres premiers grands (&gt; 1024 bits).\nSoit \\(\\phi(n) = (p-1)(q-1)\\).\nSoit \\(e\\) et \\(d\\) tels que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nPar définition des congruences: \\(ed = 1 + k\\phi(n)\\)\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption : \\(C = P^e \\pmod n\\). Clé publique : \\((n,e)\\).\nDécryption : \\(P = C^d \\pmod n\\). Clé privée : \\((d)\\).\nPreuve : \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-conclusions",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-conclusions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Conclusions",
    "text": "Cryptographie Asymétrique : Conclusions\n\nAlgorithmes dominants : RSA (le plus utilisé), Rabin, ElGamal\nServices complets :\n\nConfidentialité\nAuthentification\nIntégrité\nSignature digitale & Non-répudiation\nNon-duplication\n\nPerformances :\n\n50x plus lent que le symétrique\nSolution optimale : Combinaison asymétrique (échange de clés) + symétrique (chiffrement)\n\nGestion des clés :\n\nAvantage : Échange de clés publiques sans canal confidentiel\nRisque : Nécessité de vérifier l’authenticité des clés publiques\n\nCanal d’acquisition authentifié ou\nCertification par tiers de confiance\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nAlgos : RSA (dominant), Rabin, ElGamal\nServices : Confidentialité + Authentification + Intégrité + Signatures\nLenteur : 50x vs symétrique → hybride recommandé\nClés : Échange public simple mais authentification cruciale\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nCryptographie Asymétrique : Conclusions\n\nIl existe quelques systèmes de cryptage asymétrique (Rabin, ElGamal, etc.) mais le plus utilisé est RSA.\nServices supportés : Confidentialité, Authentification, Intégrité, Signature Digitale & Non-Refus, (Non Duplication).\nLes opérations liées à la cryptographie asymétrique sont jusqu’à 50 fois (!) plus lentes que celles de la cryptographie symétrique. Une combinaison des deux méthodes est souvent souhaitable.\nLa distribution des clés est simplifiée par le fait que seules des clés publiques doivent être échangées entre les intervenants (pas besoin d’un canal confidentiel alternatif) mais…\n… il est nécessaire de vérifier que la clé publique appartient réellement au destinataire :\n\nSoit le canal d’acquisition de la clé publique est protégé contre toute modification (authentifié)\nSoit la clé est certifiée exacte par un tiers"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-asymétrique-conclusions-1",
    "href": "exam_notes_fr.html#cryptographie-asymétrique-conclusions-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Asymétrique : Conclusions",
    "text": "Cryptographie Asymétrique : Conclusions\n\nIl existe quelques systèmes de cryptage asymétrique (Rabin, ElGamal, etc.) mais le plus utilisé est RSA.\nServices supportés : Confidentialité, Authentification, Intégrité, Signature Digitale & Non-Refus, (Non Duplication).\nLes opérations liées à la cryptographie asymétrique sont jusqu’à 50 fois (!) plus lentes que celles de la cryptographie symétrique. Une combinaison des deux méthodes est souvent souhaitable.\nLa distribution des clés est simplifiée par le fait que seules des clés publiques doivent être échangées entre les intervenants (pas besoin d’un canal confidentiel alternatif) mais…\n… il est nécessaire de vérifier que la clé publique appartient réellement au destinataire :\n\nSoit le canal d’acquisition de la clé publique est protégé contre toute modification (authentifié)\nSoit la clé est certifiée exacte par un tiers"
  },
  {
    "objectID": "exam_notes_fr.html#comparaison-symétrique-vs-asymétrique",
    "href": "exam_notes_fr.html#comparaison-symétrique-vs-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Comparaison Symétrique vs Asymétrique",
    "text": "Comparaison Symétrique vs Asymétrique\n\nAvantages comparés\n\nSymétrique :\n\nPerformance : 100x plus rapide\nImplémentation : Facile en hardware\nClés : Courtes (128 bits = 16 caractères mémorisables)\n\nAsymétrique :\n\nÉchange de clés : Canal authentifié suffisant (pas besoin de confidentialité)\nGestion : 1 paire de clés pour n correspondants (vs n clés en symétrique)\n\n\n\n\nProblématiques communes\n\nMaillon faible : Gestion des clés par les utilisateurs\nBase de sécurité : Empirique plutôt que théorique\nContraintes légales : Restrictions d’usage et d’exportation\n\n\n\nRecommandations d’usage\n\n\n\n\n\n\n\n\nCas d’usage\nSolution recommandée\nJustification\n\n\n\n\nDocuments personnels\nSymétrique\nVitesse + clés mémorisables\n\n\nGroupes d’utilisateurs proches\nSymétrique\nVitesse + échange confidentiel facile\n\n\nUtilisateurs distants/inconnus\nAsymétrique\nPas besoin de canal confidentiel\n\n\nTransactions distantes\nHybride (Asymétrique + Symétrique)\nAsymétrique pour l’échange de clé, symétrique pour les données\n\n\nProtection logicielle (distribution)\nHybride\nClé symétrique unique par version, encryptée avec asymétrique\n\n\nSegments réseaux\nSymétrique\nVitesse + environnement contrôlé (échange de clés facile entre administrateurs)\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nSymétrique :\n✅ Rapide (100x)\n✅ Clés courtes (128 bits)  \n❌ Échange de clés confidentiel requis\nAsymétrique :\n✅ Échange de clés simplifié\n✅ 1 paire de clés pour n correspondants\n❌ Lent (50x)\n❌ Clés longues (1024+ bits)\nHybride : Meilleur des deux mondes Problèmes communs : Gestion des clés, base empirique, restrictions légales\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nCryptographie Symétrique vs. Asymétrique\n\nIl existe des centaines d’algorithmes symétriques et asymétriques capables de fournir un niveau de confidentialité suffisant.\nLes solutions symétriques offrent les avantages suivants :\n\nRapidité (jusqu’à 100 fois plus rapide que les solutions asymétriques)\nFacilité d’implantation en hardware\nLongueur de clé réduite : 128 bits (= 16 caractères ⇒ mémorisable !) au lieu de 1024 bits pour des équivalents asymétriques.\n\nLes solutions asymétriques ont comme arguments principaux :\n\nÉchange de clés simplifié : les clés doivent être échangées par un canal authentifié mais non-confidentiel\nGestion de clés simplifiée : une seule paire de clés publique/privée suffit à un utilisateur pour recevoir des messages confidentiels de n utilisateurs (au lieu de n clés différentes dans le cas symétrique).\n\nProblèmes propres aux deux techniques :\n\nLa gestion de clés par l’utilisateur reste le maillon le plus faible\nSécurité (normalement) basée sur des arguments empiriques plutôt que théoriques\nRestrictions légales d’usage et d’exportation\n\n\n\n\nCryptographie Symétrique vs. Asymétrique (II)\n\n\n\n\n\n\n\n\nActivité\nRecommandation\nRemarques\n\n\n\n\nProtection de documents personnels\nCrypto symétrique\nVitesse, clés facilement mémorisables\n\n\nProtection de documents dans un groupe d’utilisateurs proches\nCrypto symétrique\nVitesse, facilité d’échange des clés confidentielles\n\n\nÉtablissement de canaux confidentiels entre utilisateurs distants (inconnus)\nCrypto asymétrique\nPas besoin d’avoir un canal confidentiel : authenticité suffit\n\n\nTransactions entre deux utilisateurs distants, Protection de logiciel (distribution multicast)\nCrypto asymétrique pour protection de clé symétrique + Crypto symétrique pour protection des données\nVitesse, Seule la clé symétrique doit être ré-encryptée pour chaque correspondant, Copie cryptée du logiciel peut être rendue publique\n\n\nProtection des segments réseaux\nCrypto symétrique\nVitesse, Environnement stable → échange confidentiel des clés facile entre sysadmins"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique",
    "href": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique vs. Asymétrique",
    "text": "Cryptographie Symétrique vs. Asymétrique\n\nIl existe des centaines d’algorithmes symétriques et asymétriques capables de fournir un niveau de confidentialité suffisant.\nLes solutions symétriques offrent les avantages suivants :\n\nRapidité (jusqu’à 100 fois plus rapide que les solutions asymétriques)\nFacilité d’implantation en hardware\nLongueur de clé réduite : 128 bits (= 16 caractères ⇒ mémorisable !) au lieu de 1024 bits pour des équivalents asymétriques.\n\nLes solutions asymétriques ont comme arguments principaux :\n\nÉchange de clés simplifié : les clés doivent être échangées par un canal authentifié mais non-confidentiel\nGestion de clés simplifiée : une seule paire de clés publique/privée suffit à un utilisateur pour recevoir des messages confidentiels de n utilisateurs (au lieu de n clés différentes dans le cas symétrique).\n\nProblèmes propres aux deux techniques :\n\nLa gestion de clés par l’utilisateur reste le maillon le plus faible\nSécurité (normalement) basée sur des arguments empiriques plutôt que théoriques\nRestrictions légales d’usage et d’exportation"
  },
  {
    "objectID": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique-ii",
    "href": "exam_notes_fr.html#cryptographie-symétrique-vs.-asymétrique-ii",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptographie Symétrique vs. Asymétrique (II)",
    "text": "Cryptographie Symétrique vs. Asymétrique (II)\n\n\n\n\n\n\n\n\nActivité\nRecommandation\nRemarques\n\n\n\n\nProtection de documents personnels\nCrypto symétrique\nVitesse, clés facilement mémorisables\n\n\nProtection de documents dans un groupe d’utilisateurs proches\nCrypto symétrique\nVitesse, facilité d’échange des clés confidentielles\n\n\nÉtablissement de canaux confidentiels entre utilisateurs distants (inconnus)\nCrypto asymétrique\nPas besoin d’avoir un canal confidentiel : authenticité suffit\n\n\nTransactions entre deux utilisateurs distants, Protection de logiciel (distribution multicast)\nCrypto asymétrique pour protection de clé symétrique + Crypto symétrique pour protection des données\nVitesse, Seule la clé symétrique doit être ré-encryptée pour chaque correspondant, Copie cryptée du logiciel peut être rendue publique\n\n\nProtection des segments réseaux\nCrypto symétrique\nVitesse, Environnement stable → échange confidentiel des clés facile entre sysadmins"
  },
  {
    "objectID": "exam_notes_fr.html#dissection-dune-attaque-ransomware",
    "href": "exam_notes_fr.html#dissection-dune-attaque-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Dissection d’une Attaque : Ransomware",
    "text": "Dissection d’une Attaque : Ransomware\n\nDéfinition et Impact\n\nDéfinition : Logiciel malveillant qui chiffre les données et exige une rançon pour leur restitution.\nLimites de la définition classique :\n\nNe couvre pas l’impact sur l’infrastructure critique (ex : Colonial Pipeline, mai 2021)\nSous-estime la portée systémique des attaques\n\nStatistiques alarmantes :\n\nMilliards d’attaques annuelles\nConsidéré comme la menace cyber la plus dangereuse en 2021 (“Ransomware Everywhere”)\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nMalware : Chiffre les données → demande rançon\nImpact : Infrastructure critique (ex : Colonial Pipeline)\nMenace n°1 en cybersécurité (2021)\nCibles : Particuliers + entreprises + États\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n“Un rançongiciel (de l’anglais ransomware), logiciel rançonneur, logiciel de rançon ou logiciel d’extorsion, est un logiciel malveillant qui prend en otage des données personnelles. Pour ce faire, un rançongiciel chiffre des données personnelles puis demande à leur propriétaire d’envoyer de l’argent en échange de la clé de déchiffrement” (Wikipedia 21 septembre 2021).\n\nDéfinition incomplète car les ransomwares portent sur un vaste spectre de l’infrastructure informatique\nÀ titre d’exemple, en mai 2021, une attaque ransomware dirigée contre la société Colonial Pipeline a provoqué une coupure d’approvisionnement de combustible d’une grande partie de la côte des États-Unis\nAvec un nombre d’attaques global chiffré en milliards par année, “Ransomware Everywhere” est globalement considérée comme la menace la plus directe, visible et dangereuse pour utilisateurs et entreprises en 2021 !"
  },
  {
    "objectID": "exam_notes_fr.html#cycle-de-vie-dune-attaque-ransomware",
    "href": "exam_notes_fr.html#cycle-de-vie-dune-attaque-ransomware",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cycle de Vie d’une Attaque Ransomware",
    "text": "Cycle de Vie d’une Attaque Ransomware\n\nPrévention et Réponse\n\n\n\n\n\n\n\nPhase\nMesures\n\n\n\n\nPrévention\n- Patching régulier- Solutions de détection (Firewalls, WAFs, IDS/IPS)- Scans anti-malware (e-mails, fichiers)\n\n\nProtection\n- Backups offline (essentiel !)- Politiques de sécurité strictes- Formation des utilisateurs\n\n\nRéponse\n- Ne pas payer (recommandation officielle)- Analyse forensique- Restauration depuis backups\n\n\n\n\n\nDissection Technique\n\nInfection :\n\nVecteurs : Phishing, exploits, RDP vulnérable\nPropagation : Latérale (réseau) ou verticale (système)\n\nExécution :\n\nChiffrement des fichiers ciblés\nSuppression des shadow copies\nPersistance (registre, tâches planifiées)\n\nExtorsion :\n\nAffichage de la demande de rançon\nPaiement en cryptomonnaies (Bitcoin, Monero)\nDélais de paiement avec majoration\n\nOccultation :\n\nObfuscation du code\nCommunication via TOR/Deep Web\nEffacement des logs\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nCycle d’attaque :\n\nInfection (phishing/exploits)\nExécution (chiffrement + persistance)\nExtorsion (rançon en crypto)\nOccultation (TOR + effacement traces)\n\nContre-mesures :\n✅ Backups offline\n✅ Patching + détection\n✅ Formation\n❌ Ne pas payer"
  },
  {
    "objectID": "exam_notes_fr.html#cryptolocker-analyse-technique",
    "href": "exam_notes_fr.html#cryptolocker-analyse-technique",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Cryptolocker : Analyse Technique",
    "text": "Cryptolocker : Analyse Technique\n\nSchéma d’Attaque\n\n\n\n\n\ngraph TD\n    A[Infection initiale] --&gt; B[Chiffrement des fichiers]\n    B --&gt; C[Stockage clé privée sur serveurs C2]\n    C --&gt; D[Demande de rançon]\n    D --&gt; E{Paiement ?}\n    E --&gt;|Oui| F[Envoi clé de déchiffrement via TOR]\n    E --&gt;|Non| G[Perte définitive des données]\n\n\n\n\n\n\n\n\nCibles Privilégiées\n\nExtensions critiques (extrait) :\n\nDocuments : .docx, .xlsx, .pdf, .pptx\nBases de données : .mdb, .sql, .sqlite\nMédias : .jpg, .png, .mp4, .avi\nDéveloppement : .java, .cpp, .py, .php\nFinancier : .qbw, .qbb, .wallet\n\nComportement :\n\nChiffrement sélectif (fichiers récents/modifiés)\nDouble extorsion : Chiffrement + menace de fuite\nRaaS (Ransomware-as-a-Service) : Modèle économique\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\nMécanisme : - Clé privée stockée sur serveurs C2 - Paiement → clé via TOR - Cibles : 100+ extensions (docs, DB, médias)\nÉvolutions récentes : - Double extorsion (chiffrement + fuite) - RaaS (location de ransomware)\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nRansomware : Vue Intégrale\n(Source : 2017 State of Cybersecurity, F-Secure Inc.)\n\n\nRansomware : Vue Intégrale\n\nPrévision, Remédiation et Réaction\n\nPatching\nDétection active et passive (Firewalls, WAFs, IDS, IPS, e-mail malware scan, etc.)\nBackups offline !\nPolitique de Sécurité - Règles de bon usage de la messagerie\nFormation !\nPayer ou pas payer…\n\n\n\nDissection Technique de l’Attaque\n\nInfection et propagation\nExécution\nPaiement (Crypto-currencies / Bitcoin)\nOccultation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nSchéma Générique d’un Ransomware Cryptolocker\n\nLes clés privées de déchiffrement sont stockées dans les serveurs de l’attaquant\nElles sont envoyées à la victime après paiement en bitcoins\nLa trace est broyée à l’aide des réseaux TOR\n\n\n\n\nRansomware Cryptolocker : Cibles\nExtensions de fichiers ciblées : .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource : Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-vue-intégrale",
    "href": "exam_notes_fr.html#ransomware-vue-intégrale",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware : Vue Intégrale",
    "text": "Ransomware : Vue Intégrale\n(Source : 2017 State of Cybersecurity, F-Secure Inc.)"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-vue-intégrale-1",
    "href": "exam_notes_fr.html#ransomware-vue-intégrale-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware : Vue Intégrale",
    "text": "Ransomware : Vue Intégrale\n\nPrévision, Remédiation et Réaction\n\nPatching\nDétection active et passive (Firewalls, WAFs, IDS, IPS, e-mail malware scan, etc.)\nBackups offline !\nPolitique de Sécurité - Règles de bon usage de la messagerie\nFormation !\nPayer ou pas payer…\n\n\n\nDissection Technique de l’Attaque\n\nInfection et propagation\nExécution\nPaiement (Crypto-currencies / Bitcoin)\nOccultation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nSchéma Générique d’un Ransomware Cryptolocker\n\nLes clés privées de déchiffrement sont stockées dans les serveurs de l’attaquant\nElles sont envoyées à la victime après paiement en bitcoins\nLa trace est broyée à l’aide des réseaux TOR"
  },
  {
    "objectID": "exam_notes_fr.html#ransomware-cryptolocker-cibles",
    "href": "exam_notes_fr.html#ransomware-cryptolocker-cibles",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Ransomware Cryptolocker : Cibles",
    "text": "Ransomware Cryptolocker : Cibles\nExtensions de fichiers ciblées : .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource : Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_fr.html#principe-de-kerckhoffs",
    "href": "exam_notes_fr.html#principe-de-kerckhoffs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Principe de Kerckhoffs",
    "text": "Principe de Kerckhoffs\n\nPrincipe fondamental : la sécurité repose uniquement sur la clé, pas sur le secret de l’algorithme.\nLe système doit rester sûr même si l’algorithme est public.\nLa clé doit être facilement modifiable et le système simple à utiliser.\nRejet explicite de la sécurité par l’obscurité.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nSécurité basée sur la clé\nAlgorithme public\nPas de sécurité par l’obscurité\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nPrincipe de Kerckhoffs\nAuguste Kerckhoffs publie en 1883 deux articles définissant six principes pour les chiffrements militaires :\n\nLe système doit être pratiquement, voire mathématiquement indéchiffrable.\nIl ne doit pas nécessiter de confidentialité et rester sûr même s’il tombe aux mains de l’ennemi.\nLa clé doit pouvoir être mémorisée, transmise et modifiée facilement, sans notes écrites.\nLe système doit être compatible avec les communications télégraphiques.\nIl doit être portable et utilisable par une seule personne.\nIl doit être simple à utiliser, sans procédures complexes ni contraintes excessives.\n\nKerckhoffs affirme dès le XIXe siècle que la sécurité doit être mathématiquement démontrable et qu’il n’existe pas de sécurité par l’obscurité."
  },
  {
    "objectID": "exam_notes_fr.html#principe-de-kerckhoffs-1",
    "href": "exam_notes_fr.html#principe-de-kerckhoffs-1",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Principe de Kerckhoffs",
    "text": "Principe de Kerckhoffs\nAuguste Kerckhoffs publie en 1883 deux articles définissant six principes pour les chiffrements militaires :\n\nLe système doit être pratiquement, voire mathématiquement indéchiffrable.\nIl ne doit pas nécessiter de confidentialité et rester sûr même s’il tombe aux mains de l’ennemi.\nLa clé doit pouvoir être mémorisée, transmise et modifiée facilement, sans notes écrites.\nLe système doit être compatible avec les communications télégraphiques.\nIl doit être portable et utilisable par une seule personne.\nIl doit être simple à utiliser, sans procédures complexes ni contraintes excessives.\n\nKerckhoffs affirme dès le XIXe siècle que la sécurité doit être mathématiquement démontrable et qu’il n’existe pas de sécurité par l’obscurité."
  },
  {
    "objectID": "exam_notes_fr.html#classification-des-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#classification-des-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Classification des systèmes de cryptage",
    "text": "Classification des systèmes de cryptage\n\nSécurité inconditionnelle\n(unconditional security / perfect secrecy)\n\nSécurité indépendante de la puissance de calcul.\nCiphertext n’apporte aucune info sur le plaintext.\nConditions : clé ≥ message, jamais réutilisée.\nUsage surtout théorique.\nExemple : one-time pad.\n\n\n\nAs hard as / équivalent / provable security\n\nCryptanalyse aussi difficile qu’un problème mathématique difficile.\nRSA et Rabin prouvés équivalent à la factorisation.\n\nDémontrée par réduction (reduction proof).\n\nConcept central mais controversé.\n\n\n\nSécurité calculatoire\n(computational security / practical security)\n\nSécurité basée sur le coût irréaliste des attaques.\nCatégorie la plus utilisée en pratique.\nExemples : AES, DES, IDEA, RC4.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nInconditionnelle : parfaite, théorique (one-time pad).\nProvable security : équivalence à problème mathématique difficile.\nCalculatoire : sûre en pratique.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nSécurité inconditionnelle (unconditional security aussi appelée perfect secrecy) :\n\nLa sécurité du système de cryptage n’est pas compromise par la puissance de calcul destinée à la cryptanalyse.\nCette catégorie s’appuie sur la théorie de l’information publiée par Shannon en 1949.\nPlus précisément, un système de cryptage est inconditionnellement sûr si la probabilité de rencontrer un plaintext x après l’observation du ciphertext correspondant y est identique à la probabilité à priori de rencontrer le plaintext x.\nEn d’autres termes, le fait de disposer de couples plaintext/ciphertext (x,y) ne constitue aucune aide pour la cryptanalyse.\nUne condition nécessaire pour qu’un système soit inconditionnellement sûr est que la clé soit au moins de la même taille que le message et, surtout, qu’elle ne soit pas réutilisée pour encrypter des messages différents.\nCette condition rend ces systèmes peu adaptés aux besoins cryptographiques habituels et réduit leur domaine d’intérêt à un cadre théorique.\nL’exemple classique est le one-time pad inventé en 1917 par J. Mauborgne and G. Vernam.\nFondements théoriques des systèmes inconditionnellement sûrs + d’autres exemples dans [Sti06].\n\nAs hard as / équivalent / provable security\n\nLorsqu’on peut prouver que la cryptanalyse de l’algorithme est aussi difficile que de résoudre un problème mathématique réputé difficile.\nPar exemple la factorisation de grands nombres, le calcul de racines carrées modulo un “composite”, le calcul de logarithmes discrets dans un groupe fini, etc.\nL’algorithme de Rabin et RSA (cas générique^1 ) sont “prouvés” équivalents à la factorisation.\nUne telle preuve s’appelle de “réduction” (reduction proof).\nLa notion de provable security est à l’origine d’une importante controverse dans le monde cryptographique.\n\nSécurité calculatoire (computational security aussi appelé practical security)\n\nUn système de cryptage est dans cette catégorie si l’effort calculatoire nécessaire à le “casser” en utilisant les meilleures techniques possibles est au delà (avec une marge raisonnable) des ressources de calcul d’un adversaire hypothétique.\nLa grande majorité de systèmes de cryptage symétriques (AES, DES, IDEA, RC4, etc.) sont dans cette catégorie."
  },
  {
    "objectID": "exam_notes_fr.html#entropie",
    "href": "exam_notes_fr.html#entropie",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Entropie",
    "text": "Entropie\n\nL’entropie (Shannon, 1948) mesure la quantité d’information effective contenue dans un message.\nL’entropie conditionnelle mesure l’incertitude qui reste sur le plaintext après observation du ciphertext.\n\n\nPropriétés\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0\\) → aucune incertitude\n\\(H(X) = \\log n\\) → tous les résultats équiprobables\n\n\n\nInterprétation\n\nApproxime le nombre de bits nécessaires pour encoder \\(X\\).\nLa redondance = différence entre codage effectif et entropie.\n\n\n\nEntropie conditionnelle\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\)\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\nMesure l’incertitude restante sur le plaintext après observation du ciphertext.\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nEntropie : quantité d’information d’un message.\nEntropie conditionnelle : incertitude sur le plaintext après le ciphertext.\nRedondance : différence entre codage effectif et entropie.\n\n\n\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\n\nUne définition essentielle en cryptographie est la quantité d’information effective contenue dans un message.\nPar exemple, les jours de la semaine (lundi, …, dimanche) peuvent intuitivement être encodés comme des chaînes de caractères de longueur (\\(\\le \\text{len}(\\text{``mercredi''})\\)), soit \\((8 \\times 8 = 64)\\) bits. Cependant, la quantité d’information effective de la variable jour de la semaine peut être encodée de manière optimale sur 3 bits (car \\((2^3 = 8)\\) est suffisant pour représenter les 7 variations possibles).\nL’entropie (Shannon, 1948) est la formalisation mathématique de cette définition.\n\n\nDéfinition formelle\nSoit \\(X\\) une variable aléatoire avec un ensemble fini de valeurs possibles \\({x_1, x_2, \\dots, x_n}\\), telles que \\(P(X=x_i) = p_i\\), avec \\(0 \\le p_i \\le 1\\) et \\(\\sum p_i = 1\\). L’entropie de \\(X\\), notée \\(H(X)\\), est définie par\n\\(H(X) = - \\sum_{i=1}^{n} p_i \\log p_i = \\sum_{i=1}^{n} p_i \\log \\left(\\frac{1}{p_i}\\right)\\)\nPar convention : \\(p_i \\log p_i = 0\\) si \\(p_i = 0\\). Tous les logarithmes sont en base 2.\n\n\nInterprétation\n\nApproximation du nombre de bits nécessaires pour encoder les éléments de \\(X\\).\nLa redondance est la différence entre le codage effectif et l’entropie.\n\n\n\nPropriétés\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0 \\iff \\exists i : p_i = 1, p_j = 0 \\ \\forall j \\ne i\\)\n\\(H(X) = \\log n \\iff p_i = 1/n \\ \\forall i\\)\n\n\n\nEntropie conditionnelle\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\),\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\n\nMesure l’incertitude sur \\(X\\) (plaintext) après avoir observé \\(Y\\) (ciphertext)."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#attaques-sur-les-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les systèmes de cryptage",
    "text": "Attaques sur les systèmes de cryptage\n\nCiphertext-only : Adversaire a seulement le ciphertext.\nKnown-plaintext : Adversaire a des couples plaintext/ciphertext.\nChosen-plaintext : Adversaire peut choisir le plaintext et voir le ciphertext (et essaye de trouver le plaintext pour d’autres messages).\nAdaptive chosen-plaintext : dépend des ciphertexts reçus.\nChosen-ciphertext : Adversaire choisit le ciphertext et obtient le plaintext (vise à trouver la clé).\nAdaptive Chosen-ciphertext : Chosen-ciphertext dépend des plaintexts reçus"
  },
  {
    "objectID": "exam_notes_fr.html#oracles-et-modèles-de-sécurité",
    "href": "exam_notes_fr.html#oracles-et-modèles-de-sécurité",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Oracles et Modèles de Sécurité",
    "text": "Oracles et Modèles de Sécurité\n\nOracles Aléatoires et Modèles de Sécurité\n\nOracle Aléatoire (Random Oracle) : Une fonction théorique “parfaite” qui renvoie une valeur uniforme et aléatoire pour chaque nouvelle entrée, mais reste déterministe pour une entrée déjà vue.\nROM (Random Oracle Model - Modèle de l’Oracle Aléatoire) : Cadre de preuve mathématique utilisant cet oracle idéal comme substitut aux fonctions de hachage.\nModèle Standard : Cadre où la sécurité repose uniquement sur la puissance de calcul de l’adversaire face à des algorithmes réels.\nLimite : Une preuve de sécurité en ROM ne garantit pas la sécurité absolue dans le monde réel (avec SHA-256, etc.).\n\n\n\n\n\n\n\nNoneVersion originale\n\n\n\n\n\nUn oracle aléatoire est une entité abstraite accessible aux parties légitimes et aux adversaires.\n\nComportement : Il répond aux requêtes d’entrée \\(x\\) par des réponses parfaitement aléatoires \\(Orc(x)\\).\nDéterminisme : La seule exception réside dans les entrées précédemment traitées (\\(x_1, x_2, \\dots, x_n\\)). Si \\(x_1' = x_1\\), alors \\(Orc(x_1') = Orc(x_1)\\).\nModélisation : On le modélise par une fonction \\(Orc : X \\to Y\\) où \\(\\forall x \\in X, \\Pr(Orc(x) = y) = \\frac{1}{|Y|}\\).\nUtilité : Il se comporte comme une fonction de hachage cryptographique « idéale », outil précieux pour prouver la sécurité dans le Modèle d’Oracle Aléatoire.\nComparaison : Le modèle standard limite les adversaires par des facteurs computationnels. Un protocole sûr dans le modèle d’oracle aléatoire peut devenir vulnérable s’il est utilisé avec une fonction de hachage « réelle » (SHA-1, SHA-256).\n\n\n\n\n\n\n\nOracles de Chiffrement, Déchiffrement et Signature\n\nFonction : Entités qui exécutent des opérations (chiffrer/signer) pour l’adversaire en utilisant des clés secrètes sans jamais les révéler.\nCryptographie symétrique : L’oracle fournit \\(E_k(x)\\) ou \\(D_k(y)\\).\nCryptographie asymétrique : L’oracle est crucial pour les opérations privées (déchiffrement/signature), car les opérations publiques sont déjà libres d’accès.\n\n\n\n\n\n\n\nNoneVersion originale : Oracles Opérationnels\n\n\n\n\n\nUn oracle de chiffrement/déchiffrement/signature est une entité abstraite offrant un service « à la demande ».\n\nAccès aux clés : Il utilise les mêmes clés que les propriétaires légitimes (systèmes symétriques et asymétriques) sans les divulguer.\nPrimitives symétriques : Pour une primitive \\(E\\) et une clé \\(k\\), il renvoie \\(y = E_k(x)\\) ou le clair \\(x\\) correspondant.\nSystèmes à clé publique : L’oracle n’est nécessaire que pour les opérations à clé privée (\\(priv_k\\)).\n\nDéchiffrement : renvoie \\(x\\) tel que \\(E'_{pubk}(x) = y\\).\nSignature : Pour un système \\(S\\), il renvoie \\(y = S_{privk}(x)\\).\n\nAttaques : Les modèles d’attaques par texte clair choisi (CPA) et par texte chiffré choisi (CCA) reposent sur la mise à disposition de ces oracles pour l’adversaire.\n\n\n\n\n\n\n\nIndiscernabilité et Sécurité Sémantique (IND-CPA)\n\nPropriété : Un adversaire ne doit pas pouvoir distinguer les chiffrés de deux messages clairs différents.\nIND-CPA (Indistinguishability under Chosen Plaintext Attack - Indiscernabilité sous attaque à texte clair choisi) : Si l’adversaire ne devine le bon message qu’avec une probabilité de \\(1/2 + \\epsilon\\), le système est considéré comme sûr.\nSécurité Sémantique : Équivalente à l’IND-CPA, elle assure qu’aucune information utile ne fuite du chiffré.\n\n\n\n\n\n\n\nNoneVersion originale : Sécurité Sémantique\n\n\n\n\n\nL’indiscernabilité des textes chiffrés garantit l’incapacité de distinguer les chiffrés de messages clairs donnés.\n\nExpérience (Jeu de sécurité IND-CPA) :\n\nL’adversaire choisit deux messages \\(M_0\\) et \\(M_1\\).\nL’oracle choisit un indice aléatoire \\(i \\in \\{0,1\\}\\) et renvoie \\(c_i = E_k(M_i)\\).\nL’adversaire peut effectuer d’autres calculs ou appels oracles.\n\nDéfinition IND-CPA : Le système est sûr si l’avantage de l’adversaire est négligeable (\\(Prob = 1/2 + \\epsilon\\) avec \\(\\epsilon\\) petit).\nNote : En clé publique, l’oracle de chiffrement est inutile car l’adversaire possède déjà la clé publique. L’IND-CPA offre la sécurité sémantique.\n\n\n\n\n\n\n\nLe Chiffrement Probabiliste et l’OAEP\n\nProblème : Le chiffrement déterministe permet les attaques par dictionnaire (comparaison de chiffrés connus).\nSolution : Ajouter de l’aléa au message avant chiffrement pour que \\(E(M)\\) soit différent à chaque exécution.\nOAEP (Optimal Asymmetric Encryption Padding - Remplissage asymétrique optimal) : Standard utilisé avec RSA. Il combine le message \\(P\\) avec un nombre aléatoire \\(R\\) via des fonctions de hachage \\(h\\) et des XOR (\\(\\oplus\\)).\n\n\n\n\n\n\n\nNoneVersion originale : Déterminisme vs Probabilisme\n\n\n\n\n\nLe comportement déterministe (mêmes entrées = mêmes sorties) crée des failles.\n\nExemple : Si Alice envoie “Oui” ou “Non”, l’adversaire peut calculer \\(C_{yes} = E_{pub}(``Oui\")\\) et comparer. Il peut créer un livre de codes (dictionnaire) pour identifier les messages sans casser la clé.\nChiffrement probabiliste : Ajoute un caractère aléatoire. L’objectif est la sécurité sémantique pour la clé publique.\nOAEP : Utilisé dans RSA-PKCS1. Le texte \\(P\\) est combiné avec un aléa \\(R\\) :\n\n\\(M_1 := P \\oplus h(R)\\)\n\\(M_2 := R \\oplus h(M_1)\\)\nLe chiffrement porte sur \\(M_1\\) et \\(M_2\\). Au déchiffrement, on retrouve \\(R = M_2 \\oplus h(M_1)\\), puis \\(P = h(R) \\oplus M_1\\).\n\n\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nOracle Aléatoire : Fonction de hachage “idéale” (modèle théorique).\nOracles CPA/CCA : Simulent un accès à la clé secrète pour tester la résistance.\nIND-CPA : Impossibilité de distinguer deux chiffrés (Sécurité Sémantique).\nChiffrement Probabiliste : Indispensable pour contrer les livres de codes (attaques par dictionnaire).\nOAEP : Méthode de padding (remplissage) ajoutant l’aléa nécessaire au RSA."
  },
  {
    "objectID": "exam_notes_fr.html#histoire-de-la-cryptographie-et-sécurité-inconditionnelle",
    "href": "exam_notes_fr.html#histoire-de-la-cryptographie-et-sécurité-inconditionnelle",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Histoire de la Cryptographie et Sécurité Inconditionnelle",
    "text": "Histoire de la Cryptographie et Sécurité Inconditionnelle\n\nSystèmes de Cryptage Historiques\nLa cryptographie a longtemps été limitée à la seule recherche de la confidentialité. Les systèmes historiques reposent sur deux principes fondamentaux : la substitution et la transposition.\n\nChiffre de César (substitution mono-alphabétique) : Décalage fixe des lettres. Très vulnérable à l’analyse de fréquences.\nChiffre de Vigenère (substitution polyalphabétique) : Utilisation d’une clé pour varier le décalage. Plus complexe, mais cassable en identifiant la longueur de la clé.\nChiffre de Transposition : Réorganisation des caractères du texte original selon une permutation définie par une clé.\n\n\n\n\n\n\n\nNoneVersion originale : Cryptographie Historique\n\n\n\n\n\nPendant des siècles la confidentialité a été la seule application de la cryptographie…\n\nI av. JC, Caesar Cipher : Cryptage à substitution mono-alphabétique \\(e_k(x) = (x + k) \\pmod{26}\\), \\(d_k(y) = (y - k) \\pmod{26}\\) où \\(x, y, k \\in \\mathbb{Z}_{26}\\).\n\nExemple: \\(E_1(\\text{'bonjour'}) = \\text{'cpokpws'}\\).\nCryptanalyse : facile, basée sur la fréquence des caractères.\n\nXVI siècle, Vigenère : Cryptage à substitution polyalphabétique \\(e_k(x_1, \\dots, x_n) = (x_1 + k_1, \\dots, x_m + k_m, x_{m+1} + k_1, \\dots) \\pmod{26}\\).\n\nCryptanalyse : trouver la taille \\(m\\) de la clé en identifiant les portions de ciphertext répétées et analyser les blocs séparés comme dans le Caesar Cipher.\n\nTransposition Ciphers (Porta, 1563) : La clé définit une permutation sur le plaintext.\nCes techniques sont toujours à la base des systèmes de cryptage actuels (ex: Enigma, qualifiée par W. Churchill d’arme secrète ayant gagné la guerre).\n\n\n\n\n\n\nLe One-Time Pad (Masque Jetable)\nLe One-Time Pad (OTP), ou chiffre de Vernam, est le seul système prouvé inconditionnellement sûr (sécurité parfaite).\n\nPrincipe : Le message est combiné à une clé de même longueur via l’opération XOR (\\(\\oplus\\)).\nSécurité Inconditionnelle : L’observation du message chiffré n’apporte aucune information sur le message clair. Même un adversaire avec une puissance de calcul infinie ne peut pas le briser.\nContraintes de Shannon : La clé doit être aussi longue que le message, purement aléatoire, et utilisée une seule fois.\nRéutilisation de la clé : Si une clé est réutilisée pour deux messages, un attaquant peut éliminer la clé par XOR (\\(y_a \\oplus y_b = x_a \\oplus x_b\\)) et retrouver les messages clairs.\n\n\n\n\n\n\n\nNoneVersion originale : Le One-Time Pad\n\n\n\n\n\nSoit \\(n \\ge 1\\) et les espaces \\(P, C, K\\) tels que \\(P, C, K = (\\mathbb{Z}_2)^n\\). Les opérations d’encryption et decryption d’un one-time pad (Vernam Cipher) sont : \\(E_k(x_i) = x_i \\oplus k_i\\) et \\(D_k(y_i) = y_i \\oplus k_i\\) pour \\(1 \\le i \\le n\\).\n\nSécurité inconditionnelle : Si \\(k_i\\) sont aléatoires et indépendants, l’observation des ciphertexts n’aide pas la cryptanalyse. L’entropie de \\(X\\) ne diminue pas : \\(H(X|C) = H(X)\\).\nThéorème de Shannon : Condition nécessaire : \\(H(K) \\ge H(X)\\). La longueur de la clé aléatoire doit être au moins aussi grande que celle du plaintext.\nRéutilisation de clé : \\(y_a \\oplus y_b = x_a \\oplus x_b\\). Avec des messages de faible entropie, on retrouve les clairs et la clé (\\(k = y_a \\oplus x_a\\)).\nVulnérable à l’attaque Known Plaintext (si la clé est réutilisée).\nProblème majeur : La distribution et gestion des clés de grande taille. Relancé par la cryptographie quantique proposant des canaux confidentiels de distribution de clés de longueur illimitées.\n\n\n\n\n\n\nStéganographie\nÀ l’inverse de la cryptographie qui rend le message illisible, la stéganographie dissimule l’existence même du message.\n\nMéthode : Utiliser un “canal subliminal” (un support innocent comme une image ou un texte banal).\nTechnique moderne : Insertion de données dans les bits les moins significatifs (LSB - Least Significant Bits) de fichiers multimédias, permettant de cacher de gros volumes de données sans altération visible.\n\n\n\n\n\n\n\nNoneVersion originale : Stéganographie\n\n\n\n\n\nLa stéganographie cache un message à l’intérieur d’un autre. Éléments constituants :\n\nUn canal physique ou logique différent (canal subliminal).\nUn mécanisme secret pour identifier ce canal.\n\n\nExemples classiques : Premières lettres des mots d’un texte, encre invisible.\nExemple moderne : Utiliser les least significant bits (bits les moins significatifs) des frames d’un CD Photo.\nPour une image 2048x3072 (RGB 24 bits), cacher un message sur 1 bit permet de stocker 2.3 Mb sans détériorer la qualité.\n\n\n\n\n\n\n\n\n\n\nNoneUltra-synthèse\n\n\n\n\n\n\nHistorique : Substitution (César/Vigenère) et Transposition (permutation).\nOne-Time Pad : Sécurité absolue si la clé est aléatoire, unique et aussi longue que le message (\\(H(K) \\ge H(X)\\)).\nStéganographie : Cacher l’existence du message (ex: technique des LSB dans les images)."
  },
  {
    "objectID": "exam_notes_fr.html#stream-ciphers-cryptage-en-chaîne",
    "href": "exam_notes_fr.html#stream-ciphers-cryptage-en-chaîne",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Stream Ciphers (Cryptage en chaîne)",
    "text": "Stream Ciphers (Cryptage en chaîne)\n\nIntroduction aux Stream Ciphers\n\nDéfinition et Principe\nLes stream ciphers (chiffrements en flux) sont une famille de systèmes de cryptage caractérisés par :\n\nTaille de bloc unitaire : chaque bloc encrypté = 1 bit\nArchitecture en deux phases :\n\nGénération du keystream : production de la séquence de clés\nSubstitution : opération sur les bits du plaintext en fonction du keystream\n\n\nExemple classique : le one-time pad\n\nGénération : générateur (pseudo-)aléatoire\nSubstitution : opération XOR (\\(\\oplus\\)) avec le keystream\n\n\n\nCaractéristiques Générales\nAvantages :\n\nRapidité : cryptage au niveau des registres, idéal pour le streaming en temps réel (vidéo)\nLégèreté : fonctionnent sur systèmes à ressources CPU limitées\nFaible mémoire : pas ou peu de buffering nécessaire\nErreurs non propagées : retransmission des paquets défectueux suffisante (adapté aux transmissions sans fil - WiFi)\n\nInconvénients :\n\nDépendance à la qualité du keystream : le caractère aléatoire (randomness) détermine la robustesse\nRéutilisation dangereuse : la réutilisation du keystream permet une cryptanalyse facile\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nCryptage en chaîne (Stream Ciphers)\n\nLes stream ciphers constituent une famille de systèmes de cryptage où la taille du bloc encrypté est égale à 1 bit.\nLes stream ciphers sont généralement composés de deux phases:\n\nUne phase de génération de la séquence d’éléments formant la clé (le keystream).\nUne phase de substitution où les bits du plaintext subissent une opération spécifique dépendante du keystream.\n\nUn exemple évident d’un stream cipher est le one-time pad avec:\n\nUne phase de génération du keystream effectuée par un générateur (pséudo-) aléatoire.\nUne phase de substitution qui consiste à effectuer un xor (\\(\\oplus\\)) avec le keystream.\n\n\n\n\nStream Ciphers: Caractéristiques\n\nRapidité: Le cryptage se fait directement au niveau des registres. Idéal pour des applications nécessitant un cryptage “on the fly” comme le video streaming.\nFacilité: Les opérations peuvent être effectuées par des systèmes ayant des ressources CPU limitées.\nPas (ou peu…) besoin de mémoire/buffering.\nPropagation des erreurs limitée ou absente: la retransmission des paquets fautifs suffit normalement (adapté aux applications où les pertes de paquets sont fréquentes comme les transmissions sans fil (WiFi)).\nInconvénients:\n\nLa qualité en termes de randomness du keystream généré détermine la robustesse du système.\nLa réutilisation du keystream permet une cryptanalyse facile (cf. le one-time pad).\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nStream Ciphers = cryptage bit par bit en 2 phases (génération keystream + substitution).\nAvantages : rapides, légers, pas de propagation d’erreurs.\nInconvénients : qualité du keystream critique, réutilisation = vulnérabilité.\n\n\n\n\n\n\n\nStream Ciphers Synchrones\n\nPrincipe de Fonctionnement\nDans un stream cipher synchrone, le keystream dépend uniquement de la clé, indépendamment du plaintext et du ciphertext.\nÉquations du processus :\n\\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nOù :\n\n\\(\\sigma_i\\) : état à l’instant \\(i\\) (état initial \\(\\sigma_0\\) peut dépendre de \\(k\\))\n\\(k\\) : clé secrète\n\\(f\\) : fonction de transition d’état\n\\(g\\) : fonction de production du keystream \\(z_i\\)\n\\(h\\) : fonction de sortie produisant le ciphertext \\(c_i\\) à partir du plaintext \\(m_i\\)\n\n\n\n\n\n\ngraph LR\n    A[Clé k] --&gt; B[État σi]\n    B --&gt; C[Fonction f]\n    C --&gt; D[État σi+1]\n    B --&gt; E[Fonction g]\n    E --&gt; F[Keystream zi]\n    F --&gt; G[Fonction h]\n    H[Plaintext mi] --&gt; G\n    G --&gt; I[Ciphertext ci]\n    D -.-&gt;|boucle| B\n\n\n\n\n\n\n\n\nCaractéristiques\nExigence de synchronisation :\n\nÉmetteur et récepteur doivent partager la même clé \\(k\\) ET le même état \\(\\sigma_i\\)\nPerte de synchronisation = nécessité de mécanismes externes (marqueurs, analyse de redondance)\n\nPropriétés :\n\nPas de propagation d’erreur : modification du ciphertext n’affecte pas les séquences ultérieures\nAttention : suppression d’un ciphertext = désynchronisation du récepteur\n\nVulnérabilités aux attaques actives :\n\n✓ Détection : insertion, élimination, replay de fragments\n✗ Modification de bits : adversaire peut modifier des bits et analyser l’impact sur le plaintext\nSolution : mécanismes d’authentification supplémentaires nécessaires\n\n\n\nCas particulier : Stream Cipher Additif\nLe cas le plus fréquent où :\n\nFonctions \\(f\\) et \\(g\\) remplacées par un générateur aléatoire\nFonction \\(h\\) = addition modulo 2 (XOR : \\(\\oplus\\))\n\nFormule : \\(c_i = z_i \\oplus m_i\\)\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers Synchrones\n\nLe keystream généré dépend seulement de la clé et non pas du plaintext ni du ciphertext.\nLe processus d’encryption d’un stream cipher synchrone est décrit par les équations suivantes: \\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] avec \\(\\sigma_i\\) l’état initial qui peut dépendre de la clé \\(k\\), \\(f\\) la fonction qui détermine l’état suivant, \\(g\\) la fonction qui produit le keystream \\(z_i\\) et \\(h\\) la fonction de sortie qui produit le ciphertext \\(c_i\\) à partir du plaintext \\(m_i\\).\n\n\n\nStream Ciphers Synchrones: Caractéristiques\n\nNécessitent la synchronisation de l’émetteur et du récepteur: En plus d’utiliser la même clé \\(k\\), les deux doivent se trouver dans le même état pour que le processus fonctionne. Si la synchronisation est perdue il faut des mécanismes externes pour la récupérer (marqueurs spéciaux, analyses de redondance du plaintext, etc.)\nPas de propagation d’erreur. La modification du ciphertext pendant la transmission n’entraîne pas des perturbations dans des séquences de ciphertext ultérieures (cependant, la suppression d’un ciphertext provoquerait la désynchronisation du récepteur).\nAttaques actives: L’insertion, l’élimination ou le replay de parties de ciphertext sont détectés par le récepteur. Cependant, un adversaire pourrait modifier certains bits du ciphertext et analyser l’impact sur le plaintext correspondant. Des mécanismes d’authentification d’origine supplémentaires sont nécessaires afin de détecter ces attaques.\nCas les plus fréquent des Stream Cipher Synchrones: le stream cipher additif (cf. le one-time pad) où les fonctions \\(f\\) et \\(g\\) générant le keystream sont remplacées par un générateur aléatoire et la fonction \\(h\\) est une addition modulo 2 (xor).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nSynchrone : keystream = \\(f\\)(clé uniquement). Équations : \\(\\sigma_{i+1} = f(\\sigma_i, k)\\), \\(z_i = g(\\sigma_i, k)\\), \\(c_i = h(z_i, m_i)\\).\nExige synchronisation émetteur/récepteur. Pas de propagation d’erreur mais vulnérable aux modifications de bits.\nCas fréquent : cipher additif avec XOR.\n\n\n\n\n\n\n\nStream Ciphers Asynchrones\n\nPrincipe de Fonctionnement\nAussi appelés auto-synchronisés (self-synchronizing ciphers).\nLe keystream dépend de la clé ET d’un nombre fixe de ciphertexts précédents.\nÉquations du processus :\n\\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nOù \\(\\sigma_i\\) représente un buffer des \\(t\\) derniers ciphertexts.\n\n\n\n\n\ngraph LR\n    A[Clé k] --&gt; B[Fonction g]\n    C[Buffer: ci-t...ci-1] --&gt; B\n    B --&gt; D[Keystream zi]\n    D --&gt; E[Fonction h]\n    F[Plaintext mi] --&gt; E\n    E --&gt; G[Ciphertext ci]\n    G -.-&gt;|feedback| C\n\n\n\n\n\n\n\n\nCaractéristiques\nAuto-synchronisation :\n\nEn cas d’insertion/élimination de ciphertexts, le récepteur se re-synchronise automatiquement\nMécanisme : mémorisation (buffer) des derniers ciphertexts\n\nPropagation d’erreurs limitée :\n\nErreur se propage uniquement sur la taille du buffer (\\(t\\) bits)\nAprès épuisement du buffer, décryption correcte reprend\n\nSécurité face aux attaques actives :\n\nMeilleure détection : modifications détectées grâce à la propagation d’erreurs\nAttention : l’auto-synchronisation permet au récepteur de continuer même après insertions/suppressions\nSolution : vérification de l’intégrité et l’authenticité du flux entier nécessaire\n\nDiffusion des statistiques du plaintext :\n\nChaque bit du plaintext influence tous les ciphertexts subséquents\nRésultat : meilleure dispersion des statistiques vs. cas synchrone\nApplication : utiliser pour plaintexts à faible entropie ou fortement redondants\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers Asynchrones\n\nAussi appelés auto-synchronisés (self synchronizing ciphers).\nLe keystream généré dépend de la clé ainsi que d’un nombre fixé de ciphertexts précédents.\nLe processus d’encryption d’un stream cipher asynchrone est décrit par les équations suivantes: \\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] avec \\(\\sigma_i\\), \\(g\\) et \\(h\\) comme pour le cas synchrone.\n\n\n\nStream Ciphers Asynchrones: Caractéristiques\n\nAuto-synchronisation: En cas d’élimination ou d’insertion de ciphertexts en cours de route, le récepteur est capable de se re-synchroniser avec l’émetteur grâce à la mémorisation (buffer) d’un nombre de ciphertext précédents.\nPropagation d’erreurs limitée: La propagation d’erreurs s’étend uniquement au nombre de bits du ciphertext mémorisés (taille du buffer). Après, la decryption se déroule à nouveau correctement.\nAttaques actives: La modification de fragments du ciphertext sera plus facilement détecté que dans le cas synchrone à cause de la propagation d’erreurs. Cependant, comme le récepteur est capable de s’auto-synchroniser avec l’émetteur, même si des ciphertexts sont éliminés ou insérés en cours de route, il convient de vérifier l’intégrité et l’authenticité du flot entier.\nDiffusion des statistiques du plaintext: Le fait que chaque bit du plaintext aura une influence sur la totalité des ciphertexts subséquents se traduit par une plus grande dispersion des statistiques du plaintext comparée au cas synchrone…\n… Il convient, donc, d’utiliser des stream ciphers asynchrones lorsque l’entropie des plaintexts est limitée et pourrait permettre des attaques ciblées aux plaintexts fortement redondants.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nAsynchrone (auto-synchronisé) : keystream = \\(f\\)(clé + derniers ciphertexts). État \\(\\sigma_i\\) = buffer de \\(t\\) ciphertexts précédents.\nAuto-synchronisation automatique. Propagation d’erreur limitée au buffer.\nMeilleure diffusion des statistiques → idéal pour plaintexts redondants/faible entropie.\n\n\n\n\n\n\n\nGénérateurs de Keystreams : LSFR\n\nContexte et Nécessité\nProblématique : générer un keystream de longueur \\(m\\) à partir d’une clé secrète de longueur \\(l\\) avec \\(l \\ll m\\).\nSolution : Linear Feedback Shift Register (LSFR ou LFSR)\n\n\nCaractéristiques des LSFR\nAvantages :\n\nImplémentation hardware optimale : circuits très efficaces\nPériodes longues : séquences de grande longueur\nBonne qualité aléatoire : randomness notable\nBase mathématique : propriétés algébriques des combinaisons linéaires\n\nStructure générique : LSFR de longueur \\(L\\)\n\n\n\n\n\ngraph LR\n    A[bit L-1] --&gt; B[bit L-2]\n    B --&gt; C[...]\n    C --&gt; D[bit 1]\n    D --&gt; E[bit 0]\n    E --&gt; F[Output]\n    A -.-&gt;|feedback| G[⊕]\n    D -.-&gt;|coeff| G\n    C -.-&gt;|coeff| G\n    G --&gt; A\n\n\n\n\n\n\n\n\nRemarques Importantes sur les LSFR\nHistorique et Usage :\n\nConstruction très répandue en cryptographie et théorie des codes\nNombreux stream ciphers militaires basés sur LSFR\n\nLimites de Sécurité :\n\nNiveau de sécurité insuffisant comparé aux block ciphers modernes\nVulnérabilité : l’algorithme de Berlekamp-Massey permet de :\n\nDéterminer la complexité linéaire d’un LSFR\nCalculer un nombre arbitraire de séquences générées\n\n\nMétrique : Complexité linéaire (linear complexity)\nSolution d’Amélioration :\nRemplacer la combinaison linéaire par une fonction non linéaire \\(f\\)\n→ Non Linear Feedback Shift Registers (NLFSR)\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nStream Ciphers: Générateurs de Keystreams\n\nLorsqu’il convient de générer un keystream d’une longueur \\(m\\) à partir d’une clé secrète de longueur \\(l\\) avec \\(l \\ll m\\), on fait appel à des générateurs de keystreams.\nLe plus courant de ces générateurs est le Linear Feedback Shift Register (LSFR).\nUn LSFR a les caractéristiques suivantes:\n\nS’adapte très bien aux implantations hardware.\nProduit des séquences de périodes longues et avec une qualité aléatoire notable (randomness assez forte)\nSe base sur les propriétés algébriques des combinaisons linéaires.\n\n\n\n\nLSFRs: Quelques Remarques\n\nLes LSFRs sont des constructions très répandues dans la cryptographie et dans la théorie de codes.\nUn grand nombre de stream ciphers basés sur les LSFRs (surtout dans la sphère militaire) ont été développés dans le passé.\nMalheureusement, le niveau de sécurité offert par ces systèmes est jugé insuffisant de nos jours (comparé à celui des blocks ciphers…)\nLa métrique permettant d’analyser un LFSR est sa complexité linéaire (linear complexity). L’algorithme de Berlekamp-Massey permet de déterminer la complexité linéaire d’un LSFR et de calculer ainsi un nombre arbitrairement grand de séquences générées par un LSFR.\nUne solution pour augmenter la complexité est de substituer la combinaison linéaire des bits du ciphertext par une fonction non linéaire \\(f\\). Ce sont les Non Linear Feedback Shift Registers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nLSFR : générateur de keystream long (\\(m\\)) depuis clé courte (\\(l\\)). Base = combinaisons linéaires.\nAvantages : hardware efficace, périodes longues.\nProblème : sécurité insuffisante, vulnérable à Berlekamp-Massey (calcul de complexité linéaire).\nSolution : NLFSR (fonction non linéaire).\n\n\n\n\n\n\n\nRC4 : Stream Cipher Logiciel\n\nPrésentation Générale\nRC4™ (Rivest Cipher 4) développé en 1987 par Ron Rivest pour RSA Security.\nCaractéristiques principales :\n\nClé variable : longueur flexible\nExtrêmement rapide : 10× plus rapide que DES\nMode synchrone : keystream indépendant du plaintext/ciphertext\n\nHistorique :\n\n1987-1994 : breveté, détails confidentiels (contrat NDA requis)\n1994 : publication non officielle dans un newsgroup\nDepuis : analyse intensive par la communauté cryptographique\n\n\n\nArchitecture\nComposants clés :\n\nS-box : boîte de substitution 8×8 (256 entrées)\n\nContenu : permutation des nombres 0 à 255\nDépend de la clé principale de longueur variable : \\(0 &lt; len(k) \\leq 255\\)\n\nCombinaisons : linéaires et non linéaires\nChiffrement final : XOR entre keystream et plaintext\n\n\n\nApplications et Sécurité\nUtilisations commerciales (nombreuses) :\n\nLotus Notes\nOracle SQL\nMicrosoft Windows\nSSL/TLS\nEt bien d’autres…\n\nAnalyses et Vulnérabilités :\n\nTravaux exhaustifs sur le key scheduling et le PRGA\nFaille majeure : implémentation dans WEP (WiFi Wired Equivalent Privacy)\n\nProtocole WEP complètement compromis\nProblème : mode d’utilisation défaillant, pas l’algorithme RC4 lui-même\n\n\n\n\nFonctionnement\nRC4 se décompose en deux étapes :\n\nKey Scheduling Algorithm (KSA)\n\nResponsable de la permutation initiale de la S-box\nFonction de la clé de longueur variable \\(len(k) = l\\)\n\nPseudo Random Generator Algorithm (PRGA)\n\nGénère le keystream de taille arbitraire\nS’appuie sur la S-box permutée par KSA\n\n\n\n\n\n\n\ngraph TB\n    A[Clé k de longueur variable] --&gt; B[KSA: Key Scheduling]\n    B --&gt; C[S-box permutée]\n    C --&gt; D[PRGA: Génération]\n    D --&gt; E[Keystream zi]\n    E --&gt; F[XOR]\n    G[Plaintext mi] --&gt; F\n    F --&gt; H[Ciphertext ci]\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\n\nSoftware Cipher Streams: RC4\n\nLe grand désavantage des stream ciphers basés sur des registres est qu’ils sont très lents en version programmée dans une machine générique. RC4™ est un stream cipher à clé variable développé en 1987 par Ron Rivest pour la société RSA security. Il est très rapide (10 fois plus rapide que DES !)\nPendant 7 ans, cet algorithme était breveté et les détails son fonctionnement interne était dévoilés seulement après la signature d’un contrat de confidentialité. Depuis sa publication (non officielle) dans un newsgroup en 1994, il est globalement discuté et analysé dans toute la communauté cryptographique.\nL’algorithme travaille en mode synchrone (le keystream est indépendant du ciphertext et du plaintext).\nIl est composé de combinaisons linéaires et non linéaires. L’élément clé est une boîte de substitution (S-box) de taille 8×8 dont les entrées sont une permutation des chiffres 0 à 255. La permutation est une fonction de la clé principale de taille variable avec \\(0 &lt; len(k) \\leq 255\\). L’encryption finale est obtenue par un xor entre le keystream et le plaintext.\nRC4 est utilisé dans un grand nombre d’applications commerciales: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. Il est l’objet d’un grand nombre de travaux analytiques et exhaustifs qui ont réussi à compromettre la sécurité du key scheduling et du PRGA.\nEn particulier l’application de RC4 sur les Wired Equivalent Privacy (WiFi WEP) protocole a été “cassée” suite à une faille dans le mode d’utilisation du protocole.\n\n\n\nRC4: Fonctionnement\n\nL’algorithme est constitué de deux étapes:\n\nLe Key Scheduling Algorithm (KSA): Responsable de la permutation initiale qui remplira la S-box en fonction de la clé de longueur variable \\(len(k) = l\\).\nLe Pseudo Random Generator Algorithm (PRGA): Génère le keystream de taille arbitraire en s’appuyant sur la S-box.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nRC4 : stream cipher logiciel, clé variable, 10× plus rapide que DES.\nArchitecture : S-box 8×8 (permutation 0-255) + XOR.\n2 étapes : KSA (permutation S-box) + PRGA (génération keystream). Mode synchrone.\nVulnérabilité : WEP cassé (faille d’utilisation). Utilisé dans SSL, Windows, Oracle…"
  },
  {
    "objectID": "exam_notes_fr.html#block-ciphers-cryptage-par-blocs",
    "href": "exam_notes_fr.html#block-ciphers-cryptage-par-blocs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Block Ciphers (Cryptage par Blocs)",
    "text": "Block Ciphers (Cryptage par Blocs)\n\n1. Introduction aux Block Ciphers\n\nDéfinition et Principe\nUn block cipher (chiffrement par blocs) est une fonction cryptographique qui :\n\nTransforme des blocs de taille fixe : fait correspondre un bloc de \\(n\\) bits à un autre bloc de la même taille\nEst paramétrisée par une clé : la clé \\(K\\) de \\(k\\) bits définit la transformation\nDoit être bijective : pour permettre un décryptage unique\nChaque clé = bijection différente : garantit la variabilité\n\nTaille nominale : taille d’entrée du bloc sur lequel s’applique l’encryption\n\n\nCritères de Qualité\n1. Taille/Entropie de la clé\n\nClés idéalement équiprobables avec entropie = \\(k\\) bits\nForte entropie protège contre les attaques brute-force\nMinimum requis : 128 bits pour les block ciphers modernes\n\n2. Performances\n\nVitesse d’exécution\nEfficacité en software/hardware\n\n3. Taille du bloc\n\nBloc trop petit = vulnérabilité aux dictionnaires plaintext/ciphertext\nStandard moderne : blocs ≥ 128 bits\n\n4. Résistance cryptographique\n\nRésistance aux techniques connues :\n\nCryptanalyse linéaire\nCryptanalyse différentielle\nMeet in the middle\n\nEffort de cryptanalyse équivalent au brute force\n\n\n\n\n\n\ngraph LR\n    A[Plaintext n bits] --&gt; B[Block Cipher]\n    C[Clé K k bits] --&gt; B\n    B --&gt; D[Ciphertext n bits]\n    \n    style B fill:#e1f5ff\n    style C fill:#fff4e1\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\nCryptage par Blocs (Block Ciphers)\n\nLes block ciphers symétriques constituent la pierre angulaire de la cryptographie. Leur fonctionnalité principale est la confidentialité mais ils sont également à la base des services d’authentification, fonctions de hachage, génération aléatoire, etc.\nDéfinition: Un block cipher est une fonction qui fait correspondre à un bloc de \\(n\\) bits un autre bloc de la même taille. La fonction est paramètrée par une clé \\(K\\) de \\(k\\) bits. Afin de permettre une decryption unique, la fonction doit être bijective. Chaque clé définit une bijection différente. La taille d’entrée du bloc sur lequel s’applique l’encryption s’appelle aussi taille nominale de l’algorithme.\nCritères pour évaluer la qualité d’un block cipher:\n\nTaille/Entropie de la clé: Idéalement, les clés sont équiprobables et l’espace des clés a une entropie égale à \\(k\\). Une forte entropie de la clé protège des attaques brute-force à partir de chosen/known plaintexts. Les block ciphers modernes doivent avoir des clés d’au moins 128 bits.\nPerformances\nTaille du bloc: Un bloc trop petit permettrait des attaques où des “dictionnaires” plaintext/ciphertext seraient construits. De nos jours, des blocs de taille ≥ 128 bits deviennent courants.\nRésistance cryptographique: Le block cipher doit se montrer résistant à des techniques de cryptanalyse connues: cryptanalyse linéaire ou différentielle, meet in the middle, etc. L’effort inhérent à ces attaques (complexité, stockage, parallélisation, etc.) doit être équivalent à celui d’une attaque brute force.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nBlock cipher : fonction bijective transformant blocs de \\(n\\) bits avec clé \\(K\\) de \\(k\\) bits. Critères : entropie clé ≥ 128 bits, taille bloc ≥ 128 bits, résistance cryptanalyse = effort brute force. Usage : confidentialité, authentification, hachage, génération aléatoire.\n\n\n\n\n\n\n\n2. Modes d’Opération des Block Ciphers\n\n2.1 Electronic Codebook (ECB)\nPrincipe : chaque bloc de plaintext est encrypté indépendamment avec la même clé.\n\\[c_i = E_K(m_i)\\] \\[m_i = D_K(c_i)\\]\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        P1[Plaintext Block 1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext Block 1]\n        \n        P2[Plaintext Block 2] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext Block 2]\n    end\n    \n    style E1 fill:#ffcccc\n    style E2 fill:#ffcccc\n    style K1 fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\nCaractéristiques :\n\n✗ Plaintexts identiques → ciphertexts identiques (prévisible)\n✓ Pas de propagation d’erreurs : erreur sur \\(c_j\\) n’affecte que \\(m_j\\)\n✗ Patterns visibles : structure du plaintext transparente dans le ciphertext\n✓ Parallélisable : chaque bloc traité indépendamment\n\n⚠️ Vulnérabilité majeure : Ne doit PAS être utilisé pour des données redondantes\n\n\n\n2.2 Cipher Block Chaining (CBC)\nPrincipe : chaque bloc de plaintext est XORé avec le ciphertext précédent avant encryption.\n\\[c_i = E_K(m_i \\oplus c_{i-1})\\] \\[m_i = D_K(c_i) \\oplus c_{i-1}\\]\nAvec \\(c_0 = IV\\) (Initialization Vector)\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        IV[IV] --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext c1]\n        \n        C1 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ccffcc\n    style E2 fill:#ccffcc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Patterns effacés : chaînage masque la structure\n✓ Propagation d’erreurs limitée : erreur sur \\(c_j\\) affecte \\(m_j\\) et \\(m_{j+1}\\) uniquement\n✗ Non parallélisable en encryption (séquentiel)\n✓ Parallélisable en décryption\n\nIV (Initialization Vector) :\n\nDoit être aléatoire ou pseudo-aléatoire\nPeut être transmis en clair\nDoit être différent pour chaque message avec la même clé\n\n\n\n\n2.3 Cipher Feedback Mode (CFB)\nPrincipe : fonctionne comme un stream cipher où le keystream est généré par le block cipher. Le keystream dépend des ciphertexts précédents (mode asynchrone).\n\\[c_i = m_i \\oplus E_K(c_{i-1})\\] \\[m_i = c_i \\oplus E_K(c_{i-1})\\]\nAvec \\(c_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph CFB_Encryption\n        IV[IV / ci-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        C1 -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#ffccff\n    style X1 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Chaînage : dépendances entre ciphertexts\n⚠️ Propagation d’erreurs : erreur sur \\(c_j\\) affecte \\(\\frac{n}{r}\\) blocs suivants\n\n\\(n\\) = taille nominale du block cipher\n\\(r\\) = taille des plaintexts\n\n✗ Non parallélisable\n⚠️ IV non confidentiel mais doit être transmis\n\nUsage : adapté aux transmissions avec pertes de paquets fréquentes\n\n\n\n2.4 Output Feedback Mode (OFB)\nPrincipe : fonctionne comme un stream cipher synchrone. Le keystream est entièrement déterminé par la clé et l’IV, indépendant du plaintext et du ciphertext.\n\\[z_i = E_K(z_{i-1})\\] \\[c_i = m_i \\oplus z_i\\] \\[m_i = c_i \\oplus z_i\\]\nAvec \\(z_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph OFB_Mode\n        IV[IV / zi-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; Z[zi keystream]\n        Z --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        Z -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#cce5ff\n    style X1 fill:#ffffcc\n    style Z fill:#e1ffe1\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Plaintexts identiques → ciphertexts différents (si IV change)\n✓ Pas de propagation d’erreurs : erreur sur \\(c_j\\) n’affecte que \\(m_j\\)\n✓ Keystream pré-calculable : efficace\n⚠️ CRITIQUE : ne JAMAIS réutiliser le même IV avec la même clé (sinon keystream identique)\n✓ Parallélisable si keystream pré-calculé\n\n⚠️ Attention réutilisation : Modifier l’IV pour chaque nouveau message !\n\n\n\n\n\n\nNote📄 Texte original (Modes CFB et OFB)\n\n\n\n\n\nModes CFB et OFB: Caractéristiques\nLes modes CFB et OFB fonctionnent comme un stream cipher avec un keystream généré par le bloc de cryptage. Dans CFB, le keystream dépend des ciphertexts précédents (asynchrone) alors que dans OFB, le keystream est entièrement déterminé par la clé et le IV (synchrone).\nParticularités de CFB:\n\nComme dans le mode CBC, des plaintext identiques sont traduits en ciphertexts différents si le IV change. Le IV n’est pas nécessairement confidentiel et peut être échangé en clair entre les parties.\nLe chaînage introduit également des dépendances entre les ciphertexts courants et les ciphertexts précédents. En particulier, si \\(n\\) est la taille nominale de l’algorithme et \\(r\\) est la taille des plaintexts, le ciphertext courant dépendra des \\(\\frac{n}{r}\\) ciphertexts précédents (chaque itération décalera l’entrée fautive de \\(r\\) positions, après \\(\\frac{n}{r}\\) itérations le ciphertext fautif sera “expulsé” complètement).\nLa propagation d’erreurs obéit au même principe: une erreur dans un ciphertext se traduira par une mauvaise decryption des \\(\\frac{n}{r}\\) ciphertexts suivants.\n\nParticularités de OFB:\n\nOFB a un comportement identique aux modes CBC et CFB pour l’encryption de plaintext identiques.\nPas de propagation d’erreurs sur les ciphertexts adjacents.\nModifiez le IV si la clé ne change pas pour éviter la réutilisation du keystream !!!\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Modes CFB/OFB)\n\n\n\n\n\nCFB (asynchrone) : keystream = \\(f\\)(ciphertexts précédents). Propagation erreur limitée (\\(\\frac{n}{r}\\) blocs).\nOFB (synchrone) : keystream = \\(f\\)(clé + IV uniquement). Pas propagation erreur.\nCRITIQUE : ne JAMAIS réutiliser même IV avec même clé. IV transmissible en clair.\n\n\n\n\n\n\n2.5 Counter Mode (CTR)\nPrincipe : le keystream est généré par l’encryption d’un compteur incrémenté à chaque bloc.\n\\[c_i = m_i \\oplus E_K(counter + i)\\] \\[m_i = c_i \\oplus E_K(counter + i)\\]\n\n\n\n\n\ngraph TB\n    subgraph CTR_Mode\n        CTR1[Counter + 0] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; C1[Ciphertext c1]\n        \n        CTR2[Counter + 1] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ffe6cc\n    style E2 fill:#ffe6cc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCaractéristiques :\n\n✓ Mode synchrone : keystream = \\(f\\)(compteur)\n✓ Parallélisable : keystream pré-calculable pour encryption ET décryption\n✓ Accès aléatoire : chaque bloc décryptable indépendamment\n✓ Pas de propagation d’erreurs\n✓ Profite des architectures SIMD : pas de dépendances entre blocs\n⚠️ Compteur : doit être de taille \\(2^b\\) (\\(b\\) = taille du bloc)\n⚠️ CRITIQUE : ne JAMAIS réutiliser le même compteur avec la même clé\n\nGestion du compteur :\n\nIncrémenter modulo \\(2^b\\) après chaque itération\nSolution : toujours incrémenter pour chaque flux encrypté\nPremier bloc du flux \\(i+1\\) &gt; dernier bloc du flux \\(i\\)\n\nApplications :\n\nATM (Asynchronous Transfer Mode)\nIPsec (IP security)\nLignes à haut débit : transmission sélective des blocs\nTransferts de grands volumes : vidéo\n\n\n\n\n\n\n\nNote📄 Texte original (Counter Mode)\n\n\n\n\n\n\nCounter Mode (CTR Mode)\nFréquemment utilisé comme support d’encryption dans des protocoles de transfert de données comme ATM (Asynchronous Transfer Mode) et IPsec (IP security).\n\n\nCounter Mode (II)\n\nLe keystream est généré par l’encryption d’un compteur aléatoire de taille \\(2^b\\) (avec \\(b\\) la taille du bloc) et nécessaire pour la décryption. Ce compteur est incrémenté modulo \\(2^b\\) après chaque itération.\nTravaille en mode synchrone. La réutilisation d’un même compteur se traduit par un keystream identique !\nSolution: Toujours incrémenter le compteur pour chaque flot encrypté de telle sorte que le compteur du premier bloc d’un flot soit plus grand que le dernier bloc du flot précédent.\nFacilement parallélisable: Le keystream peut être pré-calculé aussi bien pour l’encryption que pour la décryption. Profite pleinement des architectures SIMD car contrairement aux autres modes de chaînage il n’y a pas des dépendances entre les opérations des différents blocs.\nAccès aléatoire à l’encryption/décryption de chaque bloc: Contrairement aux autres modes de chaînage où la \\(i\\)-ème opération dépend de la \\((i-1)\\)-ème opération.\nSi à ceci on ajoute l’absence de propagation d’erreurs, le mode compteur facilite la (re)transmission sélective des blocs de ciphertext, ce qui le rend très attractif pour la sécurisation de lignes à haut débit ainsi que pour les transferts encryptés de grands volumes d’information (p.ex. vidéo).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Counter Mode)\n\n\n\n\n\nCTR : keystream = \\(E_K\\)(compteur + \\(i\\)).\nAvantages : parallélisable (encryption + décryption), accès aléatoire, pas propagation erreur, SIMD-friendly.\nCRITIQUE : ne jamais réutiliser compteur.\nUsage : ATM, IPsec, haut débit, vidéo.\n\n\n\n\n\n\n\n3. Product Ciphers et Feistel Ciphers\n\nProduct Ciphers\nDéfinition : schéma de cryptage combinant une série de transformations successives pour renforcer la résistance à la cryptanalyse.\nTransformations courantes :\n\nTranspositions (permutations)\nSubstitutions (S-boxes)\nXORs\nCombinaisons linéaires\nMultiplications modulaires\n\n\n\nFeistel Ciphers\nDéfinition : product cipher itératif avec structure spécifique.\nPrincipe de fonctionnement :\n\nEntrée : plaintext de \\(2t\\) bits = \\((L_0, R_0)\\) (deux sous-blocs de \\(t\\) bits)\nSortie : ciphertext de \\(2t\\) bits = \\((R_r, L_r)\\) après \\(r\\) étapes (rounds)\nChaque étape : bijection inversible (pour décryption unique)\n\nÉquations d’une étape \\(i\\) (\\(1 \\leq i \\leq r\\)) :\n\\[(L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\]\nAvec :\n\n\\(L_i = R_{i-1}\\)\n\\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph Feistel_Round\n        L0[Li-1] --&gt; R1[Ri = Li-1 ⊕ f]\n        R0[Ri-1] --&gt; L1[Li = Ri-1]\n        R0 --&gt; F[Function f]\n        K[Key Ki] --&gt; F\n        F --&gt; XOR[⊕]\n        L0 --&gt; XOR\n        XOR --&gt; R1\n    end\n    \n    style F fill:#ffcccc\n    style XOR fill:#ffffcc\n    style K fill:#fff4e1\n\n\n\n\n\n\nCaractéristiques :\n\n\\(K_i\\) : sous-clés générées à partir de la clé principale \\(K\\)\nNombre d’étapes \\(r\\) : généralement pair et \\(\\geq 3\\)\n\nExemple : DES a 16 étapes\n\nPermutation finale : \\((L_r, R_r) \\rightarrow (R_r, L_r)\\)\nDécryption : identique à l’encryption mais sous-clés appliquées en ordre inverse (de \\(K_r\\) à \\(K_1\\))\n\nOpérations fréquentes :\n\nPermutations\nSubstitutions (S-boxes)\n\n\n\n\n\n\n\nNote📄 Texte original\n\n\n\n\n\nProduct Ciphers et Feistel Ciphers\n\nUn product cipher est un schéma de cryptage combinant une série de transformations successives dans le but de renforcer la résistance à la cryptanalyse. Des transformations courantes pour un product cipher sont: des transpositions, des substitutions, des XORs, des combinaisons linéaires, des multiplications modulaires, etc.\nUn Feistel cipher est un product cipher itératif capable de transformer un plaintext de \\(2t\\) bits de la forme \\((L_0, R_0)\\) composé par deux sous-blocs \\(L_0\\) et \\(R_0\\) de \\(t\\) bits en un ciphertext de taille \\(2t\\) de la forme \\((R_r, L_r)\\) après \\(r\\) étapes (rounds) successives avec \\(r \\geq 1\\). Chaque étape définit une bijection (inversible !) pour permettre une decryption unique.\nDes permutations et des substitutions sont les opérations les plus fréquentes.\nLes étapes \\(1 \\leq i \\leq r\\) s’écrivent: \\((L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\) avec \\(L_i = R_{i-1}\\) et \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\). Les \\(K_i\\) sont des sous-clés, différentes pour chaque étape, générées à partir de la clé principale \\(K\\) du schéma de cryptage.\nLe nombre d’étapes propres à un Feistel cipher est normalement pair et \\(\\geq 3\\) (p.ex. DES a 16 étapes)\nAprès l’exécution de toutes les étapes, un Feistel cipher effectue une permutation des deux parties \\((L_r, R_r)\\) en \\((R_r, L_r)\\).\nLa decryption d’un Feistel Cipher est identique à l’encryption sauf que les sous-clés \\(K_i\\) sont appliquées en ordre inverse (De \\(K_r\\) à \\(K_1\\)).\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide\n\n\n\n\n\nProduct cipher : combinaison de transformations successives (transpositions, substitutions, XOR).\nFeistel cipher :\n\nproduct cipher itératif\nplaintext \\(2t\\) bits = \\((L_0, R_0)\\)\n\\(r\\) rounds avec \\(L_i = R_{i-1}\\) et \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\).\nDécryption = encryption avec sous-clés inversées.\nExemple : DES (16 rounds).\n\n\n\n\n\n\n\n\n4. Data Encryption Standard (DES)\n\nPrésentation Générale\nDES (Data Encryption Standard) : algorithme cryptographique le plus important jusqu’à l’avènement d’AES en 2001.\nCaractéristiques principales :\n\nType : Feistel Cipher\nTaille des blocs : 64 bits (taille nominale)\nTaille de la clé : 56 bits effectifs (64 bits totaux avec 8 bits de parité)\nNombre d’étapes : 16 rounds\nSous-clés : 16 sous-clés de 48 bits (une par étape)\nModes d’utilisation : ECB, CBC, CFB, OFB\n\n\n\n\n\n\ngraph TB\n    subgraph DES_Overview\n        P[Plaintext 64 bits] --&gt; DES[DES Encryption]\n        K[Key 56 bits] --&gt; DES\n        DES --&gt; C[Ciphertext 64 bits]\n        \n        C --&gt; DES_INV[DES Decryption]\n        K2[Key 56 bits] --&gt; DES_INV\n        DES_INV --&gt; P2[Plaintext 64 bits]\n    end\n    \n    style DES fill:#ffcccc\n    style DES_INV fill:#ccffcc\n    style K fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\n\n\nStructure de DES\nComposants principaux :\n\nPermutation initiale (IP) : permutation des 64 bits d’entrée\n16 rounds Feistel : transformation itérative\nPermutation finale (IP⁻¹) : inverse de IP\n\nChaque round applique :\n\nDivision en deux moitiés : \\(L_{i-1}\\) et \\(R_{i-1}\\) (32 bits chacune)\nFonction \\(f\\) sur \\(R_{i-1}\\) avec sous-clé \\(K_i\\)\nXOR avec \\(L_{i-1}\\)\nÉchange des moitiés\n\n\n\n\n\n\ngraph TB\n    Plain[Plaintext 64 bits] --&gt; IP[Initial Permutation IP]\n    IP --&gt; Split[Split L0, R0]\n    \n    Split --&gt; Round1[Round 1]\n    K1[K1] --&gt; Round1\n    Round1 --&gt; Round2[Round 2]\n    K2[K2] --&gt; Round2\n    Round2 --&gt; Dots[...]\n    Dots --&gt; Round16[Round 16]\n    K16[K16] --&gt; Round16\n    \n    Round16 --&gt; Swap[Swap R16, L16]\n    Swap --&gt; IP_inv[Final Permutation IP⁻¹]\n    IP_inv --&gt; Cipher[Ciphertext 64 bits]\n    \n    style IP fill:#e1f5ff\n    style IP_inv fill:#e1f5ff\n    style Round1 fill:#ffcccc\n    style Round2 fill:#ffcccc\n    style Round16 fill:#ffcccc\n\n\n\n\n\n\n\n\nFonction Cipher de DES\nLa fonction \\(f\\) pour chaque round :\n\nExpansion E : 32 bits → 48 bits (table E)\nKey Addition : XOR avec sous-clé \\(K_i\\) (48 bits)\nS-boxes : 8 S-boxes transforment 48 bits → 32 bits\n\nChaque S-box : 6 bits entrée → 4 bits sortie\n\nPermutation P : permutation des 32 bits résultants\n\n\n\n\n\n\ngraph TB\n    R[Ri-1 32 bits] --&gt; E[Expansion E]\n    E --&gt; E_out[48 bits]\n    E_out --&gt; XOR1[⊕]\n    K[Ki 48 bits] --&gt; XOR1\n    XOR1 --&gt; S[8 S-boxes]\n    S --&gt; S_out[32 bits]\n    S_out --&gt; P[Permutation P]\n    P --&gt; F_out[f output 32 bits]\n    \n    style E fill:#cce5ff\n    style S fill:#ffcccc\n    style P fill:#e1ffe1\n    style XOR1 fill:#ffffcc\n\n\n\n\n\n\nFonctionnement des S-boxes :\nEntrée : \\(a_1a_2a_3a_4a_5a_6\\) (6 bits)\n\nLigne : \\(a_1 + 2a_6\\) (bits externes)\nColonne : \\(a_2 + 2a_3 + 4a_4 + 8a_5\\) (bits internes)\nSortie : valeur de la cellule correspondante (4 bits)\n\n\n\nGénération des Sous-clés\nProcessus :\n\nClé principale : 64 bits (56 effectifs + 8 parité)\nPermuted Choice 1 (PC-1) : sélection de 56 bits\nDivision en deux moitiés : \\(C_0\\) et \\(D_0\\) (28 bits chacune)\nPour chaque round \\(i\\) :\n\nRotation circulaire gauche de \\(C_{i-1}\\) et \\(D_{i-1}\\)\nPermuted Choice 2 (PC-2) : sélection de 48 bits pour \\(K_i\\)\n\n\nRotations :\n\nRounds 1, 2, 9, 16 : 1 position\nAutres rounds : 2 positions\n\n\n\n\n\n\n\nNote📄 Texte original (DES Fonctionnement)\n\n\n\n\n\nDES: Fonctionnement\nCipher Fonction\n\nExpansion E: Les 32 bits de l’entrée sont transformés en un vecteur de 48 bits en utilisant la table E. La première ligne de cette table indique comment sera généré le premier sous-bloc de 6 bits: on prendra en premier le 32e bit et après les bits 1,2,3,4,5. Le deuxième sous-bloc commence par le 4e bit ensuite les bits 5,6,7,8,9 et ainsi de suite…\nKey addition: XOR du vecteur de 48 bits avec la clé.\nS-boxes: On applique 8 S-boxes sur le vecteur de 48 bits résultant du XOR précédent. Chacune de ces S-boxes prend un sous-bloc de 6 bits et le transforme en un sous-bloc de 4 bits. L’opération s’effectue de la manière suivante: Si on dénote les 6 bits d’input de la S-box comme: \\(a_1a_2a_3a_4a_5a_6\\). La sortie est donnée par le contenu de la cellule située dans la ligne \\(a_1 + 2a_6\\) et la colonne \\(a_2 + 2a_3 + 4a_4 + 8a_5\\).\nPermutation P: La permutation P fonctionne comme suit: Le premier bit est envoyé à la 16e position, le deuxième à la 7e position et ainsi de suite.\n\nPermutations IP et IP⁻¹\n\nAgissent respectivement au début et à la fin du traitement du bloc et sur l’ensemble des 64 bits.\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (DES)\n\n\n\n\n\nDES : Feistel cipher, 64 bits blocs, 56 bits clé effective, 16 rounds.\nFonction \\(f\\) : Expansion E (32→48 bits) → XOR \\(K_i\\) → 8 S-boxes (48→32 bits) → Permutation P.\nS-box : 6 bits input → 4 bits output via table (ligne = bits externes, colonne = bits internes).\nPermutations : IP (initiale) et IP⁻¹ (finale) sur 64 bits.\n\n\n\n\n\n\n\n5. Triple-DES et Sécurité de DES\n\nVulnérabilités de DES\nProblème principal : taille de l’espace de clés \\(\\{0,1\\}^{56}\\) insuffisante.\nAttaque brute force :\n\n1999 : clé trouvée en 24 heures\nTechnique : brute force massivement parallèle (100’000 PCs sur Internet)\nKnown plaintext attack\n\n\n\nTriple-DES (3DES)\nSolution : augmenter l’espace des clés à \\(\\{0,1\\}^{112}\\).\nSchéma :\n\\[C = E_{K_1}(D_{K_2}(E_{K_1}(P)))\\]\nAvec :\n\n\\(E\\) : encryption DES\n\\(D\\) : décryption DES\n\\(K_1, K_2\\) : deux clés de 56 bits\n\n\n\n\n\n\ngraph LR\n    P[Plaintext 64 bits] --&gt; E1[DES Encrypt K1]\n    E1 --&gt; D[DES Decrypt K2]\n    D --&gt; E2[DES Encrypt K1]\n    E2 --&gt; C[Ciphertext 64 bits]\n    \n    K1a[Key K1 56 bits] --&gt; E1\n    K2[Key K2 56 bits] --&gt; D\n    K1b[Key K1 56 bits] --&gt; E2\n    \n    style E1 fill:#ffcccc\n    style D fill:#ccffcc\n    style E2 fill:#ffcccc\n\n\n\n\n\n\nAvantages :\n\n✓ Sécurité satisfaisante : espace de clés \\(2^{112}\\)\n✓ Compatibilité : réutilisation du hardware/software DES existant\n✓ Migration progressive : en attendant AES\n\nInconvénient :\n\n✗ Performances : 3× plus lent (3 exécutions DES successives)\n\n\n\nPropriétés de DES\n1. DES n’est pas un groupe\nDES n’est PAS un groupe pour la composition :\n\\[\\nexists K_3 \\text{ tel que } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)\\]\nConséquence : encryption composée (Triple-DES) augmente considérablement la sécurité.\nSi DES était un groupe : recherche exhaustive sur \\(\\{0,1\\}^{56}\\) casserait l’algorithme indépendamment du nombre d’exécutions consécutives.\n2. Clés faibles et semi-faibles\n\nClé faible : \\(E_K(E_K(x)) = x\\)\nPaire de clés semi-faibles : \\(E_{K_1}(E_{K_2}(x)) = x\\)\n\nCaractéristique : clés faibles génèrent des sous-clés identiques par paires :\n\n\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)\nFacilite la cryptanalyse\n\nDES a 4 clés faibles :\n\n\n\nClé faible (hexadécimal)\n\n\n\n\n0101 0101 0101 0101\n\n\n0101 0101 FEFE FEFE\n\n\nFEFE FEFE FEFE FEFE\n\n\nFEFE FEFE 0101 0101\n\n\n\nEt 6 paires de clés semi-faibles\n\n\n\n\n\n\nNote📄 Texte original (DES et 3DES)\n\n\n\n\n\n\nDES et Triple-DES\n\nLa taille de l’ensemble de clés (\\(\\{0,1\\}^{56}\\)) constitue la plus grande menace qui pèse sur DES avec les ressources de calcul actuels. En 1999 il a suffit de 24 heures pour trouver la clé à partir d’un known plaintext en utilisant une technique brute force massivement parallèle (100’000 PCs connectés sur Internet).\nTriple DES nous met à l’abri de ces attaques brute force en augmentant l’espace des clés possibles à \\(\\{0,1\\}^{112}\\).\nCette alternative permet de continuer à utiliser les “boîtes” DES (hardware et software) en attendant une migration vers AES.\nLe niveau de sécurité obtenu par cette solution est très satisfaisant.\nL’impact en termes de performances de trois exécutions successives de DES reste un inconvénient pour certaines applications.\n\n\n\nDES: propriétés\n\nDES n’est pas un groupe (au sens algébrique) avec la composition: En d’autres termes, DES étant une permutation: \\(\\{0,1\\}^{64} \\rightarrow \\{0,1\\}^{64}\\), si DES était un groupe pour la composition, ceci voudrait dire que: \\(\\exists K_3\\) t.q. \\(E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)\\)\nCette propriété permet d’assurer que l’encryption composée (comme Triple-DES) augmente considérablement la sécurité de DES. Si DES était un groupe, la recherche exhaustive sur l’ensemble de clés possibles (\\(\\{0,1\\}^{56}\\)) permettrait de “casser” l’algorithme indépendamment du nombre d’exécutions consécutives de DES.\nClés faibles et mi-faibles (weak and semi-weak keys):\n\nUne clé \\(K\\) est dite faible si \\(E_K(E_K(x)) = x\\).\nUne paire de clés \\((K_1, K_2)\\) est dite mi-faible si \\(E_{K_1}(E_{K_2}(x)) = x\\).\n\nLes clés faibles ont la particularité de générer de sous-clés identiques par paires (\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)), ce qui facilite la cryptanalyse.\nDES a 4 clés faibles (et 6 paires de clés mi-faibles).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (3DES et sécurité)\n\n\n\n\n\nVulnérabilité DES : espace clés \\(2^{56}\\) cassable en 24h (1999). Triple-DES : \\(E_{K_1}(D_{K_2}(E_{K_1}(P)))\\), espace \\(2^{112}\\), réutilise hardware DES, 3× plus lent. DES ≠ groupe → encryption composée renforce sécurité. 4 clés faibles générant sous-clés identiques par paires → facilite cryptanalyse.\n\n\n\n\n\n\n\n6. Advanced Encryption Standard (AES)\n\nPrésentation Générale\nAES (Advanced Encryption Standard) : standard adopté en novembre 2001.\nConception : Johan Daemen et Vincent Rijmen (nom original : Rijndael)\nCaractéristiques principales :\n\nType : block cipher itératif (mais PAS un Feistel Cipher)\nTaille des blocs : 128 bits\nTaille de clé variable : 128, 192 ou 256 bits\nNombre de rounds : dépend de la taille de clé\n\n10 rounds pour clé 128 bits\n12 rounds pour clé 192 bits\n14 rounds pour clé 256 bits\n\nModes d’utilisation : ECB, CBC, CFB, OFB, CTR\n\nAvantages par rapport à DES :\n\n✓ Processus ouvert : consultation et analyse par experts mondiaux\n✓ ~2× plus performant en software\n✓ ~10²² fois plus sûr (théoriquement)\n✓ Évolutif : taille de clé augmentable si nécessaire\n\n\n\nStructure d’AES\nUnité de base : matrice State de 4 lignes × 4 colonnes (pour clé 128 bits)\n\nChaque élément = 1 byte\nTotal : 16 bytes = 128 bits\n\nOpérations sur le corps \\(GF(2^8)\\) :\n\nByte = élément de \\(GF(2^8)\\)\nCorps fini de polynômes de degré ≤ 7 avec coefficients dans \\(GF(2)\\)\nAdditions, multiplications définies dans \\(GF(2^8)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph State_Matrix\n        S00[s0,0] --- S01[s0,1]\n        S01 --- S02[s0,2]\n        S02 --- S03[s0,3]\n        \n        S10[s1,0] --- S11[s1,1]\n        S11 --- S12[s1,2]\n        S12 --- S13[s1,3]\n        \n        S20[s2,0] --- S21[s2,1]\n        S21 --- S22[s2,2]\n        S22 --- S23[s2,3]\n        \n        S30[s3,0] --- S31[s3,1]\n        S31 --- S32[s3,2]\n        S32 --- S33[s3,3]\n    end\n    \n    style S00 fill:#ffe6cc\n    style S11 fill:#ffe6cc\n    style S22 fill:#ffe6cc\n    style S33 fill:#ffe6cc\n\n\n\n\n\n\n\n\nDétail d’un Round AES\nQuatre opérations par round :\n1. SubBytes (ByteSub)\n\nSubstitution non linéaire via S-box\nChaque byte transformé indépendamment\nRésistance à la cryptanalyse linéaire et différentielle\n\n2. ShiftRows\n\nPermutation des bytes avec décalages variables par ligne\nLigne 0 : pas de décalage\nLigne 1 : décalage gauche 1 position\nLigne 2 : décalage gauche 2 positions\nLigne 3 : décalage gauche 3 positions\n\n3. MixColumns\n\nChaque colonne = combinaison linéaire des autres colonnes\nMultiplication de matrices dans \\(GF(2^8)\\)\nDiffusion maximale\n\n4. AddRoundKey\n\nXOR de la matrice State avec la sous-clé du round\nSous-clé = résultat du Key Schedule\n\n\n\n\n\n\ngraph TB\n    Input[State Input] --&gt; SB[SubBytes]\n    SB --&gt; SR[ShiftRows]\n    SR --&gt; MC[MixColumns]\n    MC --&gt; ARK[AddRoundKey]\n    K[Round Key] --&gt; ARK\n    ARK --&gt; Output[State Output]\n    \n    style SB fill:#ffcccc\n    style SR fill:#ccffcc\n    style MC fill:#cce5ff\n    style ARK fill:#ffffcc\n\n\n\n\n\n\nRound final : identique SAUF pas de MixColumns\n\n\nKey Schedule (Génération des Sous-clés)\nProcessus :\n\nKey Expansion : génération d’une matrice étendue\n\nClé 128 bits → matrice 4 × 4 × (\\(N_e\\) + 1) bytes\n\\(N_e\\) = nombre de rounds\n\nKey Selection : extraction des sous-clés\n\nPremière sous-clé : 4 premières colonnes\nDeuxième sous-clé : 4 colonnes suivantes\nEtc.\n\n\nOpérations :\n\nRotations de bytes\nSubstitutions via S-box\nXOR avec constantes (Rcon)\n\n\n\nPseudo-code AES\nRijndael(State, CipherKey) {\n    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule\n    \n    AddRoundKey(State, ExpandedKey[0..3]); // XOR initial\n    \n    for(i = 1; i &lt; Ne; i++) {\n        Round(State, ExpandedKey[4*i...(4*i)+3]);\n    }\n    \n    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Sans MixColumns\n}\n\n\nDécryption AES\nPrincipe : appliquer les opérations inverses dans chaque round.\nOpérations inverses :\n\nInvSubBytes : substitution inverse via S-box⁻¹\nInvShiftRows : décalages droite (au lieu de gauche)\nInvMixColumns : multiplication matricielle inverse\nAddRoundKey : auto-inverse (XOR)\n\nOrdre : inverse de l’encryption avec sous-clés en ordre inverse\n\n\n\n\n\n\nNote📄 Texte original (AES)\n\n\n\n\n\nAdvanced Encryption Standard (AES)\n\nAdopté comme standard en Novembre 2001, conçu par Johan Daemen et Vincent Rijmen (d’où son nom original Rijndael).\nIl s’agit également d’un block cipher itératif (comme DES) mais pas d’un Feistel Cipher.\nBlocs Plaintext/Ciphertext: 128 bits.\nClé de longueur variable: 128, 192, ou 256 bits.\nContrairement à DES, AES est issu d’un processus de consultation et d’analyse ouvert à des experts mondiaux.\nTechniques semblables à DES (substitutions, permutations, XOR…) complémentées par des opérations algébriques simples et très performantes.\nToutes les opérations s’effectuent dans le corps \\(GF(2^8)\\): le corps fini de polynômes de degré ≤ 7 avec des coefficients dans \\(GF(2)\\).\nEn particulier, un byte pour AES est un élément dans \\(GF(2^8)\\) et les opérations sur les bytes (additions, multiplications,…) sont définies comme sur \\(GF(2^8)\\).\n~2 fois plus performant (en software) et ~10²² fois (en théorie…) plus sûr que DES…\nÉvolutif: La taille de la clé peut être augmentée si nécessaire.\n\n\nDétail d’une Etape (round) AES\nL’unité de base sur laquelle s’appliquent les calculs est une matrice de 4 lignes et 4 colonnes (dans le cas d’une clé de 128 bits) dont les éléments sont des bytes:\n\nByteSub: Opération non linéaire (S-box) conçu pour résister à la cryptanalyse linéaire et différentielle.\nShiftRow: Permutation des bytes introduisant des décalages variables sur les lignes.\nMixColumn: Chaque colonne est remplacée par des combinaisons linéaires des autres colonnes (multiplication des matrices !)\nAddRoundKey: XOR de la matrice courante avec la sous-clé correspondante à l’étape courante.\n\n\n\nAES: Fonctionnement Global\n\nLe nombre d’étapes d’AES varie en fonction de la taille de la clé. Pour une clé de 128 bits, il faut effectuer 10 étapes. Chaque augmentation de 32 bits sur la taille de la clé, entraîne une étape supplémentaire (14 étapes pour des clés de 256 bits).\nLa decryption consiste en appliquer les opérations inverses dans chacune des étapes (InvSubBytes, InvShiftRows, InvMixColumns). AddRoundKey (à cause du XOR) est sa propre inverse.\nLe Key Schedule consiste en:\n\nUne opération d’expansion de la clé principal. Si \\(N_e\\) est le nombre d’étapes (dépendant de la clé), une matrice de 4 lignes et 4 × (\\(N_e\\) + 1) colonnes est générée.\nUne opération de sélection de la clé d’étape: La première sous-clé sera constituée des 4 premières colonnes de la matrice générée lors de l’expansion et ainsi de suite.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (AES)\n\n\n\n\n\nAES (Rijndael 2001) : block cipher itératif (PAS Feistel), 128 bits blocs, clés 128/192/256 bits → 10/12/14 rounds.\nState : matrice 4×4 bytes dans \\(GF(2^8)\\).\n4 opérations/round :\n\nSubBytes (S-box non linéaire)\nShiftRows (décalages lignes)\nMixColumns (combinaisons linéaires)\nAddRoundKey (XOR sous-clé).\n\n2× plus rapide que DES, 10²² fois plus sûr.\n\n\n\n\n\n\n\n7. Attaques et Sécurité d’AES\n\nForces d’AES\nSimplicité et performances :\n\n✓ Algorithme simple et efficace\n✓ Fonctionne sur plateformes limitées (cartes à puce 8 bits)\n✓ Optimisations hardware et software\n\n\n\nAttaques Publiées\n1. Attaques algébriques (2002)\nTechnique XSL (N. Courtois et P. Pieprzyk) :\n\nReprésente AES comme système de 8000 équations quadratiques avec 1600 inconnues binaires\nEffort estimé : \\(2^{100}\\) opérations (encore une conjecture)\nCaractéristique : nécessite peu de known plaintexts\nDistinction : différent des attaques linéaires/différentielles\n\nCritique : basées sur le caractère “fortement algébrique” d’AES (largement contesté)\n2. Related Key Attacks (2009-2011)\nPrincipe : attaques basées sur des clés similaires\n\nRésultats intéressants sur versions réduites d’AES\nNe compromettent pas AES complet\n\n3. Side Channel Attacks\nPrincipe : attaques sur l’implémentation (pas l’algorithme)\nTechniques :\n\nCache timing attacks : analyse des accès cache\nPower analysis : consommation électrique\nElectromagnetic analysis : émissions électromagnétiques\n\nExemple (2005) : Osvik, Shamir, Tromer\n\nExtraction de clé 128 bits avec 6-7 couples plaintext/ciphertext\nBasée sur analyse des accès cache\n\n4. Meet in the Middle sur structures bicycliques (2011-2015)\nRésultat :\n\nRéduit l’effort pour AES-128 à \\(2^{126}\\) (facteur 4 vs brute force)\nReste largement au-dessus des capacités actuelles\n\n\n\nSécurité Pratique\nHypothèse fondamentale : clé d’entropie maximale\nAttaques récentes (WPA2, etc.) :\n\nExploitent la faiblesse des passwords/passphrases\nPas de faille dans AES lui-même\nProblème : génération de clés depuis passwords faibles\n\n⚠️ Rappel critique : qualité de la clé = sécurité du système\n\n\n\n\n\n\nNote📄 Texte original (Attaques AES)\n\n\n\n\n\n\nAES: Remarques Finales et Attaques (I)\n\nLa plus grande force de AES réside dans sa simplicité et dans ses performances, y compris sur des plate-formes à capacité de calcul réduite (p.ex. des cartes à puces avec des processeurs à 8 bits).\nDepuis sa publication officielle, des nombreux travaux de cryptanalyse ont été publiés avec des résultats très intéressants. En particulier, N. Courtois et P.Pieprzyk ont présenté une technique appelée XSL permettant de représenter AES comme un système de 8000 équations quadratiques avec 1600 inconnues binaires. L’effort nécessaire pour casser ce système est estimé (il s’agit encore d’une conjecture…) à \\(2^{100}\\).\nCes attaques se basent sur le caractère fortement algébrique (et largement contesté…) de AES. De plus, il suffit de quelques known plaintexts pour les mettre en place, ce qui les distingue des attaques linéaires et différentielles.\nCes dernières années (2009-2011) des attaques basées sur des clés similaires (related key attacks) ont obtenu des résultats intéressants sur des versions réduites d’AES.\nUne autre famille d’attaques dénommée side channel attacks agissant directement sur l’implémentation de l’algorithme permet d’extraire des informations d’intérêt cryptographique lors de l’exécution de l’encryption.\n\n\n\nAES: Remarques finales et Attaques (II)\n\nEn 2015 une attaque de type Meet in the Middle basé sur des structure bicycliques a montré qu’il était possible de réduire l’effort nécessaire pour trouver une clé AES-128 à \\(2^{126}\\), soit un facteur 4 par rapport au brute force. Ceci reste tout de même largement au dessus des capacités de calcul actuelles.\nUne autre famille d’attaques dénommée side channel attacks agissant directement sur l’implémentation de l’algorithme permet d’extraire des informations d’intérêt cryptographique lors de l’exécution de l’encryption. En particulier, les auteurs arrivent à extraire la clé de 128 bits avec seulement 6-7 couples plaintext/ciphertexts en se basant sur les accès cache.\nLa sécurité de AES (comme pour tout autre algorithme d’encryption) se base toujours sur l’hypothèse d’une clé d’entropie maximale. Les attaques publiées récemment sur des protocoles basés sur AES (comme WPA2) exploitent la faiblesse des passwords/passphrases qui sont à l’origine des clés utilisées.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Sécurité AES)\n\n\n\n\n\nForces : simplicité, performances (même cartes 8 bits). Attaques : XSL (\\(2^{100}\\), algébrique), related keys (versions réduites), side channel (implémentation, cache), Meet-in-Middle bicyclique (\\(2^{126}\\)). Sécurité : hypothèse clé entropie max. Attaques pratiques = passwords faibles, pas faille AES.\n\n\n\n\n\n\n\n8. Techniques de Cryptanalyse des Block Ciphers\n\n8.1 Cryptanalyse Différentielle\nPrincipe : attaque chosen plaintext analysant la propagation des différences entre deux plaintexts à travers les rounds.\nMéthode :\n\nChoisir deux plaintexts avec différence connue : \\(x_a\\) et \\(x_b\\)\nObserver la propagation : \\(\\Delta x = x_a \\oplus x_b\\)\nAnalyser les ciphertexts : \\(\\Delta y = y_a \\oplus y_b\\)\nAttribuer des probabilités aux clés selon les changements observés\nClé la plus probable = clé correcte (après nombreux essais)\n\nCaractéristiques :\n\nNécessite \\(2^{47}\\) couples chosen plaintext pour DES\nProbabilités : dépendent des S-boxes et de la structure\nPlus le nombre de couples augmente, plus la probabilité de succès augmente\n\nSensibilité : très sensible au nombre de rounds\n\nChances de réussite augmentent exponentiellement quand rounds diminuent\n\n\n\n8.2 Cryptanalyse Linéaire\nPrincipe : attaque known plaintext créant un simulateur linéaire du block cipher.\nMéthode :\n\nCréer des approximations linéaires de l’algorithme\nAnalyser un grand nombre de paires plaintext/ciphertext\nLes bits de la clé du simulateur tendent à coïncider avec ceux de la clé réelle (calcul probabiliste)\n\nComplexité pour DES :\n\n\\(2^{38}\\) known plaintexts → probabilité 10% de deviner juste\n\\(2^{43}\\) known plaintexts → probabilité 85% de succès\n\nCaractéristiques :\n\nAttaque analytique la plus puissante à ce jour sur block ciphers\nAussi sensible au nombre de rounds\n\n\n\n8.3 Comparaison Différentielle vs Linéaire\nDifficultés communes :\n\n✗ Parallélisation : moins efficace que brute force parallèle\n⚠️ Sensibilité aux rounds : efficacité diminue exponentiellement avec le nombre de rounds\n\nDES et ces attaques :\n\nConjecture répandue : concepteurs de DES connaissaient ces attaques (années 1970, inédites à l’époque)\nDesign des S-boxes : résistance très grande aux deux techniques\n\n\n\n8.4 Attaque Meet-in-the-Middle\nPrincipe : exploite les constructions composées du type \\(y = E_{K_2}(E_{K_1}(x))\\).\nMéthode :\n\nConstruire liste \\(L_1\\) : \\(L_1 = \\{E_{K_1}(x) \\mid K_1 \\in \\text{KeySpace}\\}\\)\nConstruire liste \\(L_2\\) : \\(L_2 = \\{D_{K_2}(y) \\mid K_2 \\in \\text{KeySpace}\\}\\)\nIdentifier éléments répétés dans \\(L_1\\) et \\(L_2\\)\nVérifier hypothèse avec deuxième known plaintext\nLes clés \\(K_1\\) et \\(K_2\\) associées sont probablement les clés recherchées\n\nExemple pour DES :\nEspace de clés intuitif pour \\(E_{K_2}(E_{K_1}(x))\\) : \\(\\{0,1\\}^{112}\\)\nEffort réel :\n\n\\(2^{57}\\) opérations pour établir les deux listes\n\\(2^{56}\\) blocs de 64 bits de stockage\nNettement inférieur au \\(2^{112}\\) estimé intuitivement\n\nApplications :\n\nAttaques sur constructions composées\nCryptanalyse interne des block ciphers\n\n\n\n\n\n\ngraph TB\n    subgraph Meet_in_Middle\n        X[Known Plaintext x] --&gt; E1[Encrypt K1]\n        E1 --&gt; M[Middle Value m]\n        M --&gt; E2[Encrypt K2]\n        E2 --&gt; Y[Known Ciphertext y]\n        \n        X2[x] --&gt; L1[List L1: EK1 pour tous K1]\n        Y2[y] --&gt; L2[List L2: DK2 pour tous K2]\n        \n        L1 -.match.-&gt; Match[Trouver m commun]\n        L2 -.match.-&gt; Match\n    end\n    \n    style M fill:#ffffcc\n    style Match fill:#ccffcc\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Texte original (Cryptanalyse)\n\n\n\n\n\n\nTechniques de Cryptanalyse sur les Block Ciphers\nCryptanalyse Différentielle\n\nIl s’agit d’une attaque chosen plaintext qui s’intéresse à la propagation des différences dans deux plaintexts au fur et à mesure qu’ils évoluent dans les différentes étapes de l’algorithme.\nIl attribue des probabilités aux clés qu’il “devine” en fonction des changements qu’elles induisent sur les ciphertexts. La clé la plus probable a des bonnes chances d’être la clé correcte après un grand nombre de couples plaintext/ciphertext.\nNécessite \\(2^{47}\\) couples chosen plaintext (pour DES) pour obtenir des résultats corrects.\n\nCryptanalyse Linéaire\n\nIl s’agit d’une attaque known plaintext qui crée un simulateur du bloc à partir des approximations linéaires. En analysant un grand nombre de paires plaintext/ciphertexts, les bits de la clé du simulateur ont tendance à coïncider avec ceux du block cipher analysés (calcul probabiliste)\nPour DES une attaque basée sur cette technique nécessite \\(2^{38}\\) known plaintexts pour obtenir une probabilité de 10% de deviner juste et \\(2^{43}\\) pour un 85% !\nIl s’agit de l’attaque analytique la plus puissante à ce jour sur les block ciphers.\n\n\n\nTechniques de Cryptanalyse sur les Block Ciphers (II)\n\nLa mise en pratique des attaques différentielles et linéaires présente des difficultés dans la parallélisation des calculs par rapport à une recherche exhaustive de la clé.\nCes deux attaques sont très sensibles au nombre d’étapes du block cipher: les chances de réussite augmentent exponentiellement au fur et à mesure que le nombre d’étapes de l’algorithme diminue.\nUne conjecture très répandue parmi les cryptographes est que ces attaques, à l’époque inédites, étaient connues par les concepteurs des DES. En particulier, le design des S-boxes offre une résistance très grande aux deux techniques.\n\nAttaque Meet-in-the-Middle\n\nS’applique aux constructions du type \\(y := E_{K_2}(E_{K_1}(x))\\). Pour DES, l’espace de clés pour cette solution serait de \\(\\{0,1\\}^{112}\\). On construit d’abord deux listes \\(L_1\\) et \\(L_2\\) de \\(2^{56}\\) messages de la forme: \\(L_1 = E_{K_1}(x)\\) et \\(L_2 = D_{K_2}(y)\\) avec \\(E\\) et \\(D\\) les opérations d’encryption et decryption respectivement. Il faut alors identifier des éléments qui se répètent dans les deux listes et vérifier notre hypothèse avec un deuxième known plaintext. Les \\(K_1\\) et \\(K_2\\) associées à cette paire de known plaintexts seront (en toute vraisemblance) les clés recherchées !\nEffort nécessaire à réaliser les attaques (pour DES): \\(2^{57}\\) opérations pour établir les deux listes + \\(2^{56}\\) blocs de 64 bits de stockage pour mémoriser les résultats intermédiaires… nettement inférieur au \\(2^{112}\\) estimé intuitivement…\nCes techniques meet-in-the-middle sont aussi appliquées à la cryptanalyse interne des block ciphers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Révision rapide (Cryptanalyse)\n\n\n\n\n\nDifférentielle : chosen plaintext, propagation différences, probabilités sur clés, \\(2^{47}\\) couples (DES).\nLinéaire : known plaintext, approximations linéaires, \\(2^{38}\\)-\\(2^{43}\\) plaintexts (DES), attaque la plus puissante.\nMeet-in-Middle : constructions composées, 2 listes \\(2^{56}\\), effort \\(2^{57}\\) &lt;&lt; \\(2^{112}\\).\nSensibilité : très dépendantes du nombre de rounds."
  },
  {
    "objectID": "exam_notes_fr.html#fondements-mathématiques",
    "href": "exam_notes_fr.html#fondements-mathématiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fondements Mathématiques",
    "text": "Fondements Mathématiques\n\nThéorème Fondamental de l’Arithmétique et Fonction Phi d’Euler\nLa cryptographie asymétrique repose sur des fondements mathématiques solides issus de la théorie des nombres. Deux concepts sont essentiels :\nThéorème Fondamental de l’Arithmétique : Tout nombre entier strictement positif \\(n\\) s’écrit de façon unique (à l’ordre près) comme produit de puissances de nombres premiers :\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nFonction Phi d’Euler \\(\\phi(n)\\) : Nombre d’entiers positifs plus petits que \\(n\\) qui sont premiers avec \\(n\\).\nPour calculer \\(\\phi(n)\\) :\n\\[\\phi(n) = \\prod_{i=1}^{m} p_i^{e_i} \\cdot \\left(1 - \\frac{1}{p_i}\\right)\\]\nCas particulier important : Si \\(n = p \\cdot q\\) avec \\(p\\) et \\(q\\) premiers, alors :\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques\nThéorème Fondamental de l’Arithmétique : Tout nombre entier strictement positif \\(n\\) s’écrit de façon unique (à l’ordre près) comme un produit de puissances de nombres premiers \\(p_i\\) distincts :\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nFonction Phi d’Euler : Soit \\(n \\in \\mathbb{Z}^+\\), la fonction phi d’Euler \\(\\phi(n)\\) est égale au nombre d’entiers positifs plus petits que \\(n\\) qui sont relativement premiers à \\(n\\).\nCalcul de la fonction phi d’Euler : D’après le théorème fondamental de l’arithmétique, tout nombre entier \\(n &gt; 1\\) s’écrit :\n\\[n = \\prod_{i=1}^{m} p_i^{e_i}\\]\nalors \\(\\phi(n)\\) se calcule :\n\\[\\phi(n) = \\prod_{i=1}^{m} \\left(p_i^{e_i} - p_i^{e_i-1}\\right)\\]\nEn particulier, si \\(n = p \\cdot q\\) avec \\(p\\) et \\(q\\) premiers, alors :\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nDécomposition unique : tout entier = produit de nombres premiers\n\\(\\phi(n)\\) : compte les entiers \\(&lt; n\\) premiers avec \\(n\\)\nClé pour RSA : si \\(n = pq\\) (premiers) alors \\(\\phi(n) = (p-1)(q-1)\\)\n\n\n\n\n\n\n\nThéorèmes d’Euler et de Fermat\nCes théorèmes sont au cœur du fonctionnement de RSA et d’autres algorithmes asymétriques.\nThéorème d’Euler : Si \\(n \\in \\mathbb{Z}^+\\) et \\(a \\in \\mathbb{Z}\\) avec \\(\\text{pgcd}(a,n) = 1\\), alors :\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nPetit Théorème de Fermat (cas particulier si \\(n = p\\) premier) : Si \\(a \\in \\mathbb{Z}\\) et \\(p\\) premier ne divise pas \\(a\\) :\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nApplications importantes :\n\nRéduction des exposants : Si \\(n\\) est produit de premiers distincts et \\(r \\equiv s \\pmod{\\phi(n)}\\), alors : \\[a^r \\equiv a^s \\pmod{n}\\]\nCalcul des inverses : \\(a^{\\phi(n)-1}\\) est l’inverse de \\(a\\) modulo \\(n\\). En particulier, si \\(p\\) est premier, \\(a^{p-2}\\) est l’inverse de \\(a\\) modulo \\(p\\).\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques (II)\nThéorème d’Euler : Soient \\(n \\in \\mathbb{Z}^+\\) et \\(a \\in \\mathbb{Z}\\) avec \\(\\text{pgcd}(a,n) = 1\\), alors on a :\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nPetit Théorème de Fermat (cas particulier du théorème d’Euler si \\(n\\) est premier) : Soient \\(a \\in \\mathbb{Z}\\) et \\(p\\) un nombre premier tel que \\(p\\) ne divise pas \\(a\\), alors on a :\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nÀ noter que puisque \\(p\\) est premier, on a \\(\\phi(p) = p-1\\).\nRéduction des exposants \\(\\bmod \\phi(n)\\) : Si \\(n\\) est le produit de premiers distincts et \\(r, s \\in \\mathbb{Z}\\) t.q. \\(r \\equiv s \\pmod{\\phi(n)}\\) alors \\(\\forall a \\in \\mathbb{Z}\\) :\n\\[a^r \\equiv a^s \\pmod{n}\\]\nApplication du Théorème d’Euler au calcul des inverses : Suite au théorème d’Euler, on a que :\n\\[a \\cdot a^{\\phi(n)-1} \\equiv 1 \\pmod{n}\\]\nce qui signifie que \\(a^{\\phi(n)-1}\\) est l’inverse de \\(a\\) modulo \\(n\\). En particulier, \\(a^{p-2}\\) est l’inverse de \\(a\\) modulo \\(n\\) si \\(p\\) est premier.\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nThéorème d’Euler : \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\nFermat : cas spécial si \\(p\\) premier : \\(a^{p-1} \\equiv 1 \\pmod{p}\\)\nInverse modulaire : \\(a^{-1} \\equiv a^{\\phi(n)-1} \\pmod{n}\\)\nBase de RSA : permet encryption/decryption avec exposants\n\n\n\n\n\n\n\nGroupes Multiplicatifs et Générateurs\nGroupe multiplicatif \\(\\mathbb{Z}_n^*\\) : Ensemble des éléments de \\(\\mathbb{Z}_n\\) premiers avec \\(n\\) :\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{pgcd}(a,n) = 1\\}\\]\nSi \\(n\\) est premier : \\(\\mathbb{Z}_n^* = \\{1, 2, \\ldots, n-1\\}\\)\nOrdre d’un élément : Plus petit entier positif \\(t\\) tel que \\(a^t \\equiv 1 \\pmod{n}\\)\nGénérateur : Un élément \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) si son ordre est \\(\\phi(n)\\). On dit alors que \\(\\mathbb{Z}_n^*\\) est cyclique.\nPropriétés des générateurs :\n\n\\(\\mathbb{Z}_n^*\\) a un générateur ssi \\(n = 2, 4, p^k\\) ou \\(2p^k\\) (avec \\(p\\) premier, \\(p \\neq 2\\) et \\(k \\geq 1\\))\nSi \\(p\\) est premier, \\(\\mathbb{Z}_p^*\\) a toujours un générateur\nSi \\(\\alpha\\) est générateur, tous les éléments s’écrivent : \\(\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i &lt; \\phi(n)\\}\\)\nLe nombre de générateurs est \\(\\phi(\\phi(n))\\)\n\nTest de générateur\n\n\\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) ssi \\(\\forall\\) premier \\(p\\) divisant \\(\\phi(n)\\), \\(\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\)\nsi \\(n = 2p+1\\) est un “safe prime” avec \\(p\\) premier : \\(\\alpha\\) est générateur ssi \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) et \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFondements Mathématiques (III)\nDéfinition : Le groupe multiplicatif de \\(\\mathbb{Z}_n\\), noté \\(\\mathbb{Z}_n^*\\) est :\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{pgcd}(a,n) = 1\\}\\]\nEn particulier, si \\(n\\) est premier : \\(\\mathbb{Z}_n^* = \\{a \\mid 1 \\leq a \\leq n-1\\}\\)\nLe nombre d’éléments ou ordre du groupe multiplicatif \\(\\mathbb{Z}_n^*\\) est \\(\\phi(n)\\) (par définition de \\(\\phi\\)).\nDéfinition : Soit \\(a \\in \\mathbb{Z}_n\\), l’ordre de \\(a\\) est le plus petit entier positif \\(t\\) pour lequel :\n\\[a^t \\equiv 1 \\pmod{n}\\]\nDéfinition : Soit \\(\\alpha \\in \\mathbb{Z}_n^*\\), si l’ordre de \\(\\alpha\\) est \\(\\phi(n)\\), alors \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\). Lorsqu’un groupe \\(\\mathbb{Z}_n^*\\) a un générateur, on dit qu’il est cyclique.\nPropriétés des générateurs :\n\n\\(\\mathbb{Z}_n^*\\) a un générateur ssi \\(n = 2, 4, p^k\\) ou \\(2p^k\\), avec \\(p\\) premier, \\(p \\neq 2\\) et \\(k \\geq 1\\). En particulier, si \\(p\\) est premier, \\(\\mathbb{Z}_p^*\\) a un générateur.\nSi \\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\), alors tous les éléments de \\(\\mathbb{Z}_n^*\\) s’écrivent : \\[\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i \\leq \\phi(n)-1\\}\\]\nLe nombre de générateurs de \\(\\mathbb{Z}_n^*\\) est \\(\\phi(\\phi(n))\\).\n\\(\\alpha\\) est un générateur de \\(\\mathbb{Z}_n^*\\) ssi pour tout premier \\(p\\) divisant \\(\\phi(n)\\), on a : \\[\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\]\n\nEn particulier si \\(n\\) est un premier de la forme \\(n = 2p+1\\) avec \\(p\\) premier (un tel \\(n\\) est appelé un safe prime), \\(\\alpha\\) est générateur de \\(\\mathbb{Z}_n^*\\) ssi \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) et \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\n\\(\\mathbb{Z}_n^*\\) : éléments premiers avec \\(n\\), cardinal = \\(\\phi(n)\\)\nGénérateur : élément d’ordre \\(\\phi(n)\\) (génère tout le groupe)\nCrucial pour DH et ElGamal : sécurité basée sur logarithme discret dans groupe cyclique\nSafe prime : \\(n = 2p+1\\) avec \\(p\\) et \\(n\\) premiers\n\n\n\n\n\n\n\nFast Exponentiation (Exponentiation Rapide)\nCalcul efficace de \\(a^k \\bmod n\\) en temps polynomial, essentiel pour tous les algorithmes asymétriques.\nPrincipe : Utiliser la représentation binaire de l’exposant \\(k\\).\nExemple : Calcul de \\(2^{644} \\bmod 645\\)\n\nReprésentation binaire : \\((644)_{10} = (1010000100)_2\\)\nCalculer les puissances de 2 successives modulo 645 :\n\n\\(2^1 \\bmod 645\\)\n\\(2^2 \\bmod 645\\)\n\\(2^4 \\bmod 645\\)\n\\(2^8 \\bmod 645\\)\n…\n\\(2^{512} \\bmod 645\\)\n\nCombiner selon les bits à 1 : \\(2^{644} = 2^{512} \\cdot 2^{128} \\cdot 2^4\\)\n\nComplexité : \\(O(\\log^3 n)\\) - très efficace !\nApplication : Calcul de l’inverse avec le théorème d’Euler en temps polynomial.\nAlternative : Algorithme d’Euclide étendu pour trouver \\(x\\) tel que \\(ax \\equiv 1 \\pmod{n}\\) en résolvant \\(ax - kn = 1 = \\text{pgcd}(a,n)\\). Complexité également \\(O(\\log^3 n)\\).\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nFast Exponentiation\nFast exponentiation : En utilisant la représentation binaire d’un nombre, on peut calculer des puissances très efficacement.\nExemple : calcul de \\(2^{644} \\bmod 645\\)\n\\((644)_{10} = (1010000100)_2\\)\nMaintenant, on calcule les exposants correspondants aux puissances de 2, soient :\n\\[2^1 \\bmod 645, \\quad 2^2 \\bmod 645, \\quad 2^4 \\bmod 645, \\quad \\ldots, \\quad 2^{512} \\bmod 645\\]\nD’après la représentation binaire, on calcule :\n\\[2^{644} = 2^{512+128+4} = 2^{512} \\cdot 2^{128} \\cdot 2^4 = 160 \\cdot 153 \\cdot 6 \\bmod 645\\]\nLa complexité de cet algorithme fast exponentiation est \\(O(\\log^3 n)\\).\nEn s’appuyant sur le théorème d’Euler, le calcul de l’inverse d’un nombre dans un tel groupe est donc effectué en temps polynomial.\nL’algorithme d’Euclide étendu peut être également utilisé pour trouver un \\(x\\) tel que :\n\\[ax \\equiv 1 \\pmod{n}\\]\npuisque cette congruence s’écrit : \\(ax - 1 = kn\\) et donc :\n\\[ax - kn = 1 = \\text{pgcd}(a,n)\\]\nLa complexité de cet algorithme est également \\(O(\\log^3 n)\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nIdée : représentation binaire de l’exposant\nComplexité : \\(O(\\log^3 n)\\) - polynomial !\nEssentiel : rend RSA, ElGamal, DH praticables\nAlternative : algorithme d’Euclide étendu pour inverses\n\n\n\n\n\n\n\nThéorème des Restes Chinois (CRT)\nLe CRT permet de résoudre des systèmes de congruences simultanées, avec des applications importantes en cryptographie.\nThéorème : Soient \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) premiers deux à deux (pgcd\\((n_i, n_j) = 1\\) si \\(i \\neq j\\)) et \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Alors le système :\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\na une solution unique \\(x \\bmod N\\) avec \\(N := n_1 \\cdot n_2 \\cdots n_t\\).\nAlgorithme de Gauss (1801) pour calculer \\(x\\) :\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\navec :\n\n\\(N_i = N/n_i\\)\n\\(M_i = N_i^{-1} \\bmod n_i\\) (inverse modulaire)\n\nComplexité : \\(O(\\log^3 n)\\) - polynomial !\nApplications cryptographiques :\n\nAccélération des calculs RSA (utiliser \\(p\\) et \\(q\\) séparément)\nPartage de secret (secret sharing schemes)\nCertaines attaques sur RSA (si exposant petit et messages multiples)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nThéorème des Restes Chinois\nLe Théorème des Restes Chinois (IIIe siècle!) permet de résoudre des systèmes linéaires de congruences simultanées. Il résout des problèmes soulevés dans des anciens puzzles chinois. Il s’agissait, par exemple, de trouver un nombre qui produit un reste de 1 lorsqu’il est divisé par 3, de 2 lorsqu’il est divisé par 5 et de 3 lorsqu’il est divisé par 7… Il fut également utilisé pour calculer le moment exact d’alignement de plusieurs astres ayant des orbites (et donc des périodes) différentes.\nThéorème des Restes Chinois : Soient \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) premiers deux à deux (c.à.d. pgcd\\((n_i, n_j) = 1\\), \\(\\forall i \\neq j\\)) et \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Alors, le système de congruences :\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\na une solution unique \\(x \\bmod N := n_1 n_2 \\cdots n_t\\)\nAlgorithme de Gauss (1801) pour le calcul de \\(x\\) :\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\navec \\(N_i = N/n_i\\) et \\(M_i = N_i^{-1} \\bmod n_i\\).\nLa complexité de cet algorithme est \\(O(\\log^3 n)\\).\nIl est donc possible en temps polynomial de passer des congruences mod \\(n_i\\) aux congruences mod \\(N\\) !\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nRésout : systèmes de congruences avec moduli premiers entre eux\nSolution unique : modulo produit des moduli\nComplexité : \\(O(\\log^3 n)\\) (polynomial)\nUsage crypto : optimisation RSA, attaques si petit exposant"
  },
  {
    "objectID": "exam_notes_fr.html#problèmes-de-base-et-complexité",
    "href": "exam_notes_fr.html#problèmes-de-base-et-complexité",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Problèmes de Base et Complexité",
    "text": "Problèmes de Base et Complexité\n\nClassification des Problèmes Difficiles\nLa sécurité de la cryptographie asymétrique repose sur des problèmes mathématiques réputés difficiles :\nProblèmes génériques :\n\nFactorisation (FACTP) : Étant donné \\(n\\), trouver sa factorisation en nombres premiers\n\nBase de RSA et Rabin\n\nLogarithmes discrets (DLP) : Étant donné \\(p\\) premier, un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et \\(\\beta \\in \\mathbb{Z}_p^*\\), trouver \\(x\\) tel que : \\[\\alpha^x \\equiv \\beta \\pmod{p}\\]\n\nBase de ElGamal et Diffie-Hellman\n\nRacine carrée modulo composite (SQROOTP) : Étant donné \\(n\\) composite et un résidu quadratique \\(a\\), trouver \\(\\sqrt{a} \\bmod n\\)\n\nBase de Rabin\n\n\nProblèmes spécifiques :\n\nRSA Problem (RSAP) : Étant donné \\(n = pq\\), \\(e\\) avec pgcd\\((e, \\phi(n)) = 1\\) et \\(c\\), trouver \\(m\\) tel que \\(m^e \\equiv c \\pmod{n}\\)\nDiffie-Hellman Problem (DHP) : Étant donné \\(p\\) premier, \\(\\alpha\\) générateur, \\(\\alpha^a \\bmod p\\) et \\(\\alpha^b \\bmod p\\), trouver \\(\\alpha^{ab} \\bmod p\\)\n\nÉquivalences prouvées :\n\nDHP ⟺ DLP (équivalent sous certaines conditions)\nRSAP ⟺ FACTP (prouvé équivalent pour le cas générique)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nProblèmes de Base\nProblèmes génériques principaux :\n\nFactorisation (FACTP) : Étant donné un entier positif \\(n\\), trouver sa factorisation en nombres premiers.\nLogarithmes discrets (DLP) : Étant donné un nombre premier \\(p\\), un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et un élément \\(\\beta \\in \\mathbb{Z}_p^*\\), trouver l’entier \\(x\\), \\(0 \\leq x \\leq p-2\\), tel que : \\(\\alpha^x \\equiv \\beta \\pmod{p}\\).\nRacine carrée dans \\(\\mathbb{Z}_n\\) si \\(n\\) est composite (SQROOTP) : Étant donné un entier composite \\(n\\) et un résidu quadratique \\(a\\), trouver la racine carrée de \\(a\\) mod \\(n\\).\n\nProblèmes spécifiques (propres à un système de cryptage) :\n\nRSA (RSAP) : Étant donné un entier positif \\(n = pq\\), un entier positif \\(e\\) avec gcd\\((e, (p-1)(q-1)) = 1\\) et un entier \\(c\\), trouver un entier \\(m\\) avec \\(m^e \\equiv c \\pmod{n}\\).\nDiffie-Hellman (DHP) : Étant donné un nombre premier \\(p\\), un générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\) et les éléments \\(\\alpha^a \\bmod p\\) et \\(\\alpha^b \\bmod p\\), trouver \\(\\alpha^{ab} \\bmod p\\).\n\nRésultats prouvés :\n\nDHP ⟺ DLP (Équivalent sous certaines conditions)\nRSAP ⟺ FACTP (Prouvé équivalent pour le problème générique)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nFACTP : factoriser \\(n\\) → base de RSA/Rabin\nDLP : trouver logarithme discret → base ElGamal/DH\nSQROOTP : racine carrée mod composite → Rabin\nÉquivalences : cassage = résolution du problème de base\n\n\n\n\n\n\n\nTechniques de Factorisation\nLa sécurité de RSA dépend de la difficulté de factoriser de grands nombres.\nMéthodes à temps exponentiel : \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division (division successive)\nCrible d’Ératosthène (IIe siècle av. J.-C.)\nMéthode de Fermat (~1650)\nMéthode \\(\\rho\\) de Pollard (1975)\nMéthode \\(p-1\\) de Pollard (1974)\n\nMéthodes à temps sous-exponentiel : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981) - très efficace en pratique\nNumber Field Sieve - NFS (1990) - le plus rapide actuellement\nGeneral Number Field Sieve - GNFS (2006)\n\nMéthodes à temps polynomial :\n\nAlgorithme de Shor (1994) : \\(O(\\log^c n)\\) sur ordinateur quantique\n\nRecords actuels (2020) :\n\nPlus grand nombre factorisé : RSA-829 (250 chiffres, 829 bits)\nTemps de calcul : 2700 années-cœur (CPUs Intel Xeon Gold 6130)\nMéthode : General Number Field Sieve\n\nImplications :\n\nClés RSA &lt; 1024 bits : vulnérables\nClés RSA 1024 bits : limites (états avec ressources importantes)\nRecommandation : 2048 bits minimum (3072-4096 pour long terme)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nClassical Factoring Techniques et New Developments\nTemps exponentiel : \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division\nEratosthenes’ Sieve (II B.C.)\nFermat’s Difference of Squares Method (~1650)\nSquare Form Factorization (1971)\nPollard’s p-1 method (1974)\nPollard’s Rho Method (1975)\n\nTemps sous-exponentiel : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981)\nNumber Field Sieve - NFS (1990)\nGeneral Number Field Sieve - GNFS (2006)\n\nTemps polynomial :\n\nShor’s Algorithm in a Quantum Computer (1994) : \\(O(\\log^c n)\\)\n\nDéveloppements récents :\n\nL’ordinateur NFS spécifique de Bernstein pour factoriser un nombre de 1536 bits prendrait le même temps qu’un calcul 512 bits sur machine conventionnelle\nPlus grande factorisation à ce jour (2020) : RSA-829 (nombre de 250 chiffres) utilisant NFS\nTemps de calcul total : 2700 années-cœur (CPUs Intel Xeon Gold 6130 à 2.1GHz)\n\nFactorisation sur ordinateur quantique :\n\nProblèmes significatifs (erreurs, dispersion, etc.)\n2001 : ordinateur 7 qubits (IBM Almaden)\nFaisabilité d’un ordinateur avec millions de qubits… ?\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nSous-exponentiel : NFS actuellement le plus rapide\nRecord 2020 : RSA-829 (829 bits) en 2700 années-cœur\nRecommandation : clés ≥ 2048 bits pour RSA\nMenace future : ordinateurs quantiques (Shor)"
  },
  {
    "objectID": "exam_notes_fr.html#lalgorithme-rsa",
    "href": "exam_notes_fr.html#lalgorithme-rsa",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "L’Algorithme RSA",
    "text": "L’Algorithme RSA\n\nFonctionnement de RSA (Encryption/Decryption)\nRSA (Rivest-Shamir-Adleman, 1978) est l’algorithme asymétrique le plus utilisé.\nGénération des clés :\n\nChoisir deux nombres premiers grands \\(p\\) et \\(q\\) (≥ 1024 bits chacun)\nCalculer \\(n := p \\cdot q\\) et \\(\\phi(n) = (p-1)(q-1)\\)\nChoisir exposant d’encryption \\(e\\) avec :\n\n\\(1 &lt; e &lt; \\phi(n)\\)\npgcd\\((e, \\phi(n)) = 1\\)\n\nCalculer exposant de décryption \\(d\\) tel que : \\[e \\cdot d \\equiv 1 \\pmod{\\phi(n)}\\] (avec algorithme d’Euclide étendu ou fast exponentiation)\n\nClés résultantes :\n\nClé publique : \\((n, e)\\)\nClé privée : \\(d\\) (garder \\(p\\) et \\(q\\) secrets aussi !)\n\nEncryption (par Bob, vers Alice) :\n\nObtenir clé publique authentique \\((n, e)\\) d’Alice\nTransformer plaintext en entiers \\(m_i \\in [0, n-1]\\)\nCalculer ciphertexts : \\(c_i := m_i^e \\bmod n\\)\nEnvoyer les \\(c_i\\) à Alice\n\nDecryption (par Alice) :\n\nUtiliser clé privée \\(d\\) pour calculer : \\[m_i = c_i^d \\bmod n\\]\n\nPreuve de fonctionnement :\n\\[c^d \\equiv (m^e)^d \\equiv m^{ed} \\pmod{n}\\]\nComme \\(ed \\equiv 1 \\pmod{\\phi(n)}\\), il existe \\(k\\) tel que \\(ed = 1 + k\\phi(n)\\), donc :\n\\[c^d \\equiv m^{1+k\\phi(n)} \\equiv m \\cdot (m^{\\phi(n)})^k \\equiv m \\cdot 1^k \\equiv m \\pmod{n}\\]\n(par le théorème d’Euler)\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nProcédé d’Encryption/Decryption de RSA et Preuve\nGénération des clés :\n\nChaque entité (A) crée une paire de clés (publique et privée) comme suit :\n\nA choisit la taille du modulus \\(n\\) (p.ex. taille\\((n) = 1024\\) ou taille\\((n) = 2048\\)).\nA génère deux nombres premiers \\(p\\) et \\(q\\) de grande taille \\((n/2)\\).\nA calcule \\(n := pq\\) et \\(\\phi(n) = (p-1)(q-1)\\).\nA génère l’exposant d’encryption \\(e\\), avec \\(1 &lt; e &lt; \\phi(n)\\) t.q. pgcd\\((e, \\phi(n)) = 1\\).\nA calcule l’exposant de decryption \\(d\\), t.q. : \\(ed \\equiv 1 \\pmod{\\phi(n)}\\) avec l’algorithme d’Euclide étendu ou avec l’algorithme fast exponentiation.\n\nLe couple \\((n,e)\\) est la clé publique de A ; \\(d\\) est la clé privée de A.\n\nEncryption :\n\nL’entité B obtient \\((n,e)\\), la clé publique authentique de A.\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, n-1]\\) \\(\\forall i\\).\nB calcule le ciphertext \\(c_i := m_i^e \\bmod n\\), \\(\\forall i\\) avec l’algorithme fast exponentiation.\nB envoie à A tous les ciphertext \\(c_i\\).\n\nDecryption :\n\nA utilise sa clé privée pour calculer les plaintexts \\(m_i = c_i^d \\bmod n\\).\n\nPreuve : Soit \\(m\\) le plaintext et \\(c\\) le ciphertext avec \\(c := m^e \\bmod n\\), il s’agit de prouver : \\(m \\stackrel{!}{=} c^d \\bmod n\\)\nEn substituant \\(c\\) par sa valeur on obtient : \\[c^d \\bmod n = m^{ed} \\bmod n \\quad (*)\\]\nmais, on sait que : \\[ed \\equiv 1 \\pmod{\\phi(n)}\\]\net donc par définition des congruences, il existe un entier \\(k\\) avec : \\[ed - 1 = k\\phi(n)\\]\nen substituant dans (*) : \\[c^d \\equiv m^{k\\phi(n)+1} \\equiv m^{k\\phi(n)} \\cdot m \\pmod{n}\\]\nSi pgcd\\((m,n) = 1\\), on a par le théorème d’Euler : \\[m^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\ndonc : \\[c^d \\equiv (m^{\\phi(n)})^k \\cdot m \\equiv m \\pmod{n}\\] c.q.f.d. !\nSi pgcd\\((m,n) \\neq 1\\), \\(m\\) est nécessairement multiple de \\(p\\) ou de \\(q\\) (cas très peu probable…), on peut montrer en faisant les calculs mod \\(p\\) et mod \\(q\\) que la congruence reste vraie.\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nClé publique : \\((n, e)\\) avec \\(n = pq\\)\nClé privée : \\(d\\) tel que \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\nChiffrement : \\(c = m^e \\bmod n\\)\nDéchiffrement : \\(m = c^d \\bmod n\\)\nSécurité : basée sur difficulté de factoriser \\(n\\)\n\n\n\n\n\n\n\n\n\ngraph LR\n    A[Plaintext m] --&gt;|Encryption: m^e mod n| B[Ciphertext c]\n    B --&gt;|Decryption: c^d mod n| C[Plaintext m]\n    D[Clé publique: n, e] -.-&gt;|utilisée pour| A\n    E[Clé privée: d] -.-&gt;|utilisée pour| B\n    F[p, q premiers secrets] --&gt;|n = pq| D\n    F --&gt;|φn = p-1q-1| E\n\n\n\n\n\n\n\n\n\nSécurité de RSA\nÉquivalence problème RSA ⟺ Factorisation :\n\nTrouver \\(d\\) ⟺ factoriser \\(n\\) (prouvé équivalent)\nDécrypter sans \\(d\\) n’est pas prouvé aussi difficile que factoriser, mais…\nAucune méthode plus rapide que factorisation n’est connue\n\nComplexité de la factorisation :\n\nMéthodes les plus rapides : \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\) (sous-exponentiel)\nCalculatoirement impossible pour \\(n \\geq 1024\\) bits\nRecommandation actuelle : 2048 bits minimum (3072-4096 pour sécurité durable)\n\nChoix des exposants :\n\nExposant d’encryption \\(e\\) :\n\nSouvent petit pour accélérer : \\(e = 3, 17, 65537\\) (commun)\nAttention : si \\(e\\) trop petit ET \\(m &lt; n^{1/e}\\), attaque possible (racine \\(e\\)-ième dans \\(\\mathbb{Z}\\))\nSolution : randomization (padding) du message\n\nExposant de décryption \\(d\\) :\n\nDoit être grand : au moins la moitié de la taille de \\(n\\)\nSi \\(d\\) petit : vulnérable à l’attaque de Wiener\n\n\nConséquence performance :\n\nEncryption rapide (\\(e\\) petit)\nDecryption lente (\\(d\\) grand)\n\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nRSA: Sécurité\nLe problème RSAP consistant à trouver \\(m\\) à partir de \\(c\\) n’est pas prouvé comme étant aussi difficile que la factorisation mais… :\n\nOn peut prouver que si on trouve \\(d\\) on peut facilement calculer \\(p\\) et \\(q\\). Ceci équivaut à dire que factoriser \\(n\\) et trouver \\(d\\) nécessitent un effort de calcul équivalent.\nOn sait que les méthodes les plus rapides pour factoriser ont une complexité sub-exponentielle \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\). Le problème reste donc calculatoirement impossible pour des modulus \\(\\geq 1048\\) bits (2048 bits est un choix fréquent pour une sécurité durable…).\nAfin d’améliorer la vitesse d’encryption, on a tendance à choisir des exposants \\(e\\) assez petits (typiquement : \\(e := 3\\), \\(e := 17\\) et \\(e := 19\\)). On a cependant prouvé que le calcul d’une \\(i\\)-ème racine (avec \\(i\\) petit) modulo un composite \\(n\\) peut être nettement plus facile que la factorisation de \\(n\\). Par contre, en 2008 on a prouvé que la résolution générique du problème RSA est équivalent à la factorisation.\nL’exposant de decryption \\(d\\) doit impérativement être de grande taille (au moins la moitié de la taille de \\(n\\)) pour garantir la sécurité du système.\nPar conséquent, l’encryption est normalement nettement plus rapide que la decryption puisque les exposants utilisés sont beaucoup plus petits !\n\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nSécurité : basée sur difficulté de FACTP (factorisation)\nTaille recommandée : \\(n \\geq 2048\\) bits\n\\(e\\) petit : encryption rapide (3, 17, 65537)\n\\(d\\) grand : au moins \\(\\text{taille}(n)/2\\)\nClés séparées : encryption ≠ signature\n\n\n\n\n\n\n\nAttaques sur RSA\n\nAttaque sur exposant petit avec même message\nSi on envoie le même message \\(m\\) à 3 destinataires avec \\(e = 3\\) :\n\n\\(c_1 \\equiv m^3 \\pmod{n_1}\\)\n\\(c_2 \\equiv m^3 \\pmod{n_2}\\)\n\\(c_3 \\equiv m^3 \\pmod{n_3}\\)\n\nLe Théorème des Restes Chinois donne une solution unique \\(x \\bmod n_1n_2n_3\\) telle que : \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nSi \\(m^3 &lt; n_1n_2n_3\\) (souvent vrai), alors \\(x = m^3\\) dans \\(\\mathbb{Z}\\) et on peut calculer \\(m\\) en prenant simplement la racine cubique entière !\nProtection : toujours randomizer le message avant encryption (padding OAEP)\n\n\nAttaque si message petit\nSi \\(m &lt; n^{1/e}\\), alors \\(m^e &lt; n\\), donc \\(c = m^e\\) (dans \\(\\mathbb{Z}\\), pas modulo). On peut calculer directement la racine \\(e\\)-ième !\nProtection : padding obligatoire\n\n\nPropriété multiplicative\n\\[E(m_1) \\cdot E(m_2) \\equiv (m_1 \\cdot m_2)^e \\equiv E(m_1 \\cdot m_2) \\pmod{n}\\]\nPermet des attaques de type chosen-ciphertext et blind signatures.\n\n\nAttaque générale\nLa méthode la plus efficace reste la factorisation de \\(n\\) (si paramètres bien choisis et implémentation correcte).\n\n\n\n\n\n\nNoteTexte Original\n\n\n\n\n\nRSA: Attaques\nLors qu’on souhaite encrypter le même message pour un groupe de correspondants, il convient d’introduire des variations (randomization) avant l’encryption pour éviter l’attaque suivante :\nAdmettons qu’on calcule des ciphertexts \\(c_1, c_2, c_3\\) à partir du même plaintext \\(m\\) et du même exposant \\(e := 3\\) adressés à trois entités avec des modulus : \\(n_1, n_2, n_3\\).\nLe Théorème des Restes Chinois nous dit qu’il existe une solution \\(x \\bmod n_1n_2n_3\\), t.q. : \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nMais si \\(m\\) ne change pas pour les trois encryptions, on a que \\(x = m^3 \\bmod n_1n_2n_3\\) et, de plus : \\(m^3 &lt; n_1n_2n_3\\). On peut, donc, trouver \\(m\\) en calculant la racine cubique entière de \\(m^3\\), en sachant que pour ce calcul il existe des algorithmes efficaces !\nPlus généralement, si \\(m &lt; n^{1/e}\\), on peut appliquer des algorithmes rapides (dans \\(\\mathbb{Z}\\)) pour calculer les racines \\(e\\)-ièmes de \\(m^e\\). Il convient donc d’effectuer des opérations de “randomization” de \\(m\\) avant d’encrypter !\nLa propriété multiplicative de RSA : \\((m_1 m_2)^e \\equiv m_1^e \\cdot m_2^e \\equiv c_1 \\cdot c_2 \\pmod{n}\\)\ndonne lieu à des failles dangereuses (voir signatures aveugles).\nEn admettant que les paramètres sont correctement choisis et que l’implantation n’a pas de failles, la méthode la plus efficace pour “casser” l’algorithme générique RSA reste la factorisation de \\(n\\).\n\n\n\n\n\n\n\n\n\nTipRévision Rapide\n\n\n\n\n\n\nMême message, petit \\(e\\) : CRT permet d’extraire \\(m\\) !\nMessage trop petit : \\(m &lt; n^{1/e}\\) → racine directe\nPropriété multiplicative : \\(E(m_1) \\cdot E(m_2) = E(m_1 m_2)\\)\nProtection : toujours padding/randomization (OAEP)"
  },
  {
    "objectID": "exam_notes_fr.html#lalgorithme-elgamal",
    "href": "exam_notes_fr.html#lalgorithme-elgamal",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "L’Algorithme ElGamal",
    "text": "L’Algorithme ElGamal\nSystème asymétrique (1985) basé sur le problème du logarithme discret (DLP).\nClés :\n\nChoisir premier \\(p\\), générateur \\(\\alpha \\in \\mathbb{Z}_p^*\\), secret \\(a\\)\nCalculer \\(y = \\alpha^a \\bmod p\\)\nPublique : \\((p, \\alpha, y)\\) | Privée : \\(a\\)\n\nChiffrement : Pour message \\(m\\), choisir aléatoire \\(k\\) unique\n\n\\(\\gamma = \\alpha^k \\bmod p\\)\n\\(\\delta = m \\cdot y^k \\bmod p\\)\nEnvoyer \\((\\gamma, \\delta)\\)\n\nDéchiffrement : \\(m = \\delta \\cdot \\gamma^{-a} \\bmod p\\)\n\n\n\n\n\n\nNoteTexte original du cours\n\n\n\n\n\nProcédé d’Encryption/Decryption d’ElGamal\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère un nombre premier \\(p\\) (len(\\(p\\)) ≥ 1024 bits) et un générateur \\(\\alpha\\) du groupe multiplicatif \\(\\mathbb{Z}_p^*\\)\nA génère un nombre aléatoire \\(a\\), t.q. \\(1 \\leq a \\leq p-2\\) et calcule \\(y := \\alpha^a \\bmod p\\)\nLa clé publique de A est \\((p, \\alpha, y)\\), la clé privée de A est \\(a\\)\n\nEncryption\n\nL’entité B obtient \\((p, \\alpha, \\alpha^a \\bmod p)\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nPour chaque message \\(m_i\\) :\n\nB génère un nombre aléatoire unique \\(k\\), t.q. \\(1 \\leq k \\leq p-2\\)\nB calcule \\(\\gamma := \\alpha^k \\bmod p\\) et \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) et envoie le ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA utilise sa clé privée \\(a\\) pour calculer \\(\\gamma^{p-1-a} \\bmod p\\) (à noter que: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrouve le plaintext en calculant: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBase : DLP dans \\(\\mathbb{Z}_p^*\\)\nChiffré : \\((\\alpha^k, m \\cdot y^k)\\)\nSécurité : \\(k\\) doit être unique et grand\nInconvénient : double la taille du message\n\n\n\n\nRemarques essentielles\n\nPreuve : \\(\\delta \\cdot \\gamma^{-a} = m \\cdot (\\alpha^a)^k \\cdot (\\alpha^k)^{-a} = m \\bmod p\\)\nSécurité : basée sur DLP (complexité sub-exponentielle proche de la factorisation)\nExposants : \\(k\\) et \\(a\\) doivent être grands (sinon vulnérable à baby-step giant-step)\nRéutilisation interdite : si \\(k\\) répété, \\(\\delta_1/\\delta_2 = m_1/m_2\\) révèle les messages\nInconvénient majeur : expansion ×2 de la taille du chiffré\nGénéralisation : fonctionne sur \\(GF(2^n)\\) ou courbes elliptiques\n\n\n\n\n\n\n\nNoteTexte original - Remarques\n\n\n\n\n\nPreuve que le schéma fonctionne : Si \\(s \\equiv k^{-1}(m_h - ar) \\bmod (p-1)\\), on a que: \\(m_h \\equiv (ar + ks) \\bmod (p-1)\\) et \\(v_2 = \\alpha^{H(m)} \\bmod p\\). Si, comme on souhaite montrer \\(m_h = H(m)\\), en réduisant les exposants mod \\((p-1)\\), on peut réécrire \\(v_2\\): \\(v_2 \\equiv \\alpha^{ar+ks} \\bmod p\\). D’autre part: \\(v_1 = y^r\\alpha^{rs} \\equiv \\alpha^{ar}\\alpha^{ks} \\equiv \\alpha^{ar+ks} \\bmod p\\).\nLe procédé d’ElGamal se base sur la difficulté de calculer des logarithmes discrets modulo un nombre premier (problème DLP) même s’il n’a pas été prouvé qu’il soit strictement équivalent à ce problème.\nLes algorithmes les plus efficaces connus ont une complexité sub-exponentielle très proche de celle de la factorisation (on utilise souvent les mêmes algorithmes).\nLes exposants choisis (\\(k\\), \\(a\\)) doivent être de grande taille car il existe des algorithmes efficaces pour calculer des logarithmes discrets modulo un nombre premier lorsque l’exposant est petit (baby-step giant-step algorithm).\nUn inconvénient d’ElGamal est qu’il multiplie par 2 la longueur du ciphertext.\nIl est essentiel pour la sécurité du procédé que le nombre aléatoire \\(k\\) ne soit pas répété, autrement: soient \\((\\gamma_1, \\delta_1)\\) et \\((\\gamma_2, \\delta_2)\\) les deux ciphertexts générés, on a que \\(\\delta_1/\\delta_2 = m_1/m_2\\) et par conséquent, il est trivial de retrouver un plaintext à partir de l’autre.\nLe procédé d’ElGamal peut se généraliser à d’autres groupes comme \\(GF(2^n)\\) ou les courbes elliptiques.\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Remarques\n\n\n\n\n\nÉquivalence : basé sur DLP (non prouvé équivalent)\n\\(k\\) unique : CRITIQUE - sinon \\(m_1/m_2\\) révélé\nTaille clés : exposants grands nécessaires\nExtensions : \\(GF(2^n)\\), courbes elliptiques"
  },
  {
    "objectID": "exam_notes_fr.html#procédé-dencryptiondecryption-delgamal",
    "href": "exam_notes_fr.html#procédé-dencryptiondecryption-delgamal",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Procédé d’Encryption/Decryption d’ElGamal",
    "text": "Procédé d’Encryption/Decryption d’ElGamal\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère un nombre premier \\(p\\) (len(\\(p\\)) ≥ 1024 bits) et un générateur \\(\\alpha\\) du groupe multiplicatif \\(\\mathbb{Z}_p^*\\)\nA génère un nombre aléatoire \\(a\\), t.q. \\(1 \\leq a \\leq p-2\\) et calcule \\(y := \\alpha^a \\bmod p\\)\nLa clé publique de A est \\((p, \\alpha, y)\\), la clé privée de A est \\(a\\)\n\nEncryption\n\nL’entité B obtient \\((p, \\alpha, \\alpha^a \\bmod p)\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nPour chaque message \\(m_i\\) :\n\nB génère un nombre aléatoire unique \\(k\\), t.q. \\(1 \\leq k \\leq p-2\\)\nB calcule \\(\\gamma := \\alpha^k \\bmod p\\) et \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) et envoie le ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA utilise sa clé privée \\(a\\) pour calculer \\(\\gamma^{p-1-a} \\bmod p\\) (à noter que: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrouve le plaintext en calculant: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)"
  },
  {
    "objectID": "exam_notes_fr.html#algorithme-de-rabin",
    "href": "exam_notes_fr.html#algorithme-de-rabin",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Algorithme de Rabin",
    "text": "Algorithme de Rabin\nSystème asymétrique équivalent à la factorisation (provably secure).\nClés :\n\nGénérer deux premiers \\(p\\), \\(q\\) (≥1024 bits total), calculer \\(n = pq\\)\n\nPublique : \\(n\\)\nPrivée : \\((p, q)\\)\n\n\nChiffrement : \\(c = m^2 \\bmod n\\)\nDéchiffrement :\n\nCalculer les 4 racines carrées de \\(c \\bmod n\\) (via racines mod \\(p\\) et mod \\(q\\))\nIdentifier le bon message par redondance\n\n\n\n\n\n\n\nNoteTexte original du cours\n\n\n\n\n\nProcédé d’Encryption/Decryption de Rabin\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère deux nombres premiers aléatoires \\(p\\) et \\(q\\) de grande taille (len(\\(pq\\)) ≥ 1024)\nA calcule \\(n := pq\\)\nLa clé publique de A est \\(n\\), la clé privée de A est \\((p, q)\\)\n\nEncryption\n\nL’entité B obtient \\(n\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB calcule \\(c_i = m_i^2 \\bmod n\\) pour chaque message \\(m_i\\)\nB envoie tous les ciphertext \\(c_i\\) à A\n\nDecryption\n\nA utilise sa clé privée \\((p, q)\\) pour retrouver les 4 solutions de l’équation: \\(c_i = x^2 \\bmod n\\) en utilisant des algorithmes efficaces pour calculer des racines carrées \\(\\bmod p\\) et \\(\\bmod q\\)\nA détermine soit par une indication supplémentaire de B, soit par une analyse de redondance lequel des 4 messages \\(m_1, m_2, m_3, m_4\\) est le plaintext original\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBase : SQROOTP (racine carrée mod composite)\nAvantage : équivalent prouvé à factorisation\nProblème : 4 solutions possibles, nécessite redondance\nVulnérabilité : attaque chosen-ciphertext révèle facteurs\n\n\n\n\nRemarques essentielles\n\nSécurité prouvée : SQROOTP ⟺ FACTP (seul algorithme avec équivalence prouvée)\nAttaque chosen-ciphertext : si A décrypte \\(c = m^2 \\bmod n\\) choisi par adversaire M\n\nM reçoit une racine \\(m_x\\) parmi 4 possibles\nSi \\(m \\neq m_x \\bmod n\\) (prob. 0.5), alors \\(\\gcd(m - m_x, n)\\) donne un facteur de \\(n\\)\n\nSolution : exiger redondance suffisante pour identifier solution unique sans ambiguïté\n\n\n\n\n\n\n\nNoteTexte original - Remarques\n\n\n\n\n\nLe procédé de Rabin est basé sur l’impossibilité de trouver des racines carrées modulo un composite de factorisation inconnue (problème SQROOTP).\nL’intérêt principal de cet algorithme réside dans le fait qu’il a été prouvé comme étant équivalent à la factorisation (SQROOTP ⟺ FACTP). Cet algorithme appartient donc à la catégorie provably secure pour toute attaque passive.\nLes attaques actives peuvent, dans certains cas, compromettre la sécurité de l’algorithme. Plus précisément, si on monte l’attaque chosen ciphertext suivant:\n\nL’attaquant M génère un \\(m\\) et envoie à A le ciphertext \\(c = m^2 \\bmod n\\).\nA répond avec une racine \\(m_x\\) parmi les 4 possibles \\(m_1, m_2, m_3, m_4\\).\nSi \\(m \\neq m_x \\bmod n\\) (probabilité 0.5), M recommence avec un nouveau \\(m\\).\nSinon, A calcule \\(\\gcd(m - m_x, n)\\) et obtient ainsi un des deux facteurs de \\(n\\).\n\nCette attaque pourrait être évitée si le procédé exigeait une redondance suffisante dans les plaintexts permettant à A d’identifier sans ambiguïté laquelle des solutions possibles est le plaintext original. Dans ce cas, A répondrait toujours \\(m\\) et jetterait les autres solutions n’ayant pas le niveau de redondance préétabli.\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Remarques\n\n\n\n\n\nUnique : seul algorithme prouvé équivalent à FACTP\nAttaque : chosen-ciphertext donne facteurs (prob. 0.5)\nParade : redondance obligatoire dans messages"
  },
  {
    "objectID": "exam_notes_fr.html#procédé-dencryptiondecryption-de-rabin",
    "href": "exam_notes_fr.html#procédé-dencryptiondecryption-de-rabin",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Procédé d’Encryption/Decryption de Rabin",
    "text": "Procédé d’Encryption/Decryption de Rabin\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA génère deux nombres premiers aléatoires \\(p\\) et \\(q\\) de grande taille (len(\\(pq\\)) ≥ 1024)\nA calcule \\(n := pq\\)\nLa clé publique de A est \\(n\\), la clé privée de A est \\((p, q)\\)\n\nEncryption\n\nL’entité B obtient \\(n\\), la clé publique authentique de A\nB transforme son plaintext en une série d’entiers \\(m_i\\), t.q. \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB calcule \\(c_i = m_i^2 \\bmod n\\) pour chaque message \\(m_i\\)\nB envoie tous les ciphertext \\(c_i\\) à A\n\nDecryption\n\nA utilise sa clé privée \\((p, q)\\) pour retrouver les 4 solutions de l’équation: \\(c_i = x^2 \\bmod n\\) en utilisant des algorithmes efficaces pour calculer des racines carrées \\(\\bmod p\\) et \\(\\bmod q\\)\nA détermine soit par une indication supplémentaire de B, soit par une analyse de redondance lequel des 4 messages \\(m_1, m_2, m_3, m_4\\) est le plaintext original"
  },
  {
    "objectID": "exam_notes_fr.html#comparaison-rsa---elgamal---rabin",
    "href": "exam_notes_fr.html#comparaison-rsa---elgamal---rabin",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Comparaison RSA - ElGamal - Rabin",
    "text": "Comparaison RSA - ElGamal - Rabin\n\n\n\n\n\n\n\n\n\nCritère\nRSA\nElGamal\nRabin\n\n\n\n\nProblème\nRSAP\nDLP\nSQROOTP\n\n\nSécurité\nÉquiv. factorisation (cas générique)\nBasée sur DLP\nProuvée ⟺ factorisation\n\n\nExpansion\n1:1\n1:2\n1:1\n\n\nDéchiffrement\nDéterministe\nDéterministe\n4 solutions\n\n\nSignature\nOui\nOui\nOui (avec précautions)"
  },
  {
    "objectID": "exam_notes_fr.html#courbes-elliptiques-idée-de-base",
    "href": "exam_notes_fr.html#courbes-elliptiques-idée-de-base",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Courbes Elliptiques (Idée de base)",
    "text": "Courbes Elliptiques (Idée de base)\n\nConcept fondamental\nUne courbe elliptique \\(E\\) est définie par : \\(y^2 = x^3 + ax + b\\) (avec discriminant \\(4a^3 + 27b^2 \\neq 0\\)).\nOpération clé : Addition de points\n\nGéométriquement : tracer une droite entre deux points \\(P\\) et \\(Q\\), trouver le 3ᵉ point d’intersection, puis prendre son symétrique\nForme un groupe commutatif avec point à l’infini \\(\\mathcal{O}\\) comme identité\nMultiplication scalaire : \\(kP = P + P + ... + P\\) (\\(k\\) fois)\n\nAvantage cryptographique :\n\nLe problème ECDLP : trouver \\(k\\) tel que \\(Q = kP\\) est très difficile (effort exponentiel)\nClés plus courtes pour même sécurité qu’en \\(\\mathbb{Z}_p^*\\)\n\n\n\n\n\n\n\nNoteTexte original - Définition\n\n\n\n\n\nUne courbe elliptique est un ensemble de points \\(E\\) défini par l’équation: \\(y^2 = x^3 + ax + b\\), avec \\(x, y, a\\) et \\(b\\) des nombres rationnels, entiers ou entiers modulo \\(m\\) (\\(m &gt; 1\\)). L’ensemble \\(E\\) contient également un “point à l’infini” noté \\(\\mathcal{O}\\). Le point \\(\\mathcal{O}\\) n’est pas dans la courbe mais il est l’élément identité de \\(E\\).\nOn choisira pour nos calculs les courbes elliptiques n’ayant pas de racines multiples ou, en d’autres termes, des courbes où le discriminant \\(4a^3 + 27b^2 \\neq 0\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Concept\n\n\n\n\n\nÉquation : \\(y^2 = x^3 + ax + b\\)\nStructure : groupe avec \\(\\mathcal{O}\\)\nOpération : addition géométrique\nProblème dur : ECDLP\n\n\n\n\n\nAddition sur courbes elliptiques\nSoit \\(P := (x, y) \\in E\\), on définit \\(-P := (x, -y)\\) (symétrique par rapport à l’axe des \\(x\\)). On a \\(P + (-P) = \\mathcal{O}\\).\nPour deux points \\(P, Q \\in E\\) avec \\(Q \\neq -P\\), on définit \\(P + Q := R\\) où \\(-R\\) est le 3ᵉ point d’intersection entre la courbe et la droite passant par \\(P\\) et \\(Q\\).\nPour le doublement : \\(2P = R\\) où \\(-R\\) est le point d’intersection de la courbe avec la tangente à la courbe au point \\(P\\).\n\n\n\n\n\n\nNoteTexte original - Addition\n\n\n\n\n\nSoit \\(P := (x, y) \\in E\\), on définit \\(-P\\) comme \\(-P := (x, -y)\\). Graphiquement, \\(-P\\) est le point symétrique de \\(P\\) par rapport à l’axe des \\(x\\). À noter que \\(P + (-P) = \\mathcal{O}\\).\nSoient deux points \\(P, Q \\in E\\), tels que \\(Q \\neq -P\\), on définit l’addition \\(P + Q := R\\) où \\(R \\in E\\) tel que \\(-R\\) est le 3ᵉ point d’intersection entre la courbe et la droite qui passe par \\(P\\) et \\(Q\\).\nL’ensemble \\(E\\) avec \\(\\oplus\\) définit un groupe commutatif pour l’addition.\nSoit \\(P \\in E\\), le point \\(2P = R\\), tel que \\(-R\\) est le point d’intersection de la courbe avec la droite tangente à la courbe au point \\(P\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide - Addition\n\n\n\n\n\nInverse : \\(-P = (x, -y)\\)\nAddition : 3ᵉ point d’intersection + symétrie\nDoublement : tangente + symétrie\nPropriété : groupe commutatif\n\n\n\n\n\nECDLP et avantages cryptographiques\nLorsque la courbe elliptique est définie sur le corps \\(\\mathbb{Z}_p\\) avec \\(p\\) premier de grande taille (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), le calcul de \\(k \\in \\mathbb{Z}_p\\) tel que \\(Q = kP\\) avec \\((P, Q)\\) connus est très difficile (effort exponentiel). Ce problème est le Elliptic Curve Discrete Logarithm Problem (ECDLP).\nAvantage principal : taille des clés beaucoup plus petite pour une sécurité équivalente.\n\n\n\n\n\n\nNoteTexte original - ECDLP et avantages\n\n\n\n\n\nLorsque la courbe elliptique est définie sur le corps \\(\\mathbb{Z}_p\\) avec \\(p\\) un nombre premier de grande taille (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), le calcul de \\(k \\in \\mathbb{Z}_p\\) tel que \\(Q = kP\\) avec \\((P, Q)\\) connus, est très difficile (nécessite un effort exponentiel). Ce problème est connu comme: Elliptic Curve Discrete Logarithm Problem (ECDLP).\nL’avantage principal de la cryptographie publique basée sur des courbes elliptiques est que la taille des nombres utilisés (et donc, des clés) est plus petite.\nCeci est dû à la complexité accrue des calculs sur \\(E_p\\) (courbe elliptique définie sur le corps \\(\\mathbb{Z}_p\\)) par rapport aux corps habituels tels que \\(\\mathbb{Z}_p\\) ou \\(GF(2^m)\\).\nLa représentation d’un plaintext en points de la courbe reste une opération complexe.\nEn Octobre 2003, la US National Security Agency (NSA) a acheté un brevet de Certicom pour l’utilisation de la cryptographie à courbes elliptiques.\nEn Septembre 2013 Claus Diem montré que sous certaines conditions le problème ECDLP pouvait être résolu en temps sub-exponentiel.\n\n\n\n\n\n\n\n\n\nTipRévision rapide - ECDLP\n\n\n\n\n\nProblème : trouver \\(k\\) dans \\(Q = kP\\) (exponentiel)\nGain : clés ~6-10× plus courtes\nLimite : représenter messages en points difficile\nNSA : adopté en 2003\n\n\n\n\n\nTableau de comparaison des tailles de clés\n\n\n\nAES (symétrique)\nRSA/DH\nCourbes Elliptiques\nRapport\n\n\n\n\n56 bits\n512 bits\n112 bits\n1:4.6\n\n\n80 bits\n1024 bits\n160 bits\n1:6.4\n\n\n112 bits\n2048 bits\n224 bits\n1:9.1\n\n\n128 bits\n3072 bits\n256 bits\n1:12\n\n\n256 bits\n15360 bits\n512 bits\n1:30\n\n\n\n\n\n\n\n\n\nNoteTexte original - Tableau\n\n\n\n\n\nCe tableau montre les rapports des tailles des clés par rapport à celles de RSA pour une sécurité équivalente.\n(Tableau extrait du document original)"
  },
  {
    "objectID": "exam_notes_fr.html#elgamal-sur-courbes-elliptiques",
    "href": "exam_notes_fr.html#elgamal-sur-courbes-elliptiques",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "ElGamal sur Courbes Elliptiques",
    "text": "ElGamal sur Courbes Elliptiques\n\nAdaptation directe\nRemplacer opérations dans \\(\\mathbb{Z}_p^*\\) par opérations sur \\(E_p\\)\nClés :\n\nChoisir courbe \\(E_p\\) et point \\(P_0 \\in E_p\\) de grand ordre\nSecret \\(x\\), calculer \\(P_a = xP_0\\)\nPublique : \\((E_p, P_0, P_a)\\) | Privée : \\(x\\)\n\nChiffrement : Pour message \\(m_i \\in E_p\\)\n\nChoisir \\(k\\) aléatoire\n\\(\\gamma = kP_0\\), \\(\\delta = kP_a + m_i\\)\nEnvoyer \\((\\gamma, \\delta)\\)\n\nDéchiffrement : \\(m_i = \\delta - x\\gamma\\)\n\n\n\n\n\n\nNoteTexte original - ElGamal EC\n\n\n\n\n\nGénération des clés\nChaque entité (A) crée une paire de clés (publique et privée) comme suit:\n\nA choisit une courbe elliptique \\(E_p\\) avec \\(p\\), un nombre premier de grande taille (len(\\(p\\)) bits) et un point \\(P_0 \\in E_p\\).\nA génère un nombre aléatoire \\(x\\), tel que \\(1 \\leq x \\leq p\\) et calcule \\(P_a = xP_0\\) (multiplication par un scalaire sur \\(E_p\\), pour laquelle, il existe des algorithmes efficaces).\nLa clé publique de A est \\((E_p, P_0, P_a)\\), la clé privée de A est \\(x\\).\n\nEncryption\nL’entité B obtient \\((E_p, P_0, P_a)\\), la clé publique authentique de A.\n\nB transforme son plaintext en une série d’entiers \\(m_i\\), tel que \\(m_i \\in E_p\\) pour tout \\(i\\).\nPour chaque message \\(m_i\\) :\n\nB génère un nombre aléatoire unique \\(k\\), tel que \\(1 \\leq k \\leq p\\).\nB calcule \\(\\gamma := kP_0\\) et \\(\\delta := kP_a + m_i\\) et envoie le ciphertext \\(c := (\\gamma, \\delta)\\).\n\n\nDecryption\n\nA utilise sa clé privée \\(x\\) pour calculer: \\(x\\gamma = xkP_0 = kP_a\\).\nA retrouve le plaintext en calculant: \\(\\delta - kP_a = kP_a + m_i - kP_a = m_i\\).\n\nLa sécurité du schéma s’appuie sur ECDLP !\nIl est également nécessaire d’authentifier les parties publiques échangées afin d’éviter les attaques man-in-the middle précédemment décrites.\nLes propriétés du protocole sont identiques au cas \\(\\mathbb{Z}_p^*\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide - ElGamal EC\n\n\n\n\n\nPrincipe : même qu’ElGamal sur \\(E_p\\)\nOpérations : + et × scalaire sur points\nSécurité : ECDLP\nAuthentification : nécessaire contre MitM\nAvantage : clés courtes"
  },
  {
    "objectID": "exam_notes_fr.html#fonctions-à-sens-unique-one-way-functions",
    "href": "exam_notes_fr.html#fonctions-à-sens-unique-one-way-functions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Fonctions à Sens Unique (One-Way Functions)",
    "text": "Fonctions à Sens Unique (One-Way Functions)\nUne fonction \\(f\\) est à sens unique si \\(f(x) = y\\) est facile à calculer, mais trouver \\(x\\) à partir de \\(y\\) est calculatoirement impossible pour la majorité des valeurs.\nExemples :\n\nCarrés modulo composite : \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\)\nConstruction DES : \\(y = E_k(x) \\oplus x\\) avec \\(k\\) fixée et connue\n\nNote : OWF ≠ OWHF (les hash functions imposent compression et 2nd-preimage resistance).\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUne fonction f est dite à sens unique (one-way function ou OWF) si \\(x \\in X\\) on peut facilement calculer \\(f(x) = y\\) mais pour la grande majorité des \\(y \\in Y\\) il est calculatoirement impossible de trouver un \\(x\\) tel que \\(f(x) = y\\).\nExemples:\n\ncalcul des carrées modulo un composite: \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\) (p et q inconnus) est une one-way function car l’inverse est difficile (voir le problème de base SQROOTP).\non peut construire une one-way function sur la base de DES ou de n’importe quel autre système de cryptage à blocs \\(E\\) comme suit: \\(y = f(x) = E_k(x) \\oplus x\\), \\(\\forall x\\), avec \\(k\\) une clé fixée et connue. On peut considérer que \\(E_k(x) \\oplus x\\) a un comportement (pseudo) aléatoire par construction de \\(E\\). Le calcul de l’inverse revient à trouver un \\(x\\) tel que: \\(x = E_k^{-1}(x \\oplus y)\\), ce qui est considéré difficile avec les propriétés de \\(E\\). A noter que \\(f(x) = E_k(x)\\) ne suffirait pas pour en faire une OWF car, en connaissant la clé, DES est réversible.\n\nOWF ≠ OWHF: A noter qu’une OWHF en tant que hash function impose des restrictions supplémentaires sur les domaines sources et image ainsi que sur la 2nd-preimage resistance qui ne sont pas forcement respectés par des OWFs.\nExemple: \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\) (p et q inconnus) n’est pas une OWHF car étant donné \\(x\\), \\(-x\\) est une collision triviale.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nOWF : facile dans un sens (\\(f(x) \\to y\\)), impossible dans l’autre (\\(y \\to x\\)).\nExemples : carrés modulaires, \\(E_k(x) \\oplus x\\).\nOWF ≠ OWHF (hash functions = plus de contraintes)."
  },
  {
    "objectID": "exam_notes_fr.html#hash-functions-définitions",
    "href": "exam_notes_fr.html#hash-functions-définitions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Hash Functions : Définitions",
    "text": "Hash Functions : Définitions\nUne hash function \\(h\\) possède deux propriétés essentielles :\n\nCompression : transforme des données de longueur arbitraire en sortie de longueur fixe\nFacilité de calcul : \\(h(x)\\) est rapide à calculer\n\nClassification :\n\nUnkeyed (sans clé) : MDC (Manipulation Detection Code)\nKeyed (avec clé) : MAC (Message Authentication Code)\n\nPropriétés de sécurité :\n\nPreimage resistance : étant donné \\(y\\), impossible de trouver \\(x\\) tel que \\(h(x) = y\\)\n2nd-preimage resistance (weak collision) : étant donné \\(x\\), impossible de trouver \\(x' \\neq x\\) tel que \\(h(x) = h(x')\\)\nCollision resistance (strong collision) : impossible de trouver \\(x \\neq x'\\) quelconques avec \\(h(x) = h(x')\\)\n\nTerminologie :\n\nOWHF (weak one-way) : satisfait (1) et (2)\nCRHF (strong one-way) : satisfait (2) et (3)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUne fonction de hachage (hash function) est une fonction \\(h\\) ayant les propriétés suivantes:\n\ncompression: la fonction \\(h\\) fait correspondre à un ensemble \\(X\\) composée par des chaînes de bits de longueur finie mais arbitraire, un ensemble \\(Y\\) composé par des chaînes de bits de longueur finie et fixée (et normalement inférieur à la taille de \\(X\\)) avec \\(h(x) = y\\), et \\(x \\in X\\), \\(y \\in Y\\).\nfacile à calculer: partant de \\(h\\) et \\(x \\in X\\), \\(h(x)\\) est facile à calculer.\n\nUne hash function est dite “à clé” (keyed hash function) si une clé intervient dans le calcul de la fonction (\\(h_k(x) = y\\)); sinon on l’appelle “sans clé” (unkeyed hash function).\nLes hash functions ont des nombreuses applications informatiques dont l’archivage structuré facilitant la recherche. Coté sécurité nous allons étudier deux catégories principales:\n\ncodes détecteurs d’altérations (manipulation detection codes (MDC) or message integrity codes (MIC)): ce sont des unkeyed functions permettant de fournir un service d’intégrité sous certaines conditions. Le résultat d’une telle fonction est appelée MDC-value ou, simplement, digest.\ncodes d’authentification de message (message authentication codes ou MAC) qui sont des keyed functions permettant d’authentifier la source du message et d’assurer son intégrité sans utiliser des mécanismes (cryptage) additionnels.\n\nQuelques propriétés de base des hash functions:\n\n1) preimage resistance: étant donné un \\(y \\in Y\\), il est calculatoirement impossible de trouver une pré-image \\(x \\in X\\) satisfaisant \\(h(x) = y\\).\n2) 2nd-preimage resistance: étant donné un \\(x \\in X\\) et son image \\(y \\in Y\\), avec \\(h(x) = y\\), il est calculatoirement impossible de trouver un \\(x' \\neq x\\) tel que \\(h(x) = h(x')\\). Aussi appelée weak collision resistance.\n3) collision résistance: il est calculatoirement impossible de trouver deux pré-images \\(x, x' \\in X\\) distinctes pour lesquels \\(h(x) = h(x')\\) (pas de restriction sur le choix des valeurs). Aussi appelée strong collision resistance.\n\nUne fonction de hachage à sens unique (one way hash function ou OWHF) est un MDC satisfaisant 1) et 2). Aussi appelée: weak one-way hash function.\nUne fonction de hachage résistante aux collisions (collision resistant hash function ou CRHF) est un MDC satisfaisant le propriétés 2) et 3). (A noter que 3) ⇒ 2)). Aussi appelée: strong one-way hash function.\nOWF ≠ OWHF: A noter qu’une OWHF en tant que hash function impose des restrictions supplémentaires sur les domaines sources et image ainsi que sur la 2nd-preimage resistance qui ne sont pas forcement respectés par des OWFs.\nExemple: \\(f(x) = x^2 \\bmod n\\) avec \\(n = pq\\) (p et q inconnus) n’est pas une OWHF car étant donné \\(x\\), \\(-x\\) est une collision triviale.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nHash function : compression + calcul facile\nMDC (sans clé) pour intégrité\nMAC (avec clé) pour authentification\nPropriétés\n\npreimage resistance\n2nd-preimage resistance\ncollision resistance\n\nOWHF = (1)+(2)\nCRHF = (2)+(3)."
  },
  {
    "objectID": "exam_notes_fr.html#message-authentication-codes-macs",
    "href": "exam_notes_fr.html#message-authentication-codes-macs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Message Authentication Codes (MACs)",
    "text": "Message Authentication Codes (MACs)\nUn MAC est une famille de fonctions \\(h_k\\) paramétrées par une clé secrète \\(k\\) :\nPropriétés :\n\nCompression : entrée arbitraire → sortie fixe\nFacile à calculer : avec \\(k\\) connue, \\(h_k(x)\\) est rapide\nComputation-resistance : sans \\(k\\), impossible de calculer des paires \\((x, h_k(x))\\) valides\n\nImplications :\n\nKey non-recovery : impossible de retrouver \\(k\\) à partir de paires \\((x_i, h_k(x_i))\\)\nPreimage et collision resistance pour quiconque ne possède pas \\(k\\)\n\nUsage : Authentification d’origine + intégrité des messages sans révéler de secret directement.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUn Message Authentication Code (MAC) est une famille de fonctions \\(h_k\\) paramétrisées par une clé secrète \\(k\\) ayant les propriétés suivantes:\n\n1) compression: comme pour les fonctions de hash génériques mais appliqué à \\(h_k\\).\n2) facile à calculer: à partir d’une fonction \\(h_k\\), et d’une clé connue \\(k\\), on peut facilement calculer \\(h_k(x)\\). Le résultat est appelée un MAC-value ou, simplement, un MAC.\n3) résistance calculatoire (computation-resistance): sans connaissance de la clé symétrique \\(k\\), il est (calculatoirement) impossible de calculer des paires \\((x, h_k(x))\\) à partir de 0 ou plusieurs paires connus \\((x_i, h_k(x_i))\\) pour tout \\(x \\neq x_i\\).\n\nLa propriété 3) implique que les paires \\((x_i, h_k(x_i))\\) ne peuvent non plus servir à calculer la clé \\(k\\) (key non-recovery). Cependant la propriété key non-recovery n’implique pas computation-resistance car des attaques chosen/known-plaintext pourraient mener à des paires \\((x, h_k(x))\\) falsifiées.\nL’impossibilité de calculer des paires \\((x, h_k(x))\\) se traduit également en preimage et collision resistance (cf. transparent précédent) pour toute entité ne possédant pas la clé \\(k\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nMAC = hash avec clé \\(k\\)\nSans \\(k\\) : impossible de forger \\((x, h_k(x))\\) ou retrouver \\(k\\)\nGarantit authentification d’origine + intégrité."
  },
  {
    "objectID": "exam_notes_fr.html#attaques-sur-les-mdcs",
    "href": "exam_notes_fr.html#attaques-sur-les-mdcs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Attaques sur les MDCs",
    "text": "Attaques sur les MDCs\n\nAttaque 2nd-Preimage Resistance\nProblème : Étant donné \\(h(x) = y\\), trouver \\(x'\\) tel que \\(h(x') = h(x)\\).\nAnalyse probabiliste :\nPour un digest de \\(m\\) bits (\\(n = 2^m\\) sorties possibles), la probabilité d’avoir au moins une collision après \\(k\\) essais est :\n\\[P(\\text{collision}) \\approx 1 - (1-1/n)^k \\approx k/n\\]\nPour \\(P = 0.5\\) : \\(k = n/2 = 2^{m-1}\\)\nConclusion : Pour un digest de \\(m\\) bits, il faut environ \\(2^{m-1}\\) essais pour trouver une 2nd-preimage avec probabilité 0.5.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nProblème: étant donné \\(h(x) = y\\), trouver \\(x'\\) tel que \\(h(x')=h(x)\\).\nExemple pratique: on a un texte avec un digest associé portant une signature digitale; on veut créer un faux texte portant la même signature (sans avoir le contrôle sur le texte original). Quelles sont nos chances d’un point de vue probabiliste?\nSoit une hash function \\(h\\) avec \\(n\\) sorties possibles et une valeur donnée \\(h(x)\\). Si \\(h\\) est appliquée à \\(k\\) valeurs aléatoires, quelle doit être la valeur de \\(k\\) pour que la probabilité d’avoir au moins un \\(y\\) tel que \\(h(x) = h(y)\\) soit 0.5?\nPour la première valeur de \\(y\\), la probabilité que \\(h(x) = h(y)\\) est \\(1/n\\). Inversement, la probabilité que \\(h(x) \\neq h(y)\\) est \\(1-1/n\\). Pour \\(k\\) valeurs, la probabilité de n’avoir aucune collision est de: \\((1-1/n)^k\\), soit:\n\\[\\left(1 - \\frac{1}{n}\\right)^k = 1 - \\frac{k}{n} + \\frac{1}{2!}\\left(\\frac{k}{n}\\right)^2 - \\frac{1}{3!}\\left(\\frac{k}{n}\\right)^3 + \\ldots\\]\nce qui pour \\(n\\) très grand peut être approché par \\(1 - k/n\\). Par conséquent, la probabilité complémentaire d’avoir au moins une collision est d’environ \\(k/n\\); c’est qui nous donne \\(k = n/2\\) pour une probabilité de 0.5.\nConclusion: pour un digest de \\(m\\) bits, le nombre d’essais nécessaires à trouver un \\(y\\) tel que \\(h(x) = h(y)\\) avec une probabilité de 0.5 est \\(2^{m-1}\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nPour casser 2nd-preimage resistance avec digest de \\(m\\) bits : \\(2^{m-1}\\) essais (prob 0.5).\n\n\n\n\n\nAttaque Collision Resistance : Birthday Paradox\nProblème : Trouver deux valeurs distinctes \\(x, x'\\) telles que \\(h(x) = h(x')\\).\nParadoxe d’anniversaire : Dans un groupe de 23 personnes, probabilité &gt; 0.5 d’avoir deux anniversaires identiques.\nRésultat mathématique :\nPour \\(n\\) sorties possibles, la probabilité de collision après \\(k\\) calculs :\n\\[P(\\text{au moins 1 collision}) = 1 - e^{-k(k-1)/(2n)}\\]\nPour \\(P \\geq 0.5\\) : \\(k \\approx 1.17\\sqrt{n}\\)\nConséquence cryptographique : Pour un digest de \\(m\\) bits (\\(n = 2^m\\) sorties), il faut environ \\(2^{m/2}\\) calculs pour trouver une collision avec probabilité &gt; 0.5.\nExemple pratique : Modification d’un contrat en 237 variations pour trouver une version frauduleuse ayant le même digest que la version légitime.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nProblème: trouver deux valeurs \\(x, x'\\) distincts tel que \\(h(x) = h(x')\\).\nExemple pratique: On doit faire signer un texte à quelqu’un et on veut appliquer cette signature à un texte falsifié (on contrôle le texte original). Quelles sont nos chances de trouver deux textes originaux satisfaisant ce critère?\nLe birthday paradox est un problème probabiliste classique qui montre que dans une réunion de 23 personnes seulement, on a déjà une chance sur deux d’avoir deux personnes ayant leur anniversaire le même jour.\nSoit \\(y_1, y_2,..., y_n\\) toutes les sorties possibles d’une hash function. Combien des \\(h(x_i)\\): \\(h(x_1), h(x_2),...,h(x_k)\\) devons nous calculer pour avoir une probabilité de collision égale ou supérieure à 0.5 ?\nLe premier choix pour \\(h(x_1)\\) est arbitraire (prob = 1), le deuxième \\(h(x_2) \\neq h(x_1)\\) a une probabilité de \\(1 - 1/n\\), le troisième de \\(1 - 2/n\\), etc. Ce qui nous donne une probabilité de ne pas avoir des collisions égale à:\n\\[P_{\\text{no collision}} = \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right)\\]\nOn prouve facilement (développement en série de \\(e^{-x}\\)) que pour \\(0 \\leq x \\leq 1\\): \\(1-x \\leq e^{-x}\\) et donc:\n\\[P_{\\text{no coll}} \\leq \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right) \\leq \\prod_{i=1}^{k-1} e^{-i/n} = e^{-k(k-1)/(2n)}\\]\nLa probabilité d’avoir au moins une collision est \\(P_{\\text{au-moins1}} = 1 - P_{\\text{no-coll}}\\). Pour connaître la valeur de \\(k\\) pour laquelle \\(P_{\\text{au-moins1}}\\) est plus grand que 0.5, il suffit de calculer:\n\\[\\frac{1}{2} \\leq 1 - e^{-k(k-1)/(2n)}\\]\nSi \\(k\\) est grand, on remplace \\(k(k-1)\\) par \\(k^2\\) et on obtient après des calculs simples:\n\\[k \\geq \\sqrt{2\\ln(2) \\cdot n} \\approx 1.17\\sqrt{n}\\]\nEn prenant \\(n = 365\\) pour l’anniversaire, on obtient \\(k = 22.3\\), ce qui confirme l’énoncé du problème.\nConséquence pour les hash functions: Soit une hash function avec \\(2^m\\) sorties possibles. Si \\(h\\) est appliqué à \\(k = 2^{m/2}\\) entrées on a une probabilité supérieur à 0.5 d’obtenir \\(h(x_i) = h(x_j)\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBirthday paradox : pour casser collision resistance avec digest de \\(m\\) bits : \\(2^{m/2}\\) essais (prob &gt; 0.5).\nExemple : 23 personnes suffisent pour anniversaires identiques."
  },
  {
    "objectID": "exam_notes_fr.html#résistance-calculatoire-récapitulatif",
    "href": "exam_notes_fr.html#résistance-calculatoire-récapitulatif",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Résistance Calculatoire : Récapitulatif",
    "text": "Résistance Calculatoire : Récapitulatif\nPour une hash function avec digest de \\(n\\) bits et clé MAC de \\(t\\) bits :\n\n\n\nType\nPropriété\nDifficulté\nTaille conseillée\n\n\n\n\nOWHF\nPreimage\n\\(2^n\\)\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage\n\\(2^{n-1}\\)\n\n\n\nCRHF\nCollision\n\\(2^{n/2}\\)\n\\(n \\geq 256\\) bits\n\n\nMAC\nKey recovery\n\\(2^t\\)\n\\(t \\geq 256\\) bits\n\n\n\nComputation\n\\(\\min(2^t, 2^n)\\)\n\\(n \\geq 128\\) bits\n\n\n\nImplications pratiques :\n\nPour intégrité seule (OWHF) : 128 bits suffisent\nPour résistance aux collisions (CRHF) : minimum 256 bits\nMACs : clé de 256 bits, digest de 128 bits minimum\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\n\\(n\\): taille du MDC-value ou du MAC-value résultant de l’application de la hash function\n\\(t\\): taille de la clé du MAC\n\n\n\n\n\n\n\n\n\n\nType de Hash Fct.\nCaractéristique\nDifficulté Calculatoire\nBut de l’attaque\nTaille conseillée du digest/clé\n\n\n\n\nOWHF\npreimage resistance\n\\(2^n\\)\ntrouver une préimage\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage résistance\n\\(2^{n-1}\\)\ntrouver \\(x'\\) avec \\(h(x') = h(x)\\)\n\n\n\nCRHF\ncollision resistance\n\\(2^{n/2}\\)\ntrouver une collision\n\\(n \\geq 256\\) bits\n\n\nMAC\nkey non-recovery\n\\(2^t\\)\ntrouver la clé\n\\(n \\geq 128\\)\n\n\n\ncomputation resistance\n\\(\\min(2^t,2^n)\\)\nproduire un \\((x, h_k(x))\\)\n\\(t \\geq 256\\)\n\n\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nEfforts : preimage \\(2^n\\), 2nd-preimage \\(2^{n-1}\\), collision \\(2^{n/2}\\).\nTailles : OWHF ≥128 bits, CRHF ≥256 bits, MAC clé ≥256 bits."
  },
  {
    "objectID": "exam_notes_fr.html#mdcs-basés-sur-des-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#mdcs-basés-sur-des-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "MDCs Basés sur des Systèmes de Cryptage",
    "text": "MDCs Basés sur des Systèmes de Cryptage\nPrincipe : Utiliser un algorithme de cryptage symétrique (DES, AES) pour construire un MDC.\nDéfis à résoudre :\n\nCasser la réversibilité des algorithmes symétriques\nAugmenter la largeur nominale (DES = 64 bits insuffisant pour CRHF)\n\nFonctionnement :\n\nTraitement séquentiel des blocs\nOpérations de chaînage avec XOR\nCombinaison de \\(n\\) boîtes pour digests de taille \\(n \\times\\) largeur nominale\n\nModèles classiques :\n\nMatyas-Meyer-Oseas : \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1}\\)\nDavies-Meyer : \\(H_i = E_{m_i}(H_{i-1}) \\oplus m_i\\)\nMiyaguchi-Preneel : \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1} \\oplus m_i\\)\n\nExemples pratiques :\n\nMDC-2 : utilise 2 boîtes DES → digest 128 bits\nMDC-4 : utilise 4 boîtes DES → digest 128 bits\n\nLimitation : Sécurité fortement dépendante de l’algorithme sous-jacent.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nIdée: utiliser un système de cryptage symétrique connu pour construire un MDC.\nProblèmes à résoudre:\n\nil faut “casser” la réversibilité des algorithmes symétriques pour en faire des OWHF ou des CRHF.\nLa “largeur nominale” de certains systèmes de cryptage (eg. DES) est de 64 bits, ce qui n’est pas suffisant pour construire des CRHF.\n\nPrincipe de fonctionnement:\n\nles blocs de texte sont séquentiellement traités par la “boîte” de cryptage.\nla compression se base sur des opérations de chaînage avec les blocs résultant des itérations précédentes et des fonctions logiques (fondamentalement XOR). Ceci rend également le procédé irréversible.\nSi nécessaire, \\(n\\) boîtes de cryptage seront combinées pour obtenir des longueurs de digests \\(n\\) fois supérieures à la largeur nominale des boîtes utilisées.\n\nAttention: la sécurité de ces algorithmes est fortement dépendante des propriétés des boîtes de cryptage sous-jacents.\nExemples:\n\nLes modèles de Matyas-Meyer-Oseas, Davies-Meyer et Miyaguchi-Preneel.\nMDC-2 et MDC-4 utilisant respectivement 2 et 4 boîtes DES. Digest = 128 bits.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nMDCs à partir de crypto symétrique : casser réversibilité + chaînage XOR.\nModèles : Matyas-Meyer-Oseas, Davies-Meyer, Miyaguchi-Preneel.\nMDC-2/4 avec DES → 128 bits."
  },
  {
    "objectID": "exam_notes_fr.html#customized-mdcs",
    "href": "exam_notes_fr.html#customized-mdcs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Customized MDCs",
    "text": "Customized MDCs\nFonctions conçues spécifiquement pour la génération de digests, optimisées pour vitesse et sécurité.\nÉléments de construction :\n\nPadding + ajout de la longueur du message\nConstantes prédéfinies pour augmenter la dispersion\nRounds successifs avec opérations logiques et rotations\nChaînage des sorties entre rounds\nChaque bit du digest dépend de chaque bit d’entrée\n\nAlgorithmes principaux :\n\n\n\nAlgorithme\nAnnée\nDigest\nStatut\n\n\n\n\nMD5\n1992\n128 bits\n❌ Cassé\n\n\nSHA-0\n1993\n160 bits\n❌ Collisions en \\(2^{39}\\)\n\n\nSHA-1\n1995\n160 bits\n⚠️ Collisions en \\(2^{63}\\)\n\n\nSHA-2\n-\n224-512 bits\n✓ Sûr actuellement\n\n\nSHA-3 (Keccak)\n2012\n224-512 bits\n✓ Standard actuel\n\n\n\nÉvolution des attaques :\n\n2004 : Collisions complètes sur MD5 (X. Wang)\n2005 : SHA-1 cassé théoriquement (\\(2^{63}\\) opérations)\n2008 : Création de certificats CA frauduleux via MD5\n2012 : SHA-3 adopté comme nouveau standard\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nIl s’agit de fonctions conçues exclusivement pour générer des codes d’intégrité (des digests) avec un soucis principal de vitesse et sécurité.\nLeur fonctionnement se base sur les éléments suivants:\n\ndes opérations d’initialisation (padding + rajouter la longueur).\nun ensemble de constantes prédéfinies choisies spécialement pour augmenter la dispersion.\nun ensemble “d’étapes” (rounds) qui vont séquentiellement s’appliquer a tous les blocs des données originaux. Ces rounds vont effectuer une combinaison d’opérations logiques et des rotations sur les données et les constantes.\ndes opérations de chaînage impliquant les sorties des rounds précédents.\n\nDans ces fonctions, chaque bit du digest est une fonction de chaque bit des entrées.\nLes plus connues sont:\n\nMD5: R. Rivest, 1992; RFC 1321. Digest = 128 bits. Cassé!\nSHA-0: NIST, 1993. Digest = 160 bits. Collisions en \\(2^{39}\\) opérations au lieu de \\(2^{80}\\)\nSHA-1: NIST, 1995. Digest = 160 bits. Révision de SHA-0 avec rotation de bits additionnelle. Collisions en \\(2^{63}\\) opérations (au lieu de \\(2^{80}\\)).\nSHA-2: NIST (FIPS 190-3). Comprend: SHA-224, SHA-256, SHA-384 et SHA-512. Les tailles du digest vont de 224 à 512 bits.\nSHA-3: Keccak Algorithm (taille du digest variable de 224 à 512 bits)\n\nDerniers Développements:\n\nX.Wang et al. culminent en 2004 un long travail visant à trouver des collisions dans l’algorithme MD5. Ils publient deux paires de collisions pour des messages de 1024 bits.\nEn 2005, X.Wang et al. prouvent dans la conférence CRYPTO’05 que le nombre d’opérations nécessaires pour trouver des collisions sur SHA-1 (standard actuel pour les fonctions de hashage sécurisées) est seulement de \\(2^{63}\\).\nCes attaques ont pour cible la recherche de collisions arbitraires mais lors de CRYPTO’06 des chercheurs de l’Université de Graz en Autriche proposent une méthode pour contrôler partiellement le contenu des collisions.\nEn Décembre 2008 on montre qu’on peut générer des collisions contrôlées sur MD5 et créer ainsi une Certification Authority illicite permettant des forger des certificats acceptés par n’importe quel browser.\nCes résultats s’appuient sur des approches analytiques (par opposition au brute force!)\nLe processus de sélection de successeur de SHA-1 est semblable à celui ayant désigné AES comme standard de cryptage en blocs. Le NIST a décidé (Octobre 2012) que Keccak serait l’algorithme de base pour SHA-3.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCustomized MDCs\n\nMD5 (cassé)\nSHA-0 (cassé)\nSHA-1 (faible)\nSHA-2 (sûr)\nSHA-3/Keccak (standard actuel).\n\nConstruction : padding + constantes + rounds + chaînage."
  },
  {
    "objectID": "exam_notes_fr.html#macs-basés-sur-des-systèmes-de-cryptage",
    "href": "exam_notes_fr.html#macs-basés-sur-des-systèmes-de-cryptage",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "MACs Basés sur des Systèmes de Cryptage",
    "text": "MACs Basés sur des Systèmes de Cryptage\nCBC-MAC : Utilise un algorithme de chiffrement par blocs en mode CBC.\nFonctionnement :\n\nMode CBC avec IV = 0\nÉlimination des ciphertexts intermédiaires\nSeul le dernier bloc chiffré est conservé comme MAC\n\nAvec DES :\n\nLongueur clé : 56 bits (112 en Triple-DES optionnel)\nLongueur MAC : 64 bits\n\nAvantages :\n\nRéutilisation de l’infrastructure de chiffrement existante\nPerformances acceptables\n\nLimitations :\n\nSécurité limitée par la taille du bloc (64 bits pour DES)\nVulnérable si utilisé incorrectement (ex: sans IV variable)\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAlgorithme CBC-MAC basé sur DES-CBC avec IV = 0 et élimination des ciphertext intermédiaires\n\nlongueur de clé = 56 bits (112 en cas d’utilisation de la partie optionnelle)\nLongueur du MAC-value = 64 bits\n\nLe schéma montre le traitement séquentiel des blocs de message \\(M_1, M_2, M_3\\) avec l’algorithme de cryptage \\(E\\) et la clé \\(k\\). Les ciphertexts intermédiaires \\(C_1, C_2\\) sont éliminés. Seul le dernier bloc \\(C_3\\) constitue le MAC.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nCBC-MAC : mode CBC + IV=0, seul dernier bloc gardé. DES : clé 56/112 bits, MAC 64 bits."
  },
  {
    "objectID": "exam_notes_fr.html#nested-macs-et-hmacs",
    "href": "exam_notes_fr.html#nested-macs-et-hmacs",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Nested MACs et HMACs",
    "text": "Nested MACs et HMACs\nNested MAC (NMAC) : Composition de deux familles de MACs \\(G\\) et \\(H\\) :\n\\[\\text{NMAC}_{k,l}(x) = g_k(h_l(x))\\]\nSécurité : Dépend de deux critères :\n\n\\(G\\) résistante aux collisions\n\\(H\\) résistante aux attaques spécifiques MACs\n\nHMAC (standard FIPS 198, 2002) : Nested MAC utilisant des MDCs sans clé (SHA-1, SHA-256).\nConstruction :\n\nConstantes : ipad = 0x363636...36 et opad = 0x5C5C5C...5C (512 bits)\nClé \\(k\\) de 512 bits\n\n\\[\\text{HMAC-256}_k(x) = \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nAvantages :\n\nMACs les plus utilisés en pratique\nAttaques sur SHA plus difficiles avec clé secrète\nPerformance excellente\nStandardisé et largement supporté\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUn Nested MAC ou NMAC est une composition de 2 familles de fonctions MACs \\(G\\) et \\(H\\) paramètrès par les clés \\(k\\) et \\(l\\) tel que:\n\\[G \\circ H = \\{ g \\circ h \\text{ avec } g \\in G \\text{ et } h \\in H \\} \\text{ avec } g \\circ h_{(k,l)}(x) = g_k(h_l(x))\\]\nLa sécurité d’un NMAC dépend de deux critères:\n\nLa famille de fonctions \\(G\\) est résistante aux collisions.\nLa famille de fonctions \\(H\\) est résistante aux attaques spécifiques pour MACs, i.e.: Il est impossible de trouver un couple \\((x,y)\\) et une clé \\(m\\) fixée mais inconnue, telle que: \\(\\text{MAC}_m(x) = y\\).\n\nUn HMAC (FIPS 198, 2002) est un Nested MAC utilisant à la base des MDCs sans clé dédiées comme SHA-1 ou SHA-256.\nUn HMAC utilise deux constantes de 512 bits dénommés ipad et opad telles que:\n\nopad := 363636 ... 36\nipad := 5C5C5C ... 5C\n\net une clé \\(k\\) de 512 bits.\nLe schéma de fonctionnement de HMAC-256 (sur la base de SHA-256) est le suivant:\n\\[\\text{HMAC-256}_k(x) := \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nLes HMACs sont les MACs les plus utilisés. Les attaques mentionnées sur les fonctions de la famille SHA sont plus difficiles à réaliser sur un HMAC par cause de la clé \\(k\\).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nHMAC : double hash avec clés dérivées (ipad/opad). \\(\\text{HMAC}_k(x) = H((k \\oplus \\text{opad}) \\parallel H((k \\oplus \\text{ipad}) \\parallel x))\\). Standard, sûr, performant."
  },
  {
    "objectID": "exam_notes_fr.html#applications-des-hash-functions",
    "href": "exam_notes_fr.html#applications-des-hash-functions",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Applications des Hash Functions",
    "text": "Applications des Hash Functions\n\nIntégrité des Données\nTrois approches principales :\n\nMAC seul :\n\n\\(A \\to B: X, \\text{MAC}_k(X)\\)\nAuthentification + intégrité garanties\nNécessite clé partagée\n\nMDC + Encryption :\n\n\\(A \\to B: E_k(X, \\text{MDC}(X))\\)\nConfidentialité + intégrité\nClé symétrique partagée\n\nMDC + Canal authentique :\n\n\\(A \\to B: X\\) (canal normal)\n\\(A \\to B: \\text{MDC}(X)\\) (canal authentique)\nSéparation des canaux\n\n\nLimitations : Ces protocoles simples n’offrent pas de protection contre les replay attacks.\nSolution : ajouter timestamps ou numéros de séquence.\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nMAC Seul: \\[A \\to B: X, \\text{MAC}_k(X)\\] Si \\(B\\) calcule de son coté \\(\\text{MAC}_k(X)\\) et obtient la même valeur ⇒ le message provient de \\(A\\).\nMDC + cryptage symétrique (clé \\(k\\) connue de \\(A\\) et \\(B\\)) \\[A \\to B: X, E_k(\\text{MDC}(X))\\] \\(B\\) calcule \\(\\text{MDC}(X)\\) et puis \\(E_k(\\text{MDC}(X))\\). Si égal ⇒ message vient de \\(A\\).\nComme 2) avec confidentialité de \\(X\\) en plus: \\[A \\to B: E_k(X,\\text{MDC}(X))\\]\nMDC + signature digitale: \\[A \\to B: X, \\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\] \\(B\\) calcule \\(\\text{MDC}(X)\\) et vérifie \\(\\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\) avec une copie authentique de pub-A. Si égalité ⇒ \\(A\\) est à l’origine du message. Cette solution offre en plus la non-répudiation d’origine.\nCes protocoles simples n’offrent aucun support sur l’unicité ni sur l’actualité (timeliness) des messages reçus et sont exposés à des replay attacks! Ils nécessitent des mécanismes tenant compte du temps ou du contexte de la transaction (cf. authentification d’entités).\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nIntégrité : MAC seul, MDC+crypto, MDC+signature.\n⚠️ Vulnérable aux replay sans timestamps/nonces.\n\n\n\n\n\nBlockchains et Proof of Work\nBitcoin et blockchains : Utilisation de hash functions pour chaîner les blocs de transactions.\nCaractéristiques :\n\nTransactions publiques et visibles\nBlocs chaînés via fonctions de hachage cryptographiques\nMinage = résolution d’un puzzle cryptographique (proof of work)\n\nProof of Work :\n\nTrouver un nonce tel que \\(\\text{hash}(\\text{bloc} \\parallel \\text{nonce}) &lt; \\text{target}\\)\nPuzzle coûteux en calcul, validation rapide\nPremier mineur à résoudre reçoit récompense en bitcoins\n\nSécurité :\n\nBlockchain = registre public, décentralisé, immuable\nFalsification nécessiterait effort &gt; tous mineurs honnêtes\nProtection basée sur propriétés CRHF\n\nStatistiques Bitcoin (octobre 2025) :\n\nDifficulty : 150.84 T\nTarget : \\(\\approx 2^{177}\\) (pseudo-collision sur 79 bits)\nHashrate : ~1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hash/sec)\nTemps moyen génération bloc : 10 minutes\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nLes transactions bitcoin sont publiées et visibles par tous les intervenants. Elles sont encapsulées dans des blocs chaînés à l’aide de fonctions de hachage cryptographiques.\nLe minage (mining) consiste à rajouter itérativement des nouveaux blocs contenant les transactions courantes.\nLa génération d’un bloc valable nécessite la résolution d’un puzzle cryptographique (proof of work) très coûteux en temps de calcul (trouver des pseudo-collisions dans les fonctions de hachage cryptographiques). La validation reste très efficace.\nLe premier mineur capable de générer un bloc valable recevra une récompense monétaire (en bitcoins). Le processus de minage est ouvert à tous les mineurs mais seul le premier est récompensé.\nLa chaine de blocs résultante (blockchain) devient alors un registre publique (public ledger), décentralisé et immuable protégeant toutes les transactions passées. La falsification/modification des données protégées par la blockchain nécessiterait un effort calculatoire supérieur à celui effectué par tous les mineurs honnêtes.\nStatistiques Bitcoin 13/10/2025:\n\nDifficulty: 150.84 T\nTarget: \\(2^{224} / \\text{Difficulty} = \\approx 2^{177}\\). Le digest valable pour générer un bloc doit être inférieur à \\(2^{177}\\), ce qui signifie une pseudo-collision sur les 79 bits de poids plus fort. La variation sur les inputs dépend du nonce.\nHashrate: ~ 1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hashes /sec)\nFonctions de hachage exécutées pour obtenir un bloc: ~ \\(660 \\times 10^{21}\\)\nTemps moyen de génération d’un bloc: 10 min\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nBlockchain : chaînage de blocs via hash.\nProof of Work : trouver nonce pour hash &lt; target.\nSécurité = effort &gt; tous mineurs.\nBitcoin : ~10 min/bloc, \\(10^{21}\\) hash/sec.\n\n\n\n\n\nAutres Applications\n1. Authentification :\n\nData origin authentication (DOA)\nTransaction authentication (DOA + paramètres temporels)\n\n2. Virus checking :\n\nCréateur publie \\(\\text{digest} = h(\\text{logiciel})\\) via canal sûr\nUtilisateurs vérifient intégrité en recalculant le digest\n\n3. Distribution des clés publiques :\n\nPublier \\(h(\\text{clé publique})\\) au lieu de la clé complète\nVérification d’authenticité simplifiée\n\n4. Timestamp sur documents :\n\nTimestamp appliqué au digest plutôt qu’au document complet\nRéduction des données à signer\n\n5. One-time password (S-Key) :\n\nChaîne de hash : \\(x_1 = h(x_0), x_2 = h(x_1), \\ldots, x_n = h(x_{n-1})\\)\nSystème stocke \\(x_n\\), utilisateur fournit \\(x_{n-1}\\)\nVérification : \\(h(x_{n-1}) = x_n\\)\nAprès validation, système stocke \\(x_{n-1}\\) pour prochaine fois\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nAuthentification:\n\ndata origin authentication (DOA)\ntransaction authentication (= DOA + time-variant parameters)\n\nVirus checking:\n\nLe créateur d’un logiciel crée un digest = \\(h(x)\\) avec \\(x\\) étant l’original et le distribue par un canal sûr (eg. CD-ROM).\n\nDistribution des clés publiques:\n\nPermet de contrôler l’authenticité d’une clé publique.\n\nTimestamp sur un document:\n\nLe document sur lequel on veut effectuer le timestamp est d’abord soumis à une hash function. Le timestamp (avec la signature de l’entité correspondante) s’applique alors seulement au digest.\n\nOne-time password (S-Key) (mécanisme d’identification):\n\nA partir d’un seed secret \\(x_0\\), on crée une chaîne de hash-values: \\(x_1 = h(x_0)\\), \\(x_2 = h(x_1)\\), … \\(x_n = h(x_{n-1})\\).\nLe système mémorise \\(x_n\\) et l’utilsateur rentre \\(x_{n-1}\\). Si \\(h(x_{n-1}) == x_n\\) ⇒ OK.\nLe système mémorise alors \\(x_{n-1}\\) et ainsi de suite.\n\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nApplications\n\nauthentification\nvirus checking\ndistribution clés publiques\ntimestamp\none-time passwords (chaîne de hash)"
  },
  {
    "objectID": "exam_notes_fr.html#randomized-hash-functions-exemple-unix",
    "href": "exam_notes_fr.html#randomized-hash-functions-exemple-unix",
    "title": "Les Services de Sécurité Fondamentaux",
    "section": "Randomized Hash Functions : Exemple UNIX",
    "text": "Randomized Hash Functions : Exemple UNIX\nProblème : Fonctions de hachage déterministes produisent toujours le même résultat pour le même mot de passe.\nRisques :\n\nDétection de mots de passe identiques\nAttaques par dictionnaire offline (codebooks pré-calculés)\nRainbow tables\n\nSolution UNIX : Salt\n\nAjout d’un élément pseudo-aléatoire de 12 bits (salt) avant hachage\nSalt différent pour chaque utilisateur\n4096 possibilités (\\(2^{12}\\)) pour chaque mot de passe\n\nAvantages :\n\nEmpêche détection des duplications\nCodebooks pré-calculés deviennent inefficaces\nChaque mot de passe nécessite 4096 entrées dans le dictionnaire\n\nImplémentation UNIX :\n\nFichier /etc/passwd accessible globalement\nFormat : username:hash(salt+password):uid:gid:...\nHash basé sur DES modifié (25 itérations)\nSalt stocké en clair (2 premiers caractères du hash)\n\nExemple :\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nLimitations :\n\nProtection efficace contre dictionnaires pré-calculés\nAttaques online limitées par le système (nombre d’essais)\nAttaques offline possibles si fichier compromis\n\n\n\n\n\n\n\nNoteTexte original\n\n\n\n\n\nUNIX garde ses mots de passe dans un fichier globalement accessible (ou éventuellement distribué par NIS). L’information stockée correspond au résultat produit par une hash function.\nExemple (fictif):\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nProblèmes:\n\nla hash function étant déterministe, elle produit le même résultat pour des mots de passe identiques.\non pourrait créer des “cahiers” (codebooks) contenant le résultat de l’application de la hash function à des entrées données (p.ex. un dictionnaire) et les comparer facilement (off-line) avec les chaînes stockées par UNIX (brute force dictionnary attack).\n\nSolution:\n\nRajouter un élément (pseudo) aléatoire de 12 bits différent pour chaque mot de passe (appelé salt) avant de calculer la hash function et lors de la vérification.\nCet élément permet de rajouter un facteur aléatoire de 4096 possibilités pour chaque mot de passe et de prévenir la détection des duplications.\n\nLe schéma de fonctionnement utilise DES avec 25 itérations, le password comme clé, et le salt pour modifier les E-boxes. Le résultat final de 64 bits est converti en 11 caractères ASCII.\nLa sensibilisation des utilisateurs (ne pas visiter des sites douteux) diminue l’efficacité de cette technique dans la transmission de malware.\nLes attaques dictionnaire sont normalement moins efficaces online car les systèmes d’exploitation limitent le nombre d’essais infructueux d’authentification.\n\n\n\n\n\n\n\n\n\nTipRévision rapide\n\n\n\n\n\nUNIX salt : 12 bits aléatoires ajoutés au password avant hash.\n4096 variations possibles.\nEmpêche codebooks pré-calculés et détection duplications."
  },
  {
    "objectID": "exam_notes_en.html",
    "href": "exam_notes_en.html",
    "title": "Fundamental Security Services",
    "section": "",
    "text": "Security services are the objectives aimed at protecting a system.\n\nConfidentiality: Protection against unauthorized disclosure.\nIntegrity: Protection against unauthorized modification.\nAvailability: Guarantee of access for legitimate users.\nAuthentication:\n\nEntity authentication: Certifying the identity of an actor.\nData origin authentication: Certifying the source of data.\n\nNon-repudiation: Inability to deny a transaction.\nNon-duplication: Protection against illicit copying.\nAnonymity: Preservation of identity or source.\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nConfidentiality: Protection of information from unauthorized disclosure.\nIntegrity: Protection against unauthorized modification of information.\nAvailability: Ensuring that resources are accessible to legitimate users.\nAuthentication:\n\nEntity authentication (entity authentication): Process allowing one entity to be certain of the identity of a second entity, supported by corroborating evidence (e.g., physical presence, cryptographic, biometric, etc.). The term identification is sometimes also used for this service.\nData origin authentication (data origin authentication): Process allowing one entity to be certain that a second entity is the original source of a set of data. By definition, this service also ensures the integrity of the data.\n\nNon-repudiation: Guarantees that an entity cannot deny being involved in a transaction.\nNon-duplication: Protection against illicit copying.\nAnonymity (entity or data origin): Preserves the identity of an entity, the source of information, or a transaction."
  },
  {
    "objectID": "exam_notes_en.html#threats-and-attacks-summary",
    "href": "exam_notes_en.html#threats-and-attacks-summary",
    "title": "Fundamental Security Services",
    "section": "Threats and Attacks: Summary",
    "text": "Threats and Attacks: Summary\n\n\n\n\n\n\n\n\nServices\nThreats\nAttacks\n\n\n\n\nConfidentiality\nInformation leakage\nUnauthorized eavesdropping, traffic analysis\n\n\nIntegrity\nInformation modification\nIllicit creation, alteration, or destruction\n\n\nAvailability\nDenial of service, illicit use\nViruses, repeated access attempts to disable a system\n\n\nEntity Authentication\nUnauthorized access\nPassword theft, authentication protocol flaw\n\n\nData Authentication\nInformation falsification\nSignature forgery, protocol flaw\n\n\nNon-repudiation\nDenying involvement in a transaction\nClaiming key theft or signature protocol flaw\n\n\nNon-duplication\nDuplication\nFalsification, imitation\n\n\nAnonymity\nIdentification\nTransaction analysis, unauthorized access enabling identification"
  },
  {
    "objectID": "exam_notes_en.html#protection-mechanisms",
    "href": "exam_notes_en.html#protection-mechanisms",
    "title": "Fundamental Security Services",
    "section": "Protection Mechanisms",
    "text": "Protection Mechanisms\n\n\n\n\n\n\n\n\nServices\nClassic Mechanisms\nDigital Mechanisms\n\n\n\n\nConfidentiality\nSeals, safes, padlocks\nEncryption, logical authorization\n\n\nIntegrity\nSpecial ink, holograms\nOne-way functions + encryption\n\n\nAvailability\nPhysical access control, video surveillance\nLogical access control, audit, antivirus\n\n\nEntity Authentication\nPresence, voice, ID card, biometric recognition\nSecret + authentication protocol, network address + userid, smart card + PIN\n\n\nData Authentication\nSeals, signature, fingerprint\nOne-way functions + encryption\n\n\nNon-repudiation\nSeals, signature, notary signature, registered mail\nOne-way functions + encryption + digital signature\n\n\nNon-duplication\nSpecial ink, holograms, tagging\nDigital watermarking, cryptographic locking\n\n\nAnonymity\nVoice scrambler, disguise, cash\nMixers, remailers, e-money, deep web"
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-e-mail",
    "href": "exam_notes_en.html#malware-delivered-via-e-mail",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via E-Mail",
    "text": "Malware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to trigger an action (open attachment or click a link).\nOften personalized using social engineering.\nMain consequences:\n\nMalware installation (ransomware, keyloggers, etc.).\nLoss or theft of personal data.\nSystem hijacking and malware propagation.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nMalware spread by email\nPrompting clicks or opens\nSocial engineering\nData theft, loss, hijacking\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nMalware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to incite the recipient to open an attachment or follow a link containing ads, offensive info, risky programs, etc.\nOften targeted based on victim interests (preliminary social engineering).\nConsequences:\n\nMalware installation (ransomware, keyloggers, etc.) on victim systems (computer, tablet, smartphone, smartwatch, etc.).\nData destruction.\nTheft of personal information or data.\nSystem hijacking for malicious purposes (e.g., illegal bitcoin mining).\nMalware propagation (potentially to other users)."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-e-mail-1",
    "href": "exam_notes_en.html#malware-delivered-via-e-mail-1",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via E-Mail",
    "text": "Malware Delivered via E-Mail\n\nAlso called malware.\nEmails designed to incite the recipient to open an attachment or follow a link containing ads, offensive info, risky programs, etc.\nOften targeted based on victim interests (preliminary social engineering).\nConsequences:\n\nMalware installation (ransomware, keyloggers, etc.) on victim systems (computer, tablet, smartphone, smartwatch, etc.).\nData destruction.\nTheft of personal information or data.\nSystem hijacking for malicious purposes (e.g., illegal bitcoin mining).\nMalware propagation (potentially to other users)."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-web",
    "href": "exam_notes_en.html#malware-delivered-via-web",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via Web",
    "text": "Malware Delivered via Web\n\nMethod called drive-by download: automatic infection when visiting a website.\nSources can be:\n\nA malicious website\nA compromised legitimate site (e.g., cross-site scripting).\n\nUser caution greatly reduces this propagation method.\nImpacts are similar to email-borne infections.\nScript restriction (Java/JavaScript) reduces risk but can affect browsing.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nDrive-by download = infection without user action\nMalicious or compromised sites\nAwareness + restricted scripts = protection\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nMalware Delivered via Web\n\nOften called drive-by download, allows infecting the system (computer, tablet, smartphone, smartwatch, etc.) simply by visiting a website.\nSources may be:\n\nMalicious site containing malware\nLegitimate website previously infected (e.g., cross-site scripting). Infection may only affect certain pages.\n\nUser awareness (avoiding suspicious sites) reduces the effectiveness.\nConsequences are similar to email infections.\nRestricted script execution (Java/JavaScript) in browsers can limit infection but may constrain navigation."
  },
  {
    "objectID": "exam_notes_en.html#malware-delivered-via-web-1",
    "href": "exam_notes_en.html#malware-delivered-via-web-1",
    "title": "Fundamental Security Services",
    "section": "Malware Delivered via Web",
    "text": "Malware Delivered via Web\n\nOften called drive-by download, allows infecting the system (computer, tablet, smartphone, smartwatch, etc.) simply by visiting a website.\nSources may be:\n\nMalicious site containing malware\nLegitimate website previously infected (e.g., cross-site scripting). Infection may only affect certain pages.\n\nUser awareness (avoiding suspicious sites) reduces the effectiveness.\nConsequences are similar to email infections.\nRestricted script execution (Java/JavaScript) in browsers can limit infection but may constrain navigation."
  },
  {
    "objectID": "exam_notes_en.html#phishing",
    "href": "exam_notes_en.html#phishing",
    "title": "Fundamental Security Services",
    "section": "Phishing",
    "text": "Phishing\n\nTechnique to collect private information through indiscriminate fishing.\nPhishing can be:\n\nGeneral (broad targeting)\nTargeted (spear phishing) for a specific person or organization.\n\nMain vector: forged email address, hard to detect.\nGoal: obtain sensitive data (credentials, passwords, personal or banking info).\nAttacks use credible or threatening pretexts to prompt victim cooperation.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nInformation theft by deception\nForged emails\nSpear phishing = targeted attack\nUrgent or threatening pretexts\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nPhishing\n\nThe word phishing comes from English “password”, “harvesting”, and “fishing”.\nShows the technique’s main goal: collect as much private info via indiscriminate fishing.\nTargeted attacks are called spear phishing (from spear fishing).\nTransmission vector: email with forged sender address requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.\nPretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored."
  },
  {
    "objectID": "exam_notes_en.html#phishing-1",
    "href": "exam_notes_en.html#phishing-1",
    "title": "Fundamental Security Services",
    "section": "Phishing",
    "text": "Phishing\n\nThe word phishing comes from English “password”, “harvesting”, and “fishing”.\nShows the technique’s main goal: collect as much private info via indiscriminate fishing.\nTargeted attacks are called spear phishing (from spear fishing).\nTransmission vector: email with forged sender address requesting private info: emails, social media credentials, passwords, ID numbers, bank accounts, etc.\nPretexts vary (system update, service stoppage, delivery withdrawal) and may threaten the user if ignored."
  },
  {
    "objectID": "exam_notes_en.html#spam",
    "href": "exam_notes_en.html#spam",
    "title": "Fundamental Security Services",
    "section": "Spam",
    "text": "Spam\n\nUnwanted emails, often ads, or unsolicited pop-ups during web browsing.\nRepresent about 60% of global emails.\nMain consequences:\n\nResource consumption and time loss.\nSome can transmit malware.\n\nOften target short addresses or come from sold/exchanged address lists.\nAnti-spam filters incur significant costs for organizations.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nUnwanted emails/ads\nRisks: time/resource loss, malware\nTargeting: short addresses or lists\nFiltering costly for organizations\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nSpam\n\nIncludes all unwanted emails (often ads) received by people and organizations.\nAlso applies to pages/pop-up windows shown without user consent during web browsing.\nAround 60% of global emails belong to this category.\nConsequences: resource consumption and wasted time, but some spam can also transmit malware.\nOften target short email addresses or list-based addresses (sold/exchanged).\nAnti-spam filtering incurs high organizational costs."
  },
  {
    "objectID": "exam_notes_en.html#spam-1",
    "href": "exam_notes_en.html#spam-1",
    "title": "Fundamental Security Services",
    "section": "Spam",
    "text": "Spam\n\nIncludes all unwanted emails (often ads) received by people and organizations.\nAlso applies to pages/pop-up windows shown without user consent during web browsing.\nAround 60% of global emails belong to this category.\nConsequences: resource consumption and wasted time, but some spam can also transmit malware.\nOften target short email addresses or list-based addresses (sold/exchanged).\nAnti-spam filtering incurs high organizational costs."
  },
  {
    "objectID": "exam_notes_en.html#ransomware",
    "href": "exam_notes_en.html#ransomware",
    "title": "Fundamental Security Services",
    "section": "Ransomware",
    "text": "Ransomware\n\nTrojan-type malware that encrypts data to make it inaccessible.\nDemands a ransom (often in bitcoins) to recover files.\nCan remain dormant, triggered by an event or date.\nMain vector: malicious emails.\nOther effects: DoS attacks, extortion.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nData encrypted by Trojan\nRansom to restore access\nPossible programmed dormancy\nInfection via malicious emails\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nRansomware\n\nTrojan malware family.\nTypically encrypts victim’s data to make it completely inaccessible.\nThen displays a message requesting ransom payment (often in bitcoins).\nMay stay in dormant state triggered by event or date.\nInfection vectors vary, but malicious email attachments often responsible.\nVariants exist and continue to evolve.\nOther behaviors: DoS, targeted extortion, threats, etc."
  },
  {
    "objectID": "exam_notes_en.html#ransomware-1",
    "href": "exam_notes_en.html#ransomware-1",
    "title": "Fundamental Security Services",
    "section": "Ransomware",
    "text": "Ransomware\n\nTrojan malware family.\nTypically encrypts victim’s data to make it completely inaccessible.\nThen displays a message requesting ransom payment (often in bitcoins).\nMay stay in dormant state triggered by event or date.\nInfection vectors vary, but malicious email attachments often responsible.\nVariants exist and continue to evolve.\nOther behaviors: DoS, targeted extortion, threats, etc."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-internet-of-things-iot-devices",
    "href": "exam_notes_en.html#attacks-on-internet-of-things-iot-devices",
    "title": "Fundamental Security Services",
    "section": "Attacks on Internet of Things (IoT) Devices",
    "text": "Attacks on Internet of Things (IoT) Devices\n\nTarget connected objects (cameras, TVs, sensors, alarms, etc.).\nDevices are easy to compromise due to:\n\nKnown vulnerabilities\nDefault passwords\nUser unawareness\n\nRemote control enables:\n\nEntry point to the network\nDevice abuse for illicit activities (DDoS, hacking, mining)\n\nA precise inventory of connected devices is essential.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nTargets connected objects\nWeak security (vulnerabilities, default passwords)\nRisk of network access and abuse\nIoT inventory needed\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAttacks on IoT Devices\n\nTarget connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).\nOften easier to hack than traditional systems due to:\n\nMany vulnerabilities known to attackers\nDefault passwords\nUser negligence\n\nRemote takeover allows:\n\nEntry point to home/corporate network\nDevice use for illicit activities (hacking, DDoS, bitcoin mining)\n\nMaintaining a detailed directory of all connected devices is necessary."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-iot-devices",
    "href": "exam_notes_en.html#attacks-on-iot-devices",
    "title": "Fundamental Security Services",
    "section": "Attacks on IoT Devices",
    "text": "Attacks on IoT Devices\n\nTarget connected objects (cameras, TVs, fridges, sensors, alarm systems, etc.).\nOften easier to hack than traditional systems due to:\n\nMany vulnerabilities known to attackers\nDefault passwords\nUser negligence\n\nRemote takeover allows:\n\nEntry point to home/corporate network\nDevice use for illicit activities (hacking, DDoS, bitcoin mining)\n\nMaintaining a detailed directory of all connected devices is necessary."
  },
  {
    "objectID": "exam_notes_en.html#information-spoofing-and-website-defacement",
    "href": "exam_notes_en.html#information-spoofing-and-website-defacement",
    "title": "Fundamental Security Services",
    "section": "Information Spoofing and Website Defacement",
    "text": "Information Spoofing and Website Defacement\n\nAttacks aiming to alter information on websites and social media.\nImpact: compromised reputation and economic damage.\nWebsites: secure host system, restrictive configuration, regular audits.\nSocial media: strong passwords, multi-factor authentication, session closure, cookie deletion.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAltered info on websites and social media\nRisks: reputation, economic losses\nWebsites: security + audits\nSocial media: strong passwords, MFA, closed sessions, cookies cleared\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nInformation Spoofing and Website Defacement\n\nTarget integrity of published info on websites and social media.\nAffects reputation and can cause economic damage.\nWebsites: secure host system, as restrictive configuration as possible, recurring security audits recommended.\nSocial media: depends on authentication process:\n\nAvoid simple passwords\nPrefer strong, possibly multi-factor authentication\nClose sessions properly\nClear cookies"
  },
  {
    "objectID": "exam_notes_en.html#information-spoofing-and-website-defacement-1",
    "href": "exam_notes_en.html#information-spoofing-and-website-defacement-1",
    "title": "Fundamental Security Services",
    "section": "Information Spoofing and Website Defacement",
    "text": "Information Spoofing and Website Defacement\n\nTarget integrity of published info on websites and social media.\nAffects reputation and can cause economic damage.\nWebsites: secure host system, as restrictive configuration as possible, recurring security audits recommended.\nSocial media: depends on authentication process:\n\nAvoid simple passwords\nPrefer strong, possibly multi-factor authentication\nClose sessions properly\nClear cookies"
  },
  {
    "objectID": "exam_notes_en.html#denial-of-service-dos-ddos-attacks",
    "href": "exam_notes_en.html#denial-of-service-dos-ddos-attacks",
    "title": "Fundamental Security Services",
    "section": "Denial of Service (DoS / DDoS) Attacks",
    "text": "Denial of Service (DoS / DDoS) Attacks\n\nAim to make IT systems inaccessible, especially for organizations.\nDDoS: distributed attack using thousands of devices, generating massive traffic.\nClassic protections (firewalls, IDS/IPS sensors) often insufficient.\nConsequences:\n\nAffected reputation\nFinancial losses (sometimes ransom)\nHigh risk for critical infrastructure (hospitals, power plants, Internet backbone)\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nDDoS = inaccessible systems via massive attacks\nLimited protections\nRisks: reputation, finances, critical infrastructures\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nDenial of Service (DoS / DDoS) Attacks\n\nAim to render IT systems inaccessible, mainly targeting private or governmental organizations.\nDDoS (Distributed Denial of Service): multiple devices (often tens of thousands) simultaneously target victim system(s).\nTraffic can reach several hundred Gbps.\nTraditional protection (firewalls, intrusion detection/prevention sensors) has limited effectiveness.\nService unavailability can cause:\n\nReputational issues\nSignificant financial losses (ransom demands)\nHigh security risks (even physical) for critical infrastructures (hospitals, power plants, Internet backbone)."
  },
  {
    "objectID": "exam_notes_en.html#denial-of-service-dos-ddos-attacks-1",
    "href": "exam_notes_en.html#denial-of-service-dos-ddos-attacks-1",
    "title": "Fundamental Security Services",
    "section": "Denial of Service (DoS / DDoS) Attacks",
    "text": "Denial of Service (DoS / DDoS) Attacks\n\nAim to render IT systems inaccessible, mainly targeting private or governmental organizations.\nDDoS (Distributed Denial of Service): multiple devices (often tens of thousands) simultaneously target victim system(s).\nTraffic can reach several hundred Gbps.\nTraditional protection (firewalls, intrusion detection/prevention sensors) has limited effectiveness.\nService unavailability can cause:\n\nReputational issues\nSignificant financial losses (ransom demands)\nHigh security risks (even physical) for critical infrastructures (hospitals, power plants, Internet backbone)."
  },
  {
    "objectID": "exam_notes_en.html#cryptographic-hash-functions",
    "href": "exam_notes_en.html#cryptographic-hash-functions",
    "title": "Fundamental Security Services",
    "section": "Cryptographic Hash Functions",
    "text": "Cryptographic Hash Functions\n\nFunctions easy to compute in one direction but virtually impossible to reverse.\nAny modification of the source document radically changes the digest (avalanche effect).\nKey properties:\n\nOne-way: impossible to retrieve the input from the hash.\nCollision-free: impossible to find two inputs with the same hash.\n\nDigest size: 160 to 512 bits.\nAlgorithms (very performant): SHA-1, SHA-256, SHA-3.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nOne-way + collision-free.\nSize: 160-512 bits.\nAlgos: SHA-1/256/3.\nUsage: integrity, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nFunctions easy to compute in one direction but virtually impossible to compute in the reverse direction.\nAny modification (even insignificant) of the source document results in a fundamentally different digest.\nIt is virtually impossible to retrieve the source document using only the digest (one-way).\nIt is virtually impossible to find a second source document producing the same digest (collision-free).\nUsual digest length: 160 to 512 bits.\nOne-way algorithms are very performant.\nExamples: SHA-1, SHA-256, SHA-3, etc."
  },
  {
    "objectID": "exam_notes_en.html#pseudo-random-generators",
    "href": "exam_notes_en.html#pseudo-random-generators",
    "title": "Fundamental Security Services",
    "section": "(Pseudo) Random Generators",
    "text": "(Pseudo) Random Generators\n\nCharacteristics\n\nrandom\nunpredictable\nnon-reproducible\n\nCritical for security (keys, IV, secrets).\nTypes:\n\nTrue random: based on physical phenomena (radioactivity, quantum).\nPseudo-random: deterministic (based on a seed: initial random sequence).\n\nRisk: “Pseudo-security” if the seed is predictable (Pitkin quote).\nApplications: session keys, IV (DES-CBC), signatures (ElGamal).\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nTrue random: physical (quantum).\nPseudo-random: deterministic (seed).\nRisk: predictable seed = vulnerability.\nUses: keys, IV, signatures.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nRandom number generation is a very important process that can compromise the security of many encryption systems.\nApplications: session key generation, initialization vectors (DES - CBC mode), secrets for signatures (ElGamal), etc.\nA random generator is a device capable of generating numbers in a random, unpredictable and non-reproducible way. (e.g. based on physical phenomena: radioactive or quantum source).\nPseudo-random generators are deterministic processes developed from an initial random sequence (seed) (e.g. user keystrokes, disk access).\nQuote: R. Pitkin in [Kau95]: “The use of pseudo-random processes to generate secret quantities can result in pseudo-security”"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-cryptography",
    "href": "exam_notes_en.html#symmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Symmetric Cryptography",
    "text": "Symmetric Cryptography\n\nHistory: Used since Julius Caesar (1st century BC).\nPrinciple: A single key for encryption/decryption.\nScheme: Plaintext → Encryption (Key) → Ciphertext → Decryption (Key) → Plaintext.\nCharacteristics:\n\nAlgorithms: AES, DES, IDEA, RC4.\nServices: Confidentiality, Authentication, Integrity.\nLimit: No signatures (shared key).\nProblem: Secure key exchange required.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\n1 key to encrypt/decrypt.\nFast (AES, DES).\nProblem: key exchange.\nUses: personal documents, closed groups.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nAlso called conventional cryptography or secret key cryptography (1st century BC, Julius Caesar).\nIdea: Based on a single secret key, perform a transformation capable of respectively making information unreadable and restoring it.\nScheme: Plaintext \\(\\to\\) Encryption (Key) \\(\\to\\) Ciphertext \\(\\to\\) Decryption (Key) \\(\\to\\) Plaintext.\nCharacteristics:\n\nAlgorithms: AES, DES, IDEA, RC4, RC5, etc. (some are free and openly available)\nServices: Confidentiality, Authentication, Integrity.\nNo direct support for digital signatures (because key known by both).\nRequires a confidential channel to exchange the key.\nIdeal for protection of personal documents or closed groups."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography",
    "href": "exam_notes_en.html#asymmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography",
    "text": "Asymmetric Cryptography\n\nAlso called public cryptography (1976, Diffie & Hellman).\nPrinciple\n\nKey pair (public/private) for encryption and signatures.\n\nTwo main uses:\n\nConfidentiality:\n\nEncryption: recipient’s public key\nDecryption: recipient’s private key\n\nDigital signature:\n\nSignature: sender’s private key\nVerification: sender’s public key\nOptimization: Generally sign the hash of the document\nFundamental properties:\n\nIntegrity: Any modification invalidates the signature\nNon-collision: Impossible to have 2 documents with the same signature\nNon-repudiation: Only the holder of the private key can sign\n\n\n\nTechnical aspects:\n\nAlgorithms: RSA, ElGamal\nServices: Integrity, Authentication, Non-Repudiation\nPerformance: much slower than symmetric (100x slower)\nAdvantage: No need for a confidential channel for key exchange\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\n2 keys: public (encrypt/verify) + private (decrypt/sign)\n2 uses:\n\nConfidentiality: encrypt for a recipient\nSignature: prove authenticity\n\nSignatures:\n\nIntegrity + non-repudiation\n\nAlgorithms: RSA/ElGamal\nAdvantage: No need for secure channel to exchange keys\nDisadvantage: Slow\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography\n\nAlso called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).\nIdea: Use two different keys - one secret and one public - respectively for encryption and decryption operations.\nEach user has a keyring.\n\nConfidentiality: * Sender encrypts with the recipient’s public key. * Recipient decrypts with their private key. * Only the recipient’s key is used!\nDigital Signature: * Sender signs with their private key. * Recipient verifies with the sender’s public key. * Only the sender’s key is used! * Note: Generally sign the digest of the document (hash) for performance reasons.\nSignature characteristics: * The signature changes if the document changes, while the private key remains the same. * If the document or signature is modified, verification fails (integrity guaranteed). * It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function without collisions). * Only the holder of the private key can generate a signature verifiable using the corresponding public key (non-repudiation). * Algorithms: RSA, ElGamal. * Services: Integrity, Authentication, Non-Repudiation. * Slowness: Up to 50 times slower than symmetric cryptography. * Advantage: No need for a confidential channel to exchange keys (unlike symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography",
    "text": "Asymmetric Cryptography\n\nAlso called public cryptography or public key cryptography (1976, W. Diffie & M. Hellman).\nIdea: Use two different keys - one secret and one public - respectively for encryption and decryption operations.\nEach user has a keyring.\n\nConfidentiality: * Sender encrypts with the recipient’s public key. * Recipient decrypts with their private key. * Only the recipient’s key is used!\nDigital Signature: * Sender signs with their private key. * Recipient verifies with the sender’s public key. * Only the sender’s key is used! * Note: Generally sign the digest of the document (hash) for performance reasons.\nSignature characteristics: * The signature changes if the document changes, while the private key remains the same. * If the document or signature is modified, verification fails (integrity guaranteed). * It is virtually impossible, even for the holder of the private key, to generate a second document producing the same signature (one-way function without collisions). * Only the holder of the private key can generate a signature verifiable using the corresponding public key (non-repudiation). * Algorithms: RSA, ElGamal. * Services: Integrity, Authentication, Non-Repudiation. * Slowness: Up to 50 times slower than symmetric cryptography. * Advantage: No need for a confidential channel to exchange keys (unlike symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-symmetric-cryptography-hybrid",
    "href": "exam_notes_en.html#asymmetric-symmetric-cryptography-hybrid",
    "title": "Fundamental Security Services",
    "section": "Asymmetric + Symmetric Cryptography (Hybrid)",
    "text": "Asymmetric + Symmetric Cryptography (Hybrid)\n\nPrinciple: Use asymmetric to exchange a symmetric key (session key).\nSteps:\n\nA generates a random symmetric key \\(K_s\\).\nA encrypts \\(K_s\\) with B’s public key.\nA and B then communicate using \\(K_s\\) (symmetric).\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAsymmetric: exchange of symmetric key.\nSymmetric: data encryption.\nAdvantage: combines security + performance.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nIdea: Use public cryptography only to exchange symmetric keys (Session keys).\nA generates a random key \\(K_s\\) and transmits it to B by encrypting it with B’s public key.\nA & B then communicate using \\(K_s\\) (symmetric)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-operation-rsa",
    "href": "exam_notes_en.html#asymmetric-cryptography-operation-rsa",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Operation (RSA)",
    "text": "Asymmetric Cryptography: Operation (RSA)\n\nKey Construction\n\nChoice of prime numbers:\n\n\\(p\\) and \\(q\\): two large prime numbers (&gt; 1024 bits)\n\\(n = pq\\): RSA modulus (size = 2048+ bits)\n\nCalculation of Euler’s totient function:\n\n\\(\\phi(n) = (p-1)(q-1)\\)\nProperty: For any \\(a\\) coprime with \\(n\\), \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\n\nSelection of exponents:\n\n\\(e\\): integer coprime with \\(\\phi(n)\\) (public exponent)\n\\(d\\): modular inverse of \\(e\\) (private exponent), such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\n\n\n\nEncryption/decryption process\n\nPublic key: \\((n,e)\\)\nPrivate key: \\((d)\\)\nEncryption: \\(C = P^e \\pmod{n}\\)\nDecryption: \\(P = C^d \\pmod{n}\\)\n\n\n\nMathematical proof\n\nFundamental congruence:\n\n\\(ed = 1 + k\\phi(n)\\) (by definition of \\(d\\))\n\nApplication of Euler’s theorem:\n\n\\(P^{\\phi(n)} \\equiv 1 \\pmod{n}\\) (if \\(P\\) coprime with \\(n\\))\n\nDemonstration:\n\\[\\begin{align*}\n(P^e)^d &\\equiv P^{ed} \\pmod{n} \\\\\n&\\equiv P^{1 + k\\phi(n)} \\pmod{n} \\\\\n&\\equiv P \\cdot (P^{\\phi(n)})^k \\pmod{n} \\\\\n&\\equiv P \\cdot 1^k \\pmod{n} \\\\\n&\\equiv P \\pmod{n}\n\\end{align*}\\]\n\n\n\nSystem security\n\nHard problem: Factorization of \\(n\\) into \\(p\\) and \\(q\\)\nRecommended size:\n\n\\(n\\): 2048 bits (minimum for current security)\n\\(p\\) and \\(q\\): 1024+ bits each\n\nKnown vulnerabilities:\n\nSide-channel attacks (timing, power analysis)\nInappropriate parameter choices (\\(e\\) too small, \\(p\\) and \\(q\\) too close)\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nKeys:\n\nPublic: \\((n,e)\\) where \\(n = pq\\)\nPrivate: \\((d)\\) with \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\n\nOperations:\n\nEncryption: \\(P^e \\mod n\\)\nDecryption: \\(C^d \\mod n\\)\n\nSecurity: Factorization of \\(n\\) difficult\nSize: 2048+ bits for \\(n\\)\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography: Operation (RSA)\n\nLet \\(n := pq\\) with \\(p\\) and \\(q\\) two large prime numbers (&gt; 1024 bits).\nLet \\(\\phi(n) = (p-1)(q-1)\\).\nLet \\(e\\) and \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nBy definition of congruences: \\(ed = 1 + k\\phi(n)\\)\nEuler’s theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption: \\(C = P^e \\pmod n\\). Public key: \\((n,e)\\).\nDecryption: \\(P = C^d \\pmod n\\). Private key: \\((d)\\).\nProof: \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-operation-rsa-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-operation-rsa-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Operation (RSA)",
    "text": "Asymmetric Cryptography: Operation (RSA)\n\nLet \\(n := pq\\) with \\(p\\) and \\(q\\) two large prime numbers (&gt; 1024 bits).\nLet \\(\\phi(n) = (p-1)(q-1)\\).\nLet \\(e\\) and \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\).\nBy definition of congruences: \\(ed = 1 + k\\phi(n)\\)\nEuler’s theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod n\\).\nEncryption: \\(C = P^e \\pmod n\\). Public key: \\((n,e)\\).\nDecryption: \\(P = C^d \\pmod n\\). Private key: \\((d)\\).\nProof: \\((P^e)^d \\equiv P^{ed} \\equiv P^{1 + k\\phi(n)} \\equiv (P \\pmod n) (P^{\\phi(n)} \\pmod n)^k \\equiv P \\pmod n\\)."
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-conclusions",
    "href": "exam_notes_en.html#asymmetric-cryptography-conclusions",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Conclusions",
    "text": "Asymmetric Cryptography: Conclusions\n\nDominant algorithms: RSA (most used), Rabin, ElGamal\nComplete services:\n\nConfidentiality\nAuthentication\nIntegrity\nDigital signature & Non-repudiation\nNon-duplication\n\nPerformance:\n\n50x slower than symmetric\nOptimal solution: Combination of asymmetric (key exchange) + symmetric (encryption)\n\nKey management:\n\nAdvantage: Public key exchange without confidential channel\nRisk: Need to verify authenticity of public keys\n\nAuthenticated acquisition channel or\nCertification by trusted third party\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nAlgos: RSA (dominant), Rabin, ElGamal\nServices: Confidentiality + Authentication + Integrity + Signatures\nSlowness: 50x vs symmetric → hybrid recommended\nKeys: Simple public exchange but authentication crucial\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nAsymmetric Cryptography: Conclusions\n\nThere are a few asymmetric encryption systems (Rabin, ElGamal, etc.) but the most used is RSA.\nSupported services: Confidentiality, Authentication, Integrity, Digital Signature & Non-Repudiation, (Non-Duplication).\nOperations related to asymmetric cryptography are up to 50 times (!) slower than those of symmetric cryptography. A combination of the two methods is often desirable.\nKey distribution is simplified by the fact that only public keys need to be exchanged between participants (no need for an alternative confidential channel) but…\n… it is necessary to verify that the public key actually belongs to the recipient:\n\nEither the acquisition channel of the public key is protected against any modification (authenticated)\nOr the key is certified accurate by a third party"
  },
  {
    "objectID": "exam_notes_en.html#asymmetric-cryptography-conclusions-1",
    "href": "exam_notes_en.html#asymmetric-cryptography-conclusions-1",
    "title": "Fundamental Security Services",
    "section": "Asymmetric Cryptography: Conclusions",
    "text": "Asymmetric Cryptography: Conclusions\n\nThere are a few asymmetric encryption systems (Rabin, ElGamal, etc.) but the most used is RSA.\nSupported services: Confidentiality, Authentication, Integrity, Digital Signature & Non-Repudiation, (Non-Duplication).\nOperations related to asymmetric cryptography are up to 50 times (!) slower than those of symmetric cryptography. A combination of the two methods is often desirable.\nKey distribution is simplified by the fact that only public keys need to be exchanged between participants (no need for an alternative confidential channel) but…\n… it is necessary to verify that the public key actually belongs to the recipient:\n\nEither the acquisition channel of the public key is protected against any modification (authenticated)\nOr the key is certified accurate by a third party"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs-asymmetric-comparison",
    "href": "exam_notes_en.html#symmetric-vs-asymmetric-comparison",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs Asymmetric Comparison",
    "text": "Symmetric vs Asymmetric Comparison\n\nComparative advantages\n\nSymmetric:\n\nPerformance: 100x faster\nImplementation: Easy in hardware\nKeys: Short (128 bits = 16 memorable characters)\n\nAsymmetric:\n\nKey exchange: Authenticated channel sufficient (no need for confidentiality)\nManagement: 1 key pair for n correspondents (vs n keys in symmetric)\n\n\n\n\nCommon issues\n\nWeak link: Key management by users\nSecurity basis: Empirical rather than theoretical\nLegal constraints: Usage and export restrictions\n\n\n\nUsage recommendations\n\n\n\n\n\n\n\n\nUse case\nRecommended solution\nJustification\n\n\n\n\nPersonal documents\nSymmetric\nSpeed + memorable keys\n\n\nGroups of close users\nSymmetric\nSpeed + easy confidential exchange\n\n\nDistant/unknown users\nAsymmetric\nNo need for confidential channel\n\n\nRemote transactions\nHybrid (Asymmetric + Symmetric)\nAsymmetric for key exchange, symmetric for data\n\n\nSoftware protection (distribution)\nHybrid\nUnique symmetric key per version, encrypted with asymmetric\n\n\nNetwork segments\nSymmetric\nSpeed + controlled environment (easy key exchange between administrators)\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nSymmetric:\n✅ Fast (100x)\n✅ Short keys (128 bits)\n❌ Confidential key exchange required\nAsymmetric:\n✅ Simplified key exchange\n✅ 1 key pair for n correspondents\n❌ Slow (50x)\n❌ Long keys (1024+ bits)\nHybrid: Best of both worlds Common problems: Key management, empirical basis, legal restrictions\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nSymmetric vs. Asymmetric Cryptography\n\nThere are hundreds of symmetric and asymmetric algorithms capable of providing a sufficient level of confidentiality.\nSymmetric solutions offer the following advantages:\n\nSpeed (up to 100 times faster than asymmetric solutions)\nEase of hardware implementation\nReduced key length: 128 bits (= 16 characters ⇒ memorable!) instead of 1024 bits for asymmetric equivalents.\n\nAsymmetric solutions have as main arguments:\n\nSimplified key exchange: keys must be exchanged through an authenticated but non-confidential channel\nSimplified key management: a single public/private key pair is sufficient for a user to receive confidential messages from n users (instead of n different keys in the symmetric case).\n\nProblems common to both techniques:\n\nKey management by the user remains the weakest link\nSecurity (normally) based on empirical arguments rather than theoretical ones\nLegal restrictions on usage and export\n\n\n\n\nSymmetric vs. Asymmetric Cryptography (II)\n\n\n\n\n\n\n\n\nActivity\nRecommendation\nRemarks\n\n\n\n\nProtection of personal documents\nSymmetric crypto\nSpeed, easily memorable keys\n\n\nProtection of documents in a group of close users\nSymmetric crypto\nSpeed, ease of exchanging confidential keys\n\n\nEstablishment of confidential channels between distant users (unknown)\nAsymmetric crypto\nNo need to have a confidential channel: authenticity suffices\n\n\nTransactions between two distant users, Software protection (multicast distribution)\nAsymmetric crypto for symmetric key protection + Symmetric crypto for data protection\nSpeed, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public\n\n\nProtection of network segments\nSymmetric crypto\nSpeed, Stable environment → easy confidential key exchange between sysadmins"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography",
    "href": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs. Asymmetric Cryptography",
    "text": "Symmetric vs. Asymmetric Cryptography\n\nThere are hundreds of symmetric and asymmetric algorithms capable of providing a sufficient level of confidentiality.\nSymmetric solutions offer the following advantages:\n\nSpeed (up to 100 times faster than asymmetric solutions)\nEase of hardware implementation\nReduced key length: 128 bits (= 16 characters ⇒ memorable!) instead of 1024 bits for asymmetric equivalents.\n\nAsymmetric solutions have as main arguments:\n\nSimplified key exchange: keys must be exchanged through an authenticated but non-confidential channel\nSimplified key management: a single public/private key pair is sufficient for a user to receive confidential messages from n users (instead of n different keys in the symmetric case).\n\nProblems common to both techniques:\n\nKey management by the user remains the weakest link\nSecurity (normally) based on empirical arguments rather than theoretical ones\nLegal restrictions on usage and export"
  },
  {
    "objectID": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography-ii",
    "href": "exam_notes_en.html#symmetric-vs.-asymmetric-cryptography-ii",
    "title": "Fundamental Security Services",
    "section": "Symmetric vs. Asymmetric Cryptography (II)",
    "text": "Symmetric vs. Asymmetric Cryptography (II)\n\n\n\n\n\n\n\n\nActivity\nRecommendation\nRemarks\n\n\n\n\nProtection of personal documents\nSymmetric crypto\nSpeed, easily memorable keys\n\n\nProtection of documents in a group of close users\nSymmetric crypto\nSpeed, ease of exchanging confidential keys\n\n\nEstablishment of confidential channels between distant users (unknown)\nAsymmetric crypto\nNo need to have a confidential channel: authenticity suffices\n\n\nTransactions between two distant users, Software protection (multicast distribution)\nAsymmetric crypto for symmetric key protection + Symmetric crypto for data protection\nSpeed, Only the symmetric key needs to be re-encrypted for each correspondent, Encrypted copy of software can be made public\n\n\nProtection of network segments\nSymmetric crypto\nSpeed, Stable environment → easy confidential key exchange between sysadmins"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-attack-lifecycle",
    "href": "exam_notes_en.html#ransomware-attack-lifecycle",
    "title": "Fundamental Security Services",
    "section": "Ransomware Attack Lifecycle",
    "text": "Ransomware Attack Lifecycle\n\nPrevention and Response\n\n\n\n\n\n\n\nPhase\nMeasures\n\n\n\n\nPrevention\n- Regular patching- Detection solutions (Firewalls, WAFs, IDS/IPS)- Anti-malware scans (emails, files)\n\n\nProtection\n- Offline backups (essential!)- Strict security policies- User training\n\n\nResponse\n- Do not pay (official recommendation)- Forensic analysis- Restoration from backups\n\n\n\n\n\nTechnical Dissection\n\nInfection:\n\nVectors: Phishing, exploits, vulnerable RDP\nPropagation: Lateral (network) or vertical (system)\n\nExecution:\n\nEncryption of targeted files\nDeletion of shadow copies\nPersistence (registry, scheduled tasks)\n\nExtortion:\n\nDisplay of ransom demand\nPayment in cryptocurrencies (Bitcoin, Monero)\nPayment deadlines with penalties\n\nObfuscation:\n\nCode obfuscation\nCommunication via TOR/Deep Web\nLog erasure\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nAttack cycle:\n\nInfection (phishing/exploits)\nExecution (encryption + persistence)\nExtortion (ransom in crypto)\nObfuscation (TOR + trace erasure)\n\nCountermeasures:\n✅ Offline backups\n✅ Patching + detection\n✅ Training\n❌ Do not pay"
  },
  {
    "objectID": "exam_notes_en.html#cryptolocker-technical-analysis",
    "href": "exam_notes_en.html#cryptolocker-technical-analysis",
    "title": "Fundamental Security Services",
    "section": "Cryptolocker: Technical Analysis",
    "text": "Cryptolocker: Technical Analysis\n\nAttack Scheme\n\n\n\n\n\ngraph TD\n    A[Initial infection] --&gt; B[File encryption]\n    B --&gt; C[Private key storage on C2 servers]\n    C --&gt; D[Ransom demand]\n    D --&gt; E{Payment ?}\n    E --&gt;|Yes| F[Decryption key sent via TOR]\n    E --&gt;|No| G[Permanent data loss]\n\n\n\n\n\n\n\n\nPreferred Targets\n\nCritical extensions (extract):\n\nDocuments: .docx, .xlsx, .pdf, .pptx\nDatabases: .mdb, .sql, .sqlite\nMedia: .jpg, .png, .mp4, .avi\nDevelopment: .java, .cpp, .py, .php\nFinancial: .qbw, .qbb, .wallet\n\nBehavior:\n\nSelective encryption (recent/modified files)\nDouble extortion: Encryption + threat of leakage\nRaaS (Ransomware-as-a-Service): Economic model\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\nMechanism: - Private key stored on C2 servers - Payment → key via TOR - Targets: 100+ extensions (docs, DB, media)\nRecent evolutions: - Double extortion (encryption + leakage) - RaaS (ransomware rental)\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nRansomware: Complete View\n(Source: 2017 State of Cybersecurity, F-Secure Inc.)\n\n\nRansomware: Complete View\n\nPrevention, Remediation and Response\n\nPatching\nActive and passive detection (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)\nOffline backups !\nSecurity Policy - Rules for proper email usage\nTraining !\nTo pay or not to pay…\n\n\n\nTechnical Dissection of the Attack\n\nInfection and propagation\nExecution\nPayment (Crypto-currencies / Bitcoin)\nObfuscation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nGeneric Scheme of a Cryptolocker Ransomware\n\nDecryption private keys are stored on the attacker’s servers\nThey are sent to the victim after bitcoin payment\nThe trace is shredded using TOR networks\n\n\n\n\nRansomware Cryptolocker: Targets\nTargeted file extensions: .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource: Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-complete-view",
    "href": "exam_notes_en.html#ransomware-complete-view",
    "title": "Fundamental Security Services",
    "section": "Ransomware: Complete View",
    "text": "Ransomware: Complete View\n(Source: 2017 State of Cybersecurity, F-Secure Inc.)"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-complete-view-1",
    "href": "exam_notes_en.html#ransomware-complete-view-1",
    "title": "Fundamental Security Services",
    "section": "Ransomware: Complete View",
    "text": "Ransomware: Complete View\n\nPrevention, Remediation and Response\n\nPatching\nActive and passive detection (Firewalls, WAFs, IDS, IPS, email malware scan, etc.)\nOffline backups !\nSecurity Policy - Rules for proper email usage\nTraining !\nTo pay or not to pay…\n\n\n\nTechnical Dissection of the Attack\n\nInfection and propagation\nExecution\nPayment (Crypto-currencies / Bitcoin)\nObfuscation (Obfuscation, TOR Networks/Deep Web)\n\n\n\nGeneric Scheme of a Cryptolocker Ransomware\n\nDecryption private keys are stored on the attacker’s servers\nThey are sent to the victim after bitcoin payment\nThe trace is shredded using TOR networks"
  },
  {
    "objectID": "exam_notes_en.html#ransomware-cryptolocker-targets",
    "href": "exam_notes_en.html#ransomware-cryptolocker-targets",
    "title": "Fundamental Security Services",
    "section": "Ransomware Cryptolocker: Targets",
    "text": "Ransomware Cryptolocker: Targets\nTargeted file extensions: .jin, .xls, .xlsx, .pdf, .doc, .docx, .ppt, .pptx, .txt, .dwg, .bak, .bkf, .pst, .dbx, .zip, .rar, .mdb, .asp, .aspx, .html, .htm, .dbf, .3dm, .3ds, .3fr, .jar, .3g2, .xml, .png, .tif, .3gp, .java, .jpe, .jpeg, .jpg, .jsp, .php, .3pr, .7z, .ab4, .accdb, .accde, .accdr, .accdt, .ach, .kbx, .acr, .act, .adb, .ads, .agdl, .ai, .ait, .al, .apj, .arw, .asf, .asm, .asx, .avi, .awg, .back, .backup, .backupdb, .pbl, .bank, .bay, .bdb, .bgt, .bik, .bkp, .blend, .bpw, .c, .cdf, .cdr, .cdr3, .cdr4, .cdr5, .cdr6, .cdrw, .cdx, .ce1, .ce2, .cer, .cfp, .cgm, .cib, .class, .cls, .cmt, .cpi, .cpp, .cr2, .craw, .crt, .crw, .phtml, .php5, .cs, .csh, .csl, .tib, .csv, .dac, .db, .db3, .dbjournal, .dc2, .dcr, .dcs, .ddd, .ddoc, .ddrw, .dds, .der, .des, .design, .dgc, .djvu, .dng, .dot, .docm, .dotm, .dotx, .drf, .drw, .dtd, .dxb, .dxf, .dxg, .eml, .eps, .erbsql, .erf, .exf, .fdb, .ffd, .fff, .fh, .fmb, .fhd, .fla, .flac, .flv, .fpx, .fxg, .gray, .grey, .gry, .h, .hbk, .hpp, .ibank, .ibd, .ibz, .idx, .iif, .iiq, .incpas, .indd, .kc2, .kdbx, .kdc, .key, .kpdx, .lua, .m, .m4v, .max, .mdc, .mdf, .mef, .mfw, .mmw, .moneywell, .mos, .mov, .mp3, .mp4, .mpg, .mrw, .msg, .myd, .nd, .ndd, .nef, .nk2, .nop, .nrw, .ns2, .ns3, .ns4, .nsd, .nsf, .nsg, .nsh, .nwb, .nx2, .nxl, .nyf, .oab, .obj, .odb, .odc, .odf, .odg, .odm, .odp, .ods, .odt, .oil, .orf, .ost, .otg, .oth, .otp, .ots, .ott, .p12, .p7b, .p7c, .pab, .pages, .pas, .pat, .pcd, .pct, .pdb, .pdd, .pef, .pem, .pfx, .pl, .plc, .pot, .potm, .potx, .ppam, .pps, .ppsm, .ppsx, .pptm, .prf, .ps, .psafe3, .psd, .pspimage, .ptx, .py, .qba, .qbb, .qbm, .qbr, .qbw, .qbx, .qby, .r3d, .raf, .rat, .raw, .rdb, .rm, .rtf, .rw2, .rwl, .rwz, .s3db, .sas7bdat, .say, .sd0, .sda, .sdf, .sldm, .sldx, .sql, .sqlite, .sqlite3, .sqlitedb, .sr2, .srf, .srt, .srw, .st4, .st5, .st6, .st7, .st8, .std, .sti, .stw, .stx, .svg, .swf, .sxc, .sxd, .sxg, .sxi, .sxi, .sxm, .sxw, .tex, .tga, .thm, .tlg, .vob, .war, .wallet, .wav, .wb2, .wmv, .wpd, .wps, .x11, .x3f, .xis, .xla, .xlam, .xlk, .xlm, .xlr, .xlsb, .xlsm, .xlt, .xltm, .xltx, .xlw, .ycbcra, .yuv\nSource: Intel Security Advanced Threat Research - http://www.intelsecurity.com"
  },
  {
    "objectID": "exam_notes_en.html#kerckhoffs-principle",
    "href": "exam_notes_en.html#kerckhoffs-principle",
    "title": "Fundamental Security Services",
    "section": "Kerckhoffs’ Principle",
    "text": "Kerckhoffs’ Principle\n\nFundamental principle: security relies solely on the key, not on the secrecy of the algorithm.\nThe system must remain secure even if the algorithm is public.\nThe key must be easily modifiable and the system simple to use.\nExplicit rejection of security through obscurity.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nSecurity based on the key\nPublic algorithm\nNo security through obscurity\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nKerckhoffs’ Principle\nAuguste Kerckhoffs published in 1883 two articles defining six principles for military ciphers:\n\nThe system must be practically, if not mathematically, undecipherable.\nIt must not require confidentiality and remain secure even if it falls into enemy hands.\nThe key must be able to be memorized, transmitted and modified easily, without written notes.\nThe system must be compatible with telegraphic communications.\nIt must be portable and usable by a single person.\nIt must be simple to use, without complex procedures or excessive constraints.\n\nKerckhoffs stated as early as the 19th century that security must be mathematically demonstrable and that there is no security through obscurity."
  },
  {
    "objectID": "exam_notes_en.html#kerckhoffs-principle-1",
    "href": "exam_notes_en.html#kerckhoffs-principle-1",
    "title": "Fundamental Security Services",
    "section": "Kerckhoffs’ Principle",
    "text": "Kerckhoffs’ Principle\nAuguste Kerckhoffs published in 1883 two articles defining six principles for military ciphers:\n\nThe system must be practically, if not mathematically, undecipherable.\nIt must not require confidentiality and remain secure even if it falls into enemy hands.\nThe key must be able to be memorized, transmitted and modified easily, without written notes.\nThe system must be compatible with telegraphic communications.\nIt must be portable and usable by a single person.\nIt must be simple to use, without complex procedures or excessive constraints.\n\nKerckhoffs stated as early as the 19th century that security must be mathematically demonstrable and that there is no security through obscurity."
  },
  {
    "objectID": "exam_notes_en.html#classification-of-encryption-systems",
    "href": "exam_notes_en.html#classification-of-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "Classification of Encryption Systems",
    "text": "Classification of Encryption Systems\n\nUnconditional Security\n(unconditional security / perfect secrecy)\n\nSecurity independent of computing power.\nCiphertext provides no information about the plaintext.\nConditions: key ≥ message, never reused.\nMostly theoretical use.\nExample: one-time pad.\n\n\n\nAs hard as / equivalent / provable security\n\nCryptanalysis as difficult as a hard mathematical problem.\nRSA and Rabin proven equivalent to factorization.\n\nDemonstrated by reduction (reduction proof).\n\nCentral but controversial concept.\n\n\n\nComputational Security\n(computational security / practical security)\n\nSecurity based on unrealistic cost of attacks.\nMost used category in practice.\nExamples: AES, DES, IDEA, RC4.\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nUnconditional: perfect, theoretical (one-time pad).\nProvable security: equivalence to hard mathematical problem.\nComputational: secure in practice.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nUnconditional security (unconditional security also called perfect secrecy):\n\nThe security of the encryption system is not compromised by the computing power intended for cryptanalysis.\nThis category relies on information theory published by Shannon in 1949.\nMore precisely, an encryption system is unconditionally secure if the probability of encountering a plaintext x after observing the corresponding ciphertext y is identical to the a priori probability of encountering plaintext x.\nIn other words, having plaintext/ciphertext pairs (x,y) provides no help for cryptanalysis.\nA necessary condition for a system to be unconditionally secure is that the key be at least the same size as the message and, above all, that it not be reused to encrypt different messages.\nThis condition makes these systems poorly suited to usual cryptographic needs and reduces their domain of interest to a theoretical framework.\nThe classic example is the one-time pad invented in 1917 by J. Mauborgne and G. Vernam.\nTheoretical foundations of unconditionally secure systems + other examples in [Sti06].\n\nAs hard as / equivalent / provable security\n\nWhen it can be proven that cryptanalyzing the algorithm is as difficult as solving a reputedly hard mathematical problem.\nFor example factorization of large numbers, calculation of square roots modulo a composite, calculation of discrete logarithms in a finite group, etc.\nThe Rabin and RSA algorithms (generic case^1) are “proven” equivalent to factorization.\nSuch a proof is called a “reduction” (reduction proof).\nThe notion of provable security is at the origin of an important controversy in the cryptographic world.\n\nComputational security (computational security also called practical security)\n\nAn encryption system is in this category if the computational effort needed to “break” it using the best possible techniques is beyond (with a reasonable margin) the computing resources of a hypothetical adversary.\nThe vast majority of symmetric encryption systems (AES, DES, IDEA, RC4, etc.) are in this category."
  },
  {
    "objectID": "exam_notes_en.html#entropy",
    "href": "exam_notes_en.html#entropy",
    "title": "Fundamental Security Services",
    "section": "Entropy",
    "text": "Entropy\n\nEntropy (Shannon, 1948) measures the effective amount of information contained in a message.\nConditional entropy measures the uncertainty that remains about the plaintext after observing the ciphertext.\n\n\nProperties\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0\\) → no uncertainty\n\\(H(X) = \\log n\\) → all outcomes equally probable\n\n\n\nInterpretation\n\nApproximates the number of bits needed to encode \\(X\\).\nRedundancy = difference between effective encoding and entropy.\n\n\n\nConditional Entropy\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\)\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\nMeasures the remaining uncertainty about the plaintext after observing the ciphertext.\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nEntropy: amount of information in a message.\nConditional entropy: uncertainty about plaintext after ciphertext.\nRedundancy: difference between effective encoding and entropy.\n\n\n\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\n\nAn essential definition in cryptography is the effective amount of information contained in a message.\nFor example, days of the week (Monday, …, Sunday) can intuitively be encoded as character strings of length (\\(\\le \\text{len}(\\text{``Wednesday''})\\)), i.e., \\((8 \\times 8 = 64)\\) bits. However, the effective amount of information of the variable day of the week can be optimally encoded on 3 bits (since \\((2^3 = 8)\\) is sufficient to represent the 7 possible variations).\nEntropy (Shannon, 1948) is the mathematical formalization of this definition.\n\n\nFormal Definition\nLet \\(X\\) be a random variable with a finite set of possible values \\({x_1, x_2, \\dots, x_n}\\), such that \\(P(X=x_i) = p_i\\), with \\(0 \\le p_i \\le 1\\) and \\(\\sum p_i = 1\\). The entropy of \\(X\\), denoted \\(H(X)\\), is defined by\n\\(H(X) = - \\sum_{i=1}^{n} p_i \\log p_i = \\sum_{i=1}^{n} p_i \\log \\left(\\frac{1}{p_i}\\right)\\)\nBy convention: \\(p_i \\log p_i = 0\\) if \\(p_i = 0\\). All logarithms are in base 2.\n\n\nInterpretation\n\nApproximation of the number of bits needed to encode the elements of \\(X\\).\nRedundancy is the difference between the effective encoding and entropy.\n\n\n\nProperties\n\n\\(0 \\le H(X) \\le \\log n\\)\n\\(H(X) = 0 \\iff \\exists i : p_i = 1, p_j = 0 \\ \\forall j \\ne i\\)\n\\(H(X) = \\log n \\iff p_i = 1/n \\ \\forall i\\)\n\n\n\nConditional Entropy\n\n\\(H(X \\mid Y = y) = - \\sum_{x} P(X=x \\mid Y=y) \\log P(X=x \\mid Y=y)\\),\n\\(H(X \\mid Y) = \\sum_y P(Y=y) H(X \\mid Y=y)\\)\n\nMeasures the uncertainty about \\(X\\) (plaintext) after having observed \\(Y\\) (ciphertext)."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-encryption-systems",
    "href": "exam_notes_en.html#attacks-on-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "Attacks on Encryption Systems",
    "text": "Attacks on Encryption Systems\n\nCiphertext-only: Adversary has only the ciphertext.\nKnown-plaintext: Adversary has plaintext/ciphertext pairs.\nChosen-plaintext: Adversary chooses the plaintext and see the ciphertext (and tries to find the plaintext for other messages).\nAdaptive chosen-plaintext: depends on the received ciphertexts.\nChosen-ciphertext: Adversary chooses the ciphertext and obtains the plaintext (aims to find the key).\nAdaptive Chosen-ciphertext: Chosen-ciphertext depends on the received plaintexts."
  },
  {
    "objectID": "exam_notes_en.html#oracles-and-security-models",
    "href": "exam_notes_en.html#oracles-and-security-models",
    "title": "Fundamental Security Services",
    "section": "Oracles and Security Models",
    "text": "Oracles and Security Models\n\nRandom Oracles and Security Models\n\nRandom Oracle: A theoretical “perfect” function that returns a uniform and random value for each new input, but remains deterministic for an input already seen.\nROM (Random Oracle Model): Mathematical proof framework using this ideal oracle as a substitute for hash functions.\nStandard Model: Framework where security relies solely on the adversary’s computing power against real algorithms.\nLimit: A security proof in ROM does not guarantee absolute security in the real world (with SHA-256, etc.).\n\n\n\n\n\n\n\nNoneOriginal version\n\n\n\n\n\nA random oracle is an abstract entity accessible to legitimate parties and adversaries.\n\nBehavior: It responds to input queries \\(x\\) with perfectly random responses \\(Orc(x)\\).\nDeterminism: The only exception lies in previously processed inputs (\\(x_1, x_2, \\dots, x_n\\)). If \\(x_1' = x_1\\), then \\(Orc(x_1') = Orc(x_1)\\).\nModeling: It is modeled by a function \\(Orc : X \\to Y\\) where \\(\\forall x \\in X, \\Pr(Orc(x) = y) = \\frac{1}{|Y|}\\).\nUtility: It behaves like an “ideal” cryptographic hash function, a valuable tool for proving security in the Random Oracle Model.\nComparison: The standard model limits adversaries by computational factors. A protocol secure in the random oracle model can become vulnerable if used with a “real” hash function (SHA-1, SHA-256).\n\n\n\n\n\n\n\nEncryption, Decryption and Signature Oracles\n\nFunction: Entities that perform operations (encrypt/sign) for the adversary using secret keys without ever revealing them.\nSymmetric cryptography: The oracle provides \\(E_k(x)\\) or \\(D_k(y)\\).\nAsymmetric cryptography: The oracle is crucial for private operations (decryption/signature), as public operations are already freely accessible.\n\n\n\n\n\n\n\nNoneOriginal version: Operational Oracles\n\n\n\n\n\nAn encryption/decryption/signature oracle is an abstract entity offering an “on-demand” service.\n\nKey access: It uses the same keys as the legitimate owners (symmetric and asymmetric systems) without disclosing them.\nSymmetric primitives: For a primitive \\(E\\) and a key \\(k\\), it returns \\(y = E_k(x)\\) or the corresponding plaintext \\(x\\).\nPublic key systems: The oracle is only needed for operations with the private key (\\(priv_k\\)).\n\nDecryption: returns \\(x\\) such that \\(E'_{pubk}(x) = y\\).\nSignature: For a system \\(S\\), it returns \\(y = S_{privk}(x)\\).\n\nAttacks: The attack models using chosen plaintext (CPA) and chosen ciphertext (CCA) rely on making these oracles available to the adversary.\n\n\n\n\n\n\n\nIndistinguishability and Semantic Security (IND-CPA)\n\nProperty: An adversary must not be able to distinguish the ciphertexts of two different plaintext messages.\nIND-CPA (Indistinguishability under Chosen Plaintext Attack): If the adversary guesses the correct message only with a probability of \\(1/2 + \\epsilon\\), the system is considered secure.\nSemantic Security: Equivalent to IND-CPA, it ensures that no useful information leaks from the ciphertext.\n\n\n\n\n\n\n\nNoneOriginal version: Semantic Security\n\n\n\n\n\nCiphertext indistinguishability guarantees the inability to distinguish the ciphertexts of given plaintexts.\n\nExperiment (IND-CPA Security Game):\n\nThe adversary chooses two messages \\(M_0\\) and \\(M_1\\).\nThe oracle chooses a random index \\(i \\in \\{0,1\\}\\) and returns \\(c_i = E_k(M_i)\\).\nThe adversary can perform other calculations or oracle calls.\n\nIND-CPA Definition: The system is secure if the adversary’s advantage is negligible (\\(Prob = 1/2 + \\epsilon\\) with \\(\\epsilon\\) small).\nNote: In public key, the encryption oracle is useless because the adversary already possesses the public key. IND-CPA provides semantic security.\n\n\n\n\n\n\n\nProbabilistic Encryption and OAEP\n\nProblem: Deterministic encryption allows dictionary attacks (comparison of known ciphertexts).\nSolution: Add randomness to the message before encryption so that \\(E(M)\\) is different each time.\nOAEP (Optimal Asymmetric Encryption Padding): Standard used with RSA. It combines the message \\(P\\) with a random number \\(R\\) via hash functions \\(h\\) and XOR operations (\\(\\oplus\\)).\n\n\n\n\n\n\n\nNoneOriginal version: Determinism vs. Probabilism\n\n\n\n\n\nDeterministic behavior (same inputs = same outputs) creates vulnerabilities.\n\nExample: If Alice sends “Yes” or “No”, the adversary can compute \\(C_{yes} = E_{pub}(``Yes\")\\) and compare. They can create a codebook (dictionary) to identify messages without breaking the key.\nProbabilistic encryption: Adds randomness. The goal is semantic security for the public key.\nOAEP: Used in RSA-PKCS1. The text \\(P\\) is combined with randomness \\(R\\):\n\n\\(M_1 := P \\oplus h(R)\\)\n\\(M_2 := R \\oplus h(M_1)\\)\nEncryption applies to \\(M_1\\) and \\(M_2\\). During decryption, we recover \\(R = M_2 \\oplus h(M_1)\\), then \\(P = h(R) \\oplus M_1\\).\n\n\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nRandom Oracle: “Ideal” hash function (theoretical model).\nCPA/CCA Oracles: Simulate access to the secret key to test resistance.\nIND-CPA: Inability to distinguish two ciphertexts (Semantic Security).\nProbabilistic Encryption: Essential to counter codebooks (dictionary attacks).\nOAEP: Padding method adding the necessary randomness to RSA."
  },
  {
    "objectID": "exam_notes_en.html#history-of-cryptography-and-unconditional-security",
    "href": "exam_notes_en.html#history-of-cryptography-and-unconditional-security",
    "title": "Fundamental Security Services",
    "section": "History of Cryptography and Unconditional Security",
    "text": "History of Cryptography and Unconditional Security\n\nHistorical Encryption Systems\nCryptography was for a long time limited to the sole pursuit of confidentiality. Historical systems are based on two fundamental principles: substitution and transposition.\n\nCaesar Cipher (mono-alphabetic substitution): Fixed letter shift. Very vulnerable to frequency analysis.\nVigenère Cipher (polyalphabetic substitution): Uses a key to vary the shift. More complex, but breakable by identifying the key length.\nTransposition Cipher: Reorganization of the original text characters according to a permutation defined by a key.\n\n\n\n\n\n\n\nNoneOriginal version: Historical Cryptography\n\n\n\n\n\nFor centuries confidentiality was the only application of cryptography…\n\n1st century BC, Caesar Cipher: Mono-alphabetic substitution encryption \\(e_k(x) = (x + k) \\pmod{26}\\), \\(d_k(y) = (y - k) \\pmod{26}\\) where \\(x, y, k \\in \\mathbb{Z}_{26}\\).\n\nExample: \\(E_1(\\text{'hello'}) = \\text{'ifmmp'}\\).\nCryptanalysis: easy, based on character frequency.\n\n16th century, Vigenère: Polyalphabetic substitution encryption \\(e_k(x_1, \\dots, x_n) = (x_1 + k_1, \\dots, x_m + k_m, x_{m+1} + k_1, \\dots) \\pmod{26}\\).\n\nCryptanalysis: find the key length \\(m\\) by identifying repeated ciphertext portions and analyzing separate blocks as in the Caesar Cipher.\n\nTransposition Ciphers (Porta, 1563): The key defines a permutation on the plaintext.\nThese techniques are still the basis of modern encryption systems (ex: Enigma, qualified by W. Churchill as the secret weapon that won the war).\n\n\n\n\n\n\nThe One-Time Pad (OTP)\nThe One-Time Pad (OTP), or Vernam cipher, is the only system proven to be unconditionally secure (perfect secrecy).\n\nPrinciple: The message is combined with a key of the same length via the XOR operation (\\(\\oplus\\)).\nUnconditional Security: Observation of the encrypted message provides no information about the plaintext message. Even an adversary with infinite computing power cannot break it.\nShannon’s Constraints: The key must be as long as the message, purely random, and used only once.\nKey Reuse: If a key is reused for two messages, an attacker can eliminate the key by XOR (\\(y_a \\oplus y_b = x_a \\oplus x_b\\)) and recover the plaintext messages.\n\n\n\n\n\n\n\nNoneOriginal version: The One-Time Pad\n\n\n\n\n\nLet \\(n \\ge 1\\) and the spaces \\(P, C, K\\) such that \\(P, C, K = (\\mathbb{Z}_2)^n\\). The encryption and decryption operations of a one-time pad (Vernam Cipher) are: \\(E_k(x_i) = x_i \\oplus k_i\\) and \\(D_k(y_i) = y_i \\oplus k_i\\) for \\(1 \\le i \\le n\\).\n\nUnconditional security: If \\(k_i\\) are random and independent, observation of ciphertexts does not help cryptanalysis. The entropy of \\(X\\) does not decrease: \\(H(X|C) = H(X)\\).\nShannon’s Theorem: Necessary condition: \\(H(K) \\ge H(X)\\). The length of the random key must be at least as large as that of the plaintext.\nKey reuse: \\(y_a \\oplus y_b = x_a \\oplus x_b\\). With low-entropy messages, the plaintexts and the key (\\(k = y_a \\oplus x_a\\)) can be recovered.\nVulnerable to the Known Plaintext attack (if the key is reused).\nMajor problem: The distribution and management of large keys. Revived by quantum cryptography proposing confidential channels for unlimited-length key distribution.\n\n\n\n\n\n\nSteganography\nIn contrast to cryptography, which makes the message unreadable, steganography conceals the very existence of the message.\n\nMethod: Use a “subliminal channel” (an innocent medium like an image or a banal text).\nModern technique: Insertion of data into the least significant bits (LSB) of multimedia files, allowing the hiding of large volumes of data without visible alteration.\n\n\n\n\n\n\n\nNoneOriginal version: Steganography\n\n\n\n\n\nSteganography hides a message inside another. Constituent elements:\n\nA different physical or logical channel (subliminal channel).\nA secret mechanism to identify this channel.\n\n\nClassic examples: First letters of words in a text, invisible ink.\nModern example: Use the least significant bits of the frames of a Photo CD.\nFor a 2048x3072 image (RGB 24 bits), hiding a message using 1 bit allows storing 2.3 Mb without deteriorating quality.\n\n\n\n\n\n\n\n\n\n\nNoneUltra-summary\n\n\n\n\n\n\nHistory: Substitution (Caesar/Vigenère) and Transposition (permutation).\nOne-Time Pad: Absolute security if the key is random, unique, and as long as the message (\\(H(K) \\ge H(X)\\)).\nSteganography: Hiding the existence of the message (ex: LSB technique in images)."
  },
  {
    "objectID": "exam_notes_en.html#stream-ciphers-stream-encryption",
    "href": "exam_notes_en.html#stream-ciphers-stream-encryption",
    "title": "Fundamental Security Services",
    "section": "Stream Ciphers (Stream Encryption)",
    "text": "Stream Ciphers (Stream Encryption)\n\nIntroduction to Stream Ciphers\n\nDefinition and Principle\nStream ciphers are a family of encryption systems characterized by:\n\nUnit block size: each encrypted block = 1 bit\nTwo-phase architecture:\n\nKeystream generation: production of the key sequence\nSubstitution: operation on plaintext bits based on the keystream\n\n\nClassic example: the one-time pad\n\nGeneration: (pseudo-)random generator\nSubstitution: XOR operation (\\(\\oplus\\)) with the keystream\n\n\n\nGeneral Characteristics\nAdvantages:\n\nSpeed: encryption at register level, ideal for real-time streaming (video)\nLightweight: work on systems with limited CPU resources\nLow memory: little or no buffering needed\nNon-propagated errors: retransmission of defective packets is sufficient (suitable for wireless transmissions - WiFi)\n\nDisadvantages:\n\nDependency on keystream quality: randomness determines robustness\nDangerous reuse: keystream reuse allows easy cryptanalysis\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nStream Ciphers\n\nStream ciphers constitute a family of encryption systems where the size of the encrypted block is equal to 1 bit.\nStream ciphers are generally composed of two phases:\n\nA generation phase of the sequence of elements forming the key (the keystream).\nA substitution phase where the plaintext bits undergo a specific operation dependent on the keystream.\n\nAn obvious example of a stream cipher is the one-time pad with:\n\nA keystream generation phase performed by a (pseudo-)random generator.\nA substitution phase consisting of performing a xor (\\(\\oplus\\)) with the keystream.\n\n\n\n\nStream Ciphers: Characteristics\n\nSpeed: Encryption is done directly at the register level. Ideal for applications requiring “on the fly” encryption like video streaming.\nEase: Operations can be performed by systems with limited CPU resources.\nNo (or little…) need for memory/buffering.\nLimited or absent error propagation: retransmission of faulty packets is normally sufficient (suitable for applications where packet loss is frequent like wireless transmissions (WiFi)).\nDisadvantages:\n\nThe quality in terms of randomness of the generated keystream determines the system’s robustness.\nKeystream reuse allows easy cryptanalysis (cf. the one-time pad).\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nStream Ciphers = encryption bit by bit in 2 phases (keystream generation + substitution).\nAdvantages: fast, lightweight, no error propagation.\nDisadvantages: keystream quality critical, reuse = vulnerability.\n\n\n\n\n\n\n\nSynchronous Stream Ciphers\n\nOperating Principle\nIn a synchronous stream cipher, the keystream depends only on the key, independent of the plaintext and ciphertext.\nProcess equations:\n\\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nWhere:\n\n\\(\\sigma_i\\): state at time \\(i\\) (initial state \\(\\sigma_0\\) may depend on \\(k\\))\n\\(k\\): secret key\n\\(f\\): state transition function\n\\(g\\): keystream production function producing \\(z_i\\)\n\\(h\\): output function producing ciphertext \\(c_i\\) from plaintext \\(m_i\\)\n\n\n\n\n\n\ngraph LR\n    A[Key k] --&gt; B[State σi]\n    B --&gt; C[Function f]\n    C --&gt; D[State σi+1]\n    B --&gt; E[Function g]\n    E --&gt; F[Keystream zi]\n    F --&gt; G[Function h]\n    H[Plaintext mi] --&gt; G\n    G --&gt; I[Ciphertext ci]\n    D -.-&gt;|loop| B\n\n\n\n\n\n\n\n\nCharacteristics\nSynchronization requirement:\n\nTransmitter and receiver must share the same key \\(k\\) AND the same state \\(\\sigma_i\\)\nLoss of synchronization = need for external mechanisms (markers, redundancy analysis)\n\nProperties:\n\nNo error propagation: modification of ciphertext does not affect subsequent sequences\nAttention: deletion of a ciphertext = receiver desynchronization\n\nVulnerabilities to active attacks:\n\n✓ Detection: insertion, elimination, replay of fragments\n✗ Bit modification: adversary can modify bits and analyze impact on plaintext\nSolution: additional authentication mechanisms necessary\n\n\n\nSpecial case: Additive Stream Cipher\nThe most frequent case where:\n\nFunctions \\(f\\) and \\(g\\) replaced by a random generator\nFunction \\(h\\) = modulo 2 addition (XOR: \\(\\oplus\\))\n\nFormula: \\(c_i = z_i \\oplus m_i\\)\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nSynchronous Stream Ciphers\n\nThe generated keystream depends only on the key and not on the plaintext nor the ciphertext.\nThe encryption process of a synchronous stream cipher is described by the following equations: \\[\\sigma_{i+1} = f(\\sigma_i, k)\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] with \\(\\sigma_i\\) the initial state which may depend on the key \\(k\\), \\(f\\) the function determining the next state, \\(g\\) the function producing the keystream \\(z_i\\) and \\(h\\) the output function producing the ciphertext \\(c_i\\) from the plaintext \\(m_i\\).\n\n\n\nSynchronous Stream Ciphers: Characteristics\n\nRequire synchronization of the transmitter and receiver: In addition to using the same key \\(k\\), both must be in the same state for the process to work. If synchronization is lost, external mechanisms are needed to recover it (special markers, plaintext redundancy analysis, etc.)\nNo error propagation. Modification of the ciphertext during transmission does not cause disturbances in subsequent ciphertext sequences (however, the deletion of a ciphertext would cause desynchronization of the receiver).\nActive attacks: Insertion, elimination or replay of parts of ciphertext are detected by the receiver. However, an adversary could modify certain bits of the ciphertext and analyze the impact on the corresponding plaintext. Additional origin authentication mechanisms are necessary to detect these attacks.\nMost frequent case of Synchronous Stream Ciphers: the additive stream cipher (cf. the one-time pad) where the functions \\(f\\) and \\(g\\) generating the keystream are replaced by a random generator and the function \\(h\\) is a modulo 2 addition (xor).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nSynchronous: keystream = \\(f\\)(key only). Equations: \\(\\sigma_{i+1} = f(\\sigma_i, k)\\), \\(z_i = g(\\sigma_i, k)\\), \\(c_i = h(z_i, m_i)\\).\nRequires synchronization transmitter/receiver. No error propagation but vulnerable to bit modifications.\nFrequent case: additive cipher with XOR.\n\n\n\n\n\n\n\nAsynchronous Stream Ciphers\n\nOperating Principle\nAlso called self-synchronizing ciphers.\nThe keystream depends on the key AND a fixed number of previous ciphertexts.\nProcess equations:\n\\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\]\nWhere \\(\\sigma_i\\) represents a buffer of the last \\(t\\) ciphertexts.\n\n\n\n\n\ngraph LR\n    A[Key k] --&gt; B[Function g]\n    C[Buffer: ci-t...ci-1] --&gt; B\n    B --&gt; D[Keystream zi]\n    D --&gt; E[Function h]\n    F[Plaintext mi] --&gt; E\n    E --&gt; G[Ciphertext ci]\n    G -.-&gt;|feedback| C\n\n\n\n\n\n\n\n\nCharacteristics\nSelf-synchronization:\n\nIn case of insertion/elimination of ciphertexts, the receiver automatically re-synchronizes\nMechanism: memorization (buffer) of the last ciphertexts\n\nLimited error propagation:\n\nError propagates only over the buffer size (\\(t\\) bits)\nAfter buffer exhaustion, correct decryption resumes\n\nSecurity against active attacks:\n\nBetter detection: modifications detected thanks to error propagation\nAttention: self-synchronization allows receiver to continue even after insertions/deletions\nSolution: verification of integrity and authenticity of entire stream necessary\n\nDiffusion of plaintext statistics:\n\nEach plaintext bit influences all subsequent ciphertexts\nResult: better dispersion of statistics vs. synchronous case\nApplication: use for low entropy or highly redundant plaintexts\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nAsynchronous Stream Ciphers\n\nAlso called self-synchronizing ciphers.\nThe generated keystream depends on the key as well as a fixed number of previous ciphertexts.\nThe encryption process of an asynchronous stream cipher is described by the following equations: \\[\\sigma_i = (c_{i-t}, c_{i-t+1}, \\ldots, c_{i-1})\\] \\[z_i = g(\\sigma_i, k)\\] \\[c_i = h(z_i, m_i)\\] with \\(\\sigma_i\\), \\(g\\) and \\(h\\) as for the synchronous case.\n\n\n\nAsynchronous Stream Ciphers: Characteristics\n\nSelf-synchronization: In case of elimination or insertion of ciphertexts along the way, the receiver is capable of re-synchronizing with the transmitter thanks to the memorization (buffer) of a number of previous ciphertexts.\nLimited error propagation: Error propagation extends only to the number of ciphertext bits memorized (buffer size). Afterwards, decryption proceeds correctly again.\nActive attacks: Modification of ciphertext fragments will be more easily detected than in the synchronous case because of error propagation. However, since the receiver is capable of self-synchronizing with the transmitter, even if ciphertexts are eliminated or inserted along the way, it is necessary to verify the integrity and authenticity of the entire stream.\nDiffusion of plaintext statistics: The fact that each plaintext bit will influence all subsequent ciphertexts results in a greater dispersion of statistics compared to the synchronous case…\n… It is therefore advisable to use asynchronous stream ciphers when the entropy of plaintexts is limited and could allow targeted attacks on highly redundant plaintexts.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nAsynchronous (self-synchronizing): keystream = \\(f\\)(key + last ciphertexts). State \\(\\sigma_i\\) = buffer of \\(t\\) previous ciphertexts.\nAutomatic self-synchronization. Limited error propagation to buffer.\nBetter diffusion of statistics → ideal for redundant/low entropy plaintexts.\n\n\n\n\n\n\n\nKeystream Generators: LSFR\n\nContext and Necessity\nProblem: generate a keystream of length \\(m\\) from a secret key of length \\(l\\) with \\(l \\ll m\\).\nSolution: Linear Feedback Shift Register (LSFR or LFSR)\n\n\nLSFR Characteristics\nAdvantages:\n\nOptimal hardware implementation: very efficient circuits\nLong periods: sequences of great length\nGood random quality: notable randomness\nMathematical basis: algebraic properties of linear combinations\n\nGeneric structure: LSFR of length \\(L\\)\n\n\n\n\n\ngraph LR\n    A[bit L-1] --&gt; B[bit L-2]\n    B --&gt; C[...]\n    C --&gt; D[bit 1]\n    D --&gt; E[bit 0]\n    E --&gt; F[Output]\n    A -.-&gt;|feedback| G[⊕]\n    D -.-&gt;|coeff| G\n    C -.-&gt;|coeff| G\n    G --&gt; A\n\n\n\n\n\n\n\n\nImportant Remarks on LSFR\nHistory and Usage:\n\nVery widespread construction in cryptography and coding theory\nMany military stream ciphers based on LSFR\n\nSecurity Limits:\n\nInsufficient security level compared to modern block ciphers\nVulnerability: the Berlekamp-Massey algorithm allows to:\n\nDetermine the linear complexity of an LSFR\nCalculate an arbitrary number of generated sequences\n\n\nMetric: Linear complexity (linear complexity)\nImprovement Solution:\nReplace the linear combination with a non-linear function \\(f\\)\n→ Non Linear Feedback Shift Registers (NLFSR)\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nStream Ciphers: Keystream Generators\n\nWhen it is necessary to generate a keystream of length \\(m\\) from a secret key of length \\(l\\) with \\(l \\ll m\\), we call upon keystream generators.\nThe most common of these generators is the Linear Feedback Shift Register (LSFR).\nAn LSFR has the following characteristics:\n\nAdapts very well to hardware implementations.\nProduces sequences of long periods and with notable random quality (quite strong randomness)\nBased on the algebraic properties of linear combinations.\n\n\n\n\nLSFRs: Some Remarks\n\nLSFRs are very widespread constructions in cryptography and coding theory.\nA large number of stream ciphers based on LSFRs (especially in the military sphere) were developed in the past.\nUnfortunately, the security level offered by these systems is deemed insufficient nowadays (compared to that of block ciphers…)\nThe metric allowing analysis of an LFSR is its linear complexity. The Berlekamp-Massey algorithm allows determining the linear complexity of an LSFR and thus calculating an arbitrarily large number of sequences generated by an LSFR.\nA solution to increase complexity is to substitute the linear combination of ciphertext bits with a non-linear function \\(f\\). These are the Non Linear Feedback Shift Registers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nLSFR: long keystream generator (\\(m\\)) from short key (\\(l\\)). Base = linear combinations.\nAdvantages: efficient hardware, long periods.\nProblem: insufficient security, vulnerable to Berlekamp-Massey (linear complexity calculation).\nSolution: NLFSR (non-linear function).\n\n\n\n\n\n\n\nRC4: Software Stream Cipher\n\nGeneral Presentation\nRC4™ (Rivest Cipher 4) developed in 1987 by Ron Rivest for RSA Security.\nMain characteristics:\n\nVariable key: flexible length\nExtremely fast: 10× faster than DES\nSynchronous mode: keystream independent of plaintext/ciphertext\n\nHistory:\n\n1987-1994: patented, details confidential (NDA contract required)\n1994: unofficial publication in a newsgroup\nSince then: intensive analysis by cryptographic community\n\n\n\nArchitecture\nKey components:\n\nS-box: 8×8 substitution box (256 entries)\n\nContent: permutation of numbers 0 to 255\nDepends on the main key of variable length: \\(0 &lt; len(k) \\leq 255\\)\n\nCombinations: linear and non-linear\nFinal encryption: XOR between keystream and plaintext\n\n\n\nApplications and Security\nCommercial uses (numerous):\n\nLotus Notes\nOracle SQL\nMicrosoft Windows\nSSL/TLS\nAnd many more…\n\nAnalyses and Vulnerabilities:\n\nExhaustive work on key scheduling and PRGA\nMajor flaw: implementation in WEP (WiFi Wired Equivalent Privacy)\n\nWEP protocol completely compromised\nProblem: faulty usage mode, not the RC4 algorithm itself\n\n\n\n\nOperation\nRC4 decomposes into two steps:\n\nKey Scheduling Algorithm (KSA)\n\nResponsible for initial permutation of the S-box\nFunction of the variable length key \\(len(k) = l\\)\n\nPseudo Random Generator Algorithm (PRGA)\n\nGenerates keystream of arbitrary size\nRelies on S-box permuted by KSA\n\n\n\n\n\n\n\ngraph TB\n    A[Variable length key k] --&gt; B[KSA: Key Scheduling]\n    B --&gt; C[Permuted S-box]\n    C --&gt; D[PRGA: Generation]\n    D --&gt; E[Keystream zi]\n    E --&gt; F[XOR]\n    G[Plaintext mi] --&gt; F\n    F --&gt; H[Ciphertext ci]\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\n\nSoftware Cipher Streams: RC4\n\nThe major disadvantage of stream ciphers based on registers is that they are very slow in programmed version on a generic machine. RC4™ is a variable key stream cipher developed in 1987 by Ron Rivest for RSA security. It is very fast (10 times faster than DES !)\nFor 7 years, this algorithm was patented and its internal operational details were disclosed only after signing a confidentiality contract. Since its (unofficial) publication in a newsgroup in 1994, it has been widely discussed and analyzed by the entire cryptographic community.\nThe algorithm works in synchronous mode (the keystream is independent of the ciphertext and plaintext).\nIt is composed of linear and non-linear combinations. The key element is an 8×8 substitution box (S-box) whose entries are a permutation of the numbers 0 to 255. The permutation is a function of the main key of variable size with \\(0 &lt; len(k) \\leq 255\\). The final encryption is obtained by a xor between the keystream and the plaintext.\nRC4 is used in a large number of commercial applications: Lotus Notes, Oracle SQL, MS Windows, SSL, etc. It is the subject of a large number of analytical and exhaustive works that have managed to compromise the security of the key scheduling and the PRGA.\nIn particular the application of RC4 to the Wired Equivalent Privacy (WiFi WEP) protocol has been “broken” due to a flaw in the protocol’s usage mode.\n\n\n\nRC4: Operation\n\nThe algorithm consists of two steps:\n\nThe Key Scheduling Algorithm (KSA): Responsible for the initial permutation that will fill the S-box depending on the variable length key \\(len(k) = l\\).\nThe Pseudo Random Generator Algorithm (PRGA): Generates the keystream of arbitrary size relying on the S-box.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nRC4: software stream cipher, variable key, 10× faster than DES.\nArchitecture: 8×8 S-box (permutation 0-255) + XOR.\n2 steps: KSA (S-box permutation) + PRGA (keystream generation). Synchronous mode.\nVulnerability: WEP broken (usage flaw). Used in SSL, Windows, Oracle…"
  },
  {
    "objectID": "exam_notes_en.html#block-ciphers-block-encryption",
    "href": "exam_notes_en.html#block-ciphers-block-encryption",
    "title": "Fundamental Security Services",
    "section": "Block Ciphers (Block Encryption)",
    "text": "Block Ciphers (Block Encryption)\n\n1. Introduction to Block Ciphers\n\nDefinition and Principle\nA block cipher is a cryptographic function that:\n\nTransforms fixed-size blocks: maps a block of \\(n\\) bits to another block of the same size\nIs parameterized by a key: the key \\(K\\) of \\(k\\) bits defines the transformation\nMust be bijective: to allow unique decryption\nEach key = different bijection: guarantees variability\n\nNominal size: input block size on which encryption is applied\n\n\nQuality Criteria\n1. Key size/Entropy\n\nKeys ideally equiprobable with entropy = \\(k\\) bits\nStrong entropy protects against brute-force attacks\nMinimum required: 128 bits for modern block ciphers\n\n2. Performance\n\nExecution speed\nSoftware/hardware efficiency\n\n3. Block size\n\nToo small block = vulnerability to plaintext/ciphertext dictionaries\nModern standard: blocks ≥ 128 bits\n\n4. Cryptographic resistance\n\nResistance to known techniques:\n\nLinear cryptanalysis\nDifferential cryptanalysis\nMeet in the middle\n\nCryptanalysis effort equivalent to brute force\n\n\n\n\n\n\ngraph LR\n    A[Plaintext n bits] --&gt; B[Block Cipher]\n    C[Key K k bits] --&gt; B\n    B --&gt; D[Ciphertext n bits]\n    \n    style B fill:#e1f5ff\n    style C fill:#fff4e1\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\nBlock Ciphers\n\nSymmetric block ciphers constitute the cornerstone of cryptography. Their main functionality is confidentiality but they are also the basis for authentication, hashing functions, random generation, etc.\nDefinition: A block cipher is a function that maps a block of \\(n\\) bits to another block of the same size. The function is parameterized by a key \\(K\\) of \\(k\\) bits. To allow unique decryption, the function must be bijective. Each key defines a different bijection. The input block size on which encryption is applied is also called nominal algorithm size.\nCriteria to evaluate the quality of a block cipher:\n\nKey size/Entropy: Ideally, keys are equiprobable and the key space has an entropy equal to \\(k\\). A strong key entropy protects against brute-force attacks from chosen/known plaintexts. Modern block ciphers must have keys of at least 128 bits.\nPerformance\nBlock size: A too small block would allow attacks where plaintext/ciphertext “dictionaries” could be built. Nowadays, blocks of size ≥ 128 bits are becoming common.\nCryptographic resistance: The block cipher must show resistance to known cryptanalysis techniques: linear or differential cryptanalysis, meet in the middle, etc. The inherent effort of these attacks (complexity, storage, parallelization, etc.) must be equivalent to that of a brute force attack.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nBlock cipher: bijective function transforming blocks of \\(n\\) bits with key \\(K\\) of \\(k\\) bits. Criteria: key entropy ≥ 128 bits, block size ≥ 128 bits, cryptanalysis resistance = brute force effort. Usage: confidentiality, authentication, hashing, random generation.\n\n\n\n\n\n\n\n2. Block Cipher Modes of Operation\n\n2.1 Electronic Codebook (ECB)\nPrinciple: each plaintext block is encrypted independently with the same key.\n\\[c_i = E_K(m_i)\\] \\[m_i = D_K(c_i)\\]\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        P1[Plaintext Block 1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext Block 1]\n        \n        P2[Plaintext Block 2] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext Block 2]\n    end\n    \n    style E1 fill:#ffcccc\n    style E2 fill:#ffcccc\n    style K1 fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\nCharacteristics:\n\n✗ Identical plaintexts → identical ciphertexts (predictable)\n✓ No error propagation: error on \\(c_j\\) affects only \\(m_j\\)\n✗ Visible patterns: plaintext structure transparent in ciphertext\n✓ Parallelizable: each block processed independently\n\n⚠️ Major vulnerability: Should NOT be used for redundant data\n\n\n\n2.2 Cipher Block Chaining (CBC)\nPrinciple: each plaintext block is XORed with the previous ciphertext before encryption.\n\\[c_i = E_K(m_i \\oplus c_{i-1})\\] \\[m_i = D_K(c_i) \\oplus c_{i-1}\\]\nWith \\(c_0 = IV\\) (Initialization Vector)\n\n\n\n\n\ngraph TB\n    subgraph Encryption\n        IV[IV] --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; C1[Ciphertext c1]\n        \n        C1 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ccffcc\n    style E2 fill:#ccffcc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ Patterns erased: chaining masks the structure\n✓ Limited error propagation: error on \\(c_j\\) affects \\(m_j\\) and \\(m_{j+1}\\) only\n✗ Not parallelizable in encryption (sequential)\n✓ Parallelizable in decryption\n\nIV (Initialization Vector):\n\nMust be random or pseudo-random\nCan be transmitted in clear\nMust be different for each message with the same key\n\n\n\n\n2.3 Cipher Feedback Mode (CFB)\nPrinciple: works like a stream cipher where the keystream is generated by the block cipher. The keystream depends on previous ciphertexts (asynchronous mode).\n\\[c_i = m_i \\oplus E_K(c_{i-1})\\] \\[m_i = c_i \\oplus E_K(c_{i-1})\\]\nWith \\(c_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph CFB_Encryption\n        IV[IV / ci-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        C1 -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#ffccff\n    style X1 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ Chaining: dependencies between ciphertexts\n⚠️ Error propagation: error on \\(c_j\\) affects \\(\\frac{n}{r}\\) following blocks\n\n\\(n\\) = nominal size of block cipher\n\\(r\\) = size of plaintexts\n\n✗ Not parallelizable\n⚠️ IV non-confidential but must be transmitted\n\nUsage: suitable for transmissions with frequent packet loss\n\n\n\n2.4 Output Feedback Mode (OFB)\nPrinciple: works like a synchronous stream cipher. The keystream is entirely determined by the key and IV, independent of plaintext and ciphertext.\n\\[z_i = E_K(z_{i-1})\\] \\[c_i = m_i \\oplus z_i\\] \\[m_i = c_i \\oplus z_i\\]\nWith \\(z_0 = IV\\)\n\n\n\n\n\ngraph TB\n    subgraph OFB_Mode\n        IV[IV / zi-1] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; Z[zi keystream]\n        Z --&gt; X1[⊕]\n        P1[Plaintext mi] --&gt; X1\n        X1 --&gt; C1[Ciphertext ci]\n        Z -.feedback.-&gt; IV\n    end\n    \n    style E1 fill:#cce5ff\n    style X1 fill:#ffffcc\n    style Z fill:#e1ffe1\n\n\n\n\n\n\nCharacteristics:\n\n✓ Identical plaintexts → different ciphertexts (if IV changes)\n✓ No error propagation: error on \\(c_j\\) affects only \\(m_j\\)\n✓ Pre-computable keystream: efficient\n⚠️ CRITICAL: NEVER reuse the same IV with the same key (otherwise identical keystream)\n✓ Parallelizable if keystream pre-computed\n\n⚠️ Reuse warning: Change IV for each new message!\n\n\n\n\n\n\nNote📄 Original text (CFB and OFB Modes)\n\n\n\n\n\nCFB and OFB Modes: Characteristics\nThe CFB and OFB modes work as a stream cipher with a keystream generated by the encryption block. In CFB, the keystream depends on previous ciphertexts (asynchronous) whereas in OFB, the keystream is entirely determined by the key and the IV (synchronous).\nParticularities of CFB:\n\nAs in CBC mode, identical plaintexts are translated into different ciphertexts if the IV changes. The IV is not necessarily confidential and can be exchanged in clear between parties.\nChaining also introduces dependencies between current ciphertexts and previous ciphertexts. In particular, if \\(n\\) is the nominal algorithm size and \\(r\\) is the plaintext size, the current ciphertext will depend on the \\(\\frac{n}{r}\\) previous ciphertexts (each iteration will shift the faulty input by \\(r\\) positions, after \\(\\frac{n}{r}\\) iterations the faulty ciphertext will be completely “expelled”).\nError propagation follows the same principle: an error in a ciphertext will result in incorrect decryption of the \\(\\frac{n}{r}\\) following ciphertexts.\n\nParticularities of OFB:\n\nOFB has identical behavior to CBC and CFB modes for encryption of identical plaintexts.\nNo error propagation on adjacent ciphertexts.\nModify the IV if the key does not change to avoid keystream reuse !!!\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (CFB/OFB)\n\n\n\n\n\nCFB (asynchronous): keystream = \\(f\\)(previous ciphertexts). Limited error propagation (\\(\\frac{n}{r}\\) blocks).\nOFB (synchronous): keystream = \\(f\\)(key + IV only). No error propagation.\nCRITICAL: NEVER reuse same IV with same key. IV transmissible in clear.\n\n\n\n\n\n\n2.5 Counter Mode (CTR)\nPrinciple: the keystream is generated by encryption of a counter incremented at each block.\n\\[c_i = m_i \\oplus E_K(counter + i)\\] \\[m_i = c_i \\oplus E_K(counter + i)\\]\n\n\n\n\n\ngraph TB\n    subgraph CTR_Mode\n        CTR1[Counter + 0] --&gt; E1[Block Cipher E]\n        K1[Key K] --&gt; E1\n        E1 --&gt; X1[⊕]\n        P1[Plaintext m1] --&gt; X1\n        X1 --&gt; C1[Ciphertext c1]\n        \n        CTR2[Counter + 1] --&gt; E2[Block Cipher E]\n        K2[Key K] --&gt; E2\n        E2 --&gt; X2[⊕]\n        P2[Plaintext m2] --&gt; X2\n        X2 --&gt; C2[Ciphertext c2]\n    end\n    \n    style E1 fill:#ffe6cc\n    style E2 fill:#ffe6cc\n    style X1 fill:#ffffcc\n    style X2 fill:#ffffcc\n\n\n\n\n\n\nCharacteristics:\n\n✓ Synchronous mode: keystream = \\(f\\)(counter)\n✓ Parallelizable: keystream pre-computable for encryption AND decryption\n✓ Random access: each block decryptable independently\n✓ No error propagation\n✓ Benefits from SIMD architectures: no dependencies between blocks\n⚠️ Counter: must be of size \\(2^b\\) (\\(b\\) = block size)\n⚠️ CRITICAL: NEVER reuse the same counter with the same key\n\nCounter management:\n\nIncrement modulo \\(2^b\\) after each iteration\nSolution: always increment for each encrypted stream\nFirst block of stream \\(i+1\\) &gt; last block of stream \\(i\\)\n\nApplications:\n\nATM (Asynchronous Transfer Mode)\nIPsec (IP security)\nHigh-speed lines: selective transmission of blocks\nLarge volume transfers: video\n\n\n\n\n\n\n\nNote📄 Original text (Counter Mode)\n\n\n\n\n\n\nCounter Mode (CTR Mode)\nFrequently used as encryption support in data transfer protocols like ATM (Asynchronous Transfer Mode) and IPsec (IP security).\n\n\nCounter Mode (II)\n\nThe keystream is generated by the encryption of a random counter of size \\(2^b\\) (with \\(b\\) the block size) and necessary for decryption. This counter is incremented modulo \\(2^b\\) after each iteration.\nWorks in synchronous mode. Reuse of the same counter results in an identical keystream !\nSolution: Always increment the counter for each encrypted stream such that the counter of the first block of a stream is larger than the last block of the previous stream.\nEasily parallelizable: The keystream can be pre-calculated both for encryption and decryption. Fully benefits from SIMD architectures because unlike other chaining modes there are no dependencies between operations of different blocks.\nRandom access to encryption/decryption of each block: Unlike other chaining modes where the \\(i\\)-th operation depends on the \\((i-1)\\)-th operation.\nIf we add absence of error propagation, the counter mode facilitates selective (re)transmission of ciphertext blocks, making it very attractive for securing high-speed lines as well as for encrypted transfers of large volumes of information (e.g. video).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (Counter Mode)\n\n\n\n\n\nCTR: keystream = \\(E_K\\)(counter + \\(i\\)).\nAdvantages: parallelizable (encryption + decryption), random access, no error propagation, SIMD-friendly.\nCRITICAL: never reuse counter.\nUsage: ATM, IPsec, high speed, video.\n\n\n\n\n\n\n\n3. Product Ciphers and Feistel Ciphers\n\nProduct Ciphers\nDefinition: encryption scheme combining a series of successive transformations to strengthen resistance to cryptanalysis.\nCommon transformations:\n\nTranspositions (permutations)\nSubstitutions (S-boxes)\nXORs\nLinear combinations\nModular multiplications\n\n\n\nFeistel Ciphers\nDefinition: iterative product cipher with specific structure.\nOperating principle:\n\nInput: plaintext of \\(2t\\) bits = \\((L_0, R_0)\\) (two sub-blocks of \\(t\\) bits)\nOutput: ciphertext of \\(2t\\) bits = \\((R_r, L_r)\\) after \\(r\\) steps (rounds)\nEach step: invertible bijection (for unique decryption)\n\nEquations of step \\(i\\) (\\(1 \\leq i \\leq r\\)):\n\\[(L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\]\nWith:\n\n\\(L_i = R_{i-1}\\)\n\\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph Feistel_Round\n        L0[Li-1] --&gt; R1[Ri = Li-1 ⊕ f]\n        R0[Ri-1] --&gt; L1[Li = Ri-1]\n        R0 --&gt; F[Function f]\n        K[Key Ki] --&gt; F\n        F --&gt; XOR[⊕]\n        L0 --&gt; XOR\n        XOR --&gt; R1\n    end\n    \n    style F fill:#ffcccc\n    style XOR fill:#ffffcc\n    style K fill:#fff4e1\n\n\n\n\n\n\nCharacteristics:\n\n\\(K_i\\): subkeys generated from the main key \\(K\\)\nNumber of steps \\(r\\): generally even and \\(\\geq 3\\)\n\nExample: DES has 16 steps\n\nFinal permutation: \\((L_r, R_r) \\rightarrow (R_r, L_r)\\)\nDecryption: identical to encryption but subkeys applied in reverse order (from \\(K_r\\) to \\(K_1\\))\n\nFrequent operations:\n\nPermutations\nSubstitutions (S-boxes)\n\n\n\n\n\n\n\nNote📄 Original text\n\n\n\n\n\nProduct Ciphers and Feistel Ciphers\n\nA product cipher is an encryption scheme combining a series of successive transformations to strengthen resistance to cryptanalysis. Common transformations for a product cipher are: transpositions, substitutions, XORs, linear combinations, modular multiplications, etc.\nA Feistel cipher is an iterative product cipher capable of transforming a plaintext of \\(2t\\) bits of the form \\((L_0, R_0)\\) composed of two sub-blocks \\(L_0\\) and \\(R_0\\) of \\(t\\) bits into a ciphertext of size \\(2t\\) of the form \\((R_r, L_r)\\) after \\(r\\) successive steps (rounds) with \\(r \\geq 1\\). Each step defines a bijection (inversible !) to allow unique decryption.\nPermutations and substitutions are the most frequent operations.\nThe steps \\(1 \\leq i \\leq r\\) are written: \\((L_{i-1}, R_{i-1}) \\xrightarrow{K_i} (L_i, R_i)\\) with \\(L_i = R_{i-1}\\) and \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\). The \\(K_i\\) are sub-keys, different for each step, generated from the main key \\(K\\) of the encryption scheme.\nThe number of steps proper to a Feistel cipher is normally even and \\(\\geq 3\\) (e.g. DES has 16 steps)\nAfter execution of all steps, a Feistel cipher performs a permutation of the two parts \\((L_r, R_r)\\) into \\((R_r, L_r)\\).\nThe decryption of a Feistel Cipher is identical to encryption except that the sub-keys \\(K_i\\) are applied in reverse order (From \\(K_r\\) to \\(K_1\\)).\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision\n\n\n\n\n\nProduct cipher: combination of successive transformations (transpositions, substitutions, XOR).\nFeistel cipher:\n\niterative product cipher\nplaintext \\(2t\\) bits = \\((L_0, R_0)\\)\n\\(r\\) rounds with \\(L_i = R_{i-1}\\) and \\(R_i = L_{i-1} \\oplus f(R_{i-1}, K_i)\\).\nDecryption = encryption with reversed sub-keys.\nExample: DES (16 rounds).\n\n\n\n\n\n\n\n\n4. Data Encryption Standard (DES)\n\nGeneral Presentation\nDES (Data Encryption Standard): most important cryptographic algorithm until the advent of AES in 2001.\nMain characteristics:\n\nType: Feistel Cipher\nBlock size: 64 bits (nominal size)\nKey size: 56 effective bits (64 total bits with 8 parity bits)\nNumber of steps: 16 rounds\nSubkeys: 16 subkeys of 48 bits (one per step)\nUsage modes: ECB, CBC, CFB, OFB\n\n\n\n\n\n\ngraph TB\n    subgraph DES_Overview\n        P[Plaintext 64 bits] --&gt; DES[DES Encryption]\n        K[Key 56 bits] --&gt; DES\n        DES --&gt; C[Ciphertext 64 bits]\n        \n        C --&gt; DES_INV[DES Decryption]\n        K2[Key 56 bits] --&gt; DES_INV\n        DES_INV --&gt; P2[Plaintext 64 bits]\n    end\n    \n    style DES fill:#ffcccc\n    style DES_INV fill:#ccffcc\n    style K fill:#fff4e1\n    style K2 fill:#fff4e1\n\n\n\n\n\n\n\n\nDES Structure\nMain components:\n\nInitial permutation (IP): permutation of the 64 input bits\n16 Feistel rounds: iterative transformation\nFinal permutation (IP⁻¹): inverse of IP\n\nEach round applies:\n\nDivision into two halves: \\(L_{i-1}\\) and \\(R_{i-1}\\) (32 bits each)\nFunction \\(f\\) on \\(R_{i-1}\\) with subkey \\(K_i\\)\nXOR with \\(L_{i-1}\\)\nExchange of halves\n\n\n\n\n\n\ngraph TB\n    Plain[Plaintext 64 bits] --&gt; IP[Initial Permutation IP]\n    IP --&gt; Split[Split L0, R0]\n    \n    Split --&gt; Round1[Round 1]\n    K1[K1] --&gt; Round1\n    Round1 --&gt; Round2[Round 2]\n    K2[K2] --&gt; Round2\n    Round2 --&gt; Dots[...]\n    Dots --&gt; Round16[Round 16]\n    K16[K16] --&gt; Round16\n    \n    Round16 --&gt; Swap[Swap R16, L16]\n    Swap --&gt; IP_inv[Final Permutation IP⁻¹]\n    IP_inv --&gt; Cipher[Ciphertext 64 bits]\n    \n    style IP fill:#e1f5ff\n    style IP_inv fill:#e1f5ff\n    style Round1 fill:#ffcccc\n    style Round2 fill:#ffcccc\n    style Round16 fill:#ffcccc\n\n\n\n\n\n\n\n\nDES Cipher Function\nThe function \\(f\\) for each round:\n\nExpansion E: 32 bits → 48 bits (table E)\nKey Addition: XOR with subkey \\(K_i\\) (48 bits)\nS-boxes: 8 S-boxes transform 48 bits → 32 bits\n\nEach S-box: 6 bits input → 4 bits output\n\nPermutation P: permutation of the resulting 32 bits\n\n\n\n\n\n\ngraph TB\n    R[Ri-1 32 bits] --&gt; E[Expansion E]\n    E --&gt; E_out[48 bits]\n    E_out --&gt; XOR1[⊕]\n    K[Ki 48 bits] --&gt; XOR1\n    XOR1 --&gt; S[8 S-boxes]\n    S --&gt; S_out[32 bits]\n    S_out --&gt; P[Permutation P]\n    P --&gt; F_out[f output 32 bits]\n    \n    style E fill:#cce5ff\n    style S fill:#ffcccc\n    style P fill:#e1ffe1\n    style XOR1 fill:#ffffcc\n\n\n\n\n\n\nS-box operation:\nInput: \\(a_1a_2a_3a_4a_5a_6\\) (6 bits)\n\nRow: \\(a_1 + 2a_6\\) (external bits)\nColumn: \\(a_2 + 2a_3 + 4a_4 + 8a_5\\) (internal bits)\nOutput: value of the corresponding cell (4 bits)\n\n\n\nSubkey Generation\nProcess:\n\nMain key: 64 bits (56 effective + 8 parity)\nPermuted Choice 1 (PC-1): selection of 56 bits\nDivision into two halves: \\(C_0\\) and \\(D_0\\) (28 bits each)\nFor each round \\(i\\):\n\nLeft circular rotation of \\(C_{i-1}\\) and \\(D_{i-1}\\)\nPermuted Choice 2 (PC-2): selection of 48 bits for \\(K_i\\)\n\n\nRotations:\n\nRounds 1, 2, 9, 16: 1 position\nOther rounds: 2 positions\n\n\n\n\n\n\n\nNote📄 Original text (DES Operation)\n\n\n\n\n\nDES: Operation\nCipher Function\n\nExpansion E: The 32 bits of the input are transformed into a vector of 48 bits using the table E. The first line of this table indicates how the first sub-block of 6 bits will be generated: first take the 32nd bit then bits 1,2,3,4,5. The second sub-block starts with the 4th bit then bits 5,6,7,8,9 and so on…\nKey addition: XOR of the 48-bit vector with the key.\nS-boxes: Apply 8 S-boxes on the resulting 48-bit vector. Each of these S-boxes takes a 6-bit sub-block and transforms it into a 4-bit sub-block. The operation is performed as follows: If we denote the 6 input bits of the S-box as: \\(a_1a_2a_3a_4a_5a_6\\). The output is given by the content of the cell located in the row \\(a_1 + 2a_6\\) and the column \\(a_2 + 2a_3 + 4a_4 + 8a_5\\).\nPermutation P: Permutation P works as follows: The first bit is sent to the 16th position, the second to the 7th position and so on.\n\nPermutations IP and IP⁻¹\n\nAct respectively at the beginning and at the end of the block processing and on the entirety of the 64 bits.\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (DES)\n\n\n\n\n\nDES: Feistel cipher, 64-bit blocks, 56-bit effective key, 16 rounds.\nFunction \\(f\\): Expansion E (32→48 bits) → XOR \\(K_i\\) → 8 S-boxes (48→32 bits) → Permutation P.\nS-box: 6 bits input → 4 bits output via table (row = external bits, column = internal bits).\nPermutations: IP (initial) and IP⁻¹ (final) on 64 bits.\n\n\n\n\n\n\n\n5. Triple-DES and DES Security\n\nDES Vulnerabilities\nMain problem: key space size \\(\\{0,1\\}^{56}\\) insufficient.\nBrute force attack:\n\n1999: key found in 24 hours\nTechnique: massively parallel brute force (100,000 PCs on Internet)\nKnown plaintext attack\n\n\n\nTriple-DES (3DES)\nSolution: increase key space to \\(\\{0,1\\}^{112}\\).\nScheme:\n\\[C = E_{K_1}(D_{K_2}(E_{K_1}(P)))\\]\nWith:\n\n\\(E\\): DES encryption\n\\(D\\): DES decryption\n\\(K_1, K_2\\): two 56-bit keys\n\n\n\n\n\n\ngraph LR\n    P[Plaintext 64 bits] --&gt; E1[DES Encrypt K1]\n    E1 --&gt; D[DES Decrypt K2]\n    D --&gt; E2[DES Encrypt K1]\n    E2 --&gt; C[Ciphertext 64 bits]\n    \n    K1a[Key K1 56 bits] --&gt; E1\n    K2[Key K2 56 bits] --&gt; D\n    K1b[Key K1 56 bits] --&gt; E2\n    \n    style E1 fill:#ffcccc\n    style D fill:#ccffcc\n    style E2 fill:#ffcccc\n\n\n\n\n\n\nAdvantages:\n\n✓ Satisfactory security: key space \\(2^{112}\\)\n✓ Compatibility: reuse of existing DES hardware/software\n✓ Gradual migration: while waiting for AES\n\nDisadvantage:\n\n✗ Performance: 3× slower (3 successive DES executions)\n\n\n\nDES Properties\n1. DES is not a group\nDES is NOT a group under composition:\n\\[\\nexists K_3 \\text{ such that } E_{K_3}(E_{K_2}(E_{K_1}(x))) = E_{K_3}(x)\\]\nConsequence: composite encryption (Triple-DES) considerably increases security.\nIf DES were a group: exhaustive search on \\(\\{0,1\\}^{56}\\) would break the algorithm regardless of the number of consecutive executions.\n2. Weak and semi-weak keys\n\nWeak key: \\(E_K(E_K(x)) = x\\)\nPair of semi-weak keys: \\(E_{K_1}(E_{K_2}(x)) = x\\)\n\nCharacteristic: weak keys generate identical subkeys in pairs:\n\n\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)\nFacilitates cryptanalysis\n\nDES has 4 weak keys:\n\n\n\nWeak key (hexadecimal)\n\n\n\n\n0101 0101 0101 0101\n\n\n0101 0101 FEFE FEFE\n\n\nFEFE FEFE FEFE FEFE\n\n\nFEFE FEFE 0101 0101\n\n\n\nAnd 6 pairs of semi-weak keys\n\n\n\n\n\n\nNote📄 Original text (DES and 3DES)\n\n\n\n\n\n\nDES and Triple-DES\n\nThe size of the key set (\\(\\{0,1\\}^{56}\\)) constitutes the greatest threat weighing on DES with current computing resources. In 1999 it took only 24 hours to find the key from a known plaintext using a massively parallel brute force technique (100,000 PCs connected to the Internet).\nTriple DES protects us from these brute force attacks by increasing the possible key space to \\(\\{0,1\\}^{112}\\).\nThis alternative allows continuing to use DES “boxes” (hardware and software) while waiting for migration to AES.\nThe security level obtained by this solution is very satisfactory.\nThe performance impact of three successive DES executions remains a disadvantage for some applications.\n\n\n\nDES: properties\n\nDES is not a group (in the algebraic sense) under composition: In other words, DES being a permutation: \\(\\{0,1\\}^{64} \\rightarrow \\{0,1\\}^{64}\\), if DES were a group under composition, this would mean that: \\(\\exists K_3\\) such that \\(E_{K_3}(E_{K_2}(x)) = E_{K_3}(x)\\)\nThis property ensures that composite encryption (like Triple-DES) considerably increases the security of DES. If DES were a group, exhaustive search on the possible key set (\\(\\{0,1\\}^{56}\\)) would allow “breaking” the algorithm regardless of the number of consecutive executions of DES.\nWeak and semi-weak keys (weak and semi-weak keys):\n\nA key \\(K\\) is said to be weak if \\(E_K(E_K(x)) = x\\).\nA pair of keys \\((K_1, K_2)\\) is said to be semi-weak if \\(E_{K_1}(E_{K_2}(x)) = x\\).\n\nWeak keys have the particularity of generating identical subkeys in pairs (\\(k_1 = k_{16}\\), \\(k_2 = k_{15}\\), …, \\(k_8 = k_9\\)), which facilitates cryptanalysis.\nDES has 4 weak keys (and 6 pairs of semi-weak keys).\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (3DES and security)\n\n\n\n\n\nDES vulnerability: key space \\(2^{56}\\) breakable in 24h (1999). Triple-DES: \\(E_{K_1}(D_{K_2}(E_{K_1}(P)))\\), space \\(2^{112}\\), reuses DES hardware, 3× slower. DES ≠ group → composite encryption strengthens security. 4 weak keys generating identical subkeys in pairs → facilitates cryptanalysis.\n\n\n\n\n\n\n\n6. Advanced Encryption Standard (AES)\n\nGeneral Presentation\nAES (Advanced Encryption Standard): standard adopted in November 2001.\nDesign: Johan Daemen and Vincent Rijmen (original name: Rijndael)\nMain characteristics:\n\nType: iterative block cipher (but NOT a Feistel Cipher)\nBlock size: 128 bits\nVariable key size: 128, 192 or 256 bits\nNumber of rounds: depends on key size\n\n10 rounds for 128-bit key\n12 rounds for 192-bit key\n14 rounds for 256-bit key\n\nUsage modes: ECB, CBC, CFB, OFB, CTR\n\nAdvantages over DES:\n\n✓ Open process: consultation and analysis by worldwide experts\n✓ ~2× more performant in software\n✓ ~10²² times more secure (theoretically)\n✓ Scalable: key size can be increased if necessary\n\n\n\nAES Structure\nBasic unit: State matrix of 4 rows × 4 columns (for 128-bit key)\n\nEach element = 1 byte\nTotal: 16 bytes = 128 bits\n\nOperations on field \\(GF(2^8)\\):\n\nByte = element of \\(GF(2^8)\\)\nFinite field of polynomials of degree ≤ 7 with coefficients in \\(GF(2)\\)\nAdditions, multiplications defined in \\(GF(2^8)\\)\n\n\n\n\n\n\ngraph TB\n    subgraph State_Matrix\n        S00[s0,0] --- S01[s0,1]\n        S01 --- S02[s0,2]\n        S02 --- S03[s0,3]\n        \n        S10[s1,0] --- S11[s1,1]\n        S11 --- S12[s1,2]\n        S12 --- S13[s1,3]\n        \n        S20[s2,0] --- S21[s2,1]\n        S21 --- S22[s2,2]\n        S22 --- S23[s2,3]\n        \n        S30[s3,0] --- S31[s3,1]\n        S31 --- S32[s3,2]\n        S32 --- S33[s3,3]\n    end\n    \n    style S00 fill:#ffe6cc\n    style S11 fill:#ffe6cc\n    style S22 fill:#ffe6cc\n    style S33 fill:#ffe6cc\n\n\n\n\n\n\n\n\nAES Round Detail\nFour operations per round:\n1. SubBytes (ByteSub)\n\nNon-linear substitution via S-box\nEach byte transformed independently\nResistance to linear and differential cryptanalysis\n\n2. ShiftRows\n\nPermutation of bytes with variable shifts per row\nRow 0: no shift\nRow 1: left shift 1 position\nRow 2: left shift 2 positions\nRow 3: left shift 3 positions\n\n3. MixColumns\n\nEach column = linear combination of other columns\nMatrix multiplication in \\(GF(2^8)\\)\nMaximum diffusion\n\n4. AddRoundKey\n\nXOR of the State matrix with the round subkey\nSubkey = result of Key Schedule\n\n\n\n\n\n\ngraph TB\n    Input[State Input] --&gt; SB[SubBytes]\n    SB --&gt; SR[ShiftRows]\n    SR --&gt; MC[MixColumns]\n    MC --&gt; ARK[AddRoundKey]\n    K[Round Key] --&gt; ARK\n    ARK --&gt; Output[State Output]\n    \n    style SB fill:#ffcccc\n    style SR fill:#ccffcc\n    style MC fill:#cce5ff\n    style ARK fill:#ffffcc\n\n\n\n\n\n\nFinal round: identical EXCEPT no MixColumns\n\n\nKey Schedule (Subkey Generation)\nProcess:\n\nKey Expansion: generation of an extended matrix\n\nKey 128 bits → matrix 4 × 4 × (\\(N_e\\) + 1) bytes\n\\(N_e\\) = number of rounds\n\nKey Selection: extraction of subkeys\n\nFirst subkey: first 4 columns\nSecond subkey: next 4 columns\nEtc.\n\n\nOperations:\n\nByte rotations\nSubstitutions via S-box\nXOR with constants (Rcon)\n\n\n\nAES Pseudo-code\nRijndael(State, CipherKey) {\n    KeyExpansion(CipherKey, ExpandedKey);  // Key Schedule\n    \n    AddRoundKey(State, ExpandedKey[0..3]); // Initial XOR\n    \n    for(i = 1; i &lt; Ne; i++) {\n        Round(State, ExpandedKey[4*i...(4*i)+3]);\n    }\n    \n    FinalRound(State, ExpandedKey[4*Ne...4*Ne+3]);  // Without MixColumns\n}\n\n\nAES Decryption\nPrinciple: apply the inverse operations in each round.\nInverse operations:\n\nInvSubBytes: inverse substitution via S-box⁻¹\nInvShiftRows: right shifts (instead of left)\nInvMixColumns: inverse matrix multiplication\nAddRoundKey: self-inverse (XOR)\n\nOrder: inverse of encryption with subkeys in reverse order\n\n\n\n\n\n\nNote📄 Original text (AES)\n\n\n\n\n\nAdvanced Encryption Standard (AES)\n\nAdopted as standard in November 2001, designed by Johan Daemen and Vincent Rijmen (hence its original name Rijndael).\nIt is also an iterative block cipher (like DES) but not a Feistel Cipher.\nPlaintext/Ciphertext Blocks: 128 bits.\nVariable key length: 128, 192, or 256 bits.\nUnlike DES, AES comes from an open consultation and analysis process involving worldwide experts.\nTechniques similar to DES (substitutions, permutations, XOR…) complemented by simple and very performant algebraic operations.\nAll operations are performed in the field \\(GF(2^8)\\): the finite field of polynomials of degree ≤ 7 with coefficients in \\(GF(2)\\).\nIn particular, a byte for AES is an element in \\(GF(2^8)\\) and the operations on bytes (additions, multiplications,…) are defined as in \\(GF(2^8)\\).\n~2 times more performant (in software) and ~10²² times (in theory…) more secure than DES…\nScalable: The key size can be increased if necessary.\n\n\nDetail of an AES Step (round)\nThe basic unit on which calculations are applied is a matrix of 4 rows and 4 columns (in the case of a 128-bit key) whose elements are bytes:\n\nByteSub: Non-linear operation (S-box) designed to resist linear and differential cryptanalysis.\nShiftRow: Permutation of bytes introducing variable shifts on the rows.\nMixColumn: Each column is replaced by linear combinations of the other columns (matrix multiplication !)\nAddRoundKey: XOR of the current matrix with the subkey corresponding to the current step.\n\n\n\nAES: Global Operation\n\nThe number of steps of AES varies depending on the key size. For a 128-bit key, 10 steps must be performed. Each increase of 32 bits in the key size entails an additional step (14 steps for 256-bit keys).\nDecryption consists of applying the inverse operations in each of the steps (InvSubBytes, InvShiftRows, InvMixColumns). AddRoundKey (because of XOR) is its own inverse.\nThe Key Schedule consists of:\n\nAn operation of key expansion of the main key. If \\(N_e\\) is the number of steps (depending on the key), a matrix of 4 rows and 4 × (\\(N_e\\) + 1) columns is generated.\nAn operation of step key selection: The first subkey will be constituted by the first 4 columns of the matrix generated during expansion and so on.\n\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (AES)\n\n\n\n\n\nAES (Rijndael 2001): iterative block cipher (NOT Feistel), 128-bit blocks, keys 128/192/256 bits → 10/12/14 rounds.\nState: 4×4 byte matrix in \\(GF(2^8)\\).\n4 operations/round:\n\nSubBytes (non-linear S-box)\nShiftRows (row shifts)\nMixColumns (linear combinations)\nAddRoundKey (XOR subkey).\n\n2× faster than DES, 10²² times more secure.\n\n\n\n\n\n\n\n7. Attacks and AES Security\n\nAES Strengths\nSimplicity and performance:\n\n✓ Simple and efficient algorithm\n✓ Works on limited platforms (8-bit smart cards)\n✓ Hardware and software optimizations\n\n\n\nPublished Attacks\n1. Algebraic attacks (2002)\nXSL technique (N. Courtois and P. Pieprzyk):\n\nRepresents AES as system of 8000 quadratic equations with 1600 binary unknowns\nEstimated effort: \\(2^{100}\\) operations (still a conjecture)\nCharacteristic: requires few known plaintexts\nDistinction: different from linear/differential attacks\n\nCritique: based on the “highly algebraic” character of AES (largely contested)\n2. Related Key Attacks (2009-2011)\nPrinciple: attacks based on similar keys\n\nInteresting results on reduced versions of AES\nDo not compromise full AES\n\n3. Side Channel Attacks\nPrinciple: attacks on implementation (not the algorithm)\nTechniques:\n\nCache timing attacks: cache access analysis\nPower analysis: power consumption\nElectromagnetic analysis: electromagnetic emissions\n\nExample (2005): Osvik, Shamir, Tromer\n\nExtraction of 128-bit key with 6-7 plaintext/ciphertext pairs\nBased on cache access analysis\n\n4. Meet in the Middle on biclique structures (2011-2015)\nResult:\n\nReduces effort for AES-128 to \\(2^{126}\\) (factor 4 vs brute force)\nRemains well above current capabilities\n\n\n\nPractical Security\nFundamental assumption: key of maximum entropy\nRecent attacks (WPA2, etc.):\n\nExploit weakness of passwords/passphrases\nNo flaw in AES itself\nProblem: key generation from weak passwords\n\n⚠️ Critical reminder: key quality = system security\n\n\n\n\n\n\nNote📄 Original text (AES Attacks)\n\n\n\n\n\n\nAES: Final Remarks and Attacks (I)\n\nThe greatest strength of AES lies in its simplicity and its performance, including on reduced computing capacity platforms (e.g. smart cards with 8-bit processors).\nSince its official publication, many cryptanalysis works have been published with very interesting results. In particular, N. Courtois and P.Pieprzyk presented a technique called XSL allowing to represent AES as a system of 8000 quadratic equations with 1600 binary unknowns. The effort needed to break this system is estimated (it is still a conjecture…) to be \\(2^{100}\\).\nThese attacks are based on the highly algebraic character (and largely contested…) of AES. Moreover, only a few known plaintexts are needed to set them up, which distinguishes them from linear and differential attacks.\nIn recent years (2009-2011) attacks based on similar keys (related key attacks) have obtained interesting results on reduced versions of AES.\nAnother family of attacks called side channel attacks acting directly on the algorithm implementation allows extracting cryptographically relevant information during encryption execution.\n\n\n\nAES: Final remarks and Attacks (II)\n\nIn 2015 a Meet in the Middle type attack based on biclique structures showed that it was possible to reduce the effort needed to find an AES-128 key to \\(2^{126}\\), i.e., a factor of 4 compared to brute force. This nevertheless remains well above current computing capabilities.\nAnother family of attacks called side channel attacks acting directly on the algorithm implementation allows extracting cryptographically relevant information during encryption execution. In particular, the authors manage to extract the 128-bit key with only 6-7 plaintext/ciphertext pairs based on cache accesses.\nThe security of AES (as for any other encryption algorithm) is always based on the assumption of a key of maximum entropy. The attacks published recently on protocols based on AES (like WPA2) exploit the weakness of passwords/passphrases that are the origin of the keys used.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (AES Security)\n\n\n\n\n\nStrengths: simplicity, performance (even 8-bit cards). Attacks: XSL (\\(2^{100}\\), algebraic), related keys (reduced versions), side channel (implementation, cache), Meet-in-Middle biclique (\\(2^{126}\\)). Security: assumption of max entropy key. Practical attacks = weak passwords, not AES flaw.\n\n\n\n\n\n\n\n8. Block Cipher Cryptanalysis Techniques\n\n8.1 Differential Cryptanalysis\nPrinciple: chosen plaintext attack analyzing the propagation of differences between two plaintexts through the rounds.\nMethod:\n\nChoose two plaintexts with known difference: \\(x_a\\) and \\(x_b\\)\nObserve propagation: \\(\\Delta x = x_a \\oplus x_b\\)\nAnalyze ciphertexts: \\(\\Delta y = y_a \\oplus y_b\\)\nAssign probabilities to keys according to observed changes\nMost probable key = correct key (after many trials)\n\nCharacteristics:\n\nRequires \\(2^{47}\\) chosen plaintext pairs for DES\nProbabilities: depend on S-boxes and structure\nThe more pairs increase, the more success probability increases\n\nSensitivity: very sensitive to number of rounds\n\nChances of success increase exponentially when rounds decrease\n\n\n\n8.2 Linear Cryptanalysis\nPrinciple: known plaintext attack creating a linear simulator of the block cipher.\nMethod:\n\nCreate linear approximations of the algorithm\nAnalyze a large number of plaintext/ciphertext pairs\nThe bits of the simulator key tend to coincide with those of the real key (probabilistic calculation)\n\nComplexity for DES:\n\n\\(2^{38}\\) known plaintexts → 10% probability of guessing correctly\n\\(2^{43}\\) known plaintexts → 85% success probability\n\nCharacteristics:\n\nMost powerful analytical attack to date on block ciphers\nAlso sensitive to number of rounds\n\n\n\n8.3 Differential vs Linear Comparison\nCommon difficulties:\n\n✗ Parallelization: less efficient than parallel brute force\n⚠️ Sensitivity to rounds: efficiency decreases exponentially with number of rounds\n\nDES and these attacks:\n\nWidespread conjecture: DES designers knew these attacks (1970s, unpublished at the time)\nS-box design: very high resistance to both techniques\n\n\n\n8.4 Meet-in-the-Middle Attack\nPrinciple: exploits composite constructions of type \\(y = E_{K_2}(E_{K_1}(x))\\).\nMethod:\n\nBuild list \\(L_1\\): \\(L_1 = \\{E_{K_1}(x) \\mid K_1 \\in \\text{KeySpace}\\}\\)\nBuild list \\(L_2\\): \\(L_2 = \\{D_{K_2}(y) \\mid K_2 \\in \\text{KeySpace}\\}\\)\nIdentify repeated elements in \\(L_1\\) and \\(L_2\\)\nVerify hypothesis with second known plaintext\nThe associated keys \\(K_1\\) and \\(K_2\\) are probably the sought keys\n\nExample for DES:\nIntuitive key space for \\(E_{K_2}(E_{K_1}(x))\\): \\(\\{0,1\\}^{112}\\)\nActual effort:\n\n\\(2^{57}\\) operations to establish the two lists\n\\(2^{56}\\) blocks of 64 bits storage\nSignificantly lower than the intuitive \\(2^{112}\\)\n\nApplications:\n\nAttacks on composite constructions\nInternal cryptanalysis of block ciphers\n\n\n\n\n\n\ngraph TB\n    subgraph Meet_in_Middle\n        X[Known Plaintext x] --&gt; E1[Encrypt K1]\n        E1 --&gt; M[Middle Value m]\n        M --&gt; E2[Encrypt K2]\n        E2 --&gt; Y[Known Ciphertext y]\n        \n        X2[x] --&gt; L1[List L1: EK1 for all K1]\n        Y2[y] --&gt; L2[List L2: DK2 for all K2]\n        \n        L1 -.match.-&gt; Match[Find common m]\n        L2 -.match.-&gt; Match\n    end\n    \n    style M fill:#ffffcc\n    style Match fill:#ccffcc\n\n\n\n\n\n\n\n\n\n\n\n\nNote📄 Original text (Cryptanalysis)\n\n\n\n\n\n\nBlock Cipher Cryptanalysis Techniques\nDifferential Cryptanalysis\n\nThis is a chosen plaintext attack that focuses on the propagation of differences in two plaintexts as they evolve through the different steps of the algorithm.\nIt assigns probabilities to keys it “guesses” based on the changes they induce on the ciphertexts. The most probable key has a good chance of being the correct key after a large number of plaintext/ciphertext pairs.\nRequires \\(2^{47}\\) chosen plaintext pairs (for DES) to obtain correct results.\n\nLinear Cryptanalysis\n\nThis is a known plaintext attack that creates a block simulator from linear approximations. By analyzing a large number of plaintext/ciphertext pairs, the bits of the simulator key tend to coincide with those of the analyzed block cipher (probabilistic calculation)\nFor DES an attack based on this technique requires \\(2^{38}\\) known plaintexts to obtain a probability of 10% of guessing correctly and \\(2^{43}\\) for 85% !\nIt is the most powerful analytical attack to date on block ciphers.\n\n\n\nBlock Cipher Cryptanalysis Techniques (II)\n\nThe practical implementation of differential and linear attacks presents difficulties in parallelizing calculations compared to an exhaustive key search.\nThese two attacks are very sensitive to the number of steps of the block cipher: chances of success increase exponentially as the number of algorithm steps decreases.\nA widespread conjecture among cryptographers is that these attacks, at the time unpublished, were known to the designers of DES. In particular, the design of the S-boxes offers a very high resistance to both techniques.\n\nMeet-in-the-Middle Attack\n\nApplies to constructions of the type \\(y := E_{K_2}(E_{K_1}(x))\\). For DES, the key space for this solution would be \\(\\{0,1\\}^{112}\\). First build two lists \\(L_1\\) and \\(L_2\\) of \\(2^{56}\\) messages of the form: \\(L_1 = E_{K_1}(x)\\) and \\(L_2 = D_{K_2}(y)\\) with \\(E\\) and \\(D\\) the encryption and decryption operations respectively. Then identify elements that repeat in both lists and verify our hypothesis with a second known plaintext. The \\(K_1\\) and \\(K_2\\) associated with this pair of known plaintexts will (in all likelihood) be the sought keys !\nEffort required to carry out the attacks (for DES): \\(2^{57}\\) operations to establish the two lists + \\(2^{56}\\) blocks of 64 bits of storage to memorize intermediate results… significantly lower than the intuitive \\(2^{112}\\)…\nThese meet-in-the-middle techniques are also applied to the internal cryptanalysis of block ciphers.\n\n\n\n\n\n\n\n\n\n\n\nTip📌 Quick revision (Cryptanalysis)\n\n\n\n\n\nDifferential: chosen plaintext, difference propagation, probabilities on keys, \\(2^{47}\\) pairs (DES).\nLinear: known plaintext, linear approximations, \\(2^{38}\\)-\\(2^{43}\\) plaintexts (DES), most powerful attack.\nMeet-in-Middle: composite constructions, 2 lists \\(2^{56}\\), effort \\(2^{57}\\) &lt;&lt; \\(2^{112}\\).\nSensitivity: very dependent on number of rounds."
  },
  {
    "objectID": "exam_notes_en.html#mathematical-foundations",
    "href": "exam_notes_en.html#mathematical-foundations",
    "title": "Fundamental Security Services",
    "section": "Mathematical Foundations",
    "text": "Mathematical Foundations\n\nFundamental Theorem of Arithmetic and Euler’s Totient Function\nAsymmetric cryptography relies on solid mathematical foundations from number theory. Two concepts are essential:\nFundamental Theorem of Arithmetic: Every positive integer greater than 1 can be written uniquely (up to order) as a product of prime powers:\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nEuler’s Totient Function \\(\\phi(n)\\): Number of positive integers smaller than \\(n\\) that are coprime with \\(n\\).\nTo compute \\(\\phi(n)\\):\n\\[\\phi(n) = \\prod_{i=1}^{m} p_i^{e_i} \\cdot \\left(1 - \\frac{1}{p_i}\\right)\\]\nImportant special case: If \\(n = p \\cdot q\\) with \\(p\\) and \\(q\\) prime, then:\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMathematical Foundations\nFundamental Theorem of Arithmetic: Every positive integer \\(n\\) can be written uniquely (up to order) as a product of powers of distinct prime numbers \\(p_i\\):\n\\[n = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_m^{e_m}\\]\nEuler’s Totient Function: Let \\(n \\in \\mathbb{Z}^+\\), the Euler’s totient function \\(\\phi(n)\\) is equal to the number of positive integers smaller than \\(n\\) that are relatively prime to \\(n\\).\nCalculation of Euler’s totient function: According to the fundamental theorem of arithmetic, every integer \\(n &gt; 1\\) can be written as:\n\\[n = \\prod_{i=1}^{m} p_i^{e_i}\\]\nthen \\(\\phi(n)\\) is calculated as:\n\\[\\phi(n) = \\prod_{i=1}^{m} \\left(p_i^{e_i} - p_i^{e_i-1}\\right)\\]\nIn particular, if \\(n = p \\cdot q\\) with \\(p\\) and \\(q\\) prime, then:\n\\[\\phi(n) = (p-1)(q-1)\\]\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nUnique decomposition: every integer = product of prime numbers\n\\(\\phi(n)\\): counts integers \\(&lt; n\\) coprime with \\(n\\)\nKey for RSA: if \\(n = pq\\) (primes) then \\(\\phi(n) = (p-1)(q-1)\\)\n\n\n\n\n\n\n\nEuler’s Theorem and Fermat’s Little Theorem\nThese theorems are at the heart of RSA and other asymmetric algorithms.\nEuler’s Theorem: If \\(n \\in \\mathbb{Z}^+\\) and \\(a \\in \\mathbb{Z}\\) with \\(\\text{gcd}(a,n) = 1\\), then:\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nFermat’s Little Theorem (special case if \\(n = p\\) prime): If \\(a \\in \\mathbb{Z}\\) and \\(p\\) prime does not divide \\(a\\):\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nImportant applications:\n\nExponent reduction: If \\(n\\) is a product of distinct primes and \\(r \\equiv s \\pmod{\\phi(n)}\\), then: \\[a^r \\equiv a^s \\pmod{n}\\]\nCalculation of inverses: \\(a^{\\phi(n)-1}\\) is the inverse of \\(a\\) modulo \\(n\\). In particular, if \\(p\\) is prime, \\(a^{p-2}\\) is the inverse of \\(a\\) modulo \\(p\\).\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMathematical Foundations (II)\nEuler’s Theorem: Let \\(n \\in \\mathbb{Z}^+\\) and \\(a \\in \\mathbb{Z}\\) with \\(\\text{gcd}(a,n) = 1\\), then we have:\n\\[a^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\nFermat’s Little Theorem (special case of Euler’s theorem if \\(n\\) is prime): Let \\(a \\in \\mathbb{Z}\\) and \\(p\\) a prime number such that \\(p\\) does not divide \\(a\\), then we have:\n\\[a^{p-1} \\equiv 1 \\pmod{p}\\]\nNote that since \\(p\\) is prime, we have \\(\\phi(p) = p-1\\).\nExponent reduction \\(\\bmod \\phi(n)\\): If \\(n\\) is the product of distinct primes and \\(r, s \\in \\mathbb{Z}\\) such that \\(r \\equiv s \\pmod{\\phi(n)}\\) then \\(\\forall a \\in \\mathbb{Z}\\):\n\\[a^r \\equiv a^s \\pmod{n}\\]\nApplication of Euler’s Theorem to inverse calculation: From Euler’s theorem, we have that:\n\\[a \\cdot a^{\\phi(n)-1} \\equiv 1 \\pmod{n}\\]\nwhich means that \\(a^{\\phi(n)-1}\\) is the inverse of \\(a\\) modulo \\(n\\). In particular, \\(a^{p-2}\\) is the inverse of \\(a\\) modulo \\(n\\) if \\(p\\) is prime.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nEuler’s Theorem: \\(a^{\\phi(n)} \\equiv 1 \\pmod{n}\\)\nFermat: special case if \\(p\\) prime: \\(a^{p-1} \\equiv 1 \\pmod{p}\\)\nModular inverse: \\(a^{-1} \\equiv a^{\\phi(n)-1} \\pmod{n}\\)\nBase of RSA: enables encryption/decryption with exponents\n\n\n\n\n\n\n\nMultiplicative Groups and Generators\nMultiplicative group \\(\\mathbb{Z}_n^*\\): Set of elements of \\(\\mathbb{Z}_n\\) coprime with \\(n\\):\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{gcd}(a,n) = 1\\}\\]\nIf \\(n\\) is prime: \\(\\mathbb{Z}_n^* = \\{1, 2, \\ldots, n-1\\}\\)\nOrder of an element: Smallest positive integer \\(t\\) such that \\(a^t \\equiv 1 \\pmod{n}\\)\nGenerator: An element \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) if its order is \\(\\phi(n)\\). Then \\(\\mathbb{Z}_n^*\\) is said to be cyclic.\nProperties of generators:\n\n\\(\\mathbb{Z}_n^*\\) has a generator iff \\(n = 2, 4, p^k\\) or \\(2p^k\\) (with \\(p\\) prime, \\(p \\neq 2\\) and \\(k \\geq 1\\))\nIf \\(p\\) is prime, \\(\\mathbb{Z}_p^*\\) always has a generator\nIf \\(\\alpha\\) is a generator, all elements can be written as: \\(\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i &lt; \\phi(n)\\}\\)\nThe number of generators is \\(\\phi(\\phi(n))\\)\n\nGenerator test\n\n\\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) iff for every prime \\(p\\) dividing \\(\\phi(n)\\), \\(\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\)\nif \\(n = 2p+1\\) is a “safe prime” with \\(p\\) prime: \\(\\alpha\\) is a generator iff \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) and \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMathematical Foundations (III)\nDefinition: The multiplicative group of \\(\\mathbb{Z}_n\\), denoted \\(\\mathbb{Z}_n^*\\) is:\n\\[\\mathbb{Z}_n^* = \\{a \\in \\mathbb{Z}_n \\mid \\text{gcd}(a,n) = 1\\}\\]\nIn particular, if \\(n\\) is prime: \\(\\mathbb{Z}_n^* = \\{a \\mid 1 \\leq a \\leq n-1\\}\\)\nThe number of elements or order of the multiplicative group \\(\\mathbb{Z}_n^*\\) is \\(\\phi(n)\\) (by definition of \\(\\phi\\)).\nDefinition: Let \\(a \\in \\mathbb{Z}_n\\), the order of \\(a\\) is the smallest positive integer \\(t\\) for which:\n\\[a^t \\equiv 1 \\pmod{n}\\]\nDefinition: Let \\(\\alpha \\in \\mathbb{Z}_n^*\\), if the order of \\(\\alpha\\) is \\(\\phi(n)\\), then \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\). When a group \\(\\mathbb{Z}_n^*\\) has a generator, it is said to be cyclic.\nProperties of generators:\n\n\\(\\mathbb{Z}_n^*\\) has a generator iff \\(n = 2, 4, p^k\\) or \\(2p^k\\), with \\(p\\) prime, \\(p \\neq 2\\) and \\(k \\geq 1\\). In particular, if \\(p\\) is prime, \\(\\mathbb{Z}_p^*\\) has a generator.\nIf \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\), then all elements of \\(\\mathbb{Z}_n^*\\) can be written as: \\[\\mathbb{Z}_n^* = \\{\\alpha^i \\bmod n \\mid 0 \\leq i \\leq \\phi(n)-1\\}\\]\nThe number of generators of \\(\\mathbb{Z}_n^*\\) is \\(\\phi(\\phi(n))\\).\n\\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) iff for every prime \\(p\\) dividing \\(\\phi(n)\\), we have: \\[\\alpha^{\\phi(n)/p} \\not\\equiv 1 \\pmod{n}\\]\n\nIn particular if \\(n\\) is a prime of the form \\(n = 2p+1\\) with \\(p\\) prime (such \\(n\\) is called a safe prime), \\(\\alpha\\) is a generator of \\(\\mathbb{Z}_n^*\\) iff \\(\\alpha^2 \\not\\equiv 1 \\pmod{n}\\) and \\(\\alpha^p \\not\\equiv 1 \\pmod{n}\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\n\\(\\mathbb{Z}_n^*\\): elements coprime with \\(n\\), cardinality = \\(\\phi(n)\\)\nGenerator: element of order \\(\\phi(n)\\) (generates the entire group)\nCrucial for DH and ElGamal: security based on discrete logarithm in cyclic group\nSafe prime: \\(n = 2p+1\\) with \\(p\\) and \\(n\\) prime\n\n\n\n\n\n\n\nFast Exponentiation\nEfficient computation of \\(a^k \\bmod n\\) in polynomial time, essential for all asymmetric algorithms.\nPrinciple: Use the binary representation of the exponent \\(k\\).\nExample: Computation of \\(2^{644} \\bmod 645\\)\n\nBinary representation: \\((644)_{10} = (1010000100)_2\\)\nCompute successive powers of 2 modulo 645:\n\n\\(2^1 \\bmod 645\\)\n\\(2^2 \\bmod 645\\)\n\\(2^4 \\bmod 645\\)\n\\(2^8 \\bmod 645\\)\n…\n\\(2^{512} \\bmod 645\\)\n\nCombine according to bits set to 1: \\(2^{644} = 2^{512} \\cdot 2^{128} \\cdot 2^4\\)\n\nComplexity: \\(O(\\log^3 n)\\) - very efficient!\nApplication: Computation of the inverse using Euler’s theorem in polynomial time.\nAlternative: Extended Euclidean algorithm to find \\(x\\) such that \\(ax \\equiv 1 \\pmod{n}\\) by solving \\(ax - kn = 1 = \\text{gcd}(a,n)\\). Complexity also \\(O(\\log^3 n)\\).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nFast Exponentiation\nFast exponentiation: Using the binary representation of a number, we can compute powers very efficiently.\nExample: computation of \\(2^{644} \\bmod 645\\)\n\\((644)_{10} = (1010000100)_2\\)\nNow, we compute the exponents corresponding to the powers of 2, namely:\n\\[2^1 \\bmod 645, \\quad 2^2 \\bmod 645, \\quad 2^4 \\bmod 645, \\quad \\ldots, \\quad 2^{512} \\bmod 645\\]\nFrom the binary representation, we compute:\n\\[2^{644} = 2^{512+128+4} = 2^{512} \\cdot 2^{128} \\cdot 2^4 = 160 \\cdot 153 \\cdot 6 \\bmod 645\\]\nThe complexity of this algorithm fast exponentiation is \\(O(\\log^3 n)\\).\nBy relying on Euler’s theorem, the computation of the inverse of a number in such a group is therefore performed in polynomial time.\nThe extended Euclidean algorithm can also be used to find an \\(x\\) such that:\n\\[ax \\equiv 1 \\pmod{n}\\]\nsince this congruence can be written as: \\(ax - 1 = kn\\) and therefore:\n\\[ax - kn = 1 = \\text{gcd}(a,n)\\]\nThe complexity of this algorithm is also \\(O(\\log^3 n)\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nIdea: binary representation of the exponent\nComplexity: \\(O(\\log^3 n)\\) - polynomial!\nEssential: makes RSA, ElGamal, DH practical\nAlternative: extended Euclidean algorithm for inverses\n\n\n\n\n\n\n\nChinese Remainder Theorem (CRT)\nThe CRT allows solving systems of simultaneous congruences, with important applications in cryptography.\nTheorem: Let \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) pairwise coprime (gcd\\((n_i, n_j) = 1\\) if \\(i \\neq j\\)) and \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Then the system:\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\nhas a unique solution \\(x \\bmod N\\) with \\(N := n_1 \\cdot n_2 \\cdots n_t\\).\nGauss’s algorithm (1801) to compute \\(x\\):\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\nwith:\n\n\\(N_i = N/n_i\\)\n\\(M_i = N_i^{-1} \\bmod n_i\\) (modular inverse)\n\nComplexity: \\(O(\\log^3 n)\\) - polynomial!\nCryptographic applications:\n\nAcceleration of RSA computations (use \\(p\\) and \\(q\\) separately)\nSecret sharing (secret sharing schemes)\nCertain attacks on RSA (if small exponent and multiple messages)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nChinese Remainder Theorem\nThe Chinese Remainder Theorem (3rd century!) allows solving linear systems of simultaneous congruences. It solves problems raised in ancient Chinese puzzles. It was, for example, about finding a number that produces a remainder of 1 when divided by 3, of 2 when divided by 5 and of 3 when divided by 7… It was also used to calculate the exact moment of alignment of several celestial bodies having different orbits (and therefore periods).\nChinese Remainder Theorem: Let \\(n_1, n_2, \\ldots, n_t \\in \\mathbb{Z}^+\\) be pairwise coprime (i.e., gcd\\((n_i, n_j) = 1\\), \\(\\forall i \\neq j\\)) and \\(a_1, a_2, \\ldots, a_t \\in \\mathbb{Z}\\). Then, the system of congruences:\n\\[\\begin{cases}\nx \\equiv a_1 \\pmod{n_1} \\\\\nx \\equiv a_2 \\pmod{n_2} \\\\\n\\vdots \\\\\nx \\equiv a_t \\pmod{n_t}\n\\end{cases}\\]\nhas a unique solution \\(x \\bmod N := n_1 n_2 \\cdots n_t\\)\nGauss’s algorithm (1801) for the computation of \\(x\\):\n\\[x = \\sum_{i=1}^{t} a_i N_i M_i \\bmod N\\]\nwith \\(N_i = N/n_i\\) and \\(M_i = N_i^{-1} \\bmod n_i\\).\nThe complexity of this algorithm is \\(O(\\log^3 n)\\).\nIt is therefore possible in polynomial time to go from congruences mod \\(n_i\\) to congruences mod \\(N\\)!\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSolves: systems of congruences with pairwise coprime moduli\nUnique solution: modulo product of moduli\nComplexity: \\(O(\\log^3 n)\\) (polynomial)\nCrypto usage: RSA optimization, attacks if small exponent"
  },
  {
    "objectID": "exam_notes_en.html#basic-problems-and-complexity",
    "href": "exam_notes_en.html#basic-problems-and-complexity",
    "title": "Fundamental Security Services",
    "section": "Basic Problems and Complexity",
    "text": "Basic Problems and Complexity\n\nClassification of Hard Problems\nThe security of asymmetric cryptography relies on mathematical problems reputed to be hard:\nGeneric problems:\n\nFactorization (FACTP): Given \\(n\\), find its factorization into prime numbers\n\nBase of RSA and Rabin\n\nDiscrete Logarithms (DLP): Given prime \\(p\\), a generator \\(\\alpha \\in \\mathbb{Z}_p^*\\) and \\(\\beta \\in \\mathbb{Z}_p^*\\), find \\(x\\) such that: \\[\\alpha^x \\equiv \\beta \\pmod{p}\\]\n\nBase of ElGamal and Diffie-Hellman\n\nSquare Root modulo composite (SQROOTP): Given composite \\(n\\) and a quadratic residue \\(a\\), find \\(\\sqrt{a} \\bmod n\\)\n\nBase of Rabin\n\n\nSpecific problems:\n\nRSA Problem (RSAP): Given \\(n = pq\\), \\(e\\) with gcd\\((e, \\phi(n)) = 1\\) and \\(c\\), find \\(m\\) such that \\(m^e \\equiv c \\pmod{n}\\)\nDiffie-Hellman Problem (DHP): Given prime \\(p\\), generator \\(\\alpha\\), \\(\\alpha^a \\bmod p\\) and \\(\\alpha^b \\bmod p\\), find \\(\\alpha^{ab} \\bmod p\\)\n\nProven equivalences:\n\nDHP ⟺ DLP (equivalent under certain conditions)\nRSAP ⟺ FACTP (proven equivalent for the generic case)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nBasic Problems\nMain generic problems:\n\nFactorization (FACTP): Given a positive integer \\(n\\), find its factorization into prime numbers.\nDiscrete Logarithms (DLP): Given a prime number \\(p\\), a generator \\(\\alpha \\in \\mathbb{Z}_p^*\\) and an element \\(\\beta \\in \\mathbb{Z}_p^*\\), find the integer \\(x\\), \\(0 \\leq x \\leq p-2\\), such that: \\(\\alpha^x \\equiv \\beta \\pmod{p}\\).\nSquare Root in \\(\\mathbb{Z}_n\\) if \\(n\\) is composite (SQROOTP): Given a composite integer \\(n\\) and a quadratic residue \\(a\\), find the square root of \\(a\\) mod \\(n\\).\n\nSpecific problems (proper to an encryption system):\n\nRSA (RSAP): Given a positive integer \\(n = pq\\), a positive integer \\(e\\) with gcd\\((e, (p-1)(q-1)) = 1\\) and an integer \\(c\\), find an integer \\(m\\) with \\(m^e \\equiv c \\pmod{n}\\).\nDiffie-Hellman (DHP): Given a prime number \\(p\\), a generator \\(\\alpha \\in \\mathbb{Z}_p^*\\) and the elements \\(\\alpha^a \\bmod p\\) and \\(\\alpha^b \\bmod p\\), find \\(\\alpha^{ab} \\bmod p\\).\n\nProven results:\n\nDHP ⟺ DLP (Equivalent under certain conditions)\nRSAP ⟺ FACTP (Proven equivalent for the generic problem)\nSQROOTP ⟺ FACTP\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nFACTP: factor \\(n\\) → base of RSA/Rabin\nDLP: find discrete logarithm → base ElGamal/DH\nSQROOTP: square root mod composite → Rabin\nEquivalences: breaking = solving the base problem\n\n\n\n\n\n\n\nFactorization Techniques\nThe security of RSA depends on the difficulty of factoring large numbers.\nExponential time methods: \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division (successive division)\nSieve of Eratosthenes (2nd century BC)\nFermat’s Method (~1650)\nPollard’s \\(\\rho\\) Method (1975)\nPollard’s \\(p-1\\) Method (1974)\n\nSub-exponential time methods: \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981) - very effective in practice\nNumber Field Sieve - NFS (1990) - currently the fastest\nGeneral Number Field Sieve - GNFS (2006)\n\nPolynomial time methods:\n\nShor’s Algorithm (1994): \\(O(\\log^c n)\\) on quantum computer\n\nCurrent records (2020):\n\nLargest number factored: RSA-829 (250 digits, 829 bits)\nComputation time: 2700 core-years (Intel Xeon Gold 6130 CPUs)\nMethod: General Number Field Sieve\n\nImplications:\n\nRSA keys &lt; 1024 bits: vulnerable\nRSA keys 1024 bits: limits (states with significant resources)\nRecommendation: 2048 bits minimum (3072-4096 for long term)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nClassical Factoring Techniques and New Developments\nExponential time: \\(O(\\exp(c \\cdot \\ln(n)))\\)\n\nTrial Division\nEratosthenes’ Sieve (II B.C.)\nFermat’s Difference of Squares Method (~1650)\nSquare Form Factorization (1971)\nPollard’s p-1 method (1974)\nPollard’s Rho Method (1975)\n\nSub-exponential time: \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\)\n\nContinued Fractions (1975)\nQuadratic Sieve (1981)\nNumber Field Sieve - NFS (1990)\nGeneral Number Field Sieve - GNFS (2006)\n\nPolynomial time:\n\nShor’s Algorithm in a Quantum Computer (1994): \\(O(\\log^c n)\\)\n\nRecent developments:\n\nBernstein’s specific NFS computer to factor a 1536-bit number would take the same time as a 512-bit computation on a conventional machine\nLargest factorization to date (2020): RSA-829 (250-digit number) using NFS\nTotal computation time: 2700 core-years (Intel Xeon Gold 6130 CPUs at 2.1GHz)\n\nFactorization on quantum computer:\n\nSignificant problems (errors, dispersion, etc.)\n2001: 7-qubit computer (IBM Almaden)\nFeasibility of a computer with millions of qubits… ?\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSub-exponential: NFS currently the fastest\nRecord 2020: RSA-829 (829 bits) in 2700 core-years\nRecommendation: keys ≥ 2048 bits for RSA\nFuture threat: quantum computers (Shor)"
  },
  {
    "objectID": "exam_notes_en.html#the-rsa-algorithm",
    "href": "exam_notes_en.html#the-rsa-algorithm",
    "title": "Fundamental Security Services",
    "section": "The RSA Algorithm",
    "text": "The RSA Algorithm\n\nRSA Operation (Encryption/Decryption)\nRSA (Rivest-Shamir-Adleman, 1978) is the most used asymmetric algorithm.\nKey generation:\n\nChoose two large prime numbers \\(p\\) and \\(q\\) (≥ 1024 bits each)\nCompute \\(n := p \\cdot q\\) and \\(\\phi(n) = (p-1)(q-1)\\)\nChoose encryption exponent \\(e\\) with:\n\n\\(1 &lt; e &lt; \\phi(n)\\)\ngcd\\((e, \\phi(n)) = 1\\)\n\nCompute decryption exponent \\(d\\) such that: \\[e \\cdot d \\equiv 1 \\pmod{\\phi(n)}\\] (using extended Euclidean algorithm or fast exponentiation)\n\nResulting keys:\n\nPublic key: \\((n, e)\\)\nPrivate key: \\(d\\) (keep \\(p\\) and \\(q\\) secret too!)\n\nEncryption (by Bob, to Alice):\n\nObtain authentic public key \\((n, e)\\) of Alice\nTransform plaintext into integers \\(m_i \\in [0, n-1]\\)\nCompute ciphertexts: \\(c_i := m_i^e \\bmod n\\)\nSend the \\(c_i\\) to Alice\n\nDecryption (by Alice):\n\nUse private key \\(d\\) to compute: \\[m_i = c_i^d \\bmod n\\]\n\nProof of operation:\n\\[c^d \\equiv (m^e)^d \\equiv m^{ed} \\pmod{n}\\]\nSince \\(ed \\equiv 1 \\pmod{\\phi(n)}\\), there exists \\(k\\) such that \\(ed = 1 + k\\phi(n)\\), therefore:\n\\[c^d \\equiv m^{1+k\\phi(n)} \\equiv m \\cdot (m^{\\phi(n)})^k \\equiv m \\cdot 1^k \\equiv m \\pmod{n}\\]\n(by Euler’s theorem)\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRSA Encryption/Decryption Procedure and Proof\nKey generation:\n\nEach entity (A) creates a key pair (public and private) as follows:\n\nA chooses the size of the modulus \\(n\\) (e.g., size\\((n) = 1024\\) or size\\((n) = 2048\\)).\nA generates two prime numbers \\(p\\) and \\(q\\) of large size \\((n/2)\\).\nA computes \\(n := pq\\) and \\(\\phi(n) = (p-1)(q-1)\\).\nA generates the encryption exponent \\(e\\), with \\(1 &lt; e &lt; \\phi(n)\\) such that gcd\\((e, \\phi(n)) = 1\\).\nA computes the decryption exponent \\(d\\), such that: \\(ed \\equiv 1 \\pmod{\\phi(n)}\\) using the extended Euclidean algorithm or fast exponentiation.\n\nThe pair \\((n,e)\\) is A’s public key; \\(d\\) is A’s private key.\n\nEncryption:\n\nEntity B obtains \\((n,e)\\), the authentic public key of A.\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, n-1]\\) \\(\\forall i\\).\nB computes the ciphertext \\(c_i := m_i^e \\bmod n\\), \\(\\forall i\\) using fast exponentiation.\nB sends to A all the ciphertexts \\(c_i\\).\n\nDecryption:\n\nA uses its private key to compute the plaintexts \\(m_i = c_i^d \\bmod n\\).\n\nProof: Let \\(m\\) be the plaintext and \\(c\\) the ciphertext with \\(c := m^e \\bmod n\\), we need to prove: \\(m \\stackrel{!}{=} c^d \\bmod n\\)\nSubstituting \\(c\\) by its value we obtain: \\[c^d \\bmod n = m^{ed} \\bmod n \\quad (*)\\]\nbut, we know that: \\[ed \\equiv 1 \\pmod{\\phi(n)}\\]\nand therefore by definition of congruences, there exists an integer \\(k\\) with: \\[ed - 1 = k\\phi(n)\\]\nsubstituting in (*): \\[c^d \\equiv m^{k\\phi(n)+1} \\equiv m^{k\\phi(n)} \\cdot m \\pmod{n}\\]\nIf gcd\\((m,n) = 1\\), we have by Euler’s theorem: \\[m^{\\phi(n)} \\equiv 1 \\pmod{n}\\]\ntherefore: \\[c^d \\equiv (m^{\\phi(n)})^k \\cdot m \\equiv m \\pmod{n}\\] Q.E.D. !\nIf gcd\\((m,n) \\neq 1\\), \\(m\\) is necessarily a multiple of \\(p\\) or \\(q\\) (very unlikely case…), we can show by doing the calculations mod \\(p\\) and mod \\(q\\) that the congruence remains true.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nPublic key: \\((n, e)\\) with \\(n = pq\\)\nPrivate key: \\(d\\) such that \\(ed \\equiv 1 \\pmod{\\phi(n)}\\)\nEncryption: \\(c = m^e \\bmod n\\)\nDecryption: \\(m = c^d \\bmod n\\)\nSecurity: based on difficulty of factoring \\(n\\)\n\n\n\n\n\n\n\n\n\ngraph LR\n    A[Plaintext m] --&gt;|Encryption: m^e mod n| B[Ciphertext c]\n    B --&gt;|Decryption: c^d mod n| C[Plaintext m]\n    D[Public key: n, e] -.-&gt;|used for| A\n    E[Private key: d] -.-&gt;|used for| B\n    F[p, q secret primes] --&gt;|n = pq| D\n    F --&gt;|φn = p-1q-1| E\n\n\n\n\n\n\n\n\n\nRSA Security\nEquivalence RSA problem ⟺ Factorization:\n\nFinding \\(d\\) ⟺ factoring \\(n\\) (proven equivalent)\nDecrypting without \\(d\\) is not proven as hard as factoring, but…\nNo method faster than factoring is known\n\nFactorization complexity:\n\nFastest methods: \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\) (sub-exponential)\nComputationally impossible for \\(n \\geq 1024\\) bits\nCurrent recommendation: 2048 bits minimum (3072-4096 for long-term security)\n\nChoice of exponents:\n\nEncryption exponent \\(e\\):\n\nOften small for speed: \\(e = 3, 17, 65537\\) (common)\nCaution: if \\(e\\) too small AND \\(m &lt; n^{1/e}\\), attack possible (\\(e\\)-th root in \\(\\mathbb{Z}\\))\nSolution: randomization (padding) of the message\n\nDecryption exponent \\(d\\):\n\nMust be large: at least half the size of \\(n\\)\nIf \\(d\\) small: vulnerable to Wiener’s attack\n\n\nPerformance consequence:\n\nFast encryption (\\(e\\) small)\nSlow decryption (\\(d\\) large)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRSA: Security\nThe RSAP problem of finding \\(m\\) from \\(c\\) is not proven to be as hard as factorization but…:\n\nWe can prove that if we find \\(d\\) we can easily compute \\(p\\) and \\(q\\). This is equivalent to saying that factoring \\(n\\) and finding \\(d\\) require equivalent computational effort.\nWe know that the fastest methods for factoring have a sub-exponential complexity \\(O(\\exp(c \\cdot (\\ln(n))^{1/3}))\\). The problem therefore remains computationally impossible for modulus \\(\\geq 1048\\) bits (2048 bits is a frequent choice for long-term security…).\nTo improve encryption speed, we tend to choose relatively small exponents \\(e\\) (typically: \\(e := 3\\), \\(e := 17\\) and \\(e := 19\\)). However, it has been proven that computing an \\(i\\)-th root (with small \\(i\\)) modulo a composite \\(n\\) can be significantly easier than factoring \\(n\\). On the other hand, in 2008 it was proven that the generic RSA problem is equivalent to factorization.\nThe decryption exponent \\(d\\) must imperatively be large (at least half the size of \\(n\\)) to guarantee the system’s security.\nConsequently, encryption is normally significantly faster than decryption since the exponents used are much smaller!\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSecurity: based on difficulty of FACTP (factorization)\nRecommended size: \\(n \\geq 2048\\) bits\nSmall \\(e\\): fast encryption (3, 17, 65537)\nLarge \\(d\\): at least \\(\\text{size}(n)/2\\)\nSeparate keys: encryption ≠ signature\n\n\n\n\n\n\n\nAttacks on RSA\n\nAttack on small exponent with same message\nIf the same message \\(m\\) is sent to 3 recipients with \\(e = 3\\):\n\n\\(c_1 \\equiv m^3 \\pmod{n_1}\\)\n\\(c_2 \\equiv m^3 \\pmod{n_2}\\)\n\\(c_3 \\equiv m^3 \\pmod{n_3}\\)\n\nThe Chinese Remainder Theorem gives a unique solution \\(x \\bmod n_1n_2n_3\\) such that: \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nIf \\(m^3 &lt; n_1n_2n_3\\) (often true), then \\(x = m^3\\) in \\(\\mathbb{Z}\\) and we can compute \\(m\\) by simply taking the integer cube root!\nProtection: always randomize the message before encryption (OAEP padding)\n\n\nAttack if message small\nIf \\(m &lt; n^{1/e}\\), then \\(m^e &lt; n\\), so \\(c = m^e\\) (in \\(\\mathbb{Z}\\), not modulo). We can directly compute the \\(e\\)-th root!\nProtection: padding mandatory\n\n\nMultiplicative property\n\\[E(m_1) \\cdot E(m_2) \\equiv (m_1 \\cdot m_2)^e \\equiv E(m_1 \\cdot m_2) \\pmod{n}\\]\nAllows chosen-ciphertext attacks and blind signatures.\n\n\nGeneral attack\nThe most effective method remains factoring \\(n\\) (if parameters well chosen and implementation correct).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRSA: Attacks\nWhen we want to encrypt the same message for a group of correspondents, it is advisable to introduce variations (randomization) before encryption to avoid the following attack:\nAssume we compute ciphertexts \\(c_1, c_2, c_3\\) from the same plaintext \\(m\\) and the same exponent \\(e := 3\\) addressed to three entities with modulus: \\(n_1, n_2, n_3\\).\nThe Chinese Remainder Theorem tells us that there exists a solution \\(x \\bmod n_1n_2n_3\\), such that: \\[x \\equiv c_1 \\pmod{n_1}, \\quad x \\equiv c_2 \\pmod{n_2}, \\quad x \\equiv c_3 \\pmod{n_3}\\]\nBut if \\(m\\) does not change for the three encryptions, we have that \\(x = m^3 \\bmod n_1n_2n_3\\) and, moreover: \\(m^3 &lt; n_1n_2n_3\\). We can, therefore, find \\(m\\) by computing the integer cube root of \\(m^3\\), knowing that for this calculation there exist efficient algorithms!\nMore generally, if \\(m &lt; n^{1/e}\\), we can apply fast algorithms (in \\(\\mathbb{Z}\\)) to compute the \\(e\\)-th roots of \\(m^e\\). It is therefore advisable to perform “randomization” of \\(m\\) before encrypting!\nThe multiplicative property of RSA: \\((m_1 m_2)^e \\equiv m_1^e \\cdot m_2^e \\equiv c_1 \\cdot c_2 \\pmod{n}\\)\ngives rise to dangerous vulnerabilities (see blind signatures).\nAssuming parameters are correctly chosen and the implementation has no flaws, the most effective method to “break” the generic RSA algorithm remains factoring \\(n\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\n\nSame message, small \\(e\\): CRT allows extracting \\(m\\)!\nMessage too small: \\(m &lt; n^{1/e}\\) → direct root\nMultiplicative property: \\(E(m_1) \\cdot E(m_2) = E(m_1 m_2)\\)\nProtection: always padding/randomization (OAEP)"
  },
  {
    "objectID": "exam_notes_en.html#the-elgamal-algorithm",
    "href": "exam_notes_en.html#the-elgamal-algorithm",
    "title": "Fundamental Security Services",
    "section": "The ElGamal Algorithm",
    "text": "The ElGamal Algorithm\nAsymmetric system (1985) based on the discrete logarithm problem (DLP).\nKeys:\n\nChoose prime \\(p\\), generator \\(\\alpha \\in \\mathbb{Z}_p^*\\), secret \\(a\\)\nCompute \\(y = \\alpha^a \\bmod p\\)\nPublic: \\((p, \\alpha, y)\\) | Private: \\(a\\)\n\nEncryption: For message \\(m\\), choose unique random \\(k\\)\n\n\\(\\gamma = \\alpha^k \\bmod p\\)\n\\(\\delta = m \\cdot y^k \\bmod p\\)\nSend \\((\\gamma, \\delta)\\)\n\nDecryption: \\(m = \\delta \\cdot \\gamma^{-a} \\bmod p\\)\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nElGamal Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates a prime number \\(p\\) (len(\\(p\\)) ≥ 1024 bits) and a generator \\(\\alpha\\) of the multiplicative group \\(\\mathbb{Z}_p^*\\)\nA generates a random number \\(a\\), such that \\(1 \\leq a \\leq p-2\\) and computes \\(y := \\alpha^a \\bmod p\\)\nThe public key of A is \\((p, \\alpha, y)\\), the private key of A is \\(a\\)\n\nEncryption\n\nEntity B obtains \\((p, \\alpha, \\alpha^a \\bmod p)\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nFor each message \\(m_i\\):\n\nB generates a unique random number \\(k\\), such that \\(1 \\leq k \\leq p-2\\)\nB computes \\(\\gamma := \\alpha^k \\bmod p\\) and \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) and sends the ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA uses its private key \\(a\\) to compute \\(\\gamma^{p-1-a} \\bmod p\\) (note that: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrieves the plaintext by computing: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBase: DLP in \\(\\mathbb{Z}_p^*\\)\nCiphertext: \\((\\alpha^k, m \\cdot y^k)\\)\nSecurity: \\(k\\) must be unique and large\nDisadvantage: doubles message size\n\n\n\n\nEssential Remarks\n\nProof: \\(\\delta \\cdot \\gamma^{-a} = m \\cdot (\\alpha^a)^k \\cdot (\\alpha^k)^{-a} = m \\bmod p\\)\nSecurity: based on DLP (complexity sub-exponential close to factorization)\nExponents: \\(k\\) and \\(a\\) must be large (otherwise vulnerable to baby-step giant-step)\nReuse prohibited: if \\(k\\) repeated, \\(\\delta_1/\\delta_2 = m_1/m_2\\) reveals the messages\nMajor disadvantage: ×2 expansion of ciphertext size\nGeneralization: works on \\(GF(2^n)\\) or elliptic curves\n\n\n\n\n\n\n\nNoteOriginal Text - Remarks\n\n\n\n\n\nProof that the scheme works: If \\(s \\equiv k^{-1}(m_h - ar) \\bmod (p-1)\\), we have that: \\(m_h \\equiv (ar + ks) \\bmod (p-1)\\) and \\(v_2 = \\alpha^{H(m)} \\bmod p\\). If, as we wish to show \\(m_h = H(m)\\), by reducing exponents mod \\((p-1)\\), we can rewrite \\(v_2\\): \\(v_2 \\equiv \\alpha^{ar+ks} \\bmod p\\). On the other hand: \\(v_1 = y^r\\alpha^{rs} \\equiv \\alpha^{ar}\\alpha^{ks} \\equiv \\alpha^{ar+ks} \\bmod p\\).\nThe ElGamal procedure is based on the difficulty of computing discrete logarithms modulo a prime number (DLP problem) even though it has not been proven to be strictly equivalent to this problem.\nThe most efficient algorithms known have a sub-exponential complexity very close to that of factorization (we often use the same algorithms).\nThe chosen exponents (\\(k\\), \\(a\\)) must be large because there exist efficient algorithms to compute discrete logarithms modulo a prime number when the exponent is small (baby-step giant-step algorithm).\nA disadvantage of ElGamal is that it multiplies the ciphertext length by 2.\nIt is essential for the security of the procedure that the random number \\(k\\) is not repeated, otherwise: let \\((\\gamma_1, \\delta_1)\\) and \\((\\gamma_2, \\delta_2)\\) be the two generated ciphertexts, we have that \\(\\delta_1/\\delta_2 = m_1/m_2\\) and consequently, it is trivial to recover one plaintext from the other.\nThe ElGamal procedure can be generalized to other groups like \\(GF(2^n)\\) or elliptic curves.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Remarks\n\n\n\n\n\nEquivalence: based on DLP (not proven equivalent)\n\\(k\\) unique: CRITICAL - otherwise \\(m_1/m_2\\) revealed\nKey size: large exponents necessary\nExtensions: \\(GF(2^n)\\), elliptic curves"
  },
  {
    "objectID": "exam_notes_en.html#elgamal-encryptiondecryption-procedure",
    "href": "exam_notes_en.html#elgamal-encryptiondecryption-procedure",
    "title": "Fundamental Security Services",
    "section": "ElGamal Encryption/Decryption Procedure",
    "text": "ElGamal Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates a prime number \\(p\\) (len(\\(p\\)) ≥ 1024 bits) and a generator \\(\\alpha\\) of the multiplicative group \\(\\mathbb{Z}_p^*\\)\nA generates a random number \\(a\\), such that \\(1 \\leq a \\leq p-2\\) and computes \\(y := \\alpha^a \\bmod p\\)\nThe public key of A is \\((p, \\alpha, y)\\), the private key of A is \\(a\\)\n\nEncryption\n\nEntity B obtains \\((p, \\alpha, \\alpha^a \\bmod p)\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, p-1]\\) \\(\\forall i\\)\nFor each message \\(m_i\\):\n\nB generates a unique random number \\(k\\), such that \\(1 \\leq k \\leq p-2\\)\nB computes \\(\\gamma := \\alpha^k \\bmod p\\) and \\(\\delta := m_i \\cdot (\\alpha^a)^k \\bmod p\\) and sends the ciphertext \\(c := (\\gamma, \\delta)\\)\n\n\nDecryption\n\nA uses its private key \\(a\\) to compute \\(\\gamma^{p-1-a} \\bmod p\\) (note that: \\(\\gamma^{p-1-a} \\equiv \\gamma^{-a} \\equiv \\alpha^{-ak} \\bmod p\\))\nA retrieves the plaintext by computing: \\(\\delta \\cdot \\gamma^{-ak} \\bmod p\\)"
  },
  {
    "objectID": "exam_notes_en.html#rabin-algorithm",
    "href": "exam_notes_en.html#rabin-algorithm",
    "title": "Fundamental Security Services",
    "section": "Rabin Algorithm",
    "text": "Rabin Algorithm\nAsymmetric system equivalent to factorization (provably secure).\nKeys:\n\nGenerate two primes \\(p\\), \\(q\\) (≥1024 bits total), compute \\(n = pq\\)\n\nPublic: \\(n\\)\nPrivate: \\((p, q)\\)\n\n\nEncryption: \\(c = m^2 \\bmod n\\)\nDecryption:\n\nCompute the 4 square roots of \\(c \\bmod n\\) (via roots mod \\(p\\) and mod \\(q\\))\nIdentify the correct message by redundancy\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nRabin Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates two random prime numbers \\(p\\) and \\(q\\) of large size (len(\\(pq\\)) ≥ 1024)\nA computes \\(n := pq\\)\nThe public key of A is \\(n\\), the private key of A is \\((p, q)\\)\n\nEncryption\n\nEntity B obtains \\(n\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB computes \\(c_i = m_i^2 \\bmod n\\) for each message \\(m_i\\)\nB sends all the ciphertexts \\(c_i\\) to A\n\nDecryption\n\nA uses its private key \\((p, q)\\) to retrieve the 4 solutions of the equation: \\(c_i = x^2 \\bmod n\\) using efficient algorithms to compute square roots \\(\\bmod p\\) and \\(\\bmod q\\)\nA determines either by an additional indication from B, or by redundancy analysis which of the 4 messages \\(m_1, m_2, m_3, m_4\\) is the original plaintext\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBase: SQROOTP (square root mod composite)\nAdvantage: proven equivalent to factorization\nProblem: 4 possible solutions, requires redundancy\nVulnerability: chosen-ciphertext attack reveals factors\n\n\n\n\nEssential Remarks\n\nProven security: SQROOTP ⟺ FACTP (only algorithm with proven equivalence)\nChosen-ciphertext attack: if A decrypts \\(c = m^2 \\bmod n\\) chosen by adversary M\n\nM receives a root \\(m_x\\) among 4 possible\nIf \\(m \\neq m_x \\bmod n\\) (prob. 0.5), then \\(\\gcd(m - m_x, n)\\) gives a factor of \\(n\\)\n\nSolution: require sufficient redundancy to identify unique solution without ambiguity\n\n\n\n\n\n\n\nNoteOriginal Text - Remarks\n\n\n\n\n\nThe Rabin procedure is based on the impossibility of finding square roots modulo a composite of unknown factorization (SQROOTP problem).\nThe main interest of this algorithm lies in the fact that it has been proven to be equivalent to factorization (SQROOTP ⟺ FACTP). This algorithm therefore belongs to the provably secure category for any passive attack.\nActive attacks can, in some cases, compromise the algorithm’s security. More precisely, if we mount the following chosen ciphertext attack:\n\nThe attacker M generates an \\(m\\) and sends to A the ciphertext \\(c = m^2 \\bmod n\\).\nA responds with a root \\(m_x\\) among the 4 possible \\(m_1, m_2, m_3, m_4\\).\nIf \\(m \\neq m_x \\bmod n\\) (probability 0.5), M repeats with a new \\(m\\).\nOtherwise, A computes \\(\\gcd(m - m_x, n)\\) and thus obtains one of the two factors of \\(n\\).\n\nThis attack could be avoided if the procedure required sufficient redundancy in the plaintexts allowing A to identify without ambiguity which of the possible solutions is the original plaintext. In this case, A would always respond with \\(m\\) and discard the other solutions that do not have the predefined level of redundancy.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Remarks\n\n\n\n\n\nUnique: only algorithm proven equivalent to FACTP\nAttack: chosen-ciphertext gives factors (prob. 0.5)\nCountermeasure: mandatory redundancy in messages"
  },
  {
    "objectID": "exam_notes_en.html#rabin-encryptiondecryption-procedure",
    "href": "exam_notes_en.html#rabin-encryptiondecryption-procedure",
    "title": "Fundamental Security Services",
    "section": "Rabin Encryption/Decryption Procedure",
    "text": "Rabin Encryption/Decryption Procedure\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA generates two random prime numbers \\(p\\) and \\(q\\) of large size (len(\\(pq\\)) ≥ 1024)\nA computes \\(n := pq\\)\nThe public key of A is \\(n\\), the private key of A is \\((p, q)\\)\n\nEncryption\n\nEntity B obtains \\(n\\), the authentic public key of A\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in [0, n-1]\\) \\(\\forall i\\)\nB computes \\(c_i = m_i^2 \\bmod n\\) for each message \\(m_i\\)\nB sends all the ciphertexts \\(c_i\\) to A\n\nDecryption\n\nA uses its private key \\((p, q)\\) to retrieve the 4 solutions of the equation: \\(c_i = x^2 \\bmod n\\) using efficient algorithms to compute square roots \\(\\bmod p\\) and \\(\\bmod q\\)\nA determines either by an additional indication from B, or by redundancy analysis which of the 4 messages \\(m_1, m_2, m_3, m_4\\) is the original plaintext"
  },
  {
    "objectID": "exam_notes_en.html#comparison-rsa---elgamal---rabin",
    "href": "exam_notes_en.html#comparison-rsa---elgamal---rabin",
    "title": "Fundamental Security Services",
    "section": "Comparison RSA - ElGamal - Rabin",
    "text": "Comparison RSA - ElGamal - Rabin\n\n\n\n\n\n\n\n\n\nCriterion\nRSA\nElGamal\nRabin\n\n\n\n\nProblem\nRSAP\nDLP\nSQROOTP\n\n\nSecurity\nEquiv. factorization (generic case)\nBased on DLP\nProven ⟺ factorization\n\n\nExpansion\n1:1\n1:2\n1:1\n\n\nDecryption\nDeterministic\nDeterministic\n4 solutions\n\n\nSignature\nYes\nYes\nYes (with precautions)"
  },
  {
    "objectID": "exam_notes_en.html#elliptic-curves-basic-idea",
    "href": "exam_notes_en.html#elliptic-curves-basic-idea",
    "title": "Fundamental Security Services",
    "section": "Elliptic Curves (Basic Idea)",
    "text": "Elliptic Curves (Basic Idea)\n\nFundamental Concept\nAn elliptic curve \\(E\\) is defined by: \\(y^2 = x^3 + ax + b\\) (with discriminant \\(4a^3 + 27b^2 \\neq 0\\)).\nKey operation: Point addition\n\nGeometrically: draw a line between two points \\(P\\) and \\(Q\\), find the 3rd intersection point, then take its symmetric\nForms a commutative group with point at infinity \\(\\mathcal{O}\\) as identity\nScalar multiplication: \\(kP = P + P + ... + P\\) (\\(k\\) times)\n\nCryptographic advantage:\n\nThe ECDLP problem: finding \\(k\\) such that \\(Q = kP\\) is very difficult (exponential effort)\nShorter keys for same security as in \\(\\mathbb{Z}_p^*\\)\n\n\n\n\n\n\n\nNoteOriginal Text - Definition\n\n\n\n\n\nAn elliptic curve is a set of points \\(E\\) defined by the equation: \\(y^2 = x^3 + ax + b\\), with \\(x, y, a\\) and \\(b\\) rational numbers, integers or integers modulo \\(m\\) (\\(m &gt; 1\\)). The set \\(E\\) also contains a “point at infinity” denoted \\(\\mathcal{O}\\). The point \\(\\mathcal{O}\\) is not on the curve but it is the identity element of \\(E\\).\nWe will choose for our calculations elliptic curves that do not have multiple roots or, in other words, curves where the discriminant \\(4a^3 + 27b^2 \\neq 0\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Concept\n\n\n\n\n\nEquation: \\(y^2 = x^3 + ax + b\\)\nStructure: group with \\(\\mathcal{O}\\)\nOperation: geometric addition\nHard problem: ECDLP\n\n\n\n\n\nAddition on Elliptic Curves\nLet \\(P := (x, y) \\in E\\), we define \\(-P := (x, -y)\\) (symmetric with respect to the x-axis). We have \\(P + (-P) = \\mathcal{O}\\).\nFor two points \\(P, Q \\in E\\) with \\(Q \\neq -P\\), we define \\(P + Q := R\\) where \\(-R\\) is the 3rd intersection point between the curve and the line passing through \\(P\\) and \\(Q\\).\nFor doubling: \\(2P = R\\) where \\(-R\\) is the intersection point of the curve with the tangent to the curve at point \\(P\\).\n\n\n\n\n\n\nNoteOriginal Text - Addition\n\n\n\n\n\nLet \\(P := (x, y) \\in E\\), we define \\(-P\\) as \\(-P := (x, -y)\\). Graphically, \\(-P\\) is the symmetric point of \\(P\\) with respect to the x-axis. Note that \\(P + (-P) = \\mathcal{O}\\).\nLet two points \\(P, Q \\in E\\), such that \\(Q \\neq -P\\), we define the addition \\(P + Q := R\\) where \\(R \\in E\\) such that \\(-R\\) is the 3rd intersection point between the curve and the line passing through \\(P\\) and \\(Q\\).\nThe set \\(E\\) with \\(\\oplus\\) defines a commutative group for addition.\nLet \\(P \\in E\\), the point \\(2P = R\\), such that \\(-R\\) is the intersection point of the curve with the line tangent to the curve at point \\(P\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision - Addition\n\n\n\n\n\nInverse: \\(-P = (x, -y)\\)\nAddition: 3rd intersection point + symmetry\nDoubling: tangent + symmetry\nProperty: commutative group\n\n\n\n\n\nECDLP and Cryptographic Advantages\nWhen the elliptic curve is defined over the field \\(\\mathbb{Z}_p\\) with \\(p\\) a large prime (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), the computation of \\(k \\in \\mathbb{Z}_p\\) such that \\(Q = kP\\) with \\((P, Q)\\) known is very difficult (exponential effort). This problem is the Elliptic Curve Discrete Logarithm Problem (ECDLP).\nMain advantage: key sizes much smaller for equivalent security.\n\n\n\n\n\n\nNoteOriginal Text - ECDLP and Advantages\n\n\n\n\n\nWhen the elliptic curve is defined over the field \\(\\mathbb{Z}_p\\) with \\(p\\) a large prime number (\\(y^2 \\equiv x^3 + ax + b \\bmod p\\)), the computation of \\(k \\in \\mathbb{Z}_p\\) such that \\(Q = kP\\) with \\((P, Q)\\) known, is very difficult (requires exponential effort). This problem is known as: Elliptic Curve Discrete Logarithm Problem (ECDLP).\nThe main advantage of public cryptography based on elliptic curves is that the size of the numbers used (and therefore, keys) is smaller.\nThis is due to the increased complexity of computations on \\(E_p\\) (elliptic curve defined over field \\(\\mathbb{Z}_p\\)) compared to usual fields such as \\(\\mathbb{Z}_p\\) or \\(GF(2^m)\\).\nThe representation of a plaintext as points of the curve remains a complex operation.\nIn October 2003, the US National Security Agency (NSA) purchased a patent from Certicom for the use of elliptic curve cryptography.\nIn September 2013 Claus Diem showed that under certain conditions the ECDLP problem could be solved in sub-exponential time.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - ECDLP\n\n\n\n\n\nProblem: finding \\(k\\) in \\(Q = kP\\) (exponential)\nGain: keys ~6-10× shorter\nLimit: representing messages as points difficult\nNSA: adopted in 2003\n\n\n\n\n\nKey Size Comparison Table\n\n\n\nAES (symmetric)\nRSA/DH\nElliptic Curves\nRatio\n\n\n\n\n56 bits\n512 bits\n112 bits\n1:4.6\n\n\n80 bits\n1024 bits\n160 bits\n1:6.4\n\n\n112 bits\n2048 bits\n224 bits\n1:9.1\n\n\n128 bits\n3072 bits\n256 bits\n1:12\n\n\n256 bits\n15360 bits\n512 bits\n1:30\n\n\n\n\n\n\n\n\n\nNoteOriginal Text - Table\n\n\n\n\n\nThis table shows the key size ratios compared to RSA for equivalent security.\n(Table extracted from original document)"
  },
  {
    "objectID": "exam_notes_en.html#elgamal-on-elliptic-curves",
    "href": "exam_notes_en.html#elgamal-on-elliptic-curves",
    "title": "Fundamental Security Services",
    "section": "ElGamal on Elliptic Curves",
    "text": "ElGamal on Elliptic Curves\n\nDirect Adaptation\nReplace operations in \\(\\mathbb{Z}_p^*\\) with operations on \\(E_p\\)\nKeys:\n\nChoose curve \\(E_p\\) and point \\(P_0 \\in E_p\\) of large order\nSecret \\(x\\), compute \\(P_a = xP_0\\)\nPublic: \\((E_p, P_0, P_a)\\) | Private: \\(x\\)\n\nEncryption: For message \\(m_i \\in E_p\\)\n\nChoose random \\(k\\)\n\\(\\gamma = kP_0\\), \\(\\delta = kP_a + m_i\\)\nSend \\((\\gamma, \\delta)\\)\n\nDecryption: \\(m_i = \\delta - x\\gamma\\)\n\n\n\n\n\n\nNoteOriginal Text - ElGamal EC\n\n\n\n\n\nKey generation\nEach entity (A) creates a key pair (public and private) as follows:\n\nA chooses an elliptic curve \\(E_p\\) with \\(p\\), a large prime number (len(\\(p\\)) bits) and a point \\(P_0 \\in E_p\\).\nA generates a random number \\(x\\), such that \\(1 \\leq x \\leq p\\) and computes \\(P_a = xP_0\\) (multiplication by a scalar on \\(E_p\\), for which efficient algorithms exist).\nThe public key of A is \\((E_p, P_0, P_a)\\), the private key of A is \\(x\\).\n\nEncryption\nEntity B obtains \\((E_p, P_0, P_a)\\), the authentic public key of A.\n\nB transforms its plaintext into a series of integers \\(m_i\\), such that \\(m_i \\in E_p\\) for all \\(i\\).\nFor each message \\(m_i\\):\n\nB generates a unique random number \\(k\\), such that \\(1 \\leq k \\leq p\\).\nB computes \\(\\gamma := kP_0\\) and \\(\\delta := kP_a + m_i\\) and sends the ciphertext \\(c := (\\gamma, \\delta)\\).\n\n\nDecryption\n\nA uses its private key \\(x\\) to compute: \\(x\\gamma = xkP_0 = kP_a\\).\nA retrieves the plaintext by computing: \\(\\delta - kP_a = kP_a + m_i - kP_a = m_i\\).\n\nThe security of the scheme relies on ECDLP!\nIt is also necessary to authenticate the exchanged public parts to avoid the previously described man-in-the-middle attacks.\nThe properties of the protocol are identical to the \\(\\mathbb{Z}_p^*\\) case.\n\n\n\n\n\n\n\n\n\nTipQuick Revision - ElGamal EC\n\n\n\n\n\nPrinciple: same as ElGamal on \\(E_p\\)\nOperations: + and scalar multiplication on points\nSecurity: ECDLP\nAuthentication: necessary against MitM\nAdvantage: short keys"
  },
  {
    "objectID": "exam_notes_en.html#one-way-functions-owf",
    "href": "exam_notes_en.html#one-way-functions-owf",
    "title": "Fundamental Security Services",
    "section": "One-Way Functions (OWF)",
    "text": "One-Way Functions (OWF)\nA function \\(f\\) is one-way if \\(f(x) = y\\) is easy to compute, but finding \\(x\\) from \\(y\\) is computationally impossible for the majority of values.\nExamples:\n\nSquares modulo composite: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\)\nDES construction: \\(y = E_k(x) \\oplus x\\) with \\(k\\) fixed and known\n\nNote: OWF ≠ OWHF (hash functions impose compression and 2nd-preimage resistance).\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA function f is called one-way (one-way function or OWF) if for \\(x \\in X\\) we can easily compute \\(f(x) = y\\) but for the vast majority of \\(y \\in Y\\) it is computationally impossible to find an \\(x\\) such that \\(f(x) = y\\).\nExamples:\n\ncomputing squares modulo a composite: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\) (p and q unknown) is a one-way function because the inverse is difficult (see the basic problem SQROOTP).\nwe can construct a one-way function based on DES or any other block encryption system \\(E\\) as follows: \\(y = f(x) = E_k(x) \\oplus x\\), \\(\\forall x\\), with \\(k\\) a fixed and known key. We can consider that \\(E_k(x) \\oplus x\\) has (pseudo)random behavior by construction of \\(E\\). Computing the inverse amounts to finding an \\(x\\) such that: \\(x = E_k^{-1}(x \\oplus y)\\), which is considered difficult given the properties of \\(E\\). Note that \\(f(x) = E_k(x)\\) would not be sufficient to make an OWF because, with the key known, DES is reversible.\n\nOWF ≠ OWHF: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.\nExample: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\) (p and q unknown) is not an OWHF because given \\(x\\), \\(-x\\) is a trivial collision.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nOWF: easy in one direction (\\(f(x) \\to y\\)), impossible in the other (\\(y \\to x\\)).\nExamples: modular squares, \\(E_k(x) \\oplus x\\).\nOWF ≠ OWHF (hash functions = more constraints)."
  },
  {
    "objectID": "exam_notes_en.html#hash-functions-definitions",
    "href": "exam_notes_en.html#hash-functions-definitions",
    "title": "Fundamental Security Services",
    "section": "Hash Functions: Definitions",
    "text": "Hash Functions: Definitions\nA hash function \\(h\\) has two essential properties:\n\nCompression: transforms data of arbitrary length into fixed-length output\nEase of computation: \\(h(x)\\) is fast to compute\n\nClassification:\n\nUnkeyed (no key): MDC (Manipulation Detection Code)\nKeyed (with key): MAC (Message Authentication Code)\n\nSecurity properties:\n\nPreimage resistance: given \\(y\\), impossible to find \\(x\\) such that \\(h(x) = y\\)\n2nd-preimage resistance (weak collision): given \\(x\\), impossible to find \\(x' \\neq x\\) such that \\(h(x) = h(x')\\)\nCollision resistance (strong collision): impossible to find any \\(x \\neq x'\\) with \\(h(x) = h(x')\\)\n\nTerminology:\n\nOWHF (weak one-way): satisfies (1) and (2)\nCRHF (strong one-way): satisfies (2) and (3)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA hash function is a function \\(h\\) having the following properties:\n\ncompression: the function \\(h\\) maps a set \\(X\\) composed of bit strings of finite but arbitrary length to a set \\(Y\\) composed of bit strings of finite and fixed length (and normally smaller than the size of \\(X\\)) with \\(h(x) = y\\), and \\(x \\in X\\), \\(y \\in Y\\).\neasy to compute: given \\(h\\) and \\(x \\in X\\), \\(h(x)\\) is easy to compute.\n\nA hash function is called “keyed” (keyed hash function) if a key is involved in the computation of the function (\\(h_k(x) = y\\)); otherwise it is called “unkeyed” (unkeyed hash function).\nHash functions have many computer applications including structured archiving facilitating search. On the security side we will study two main categories:\n\nmanipulation detection codes (MDC) or message integrity codes (MIC): these are unkeyed functions allowing to provide an integrity service under certain conditions. The result of such a function is called MDC-value or simply digest.\nmessage authentication codes (MAC) which are keyed functions allowing to authenticate the source of the message and ensure its integrity without using additional (encryption) mechanisms.\n\nSome basic properties of hash functions:\n\n1) preimage resistance: given a \\(y \\in Y\\), it is computationally impossible to find a preimage \\(x \\in X\\) satisfying \\(h(x) = y\\).\n2) 2nd-preimage resistance: given an \\(x \\in X\\) and its image \\(y \\in Y\\), with \\(h(x) = y\\), it is computationally impossible to find an \\(x' \\neq x\\) such that \\(h(x) = h(x')\\). Also called weak collision resistance.\n3) collision resistance: it is computationally impossible to find two distinct preimages \\(x, x' \\in X\\) for which \\(h(x) = h(x')\\) (no restriction on the choice of values). Also called strong collision resistance.\n\nA one-way hash function (OWHF) is an MDC satisfying 1) and 2). Also called: weak one-way hash function.\nA collision resistant hash function (CRHF) is an MDC satisfying properties 2) and 3). (Note that 3) ⇒ 2)). Also called: strong one-way hash function.\nOWF ≠ OWHF: Note that an OWHF as a hash function imposes additional restrictions on the source and image domains as well as on 2nd-preimage resistance that are not necessarily satisfied by OWFs.\nExample: \\(f(x) = x^2 \\bmod n\\) with \\(n = pq\\) (p and q unknown) is not an OWHF because given \\(x\\), \\(-x\\) is a trivial collision.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nHash function: compression + easy computation\nMDC (unkeyed) for integrity\nMAC (keyed) for authentication\nProperties\n\npreimage resistance\n2nd-preimage resistance\ncollision resistance\n\nOWHF = (1)+(2)\nCRHF = (2)+(3)."
  },
  {
    "objectID": "exam_notes_en.html#message-authentication-codes-macs",
    "href": "exam_notes_en.html#message-authentication-codes-macs",
    "title": "Fundamental Security Services",
    "section": "Message Authentication Codes (MACs)",
    "text": "Message Authentication Codes (MACs)\nA MAC is a family of functions \\(h_k\\) parameterized by a secret key \\(k\\):\nProperties:\n\nCompression: arbitrary input → fixed output\nEasy to compute: with known \\(k\\), \\(h_k(x)\\) is fast\nComputation-resistance: without \\(k\\), impossible to compute valid pairs \\((x, h_k(x))\\)\n\nImplications:\n\nKey non-recovery: impossible to recover \\(k\\) from pairs \\((x_i, h_k(x_i))\\)\nPreimage and collision resistance for anyone not possessing \\(k\\)\n\nUsage: Source authentication + message integrity without directly revealing secrets.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA Message Authentication Code (MAC) is a family of functions \\(h_k\\) parameterized by a secret key \\(k\\) having the following properties:\n\n1) compression: as for generic hash functions but applied to \\(h_k\\).\n2) easy to compute: from a function \\(h_k\\), and a known key \\(k\\), we can easily compute \\(h_k(x)\\). The result is called a MAC-value or simply a MAC.\n3) computational resistance (computation-resistance): without knowledge of the symmetric key \\(k\\), it is (computationally) impossible to compute pairs \\((x, h_k(x))\\) from 0 or several known pairs \\((x_i, h_k(x_i))\\) for any \\(x \\neq x_i\\).\n\nProperty 3) implies that the pairs \\((x_i, h_k(x_i))\\) cannot be used to compute the key \\(k\\) (key non-recovery). However the key non-recovery property does not imply computation-resistance because chosen/known-plaintext attacks could lead to forged pairs \\((x, h_k(x))\\).\nThe impossibility of computing pairs \\((x, h_k(x))\\) also translates to preimage and collision resistance (cf. previous slide) for any entity not possessing the key \\(k\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nMAC = hash with key \\(k\\)\nWithout \\(k\\): impossible to forge \\((x, h_k(x))\\) or recover \\(k\\)\nGuarantees source authentication + integrity."
  },
  {
    "objectID": "exam_notes_en.html#attacks-on-mdcs",
    "href": "exam_notes_en.html#attacks-on-mdcs",
    "title": "Fundamental Security Services",
    "section": "Attacks on MDCs",
    "text": "Attacks on MDCs\n\n2nd-Preimage Resistance Attack\nProblem: Given \\(h(x) = y\\), find \\(x'\\) such that \\(h(x') = h(x)\\).\nProbabilistic analysis:\nFor an \\(m\\)-bit digest (\\(n = 2^m\\) possible outputs), the probability of having at least one collision after \\(k\\) attempts is:\n\\[P(\\text{collision}) \\approx 1 - (1-1/n)^k \\approx k/n\\]\nFor \\(P = 0.5\\): \\(k = n/2 = 2^{m-1}\\)\nConclusion: For an \\(m\\)-bit digest, approximately \\(2^{m-1}\\) attempts are needed to find a 2nd-preimage with probability 0.5.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nProblem: given \\(h(x) = y\\), find \\(x'\\) such that \\(h(x')=h(x)\\).\nPractical example: we have a text with an associated digest bearing a digital signature; we want to create a fake text bearing the same signature (without control over the original text). What are our chances from a probabilistic point of view?\nLet a hash function \\(h\\) with \\(n\\) possible outputs and a given value \\(h(x)\\). If \\(h\\) is applied to \\(k\\) random values, what must be the value of \\(k\\) so that the probability of having at least one \\(y\\) such that \\(h(x) = h(y)\\) is 0.5?\nFor the first value of \\(y\\), the probability that \\(h(x) = h(y)\\) is \\(1/n\\). Conversely, the probability that \\(h(x) \\neq h(y)\\) is \\(1-1/n\\). For \\(k\\) values, the probability of having no collision is: \\((1-1/n)^k\\), i.e.:\n\\[\\left(1 - \\frac{1}{n}\\right)^k = 1 - \\frac{k}{n} + \\frac{1}{2!}\\left(\\frac{k}{n}\\right)^2 - \\frac{1}{3!}\\left(\\frac{k}{n}\\right)^3 + \\ldots\\]\nwhich for very large \\(n\\) can be approximated by \\(1 - k/n\\). Therefore, the complementary probability of having at least one collision is about \\(k/n\\); which gives us \\(k = n/2\\) for a probability of 0.5.\nConclusion: for an \\(m\\)-bit digest, the number of attempts needed to find a \\(y\\) such that \\(h(x) = h(y)\\) with a probability of 0.5 is \\(2^{m-1}\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nTo break 2nd-preimage resistance with \\(m\\)-bit digest: \\(2^{m-1}\\) attempts (prob 0.5).\n\n\n\n\n\nCollision Resistance Attack: Birthday Paradox\nProblem: Find two distinct values \\(x, x'\\) such that \\(h(x) = h(x')\\).\nBirthday paradox: In a group of 23 people, probability &gt; 0.5 of having two people with the same birthday.\nMathematical result:\nFor \\(n\\) possible outputs, the probability of collision after \\(k\\) computations:\n\\[P(\\text{at least 1 collision}) = 1 - e^{-k(k-1)/(2n)}\\]\nFor \\(P \\geq 0.5\\): \\(k \\approx 1.17\\sqrt{n}\\)\nCryptographic consequence: For an \\(m\\)-bit digest (\\(n = 2^m\\) outputs), approximately \\(2^{m/2}\\) computations are needed to find a collision with probability &gt; 0.5.\nPractical example: Modification of a contract into 237 variations to find a fraudulent version having the same digest as the legitimate version.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nProblem: find two values \\(x, x'\\) distinct such that \\(h(x) = h(x')\\).\nPractical example: We have to have someone sign a text and we want to apply this signature to a falsified text (we control the original text). What are our chances of finding two original texts satisfying this criterion?\nThe birthday paradox is a classic probabilistic problem that shows that in a gathering of only 23 people, there is already a 50% chance of having two people with the same birthday.\nLet \\(y_1, y_2,..., y_n\\) all the possible outputs of a hash function. How many \\(h(x_i)\\): \\(h(x_1), h(x_2),...,h(x_k)\\) must we compute to have a probability of collision equal to or greater than 0.5?\nThe first choice for \\(h(x_1)\\) is arbitrary (prob = 1), the second \\(h(x_2) \\neq h(x_1)\\) has a probability of \\(1 - 1/n\\), the third of \\(1 - 2/n\\), etc. This gives us a probability of having no collisions equal to:\n\\[P_{\\text{no collision}} = \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right)\\]\nWe easily prove (series expansion of \\(e^{-x}\\)) that for \\(0 \\leq x \\leq 1\\): \\(1-x \\leq e^{-x}\\) and therefore:\n\\[P_{\\text{no coll}} \\leq \\prod_{i=1}^{k-1}\\left(1 - \\frac{i}{n}\\right) \\leq \\prod_{i=1}^{k-1} e^{-i/n} = e^{-k(k-1)/(2n)}\\]\nThe probability of having at least one collision is \\(P_{\\text{at least1}} = 1 - P_{\\text{no-coll}}\\). To know the value of \\(k\\) for which \\(P_{\\text{at least1}}\\) is greater than 0.5, it suffices to calculate:\n\\[\\frac{1}{2} \\leq 1 - e^{-k(k-1)/(2n)}\\]\nIf \\(k\\) is large, we replace \\(k(k-1)\\) by \\(k^2\\) and we obtain after simple calculations:\n\\[k \\geq \\sqrt{2\\ln(2) \\cdot n} \\approx 1.17\\sqrt{n}\\]\nTaking \\(n = 365\\) for the birthday, we get \\(k = 22.3\\), which confirms the statement of the problem.\nConsequence for hash functions: Let a hash function with \\(2^m\\) possible outputs. If \\(h\\) is applied to \\(k = 2^{m/2}\\) inputs we have a probability greater than 0.5 of obtaining \\(h(x_i) = h(x_j)\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBirthday paradox: to break collision resistance with \\(m\\)-bit digest: \\(2^{m/2}\\) attempts (prob &gt; 0.5).\nExample: 23 people suffice for identical birthdays."
  },
  {
    "objectID": "exam_notes_en.html#computational-resistance-recap",
    "href": "exam_notes_en.html#computational-resistance-recap",
    "title": "Fundamental Security Services",
    "section": "Computational Resistance: Recap",
    "text": "Computational Resistance: Recap\nFor a hash function with \\(n\\)-bit digest and MAC key of \\(t\\) bits:\n\n\n\nType\nProperty\nDifficulty\nRecommended Size\n\n\n\n\nOWHF\nPreimage\n\\(2^n\\)\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage\n\\(2^{n-1}\\)\n\n\n\nCRHF\nCollision\n\\(2^{n/2}\\)\n\\(n \\geq 256\\) bits\n\n\nMAC\nKey recovery\n\\(2^t\\)\n\\(t \\geq 256\\) bits\n\n\n\nComputation\n\\(\\min(2^t, 2^n)\\)\n\\(n \\geq 128\\) bits\n\n\n\nPractical implications:\n\nFor integrity only (OWHF): 128 bits sufficient\nFor collision resistance (CRHF): minimum 256 bits\nMACs: 256-bit key, 128-bit digest minimum\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\n\\(n\\): size of the MDC-value or MAC-value resulting from the application of the hash function\n\\(t\\): size of the MAC key\n\n\n\n\n\n\n\n\n\n\nHash Fct. Type\nCharacteristic\nComputational Difficulty\nAttack Goal\nRecommended digest/key size\n\n\n\n\nOWHF\npreimage resistance\n\\(2^n\\)\nfind a preimage\n\\(n \\geq 128\\) bits\n\n\n\n2nd-preimage resistance\n\\(2^{n-1}\\)\nfind \\(x'\\) with \\(h(x') = h(x)\\)\n\n\n\nCRHF\ncollision resistance\n\\(2^{n/2}\\)\nfind a collision\n\\(n \\geq 256\\) bits\n\n\nMAC\nkey non-recovery\n\\(2^t\\)\nfind the key\n\\(n \\geq 128\\)\n\n\n\ncomputation resistance\n\\(\\min(2^t,2^n)\\)\nproduce a \\((x, h_k(x))\\)\n\\(t \\geq 256\\)\n\n\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nEfforts: preimage \\(2^n\\), 2nd-preimage \\(2^{n-1}\\), collision \\(2^{n/2}\\).\nSizes: OWHF ≥128 bits, CRHF ≥256 bits, MAC key ≥256 bits."
  },
  {
    "objectID": "exam_notes_en.html#mdcs-based-on-encryption-systems",
    "href": "exam_notes_en.html#mdcs-based-on-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "MDCs Based on Encryption Systems",
    "text": "MDCs Based on Encryption Systems\nPrinciple: Use a symmetric encryption algorithm (DES, AES) to construct an MDC.\nChallenges to solve:\n\nBreak the reversibility of symmetric algorithms\nIncrease the nominal width (DES = 64 bits insufficient for CRHF)\n\nOperation:\n\nSequential processing of blocks\nChaining operations with XOR\nCombination of \\(n\\) boxes for digests of size \\(n \\times\\) nominal width\n\nClassical models:\n\nMatyas-Meyer-Oseas: \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1}\\)\nDavies-Meyer: \\(H_i = E_{m_i}(H_{i-1}) \\oplus m_i\\)\nMiyaguchi-Preneel: \\(H_i = E_{m_i}(H_{i-1}) \\oplus H_{i-1} \\oplus m_i\\)\n\nPractical examples:\n\nMDC-2: uses 2 DES boxes → 128-bit digest\nMDC-4: uses 4 DES boxes → 128-bit digest\n\nLimitation: Security strongly dependent on the underlying algorithm.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nIdea: use a known symmetric encryption system to construct an MDC.\nProblems to solve:\n\nwe must “break” the reversibility of symmetric algorithms to make them OWHF or CRHF.\nThe “nominal width” of some encryption systems (eg. DES) is 64 bits, which is not sufficient to build CRHF.\n\nOperating principle:\n\nthe text blocks are sequentially processed by the encryption “box”.\ncompression is based on chaining operations with the blocks resulting from previous iterations and logical functions (fundamentally XOR). This also makes the process irreversible.\nIf necessary, \\(n\\) encryption boxes will be combined to obtain digest lengths \\(n\\) times greater than the nominal width of the boxes used.\n\nAttention: the security of these algorithms is strongly dependent on the properties of the underlying encryption boxes.\nExamples:\n\nThe models of Matyas-Meyer-Oseas, Davies-Meyer and Miyaguchi-Preneel.\nMDC-2 and MDC-4 using respectively 2 and 4 DES boxes. Digest = 128 bits.\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nMDCs from symmetric crypto: break reversibility + chaining XOR.\nModels: Matyas-Meyer-Oseas, Davies-Meyer, Miyaguchi-Preneel.\nMDC-2/4 with DES → 128 bits."
  },
  {
    "objectID": "exam_notes_en.html#customized-mdcs",
    "href": "exam_notes_en.html#customized-mdcs",
    "title": "Fundamental Security Services",
    "section": "Customized MDCs",
    "text": "Customized MDCs\nFunctions specifically designed for digest generation, optimized for speed and security.\nConstruction elements:\n\nPadding + adding the message length\nPredefined constants to increase dispersion\nSuccessive rounds with logical operations and rotations\nChaining of outputs between rounds\nEvery bit of the digest depends on every input bit\n\nMain algorithms:\n\n\n\nAlgorithm\nYear\nDigest\nStatus\n\n\n\n\nMD5\n1992\n128 bits\n❌ Broken\n\n\nSHA-0\n1993\n160 bits\n❌ Collisions in \\(2^{39}\\)\n\n\nSHA-1\n1995\n160 bits\n⚠️ Collisions in \\(2^{63}\\)\n\n\nSHA-2\n-\n224-512 bits\n✓ Currently secure\n\n\nSHA-3 (Keccak)\n2012\n224-512 bits\n✓ Current standard\n\n\n\nAttack evolution:\n\n2004: Full collisions on MD5 (X. Wang)\n2005: SHA-1 theoretically broken (\\(2^{63}\\) operations)\n2008: Creation of fraudulent CA certificates via MD5\n2012: SHA-3 adopted as new standard\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nThese are functions designed exclusively to generate integrity codes (digests) with a main concern for speed and security.\nTheir operation is based on the following elements:\n\ninitialization operations (padding + adding the length).\na set of predefined constants chosen specifically to increase dispersion.\na set of “steps” (rounds) that will sequentially apply to all the original data blocks. These rounds will perform a combination of logical operations and rotations on the data and constants.\nchaining operations involving the outputs of previous rounds.\n\nIn these functions, every bit of the digest is a function of every bit of the inputs.\nThe most famous are:\n\nMD5: R. Rivest, 1992; RFC 1321. Digest = 128 bits. Broken!\nSHA-0: NIST, 1993. Digest = 160 bits. Collisions in \\(2^{39}\\) operations instead of \\(2^{80}\\)\nSHA-1: NIST, 1995. Digest = 160 bits. Revision of SHA-0 with additional bit rotation. Collisions in \\(2^{63}\\) operations (instead of \\(2^{80}\\)).\nSHA-2: NIST (FIPS 190-3). Includes: SHA-224, SHA-256, SHA-384 and SHA-512. Digest sizes range from 224 to 512 bits.\nSHA-3: Keccak Algorithm (digest size variable from 224 to 512 bits)\n\nLatest Developments:\n\nX.Wang et al. culminated in 2004 a long work aiming to find collisions in the MD5 algorithm. They publish two pairs of collisions for 1024-bit messages.\nIn 2005, X.Wang et al. prove at the CRYPTO’05 conference that the number of operations needed to find collisions on SHA-1 (current standard for secure hash functions) is only \\(2^{63}\\).\nThese attacks target the search for arbitrary collisions but during CRYPTO’06 researchers from the University of Graz in Austria propose a method to partially control the content of collisions.\nIn December 2008 it is shown that controlled collisions on MD5 can be generated and thus create an illicit Certification Authority allowing to forge certificates accepted by any browser.\nThese results rely on analytical approaches (as opposed to brute force!)\nThe selection process for SHA-1’s successor is similar to the one that designated AES as a block encryption standard. NIST decided (October 2012) that Keccak would be the base algorithm for SHA-3.\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nCustomized MDCs\n\nMD5 (broken)\nSHA-0 (broken)\nSHA-1 (weak)\nSHA-2 (secure)\nSHA-3/Keccak (current standard).\n\nConstruction: padding + constants + rounds + chaining."
  },
  {
    "objectID": "exam_notes_en.html#macs-based-on-encryption-systems",
    "href": "exam_notes_en.html#macs-based-on-encryption-systems",
    "title": "Fundamental Security Services",
    "section": "MACs Based on Encryption Systems",
    "text": "MACs Based on Encryption Systems\nCBC-MAC: Uses a block cipher algorithm in CBC mode.\nOperation:\n\nCBC mode with IV = 0\nElimination of intermediate ciphertexts\nOnly the last encrypted block is kept as MAC\n\nWith DES:\n\nKey length: 56 bits (112 in optional Triple-DES)\nMAC length: 64 bits\n\nAdvantages:\n\nReuse of existing encryption infrastructure\nAcceptable performance\n\nLimitations:\n\nSecurity limited by block size (64 bits for DES)\nVulnerable if used incorrectly (ex: without variable IV)\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nCBC-MAC algorithm based on DES-CBC with IV = 0 and elimination of intermediate ciphertexts\n\nkey length = 56 bits (112 in case of using the optional part)\nMAC-value length = 64 bits\n\nThe diagram shows the sequential processing of message blocks \\(M_1, M_2, M_3\\) with the encryption algorithm \\(E\\) and the key \\(k\\). The intermediate ciphertexts \\(C_1, C_2\\) are eliminated. Only the last block \\(C_3\\) constitutes the MAC.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nCBC-MAC: CBC mode + IV=0, only last block kept. DES: key 56/112 bits, MAC 64 bits."
  },
  {
    "objectID": "exam_notes_en.html#nested-macs-and-hmacs",
    "href": "exam_notes_en.html#nested-macs-and-hmacs",
    "title": "Fundamental Security Services",
    "section": "Nested MACs and HMACs",
    "text": "Nested MACs and HMACs\nNested MAC (NMAC): Composition of two MAC families \\(G\\) and \\(H\\):\n\\[\\text{NMAC}_{k,l}(x) = g_k(h_l(x))\\]\nSecurity: Depends on two criteria:\n\n\\(G\\) resistant to collisions\n\\(H\\) resistant to specific MAC attacks\n\nHMAC (FIPS 198 standard, 2002): Nested MAC using unkeyed MDCs (SHA-1, SHA-256).\nConstruction:\n\nConstants: ipad = 0x363636...36 and opad = 0x5C5C5C...5C (512 bits)\nKey \\(k\\) of 512 bits\n\n\\[\\text{HMAC-256}_k(x) = \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nAdvantages:\n\nMost widely used MACs in practice\nAttacks on SHA more difficult with secret key\nExcellent performance\nStandardized and widely supported\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nA Nested MAC or NMAC is a composition of 2 families of MAC functions \\(G\\) and \\(H\\) parameterized by keys \\(k\\) and \\(l\\) such that:\n\\[G \\circ H = \\{ g \\circ h \\text{ with } g \\in G \\text{ and } h \\in H \\} \\text{ with } g \\circ h_{(k,l)}(x) = g_k(h_l(x))\\]\nThe security of an NMAC depends on two criteria:\n\nThe family of functions \\(G\\) is collision resistant.\nThe family of functions \\(H\\) is resistant to specific attacks for MACs, i.e.: It is impossible to find a pair \\((x,y)\\) and a fixed but unknown key \\(m\\), such that: \\(\\text{MAC}_m(x) = y\\).\n\nAn HMAC (FIPS 198, 2002) is a Nested MAC using at its base dedicated unkeyed MDCs like SHA-1 or SHA-256.\nAn HMAC uses two 512-bit constants called ipad and opad such that:\n\nopad := 363636 ... 36\nipad := 5C5C5C ... 5C\n\nand a key \\(k\\) of 512 bits.\nThe operating scheme of HMAC-256 (based on SHA-256) is as follows:\n\\[\\text{HMAC-256}_k(x) := \\text{SHA-256}((k \\oplus \\text{opad}) \\parallel \\text{SHA-256}((k \\oplus \\text{ipad}) \\parallel x))\\]\nHMACs are the most used MACs. The attacks mentioned on the functions of the SHA family are more difficult to carry out on an HMAC because of the key \\(k\\).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nHMAC: double hash with derived keys (ipad/opad). \\(\\text{HMAC}_k(x) = H((k \\oplus \\text{opad}) \\parallel H((k \\oplus \\text{ipad}) \\parallel x))\\). Standard, secure, performant."
  },
  {
    "objectID": "exam_notes_en.html#hash-functions-applications",
    "href": "exam_notes_en.html#hash-functions-applications",
    "title": "Fundamental Security Services",
    "section": "Hash Functions Applications",
    "text": "Hash Functions Applications\n\nData Integrity\nThree main approaches:\n\nMAC only:\n\n\\(A \\to B: X, \\text{MAC}_k(X)\\)\nAuthentication + integrity guaranteed\nRequires shared key\n\nMDC + Encryption:\n\n\\(A \\to B: E_k(X, \\text{MDC}(X))\\)\nConfidentiality + integrity\nShared symmetric key\n\nMDC + Authentic channel:\n\n\\(A \\to B: X\\) (normal channel)\n\\(A \\to B: \\text{MDC}(X)\\) (authentic channel)\nChannel separation\n\n\nLimitations: These simple protocols offer no protection against replay attacks.\nSolution: add timestamps or sequence numbers.\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nMAC Only: \\[A \\to B: X, \\text{MAC}_k(X)\\] If \\(B\\) computes on its side \\(\\text{MAC}_k(X)\\) and obtains the same value ⇒ the message comes from \\(A\\).\nMDC + symmetric encryption (key \\(k\\) known to \\(A\\) and \\(B\\)) \\[A \\to B: X, E_k(\\text{MDC}(X))\\] \\(B\\) computes \\(\\text{MDC}(X)\\) and then \\(E_k(\\text{MDC}(X))\\). If equal ⇒ message comes from \\(A\\).\nAs 2) with confidentiality of \\(X\\) added: \\[A \\to B: E_k(X,\\text{MDC}(X))\\]\nMDC + digital signature: \\[A \\to B: X, \\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\] \\(B\\) computes \\(\\text{MDC}(X)\\) and verifies \\(\\text{Sig}_{\\text{priv-A}}(\\text{MDC}(X))\\) with an authentic copy of pub-A. If equality ⇒ \\(A\\) is the origin of the message. This solution additionally offers origin non-repudiation.\nThese simple protocols offer no support for uniqueness nor for the timeliness of received messages and are exposed to replay attacks! They require mechanisms taking into account time or the transaction context (cf. entity authentication).\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nIntegrity: MAC only, MDC+crypto, MDC+signature.\n⚠️ Vulnerable to replay without timestamps/nonces.\n\n\n\n\n\nBlockchains and Proof of Work\nBitcoin and blockchains: Use of hash functions to chain transaction blocks.\nCharacteristics:\n\nPublic and visible transactions\nBlocks chained via cryptographic hash functions\nMining = solving a cryptographic puzzle (proof of work)\n\nProof of Work:\n\nFind a nonce such that \\(\\text{hash}(\\text{block} \\parallel \\text{nonce}) &lt; \\text{target}\\)\nComputationally expensive puzzle, rapid validation\nFirst miner to solve receives bitcoin reward\n\nSecurity:\n\nBlockchain = public, decentralized, immutable ledger\nFalsification would require effort &gt; all honest miners\nProtection based on CRHF properties\n\nBitcoin statistics (October 2025):\n\nDifficulty: 150.84 T\nTarget: \\(\\approx 2^{177}\\) (pseudo-collision on 79 bits)\nHashrate: ~1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hash/sec)\nAverage block generation time: 10 minutes\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nBitcoin transactions are published and visible by all participants. They are encapsulated in blocks chained using cryptographic hash functions.\nMining consists of iteratively adding new blocks containing current transactions.\nGenerating a valid block requires solving a cryptographic puzzle (proof of work) very costly in computation time (finding pseudo-collisions in cryptographic hash functions). Validation remains very efficient.\nThe first miner able to generate a valid block will receive a monetary reward (in bitcoins). The mining process is open to all miners but only the first is rewarded.\nThe resulting chain of blocks (blockchain) then becomes a public ledger, decentralized and immutable protecting all past transactions. Falsification/modification of data protected by the blockchain would require computational effort greater than that performed by all honest miners.\nBitcoin Statistics 13/10/2025:\n\nDifficulty: 150.84 T\nTarget: \\(2^{224} / \\text{Difficulty} = \\approx 2^{177}\\). The valid digest to generate a block must be less than \\(2^{177}\\), which means a pseudo-collision on the 79 most significant bits. The variation on the inputs depends on the nonce.\nHashrate: ~ 1.1 ZH/sec (\\(1.1 \\times 10^{21}\\) hashes /sec)\nHash functions executed to obtain a block: ~ \\(660 \\times 10^{21}\\)\nAverage block generation time: 10 min\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nBlockchain: chaining of blocks via hash.\nProof of Work: find nonce for hash &lt; target.\nSecurity = effort &gt; all miners.\nBitcoin: ~10 min/block, \\(10^{21}\\) hash/sec.\n\n\n\n\n\nOther Applications\n1. Authentication:\n\nData origin authentication (DOA)\nTransaction authentication (DOA + temporal parameters)\n\n2. Virus checking:\n\nCreator publishes \\(\\text{digest} = h(\\text{software})\\) via secure channel\nUsers verify integrity by recalculating the digest\n\n3. Public key distribution:\n\nPublish \\(h(\\text{public key})\\) instead of the complete key\nSimplified authenticity verification\n\n4. Document timestamping:\n\nTimestamp applied to digest rather than complete document\nReduction of data to sign\n\n5. One-time password (S-Key):\n\nHash chain: \\(x_1 = h(x_0), x_2 = h(x_1), \\ldots, x_n = h(x_{n-1})\\)\nSystem stores \\(x_n\\), user provides \\(x_{n-1}\\)\nVerification: \\(h(x_{n-1}) = x_n\\)\nAfter validation, system stores \\(x_{n-1}\\) for next time\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nAuthentication:\n\ndata origin authentication (DOA)\ntransaction authentication (= DOA + time-variant parameters)\n\nVirus checking:\n\nThe creator of software creates a digest = \\(h(x)\\) with \\(x\\) being the original and distributes it via a secure channel (eg. CD-ROM).\n\nDistribution of public keys:\n\nAllows controlling the authenticity of a public key.\n\nTimestamp on a document:\n\nThe document on which we want to perform the timestamp is first submitted to a hash function. The timestamp (with the signature of the corresponding entity) then applies only to the digest.\n\nOne-time password (S-Key) (identification mechanism):\n\nFrom a secret seed \\(x_0\\), we create a chain of hash-values: \\(x_1 = h(x_0)\\), \\(x_2 = h(x_1)\\), … \\(x_n = h(x_{n-1})\\).\nThe system stores \\(x_n\\) and the user enters \\(x_{n-1}\\). If \\(h(x_{n-1}) == x_n\\) ⇒ OK.\nThe system then stores \\(x_{n-1}\\) and so on.\n\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nApplications\n\nauthentication\nvirus checking\npublic key distribution\ntimestamping\none-time passwords (hash chain)"
  },
  {
    "objectID": "exam_notes_en.html#randomized-hash-functions-unix-example",
    "href": "exam_notes_en.html#randomized-hash-functions-unix-example",
    "title": "Fundamental Security Services",
    "section": "Randomized Hash Functions: UNIX Example",
    "text": "Randomized Hash Functions: UNIX Example\nProblem: Deterministic hash functions always produce the same result for the same password.\nRisks:\n\nDetection of identical passwords\nOffline dictionary attacks (pre-computed codebooks)\nRainbow tables\n\nUNIX solution: Salt\n\nAddition of a 12-bit pseudo-random element (salt) before hashing\nDifferent salt for each user\n4096 possibilities (\\(2^{12}\\)) for each password\n\nAdvantages:\n\nPrevents detection of duplicates\nPre-computed codebooks become ineffective\nEach password requires 4096 dictionary entries\n\nUNIX implementation:\n\nFile /etc/passwd globally accessible\nFormat: username:hash(salt+password):uid:gid:...\nHash based on modified DES (25 iterations)\nSalt stored in clear (first 2 characters of hash)\n\nExample:\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nLimitations:\n\nEffective protection against pre-computed dictionaries\nOnline attacks limited by the system (number of attempts)\nOffline attacks possible if file compromised\n\n\n\n\n\n\n\nNoteOriginal Text\n\n\n\n\n\nUNIX keeps its passwords in a globally accessible file (or possibly distributed by NIS). The stored information corresponds to the result produced by a hash function.\nExample (fictional):\nroot:Jw87u9bebeb9i:0:1:Operator:/:/bin/csh\npp:1Qhw.oihEtHK6:359:355:PP:/net/spp_telecom/pp:/bin/cs\nProblems:\n\nthe hash function being deterministic, it produces the same result for identical passwords.\none could create “books” (codebooks) containing the result of applying the hash function to given inputs (eg. a dictionary) and easily compare them (off-line) with the strings stored by UNIX (brute force dictionary attack).\n\nSolution:\n\nAdd a (pseudo) random element of 12 bits different for each password (called salt) before computing the hash function and during verification.\nThis element allows adding a random factor of 4096 possibilities for each password and prevents detection of duplicates.\n\nThe operating scheme uses DES with 25 iterations, the password as key, and the salt to modify the E-boxes. The final 64-bit result is converted to 11 ASCII characters.\nUser awareness (not visiting dubious sites) decreases the effectiveness of this technique in malware transmission.\nDictionary attacks are normally less effective online because operating systems limit the number of unsuccessful authentication attempts.\n\n\n\n\n\n\n\n\n\nTipQuick Revision\n\n\n\n\n\nUNIX salt: 12 random bits added to password before hash.\n4096 possible variations.\nPrevents pre-computed codebooks and duplicate detection."
  }
]